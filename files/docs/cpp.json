{
    "Freestanding and hosted implementations": {
        "description": {
            "texte": "There are two kinds of implementations defined by the C++ standard: hosted and freestanding implementations. For hosted implementations the set of standard library headers required by the C++ standard is much larger than for freestanding ones. In a freestanding implementation execution may happen without an operating system."
        }
    },
    "Utility library": {
        "description": {
            "texte": "C++ includes a variety of utility libraries that provide functionality ranging from bit-counting to partial function application. These libraries can be broadly divided into two groups:Language support libraries provide classes and functions that interact closely with language features and support common language idioms."
        }
    },
    "Error handling": {
        "description": {
            "texte": "The header <exception> provides several classes and functions related to exception handling in C++ programs.Several convenience classes are predefined in the header <stdexcept> to report particular error conditions. These classes can be divided into two categories: logic errors and runtime errors. Logic errors are a consequence of faulty logic within the program and may be preventable. Runtime errors are due to events beyond the scope of the program and can not be easily predicted."
        }
    },
    "Strings library": {
        "description": {
            "texte": "The C++ strings library includes support for three general types of strings:"
        }
    },
    "Containers library": {
        "description": {
            "texte": "The Containers library is a generic collection of class templates and algorithms that allow programmers to easily implement common data structures like queues, lists and stacks. There are three classes of containers -- sequence containers, associative containers, and unordered associative containers -- each of which is designed to support a different set of operations.The container manages the storage space that is allocated for its elements and provides member functions to access them, either directly or through iterators (objects with properties similar to pointers).Most containers have at least several member functions in common, and share functionalities. Which container is the best for the particular application depends not only on the offered functionality, but also on its efficiency for different workloads."
        }
    },
    "Iterator library": {
        "description": {
            "texte": "The iterator library provides definitions for five (until C++17)six (since C++17) kinds of iterators as well as iterator traits, adaptors, and utility functions."
        }
    },
    "Ranges library (C++20)\n": {
        "description": {
            "texte": "The ranges library provides components for dealing with ranges of elements, including a variety of view adapters.The namespace alias std::view is provided as a shorthand for std::ranges::view."
        },
        "exemple": {
            "input": "#include <vector>\n#include <ranges>\n#include <iostream>\n \nint main()\n{\n  std::vector<int> ints{0,1,2,3,4,5};\n  auto even = [](int i){ return 0 == i % 2; };\n  auto square = [](int i) { return i * i; };\n \n  for (int i : ints | std::view::filter(even) | std::view::transform(square)) {\n    std::cout << i << ' ';\n  }\n}",
            "output": "0 4 16"
        }
    },
    "Numerics library": {
        "description": {
            "texte": "The C++ numerics library includes common mathematical functions and types, as well as optimized numeric arrays and support for random number generation."
        }
    },
    "Input/output library": {
        "description": {
            "texte": "C++ includes two input/output libraries: a modern, stream-based I/O library and the standard set of C-style I/O functions."
        }
    },
    "Localization library": {
        "description": {
            "texte": "The locale facility includes internationalization support for character classification and string collation, numeric, monetary, and date/time formatting and parsing, and message retrieval. Locale settings control the behavior of stream I/O, regular expression library, and other components of the C++ standard library."
        }
    },
    "Regular expressions library": {
        "description": {
            "texte": "The regular expressions library provides a class that represents regular expressions, which are a kind of mini-language used to perform pattern matching within strings. Almost all operations with regexes can be characterized by operating on several of the following objects:"
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n#include <string>\n#include <regex>\n \nint main()\n{\n    std::string s = \"Some people, when confronted with a problem, think \"\n        \"\\\"I know, I'll use regular expressions.\\\" \"\n        \"Now they have two problems.\";\n \n    std::regex self_regex(\"REGULAR EXPRESSIONS\",\n            std::regex_constants::ECMAScript | std::regex_constants::icase);\n    if (std::regex_search(s, self_regex)) {\n        std::cout << \"Text contains the phrase 'regular expressions'\\n\";\n    }\n \n    std::regex word_regex(\"(\\\\S+)\");\n    auto words_begin = \n        std::sregex_iterator(s.begin(), s.end(), word_regex);\n    auto words_end = std::sregex_iterator();\n \n    std::cout << \"Found \"\n              << std::distance(words_begin, words_end)\n              << \" words\\n\";\n \n    const int N = 6;\n    std::cout << \"Words longer than \" << N << \" characters:\\n\";\n    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {\n        std::smatch match = *i;\n        std::string match_str = match.str();\n        if (match_str.size() > N) {\n            std::cout << \"  \" << match_str << '\\n';\n        }\n    }\n \n    std::regex long_word_regex(\"(\\\\w{7,})\");\n    std::string new_s = std::regex_replace(s, long_word_regex, \"[$&]\");\n    std::cout << new_s << '\\n';\n}",
            "output": "Text contains the phrase 'regular expressions'\nFound 19 words\nWords longer than 6 characters:\n  people,\n  confronted\n  problem,\n  regular\n  expressions.\"\n  problems.\nSome people, when [confronted] with a [problem], think \n\"I know, I'll use [regular] [expressions].\" Now they have two [problems]."
        }
    },
    "Atomic operations library": {
        "description": {
            "texte": "The atomic library provides components for fine-grained atomic operations allowing for lockless concurrent programming. Each atomic operation is indivisible with regards to any other atomic operation that involves the same object. Atomic objects are free of data races."
        }
    },
    "Thread support library": {
        "description": {
            "texte": "C++ includes built-in support for threads, mutual exclusion, condition variables, and futures."
        }
    },
    "Filesystem library": {
        "description": {
            "texte": "The Filesystem library provides facilities for performing operations on file systems and their components, such as paths, regular files, and directories.The filesystem library was originally developed as boost.filesystem, was published as the technical specification ISO/IEC TS 18822:2015, and finally merged to ISO C++ as of C++17. The boost implementation is currently available on more compilers and platforms than the C++17 library.The filesystem library facilities may be unavailable if a hierarchical file system is not accessible to the implementation, or if it does not provide the necessary capabilities. Some features may not be available if they are not supported by the underlying file system (e.g. the FAT filesystem lacks symbolic links and forbids multiple hardlinks). In those cases, errors must be reported.The behavior is undefined if the calls to functions in this library introduce a file system race, that is, when multiple threads, processes, or computers interleave access and modification to the same object in a file system."
        }
    },
    "Program support utilities": {
        "description": {
            "texte": "The following functions manage program termination and resource cleanup."
        }
    },
    "Pseudo-random number generation": {
        "description": {
            "texte": "The random number library provides classes that generate random and pseudo-random numbers. These classes include:URBGs and distributions are designed to be used together to produce random values. All of the random number engines may be specifically seeded, serialized, and deserialized for use with repeatable simulators."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\n#include <cmath>\n \nint main()\n{\n    // Seed with a real random value, if available\n    std::random_device r;\n \n    // Choose a random mean between 1 and 6\n    std::default_random_engine e1(r());\n    std::uniform_int_distribution<int> uniform_dist(1, 6);\n    int mean = uniform_dist(e1);\n    std::cout << \"Randomly-chosen mean: \" << mean << '\\n';\n \n    // Generate a normal distribution around that mean\n    std::seed_seq seed2{r(), r(), r(), r(), r(), r(), r(), r()}; \n    std::mt19937 e2(seed2);\n    std::normal_distribution<> normal_dist(mean, 2);\n \n    std::map<int, int> hist;\n    for (int n = 0; n < 10000; ++n) {\n        ++hist[std::round(normal_dist(e2))];\n    }\n    std::cout << \"Normal distribution around \" << mean << \":\\n\";\n    for (auto p : hist) {\n        std::cout << std::fixed << std::setprecision(1) << std::setw(2)\n                  << p.first << ' ' << std::string(p.second/200, '*') << '\\n';\n    }\n}",
            "output": "Randomly-chosen mean: 4\nNormal distribution around 4:\n-4 \n-3 \n-2 \n-1 \n 0 *\n 1 ***\n 2 ******\n 3 ********\n 4 *********\n 5 ********\n 6 ******\n 7 ***\n 8 *\n 9 \n10 \n11 \n12"
        }
    },
    "setjmp": {
        "description": {
            "texte": "Saves the current execution context into a variable env of type std::jmp_buf. This variable can later be used to restore the current execution context by std::longjmp function. That is, when a call to std::longjmp function is made, the execution continues at the particular call site that constructed the std::jmp_buf variable passed to std::longjmp. In that case setjmp returns the value passed to std::longjmp.The invocation of setjmp must appear only in one of the following contexts:If setjmp appears in any other context, the behavior is undefined.Upon return to the scope of setjmp, all accessible objects, floating-point status flags, and other components of the abstract machine have the same values as they had when std::longjmp was executed, except for the non-volatile local variables in setjmp's scope, whose values are indeterminate if they have been changed since the setjmp invocation.",
            "code": "setjmp(env);"
        },
        "parametres": "   env   -   variable to save the execution state of the program to. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <csetjmp>\n \nstd::jmp_buf jump_buffer;\n \n[[noreturn]] void a(int count) \n{\n    std::cout << \"a(\" << count << \") called\\n\";\n    std::longjmp(jump_buffer, count+1);  // setjmp() will return count+1\n}\n \nint main()\n{\n    volatile int count = 0; // modified locals in setjmp scope must be volatile\n    if (setjmp(jump_buffer) != 9) { // equality against constant expression in an if\n        a(++count);  // This will cause setjmp() to exit\n    }\n}",
            "output": "a(1) called\na(2) called\na(3) called\na(4) called\na(5) called\na(6) called\na(7) called\na(8) called"
        }
    },
    "Variadic functions": {
        "description": {
            "texte": "Variadic functions are functions (e.g. std::printf) which take a variable number of arguments.To declare a variadic function, an ellipsis is used as the last parameter, e.g. int printf(const char* format, ...);. See Variadic arguments for additional detail on the syntax, automatic argument conversions and the alternatives.To access the variadic arguments from the function body, the following library facilities are provided:"
        },
        "exemple": {
            "input": "#include <iostream>\n#include <cstdarg>\n \nvoid simple_printf(const char* fmt...)\n{\n    va_list args;\n    va_start(args, fmt);\n \n    while (*fmt != '\\0') {\n        if (*fmt == 'd') {\n            int i = va_arg(args, int);\n            std::cout << i << '\\n';\n        } else if (*fmt == 'c') {\n            // note automatic conversion to integral type\n            int c = va_arg(args, int);\n            std::cout << static_cast<char>(c) << '\\n';\n        } else if (*fmt == 'f') {\n            double d = va_arg(args, double);\n            std::cout << d << '\\n';\n        }\n        ++fmt;\n    }\n \n    va_end(args);\n}\n \nint main()\n{\n    simple_printf(\"dcff\", 3, 'a', 1.999, 42.5); \n}",
            "output": "3\na\n1.999\n42.5"
        }
    },
    "Type support (basic types, RTTI, type traits)": {
        "description": {
            "texte": "(See also type for type system overview)."
        }
    },
    "bitset": {
        "description": {
            "texte": "The class template bitset represents a fixed-size sequence of N bits. Bitsets can be manipulated by standard logic operators and converted to and from strings and integers.bitset meets the requirements of CopyConstructible and CopyAssignable."
        }
    },
    "Function objects": {
        "description": {
            "texte": "A function object is any object for which the function call operator is defined. C++ provides many built-in function objects as well as support for creation and manipulation of new function objects."
        }
    },
    "Date and time utilities": {
        "description": {
            "texte": "C++ includes support for two types of time manipulation:"
        },
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n#include <ctime>\n \nlong fibonacci(unsigned n)\n{\n    if (n < 2) return n;\n    return fibonacci(n-1) + fibonacci(n-2);\n}\n \nint main()\n{\n    auto start = std::chrono::system_clock::now();\n    std::cout << \"f(42) = \" << fibonacci(42) << '\\n';\n    auto end = std::chrono::system_clock::now();\n \n    std::chrono::duration<double> elapsed_seconds = end-start;\n    std::time_t end_time = std::chrono::system_clock::to_time_t(end);\n \n    std::cout << \"finished computation at \" << std::ctime(&end_time)\n              << \"elapsed time: \" << elapsed_seconds.count() << \"s\\n\";\n}",
            "output": "f(42) = 267914296\nfinished computation at Mon Oct  2 00:59:08 2017\nelapsed time: 1.88232s"
        }
    },
    "initializer_list": {
        "description": {
            "texte": "(not to be confused with member initializer list).An object of type std::initializer_list<T> is a lightweight proxy object that provides access to an array of objects of type const T.A std::initializer_list object is automatically constructed when:Initializer lists may be implemented as a pair of pointers or pointer and length. Copying a std::initializer_list does not copy the underlying objects."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <initializer_list>\n \ntemplate <class T>\nstruct S {\n    std::vector<T> v;\n    S(std::initializer_list<T> l) : v(l) {\n         std::cout << \"constructed with a \" << l.size() << \"-element list\\n\";\n    }\n    void append(std::initializer_list<T> l) {\n        v.insert(v.end(), l.begin(), l.end());\n    }\n    std::pair<const T*, std::size_t> c_arr() const {\n        return {&v[0], v.size()};  // copy list-initialization in return statement\n                                   // this is NOT a use of std::initializer_list\n    }\n};\n \ntemplate <typename T>\nvoid templated_fn(T) {}\n \nint main()\n{\n    S<int> s = {1, 2, 3, 4, 5}; // copy list-initialization\n    s.append({6, 7, 8});      // list-initialization in function call\n \n    std::cout << \"The vector size is now \" << s.c_arr().second << \" ints:\\n\";\n \n    for (auto n : s.v)\n        std::cout << n << ' ';\n    std::cout << '\\n';\n \n    std::cout << \"Range-for over brace-init-list: \\n\";\n \n    for (int x : {-1, -2, -3}) // the rule for auto makes this ranged-for work\n        std::cout << x << ' ';\n    std::cout << '\\n';\n \n    auto al = {10, 11, 12};   // special rule for auto\n \n    std::cout << \"The list bound to auto has size() = \" << al.size() << '\\n';\n \n//    templated_fn({1, 2, 3}); // compiler error! \"{1, 2, 3}\" is not an expression,\n                             // it has no type, and so T cannot be deduced\n    templated_fn<std::initializer_list<int>>({1, 2, 3}); // OK\n    templated_fn<std::vector<int>>({1, 2, 3});           // also OK\n}",
            "output": "constructed with a 5-element list\nThe vector size is now 8 ints:\n1 2 3 4 5 6 7 8\nRange-for over brace-init-list: \n-1 -2 -3 \nThe list bound to auto has size() = 3"
        }
    },
    "tuple": {
        "description": {
            "texte": "Class template std::tuple is a fixed-size collection of heterogeneous values. It is a generalization of std::pair."
        },
        "exemple": {
            "input": "#include <tuple>\n#include <iostream>\n#include <string>\n#include <stdexcept>\n \nstd::tuple<double, char, std::string> get_student(int id)\n{\n    if (id == 0) return std::make_tuple(3.8, 'A', \"Lisa Simpson\");\n    if (id == 1) return std::make_tuple(2.9, 'C', \"Milhouse Van Houten\");\n    if (id == 2) return std::make_tuple(1.7, 'D', \"Ralph Wiggum\");\n    throw std::invalid_argument(\"id\");\n}\n \nint main()\n{\n    auto student0 = get_student(0);\n    std::cout << \"ID: 0, \"\n              << \"GPA: \" << std::get<0>(student0) << \", \"\n              << \"grade: \" << std::get<1>(student0) << \", \"\n              << \"name: \" << std::get<2>(student0) << '\\n';\n \n    double gpa1;\n    char grade1;\n    std::string name1;\n    std::tie(gpa1, grade1, name1) = get_student(1);\n    std::cout << \"ID: 1, \"\n              << \"GPA: \" << gpa1 << \", \"\n              << \"grade: \" << grade1 << \", \"\n              << \"name: \" << name1 << '\\n';\n \n    // C++17 structured binding:\n    auto [ gpa2, grade2, name2 ] = get_student(2);\n    std::cout << \"ID: 2, \"\n              << \"GPA: \" << gpa2 << \", \"\n              << \"grade: \" << grade2 << \", \"\n              << \"name: \" << name2 << '\\n';\n}",
            "output": "ID: 0, GPA: 3.8, grade: A, name: Lisa Simpson\nID: 1, GPA: 2.9, grade: C, name: Milhouse Van Houten\nID: 2, GPA: 1.7, grade: D, name: Ralph Wiggum"
        }
    },
    "any": {
        "description": {
            "texte": "The class any describes a type-safe container for single values of any type.Implementations are encouraged to avoid dynamic allocations for small objects, but such an optimization may only be applied to types for which std::is_nothrow_move_constructible returns true."
        },
        "exemple": {
            "input": "#include <any>\n#include <iostream>\n \nint main()\n{\n    std::cout << std::boolalpha;\n \n    // any type\n    std::any a = 1;\n    std::cout << a.type().name() << \": \" << std::any_cast<int>(a) << '\\n';\n    a = 3.14;\n    std::cout << a.type().name() << \": \" << std::any_cast<double>(a) << '\\n';\n    a = true;\n    std::cout << a.type().name() << \": \" << std::any_cast<bool>(a) << '\\n';\n \n    // bad cast\n    try\n    {\n        a = 1;\n        std::cout << std::any_cast<float>(a) << '\\n';\n    }\n    catch (const std::bad_any_cast& e)\n    {\n        std::cout << e.what() << '\\n';\n    }\n \n    // has value\n    a = 1;\n    if (a.has_value())\n    {\n        std::cout << a.type().name() << '\\n';\n    }\n \n    // reset\n    a.reset();\n    if (!a.has_value())\n    {\n        std::cout << \"no value\\n\";\n    }\n \n    // pointer to contained data\n    a = 1;\n    int* i = std::any_cast<int>(&a);\n    std::cout << *i << \"\\n\";\n}",
            "output": "i: 1\nd: 3.14\nb: true\nbad any_cast\ni\nno value\n1"
        }
    },
    "optional": {
        "description": {
            "texte": "The class template std::optional manages an optional contained value, i.e. a value that may or may not be present.A common use case for optional is the return value of a function that may fail. As opposed to other approaches, such as std::pair<T,bool>, optional handles expensive-to-construct objects well and is more readable, as the intent is expressed explicitly.Any instance of optional<T> at any given point in time either contains a value or does not contain a value.If an optional<T> contains a value, the value is guaranteed to be allocated as part of the optional object footprint, i.e. no dynamic memory allocation ever takes place. Thus, an optional object models an object, not a pointer, even though operator*() and operator->() are defined.When an object of type optional<T> is contextually converted to bool, the conversion returns true if the object contains a value and false if it does not contain a value.The optional object contains a value in the following conditions:The object does not contain a value in the following conditions:There are no optional references; a program is ill-formed if it instantiates an optional with a reference type. Alternatively, an optional of a std::reference_wrapper of type T may be used to hold a reference. In addition, a program is ill-formed if it instantiates an optional with the tag types std::nullopt_t or std::in_place_t."
        },
        "exemple": {
            "input": "#include <string>\n#include <functional>\n#include <iostream>\n#include <optional>\n \n// optional can be used as the return type of a factory that may fail\nstd::optional<std::string> create(bool b) {\n    if (b)\n        return \"Godzilla\";\n    return {};\n}\n \n// std::nullopt can be used to create any (empty) std::optional\nauto create2(bool b) {\n    return b ? std::optional<std::string>{\"Godzilla\"} : std::nullopt;\n}\n \n// std::reference_wrapper may be used to return a reference\nauto create_ref(bool b) {\n    static std::string value = \"Godzilla\";\n    return b ? std::optional<std::reference_wrapper<std::string>>{value}\n             : std::nullopt;\n}\n \nint main()\n{\n    std::cout << \"create(false) returned \"\n              << create(false).value_or(\"empty\") << '\\n';\n \n    // optional-returning factory functions are usable as conditions of while and if\n    if (auto str = create2(true)) {\n        std::cout << \"create2(true) returned \" << *str << '\\n';\n    }\n \n    if (auto str = create_ref(true)) {\n        // using get() to access the reference_wrapper's value\n        std::cout << \"create_ref(true) returned \" << str->get() << '\\n';\n        str->get() = \"Mothra\";\n        std::cout << \"modifying it changed it to \" << str->get() << '\\n';\n    }\n}",
            "output": "create(false) returned empty\ncreate2(true) returned Godzilla\ncreate_ref(true) returned Godzilla\nmodifying it changed it to Mothra"
        }
    },
    "variant": {
        "description": {
            "texte": "The class template std::variant represents a type-safe union. An instance of std::variant at any given time either holds a value of one of its alternative types, or in the case of error - no value (this state is hard to achieve, see valueless_by_exception).As with unions, if a variant holds a value of some object type T, the object representation of T is allocated directly within the object representation of the variant itself. Variant is not allowed to allocate additional (dynamic) memory.A variant is not permitted to hold references, arrays, or the type void. Empty variants are also ill-formed (std::variant<std::monostate> can be used instead).A variant is permitted to hold the same type more than once, and to hold differently cv-qualified versions of the same type.Consistent with the behavior of unions during aggregate initialization, a default-constructed variant holds a value of its first alternative, unless that alternative is not default-constructible (in which case the variant is not default-constructible either). The helper class std::monostate can be used to make such variants default-constructible."
        },
        "exemple": {
            "input": "#include <variant>\n#include <string>\n#include <cassert>\n \nint main()\n{\n    std::variant<int, float> v, w;\n    v = 12; // v contains int\n    int i = std::get<int>(v);\n    w = std::get<int>(v);\n    w = std::get<0>(v); // same effect as the previous line\n    w = v; // same effect as the previous line\n \n//  std::get<double>(v); // error: no double in [int, float]\n//  std::get<3>(v);      // error: valid index values are 0 and 1\n \n    try {\n      std::get<float>(w); // w contains int, not float: will throw\n    }\n    catch (const std::bad_variant_access&) {}\n \n    using namespace std::literals;\n \n    std::variant<std::string> x(\"abc\");\n    // converting constructors work when unambiguous\n    x = \"def\"; // converting assignment also works when unambiguous\n \n    std::variant<std::string, void const*> y(\"abc\");\n    // casts to void const * when passed a char const *\n    assert(std::holds_alternative<void const*>(y)); // succeeds\n    y = \"xyz\"s;\n    assert(std::holds_alternative<std::string>(y)); // succeeds\n}"
        }
    },
    "Dynamic memory management": {
        "description": {
            "texte": "Smart pointers enable automatic, exception-safe, object lifetime management."
        }
    },
    "scoped_allocator_adaptor": {
        "description": {
            "texte": "The std::scoped_allocator_adaptor class template is an allocator which can be used with multilevel containers (vector of sets of lists of tuples of maps, etc). It is instantiated with one outer allocator type OuterAlloc and zero or more inner allocator types InnerAlloc.... A container constructed directly with a scoped_allocator_adaptor uses OuterAlloc to allocate its elements, but if an element is itself a container, it uses the first inner allocator. The elements of that container, if they are themselves containers, use the second inner allocator, etc. If there are more levels to the container than there are inner allocators, the last inner allocator is reused for all further nested containers.The purpose of this adaptor is to correctly initialize stateful allocators in nested containers, such as when all levels of a nested container must be placed in the same shared memory segment. The adaptor's constructor takes the arguments for all allocators in the list, and each nested container obtains its allocator's state from the adaptor as needed.For the purpose of scoped_allocator_adaptor, if the next inner allocator is A, any class T for which std::uses_allocator<T,A>::value == true participates in the recursion as if it was a container. Additionally, std::pair is treated as such a container by specific overloads of scoped_allocator_adaptor::construct.Typical implementation holds an instance of a std::scoped_allocator_adaptor<InnerAllocs...> as a member object."
        },
        "exemple": {
            "input": "#include <vector>\n#include <scoped_allocator>\n#include <boost/interprocess/managed_shared_memory.hpp>\n#include <boost/interprocess/allocators/adaptive_pool.hpp>\nnamespace bi = boost::interprocess;\ntemplate<class T> using alloc = bi::adaptive_pool<T,\n                                    bi::managed_shared_memory::segment_manager>;\nusing ipc_row = std::vector<int, alloc<int>>;\nusing ipc_matrix = std::vector<ipc_row, std::scoped_allocator_adaptor<alloc<ipc_row>>>;\nint main ()\n{\n   bi::managed_shared_memory s(bi::create_only, \"Demo\", 65536);\n \n   // create vector of vectors in shared memory\n   ipc_matrix v(s.get_segment_manager());\n \n   // for all these additions, the inner vectors obtain their allocator arguments\n   // from the outer vector's scoped_allocator_adaptor\n   v.resize(1); v[0].push_back(1);\n   v.emplace_back(2);\n   std::vector<int> local_row = {1,2,3};\n   v.emplace_back(local_row.begin(), local_row.end());\n \n   bi::shared_memory_object::remove(\"Demo\");\n}"
        }
    },
    "pmr::memory_resource": {
        "description": {
            "texte": "The class std::pmr::memory_resource is an abstract interface to an unbounded set of classes encapsulating memory resources."
        }
    },
    "C numeric limits interface": {
        "description": {
            "texte": "See also std::numeric_limits interface."
        }
    },
    "Fixed width integer types (since C++11)\n": {
        "description": {
            "texte": "Because C++ interprets a character immediately following a string literal as a user-defined string literal, C code such as printf(\"%\"PRId64\"\\n\",n); is invalid C++ and requires a space before PRId64.The C99 standard suggests that C++ implementations should not define the above limit, constant, or format macros unless the macros __STDC_LIMIT_MACROS, __STDC_CONSTANT_MACROS or __STDC_FORMAT_MACROS (respectively) are defined before including the relevant C header (stdint.h or inttypes.h). This recommendation was not adopted by any C++ standard and was removed in C11. However, some implementations (such as glibc 2.17) try to apply this rule, and it may be necessary to define the __STDC macros; C++ compilers may try to work around this by automatically defining them in some circumstances."
        },
        "exemple": {
            "input": "#include <cstdio>\n#include <cinttypes>\n \nint main()\n{\n    std::printf(\"%zu\\n\", sizeof(std::int64_t));\n    std::printf(\"%s\\n\", PRId64);\n    std::printf(\"%+\" PRId64 \"\\n\", INT64_MIN);\n    std::printf(\"%+\" PRId64 \"\\n\", INT64_MAX);\n \n    std::int64_t n = 7;\n    std::printf(\"%+\" PRId64 \"\\n\", n);\n}",
            "output": "8\nlld\n-9223372036854775808\n+9223372036854775807\n+7"
        }
    },
    "numeric_limits": {
        "description": {
            "texte": "The numeric_limits class template provides a standardized way to query various properties of arithmetic types (e.g. the largest possible value for type int is std::numeric_limits<int>::max()).This information is provided via specializations of the numeric_limits template. The standard library makes available specializations for all arithmetic types:Additionally, a specialization exists for every cv-qualified version of each arithmetic type, identical to the unqualified specialization, e.g. std::numeric_limits<const int>, std::numeric_limits<volatile int>, and std::numeric_limits<const volatile int> are provided and are equivalent to std::numeric_limits<int>.The standard library types that are aliases of arithmetic types (such as std::size_t or std::streamsize) may also be examined with the std::numeric_limits type traits.Non-arithmetic standard types, such as std::complex<T> or std::nullptr_t, do not have specializations.Implementations may provide specializations of std::numeric_limits for implementation-specific types: e.g. GCC provides std::numeric_limits<__int128>. Non-standard libraries may add specializations for library-provided types, e.g. OpenEXR provides std::numeric_limits<half> for a 16-bit floating-point type."
        },
        "exemple": {
            "input": "#include <limits>\n#include <iostream>\n \nint main() \n{\n    std::cout << \"type\\tlowest()\\tmin()\\t\\tmax()\\n\\n\";\n \n    std::cout << \"uchar\\t\"\n              << +std::numeric_limits<unsigned char>::lowest() << '\\t' << '\\t'\n              << +std::numeric_limits<unsigned char>::min() << '\\t' << '\\t'\n              << +std::numeric_limits<unsigned char>::max() << '\\n';\n    std::cout << \"int\\t\"\n              << std::numeric_limits<int>::lowest() << '\\t'\n              << std::numeric_limits<int>::min() << '\\t'\n              << std::numeric_limits<int>::max() << '\\n';\n    std::cout << \"float\\t\"\n              << std::numeric_limits<float>::lowest() << '\\t'\n              << std::numeric_limits<float>::min() << '\\t'\n              << std::numeric_limits<float>::max() << '\\n';\n    std::cout << \"double\\t\"\n              << std::numeric_limits<double>::lowest() << '\\t'\n              << std::numeric_limits<double>::min() << '\\t'\n              << std::numeric_limits<double>::max() << '\\n';\n}",
            "output": "type        lowest()        min()                max()\n \nuchar        0                0                255\nint        -2147483648        -2147483648        2147483647\nfloat        -3.40282e+38        1.17549e-38        3.40282e+38\ndouble        -1.79769e+308        2.22507e-308        1.79769e+308"
        }
    },
    "assert": {
        "description": {
            "texte": "The definition of the macro assert depends on another macro, NDEBUG, which is not defined by the standard library.If NDEBUG is defined as a macro name at the point in the source code where <cassert> is included, then assert does nothing.If NDEBUG is not defined, then assert checks if its argument (which must have scalar type) compares equal to zero. If it does, assert outputs implementation-specific diagnostic information on the standard error output and calls std::abort. The diagnostic information is required to include the text of expression, as well as the values of the standard macros __FILE__, __LINE__, and the standard variable __func__ (since C++11)."
        },
        "parametres": "   condition   -   expression of scalar type \n\n",
        "exemple": {
            "input": "#include <iostream>\n// uncomment to disable assert()\n// #define NDEBUG\n#include <cassert>\n \nint main()\n{\n    assert(2+2==4);\n    std::cout << \"Execution continues past the first assert\\n\";\n    assert(2+2==5);\n    std::cout << \"Execution continues past the second assert\\n\";\n}",
            "output": "Execution continues past the first assert\ntest: test.cc:10: int main(): Assertion `2+2==5' failed.\nAborted"
        }
    },
    "error_code": {
        "description": {
            "texte": "std::error_code is a platform-dependent error code. Each std::error_code object holds an error code originating from the operating system or some low-level interface and a pointer to an object of type std::error_category, which corresponds to the said interface. The error code values may be not unique across different error categories."
        }
    },
    "contract_violation": {
        "description": {
            "texte": "The class contract_violation describes information about a contract violation. It is generated by a C++ implementation and passed to a contract violation handler when a contract violation is detected."
        }
    },
    "Null-terminated byte strings": {
        "description": {
            "texte": "A null-terminated byte string (NTBS) is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character). Each byte in a byte string encodes one character of some character set. For example, the character array {'\\x63', '\\x61', '\\x74', '\\0'} is an NTBS holding the string \"cat\" in ASCII encoding."
        }
    },
    "Null-terminated wide strings": {
        "description": {
            "texte": "A null-terminated wide string is a sequence of valid wide characters, ending with a null character."
        }
    },
    "Null-terminated multibyte strings": {
        "description": {
            "texte": "A null-terminated multibyte string (NTMBS), or \"multibyte string\", is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character).Each character stored in the string may occupy more than one byte. The encoding used to represent characters in a multibyte character string is locale-specific: it may be UTF-8, GB18030, EUC-JP, Shift-JIS, etc. For example, the char array {'\\xe4','\\xbd','\\xa0','\\xe5','\\xa5','\\xbd','\\0'} is an NTMBS holding the string \"\u4f60\u597d\" in UTF-8 multibyte encoding: the first three bytes encode the character \u4f60, the next three bytes encode the character \u597d. The same string encoded in GB18030 is the char array {'\\xc4', '\\xe3', '\\xba', '\\xc3', '\\0'}, where each of the two characters is encoded as a two-byte sequence.In some multibyte encodings, any given multibyte character sequence may represent different characters depending on the previous byte sequences, known as \"shift sequences\". Such encodings are known as state-dependent: knowledge of the current shift state is required to interpret each character. An NTMBS is only valid if it begins and ends in the initial shift state: if a shift sequence was used, the corresponding unshift sequence has to be present before the terminating null character. Examples of such encodings are the 7-bit JIS, BOCU-1 and SCSU.A multibyte character string is layout-compatible with null-terminated byte string (NTBS), that is, can be stored, copied, and examined using the same facilities, except for calculating the number of characters. If the correct locale is in effect, I/O functions also handle multibyte strings. Multibyte strings can be converted to and from wide strings using the std::codecvt member functions, std::wstring_convert, or the following locale-dependent conversion functions:"
        }
    },
    "basic_string": {
        "description": {
            "texte": "The class template basic_string stores and manipulates sequences of char-like objects, which are non-array objects of trivial standard-layout type. The class is dependent neither on the character type nor on the nature of operations on that type. The definitions of the operations are supplied via the Traits template parameter - a specialization of std::char_traits or a compatible traits class. Traits::char_type and CharT must name the same type; otherwise the program is ill-formed.std::basic_string satisfies the requirements of AllocatorAwareContainer, SequenceContainer and ContiguousContainer (since C++17).Several typedefs for common character types are provided:"
        }
    },
    "basic_string_view": {
        "description": {
            "texte": "The class template basic_string_view describes an object that can refer to a constant contiguous sequence of char-like objects with the first element of the sequence at position zero.A typical implementation holds only two members: a pointer to constant CharT and a size.Several typedefs for common character types are provided:"
        }
    },
    "array": {
        "description": {
            "texte": "std::array is a container that encapsulates fixed size arrays.This container is an aggregate type with the same semantics as a struct holding a C-style array T[N] as its only non-static data member. Unlike a C-style array, it doesn't decay to T* automatically. As an aggregate type, it can be initialized with aggregate-initialization given at most N initializers that are convertible to T: std::array<int, 3> a = {1,2,3};.The struct combines the performance and accessibility of a C-style array with the benefits of a standard container, such as knowing its own size, supporting assignment, random access iterators, etc.std::array satisfies the requirements of Container and ReversibleContainer except that default-constructed array is not empty and that the complexity of swapping is linear, satisfies the requirements of ContiguousContainer, (since C++17) and partially satisfies the requirements of SequenceContainer.There is a special case for a zero-length array (N == 0). In that case, array.begin() == array.end(), which is some unique value. The effect of calling front() or back() on a zero-sized array is undefined.An array can also be used as a tuple of N elements of the same type."
        },
        "exemple": {
            "input": "#include <string>\n#include <iterator>\n#include <iostream>\n#include <algorithm>\n#include <array>\n \nint main()\n{\n    // construction uses aggregate initialization\n    std::array<int, 3> a1{ {1, 2, 3} }; // double-braces required in C++11 prior to the CWG 1270 revision\n                                        // (not needed in C++11 after the revision and in C++14 and beyond)\n    std::array<int, 3> a2 = {1, 2, 3};  // never required after =\n    std::array<std::string, 2> a3 = { std::string(\"a\"), \"b\" };\n \n    // container operations are supported\n    std::sort(a1.begin(), a1.end());\n    std::reverse_copy(a2.begin(), a2.end(), \n                      std::ostream_iterator<int>(std::cout, \" \"));\n \n    std::cout << '\\n';\n \n    // ranged for loop is supported\n    for(const auto& s: a3)\n        std::cout << s << ' ';\n}",
            "output": "3 2 1 \na b"
        }
    },
    "deque": {
        "description": {
            "texte": "std::deque (double-ended queue) is an indexed sequence container that allows fast insertion and deletion at both its beginning and its end. In addition, insertion and deletion at either end of a deque never invalidates pointers or references to the rest of the elements.As opposed to std::vector, the elements of a deque are not stored contiguously: typical implementations use a sequence of individually allocated fixed-size arrays, with additional bookkeeping, which means indexed access to deque must perform two pointer dereferences, compared to vector's indexed access which performs only one.The storage of a deque is automatically expanded and contracted as needed. Expansion of a deque is cheaper than the expansion of a std::vector because it does not involve copying of the existing elements to a new memory location. On the other hand, deques typically have large minimal memory cost; a deque holding just one element has to allocate its full internal array (e.g. 8 times the object size on 64-bit libstdc++; 16 times the object size or 4096 bytes, whichever is larger, on 64-bit libc++).The complexity (efficiency) of common operations on deques is as follows:std::deque meets the requirements of Container, AllocatorAwareContainer, SequenceContainer and ReversibleContainer."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <deque>\n \nint main()\n{\n    // Create a deque containing integers\n    std::deque<int> d = {7, 5, 16, 8};\n \n    // Add an integer to the beginning and end of the deque\n    d.push_front(13);\n    d.push_back(25);\n \n    // Iterate and print values of deque\n    for(int n : d) {\n        std::cout << n << '\\n';\n    }\n}",
            "output": "13\n7\n5\n16\n8\n25"
        }
    },
    "list": {
        "description": {
            "texte": "std::list is a container that supports constant time insertion and removal of elements from anywhere in the container. Fast random access is not supported. It is usually implemented as a doubly-linked list. Compared to std::forward_list this container provides bidirectional iteration capability while being less space efficient.Adding, removing and moving the elements within the list or across several lists does not invalidate the iterators or references. An iterator is invalidated only when the corresponding element is deleted.std::list meets the requirements of Container, AllocatorAwareContainer, SequenceContainer and ReversibleContainer."
        },
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <list>\n \nint main()\n{\n    // Create a list containing integers\n    std::list<int> l = { 7, 5, 16, 8 };\n \n    // Add an integer to the front of the list\n    l.push_front(25);\n    // Add an integer to the back of the list\n    l.push_back(13);\n \n    // Insert an integer before 16 by searching\n    auto it = std::find(l.begin(), l.end(), 16);\n    if (it != l.end()) {\n        l.insert(it, 42);\n    }\n \n    // Iterate and print values of the list\n    for (int n : l) {\n        std::cout << n << '\\n';\n    }\n}",
            "output": "25\n7\n5\n42\n16\n8\n13"
        }
    },
    "forward_list": {
        "description": {
            "texte": "std::forward_list is a container that supports fast insertion and removal of elements from anywhere in the container. Fast random access is not supported. It is implemented as a singly-linked list and essentially does not have any overhead compared to its implementation in C. Compared to std::list this container provides more space efficient storage when bidirectional iteration is not needed.Adding, removing and moving the elements within the list, or across several lists, does not invalidate the iterators currently referring to other elements in the list. However, an iterator or reference referring to an element is invalidated when the corresponding element is removed (via erase_after) from the list.std::forward_list meets the requirements of Container (except for the size member function and that operator=='s complexity is always linear), AllocatorAwareContainer and SequenceContainer."
        }
    },
    "set": {
        "description": {
            "texte": "std::set is an associative container that contains a sorted set of unique objects of type Key. Sorting is done using the key comparison function Compare. Search, removal, and insertion operations have logarithmic complexity. Sets are usually implemented as red-black trees.Everywhere the standard library uses the Compare requirements, uniqueness is determined by using the equivalence relation. In imprecise terms, two objects a and b are considered equivalent if neither compares less than the other: !comp(a, b) &&\u00a0!comp(b, a).std::set meets the requirements of Container, AllocatorAwareContainer, AssociativeContainer and ReversibleContainer."
        }
    },
    "multiset": {
        "description": {
            "texte": "std::multiset is an associative container that contains a sorted set of objects of type Key. Unlike set, multiple keys with equivalent values are allowed. Sorting is done using the key comparison function Compare. Search, insertion, and removal operations have logarithmic complexity.Everywhere the standard library uses the Compare requirements, equivalence is determined by using the equivalence relation as described on Compare. In imprecise terms, two objects a and b are considered equivalent if neither compares less than the other: !comp(a, b) &&\u00a0!comp(b, a).The order of the elements that compare equivalent is the order of insertion and does not change. (since C++11).std::multiset meets the requirements of Container, AllocatorAwareContainer, AssociativeContainer and ReversibleContainer."
        }
    },
    "map": {
        "description": {
            "texte": "std::map is a sorted associative container that contains key-value pairs with unique keys. Keys are sorted by using the comparison function Compare. Search, removal, and insertion operations have logarithmic complexity. Maps are usually implemented as red-black trees.Everywhere the standard library uses the Compare requirements, uniqueness is determined by using the equivalence relation. In imprecise terms, two objects a and b are considered equivalent (not unique) if neither compares less than the other: !comp(a, b) &&\u00a0!comp(b, a).std::map meets the requirements of Container, AllocatorAwareContainer, AssociativeContainer and ReversibleContainer."
        }
    },
    "multimap": {
        "description": {
            "texte": "Multimap is an associative container that contains a sorted list of key-value pairs, while permitting multiple entries with the same key. Sorting is done according to the comparison function Compare, applied to the keys. Search, insertion, and removal operations have logarithmic complexity.The order of the key-value pairs whose keys compare equivalent is the order of insertion and does not change. (since C++11).Everywhere the standard library uses the Compare requirements, equivalence is determined by using the equivalence relation as described on Compare. In imprecise terms, two objects a and b are considered equivalent if neither compares less than the other: !comp(a, b) &&\u00a0!comp(b, a).std::multimap meets the requirements of Container, AllocatorAwareContainer, AssociativeContainer and ReversibleContainer."
        }
    },
    "unordered_set": {
        "description": {
            "texte": "Unordered set is an associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity.Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its value. This allows fast access to individual elements, since once a hash is computed, it refers to the exact bucket the element is placed into.Container elements may not be modified (even by non const iterators) since modification could change an element's hash and corrupt the container.std::unordered_set meets the requirements of Container, AllocatorAwareContainer, UnorderedAssociativeContainer."
        }
    },
    "unordered_multiset": {
        "description": {
            "texte": "Unordered multiset is an associative container that contains set of possibly non-unique objects of type Key. Search, insertion, and removal have average constant-time complexity.Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its value. This allows fast access to individual elements, since once hash is computed, it refers to the exact bucket the element is placed into.The iteration order of this container is not required to be stable (so, for example, std::equal cannot be used to compare two std::unordered_multisets), except that every group of elements whose keys compare equivalent (compare equal with key_eq() as the comparator) forms a contiguous subrange in the iteration order, also accessible with equal_range().std::unordered_multiset meets the requirements of Container, AllocatorAwareContainer, UnorderedAssociativeContainer."
        }
    },
    "unordered_map": {
        "description": {
            "texte": "Unordered map is an associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity.Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its key. This allows fast access to individual elements, since once the hash is computed, it refers to the exact bucket the element is placed into.std::unordered_map meets the requirements of Container, AllocatorAwareContainer, UnorderedAssociativeContainer."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <unordered_map>\n \nint main()\n{\n    // Create an unordered_map of three strings (that map to strings)\n    std::unordered_map<std::string, std::string> u = {\n        {\"RED\",\"#FF0000\"},\n        {\"GREEN\",\"#00FF00\"},\n        {\"BLUE\",\"#0000FF\"}\n    };\n \n    // Iterate and print keys and values of unordered_map\n    for( const auto& n : u ) {\n        std::cout << \"Key:[\" << n.first << \"] Value:[\" << n.second << \"]\\n\";\n    }\n \n    // Add two new entries to the unordered_map\n    u[\"BLACK\"] = \"#000000\";\n    u[\"WHITE\"] = \"#FFFFFF\";\n \n    // Output values by key\n    std::cout << \"The HEX of color RED is:[\" << u[\"RED\"] << \"]\\n\";\n    std::cout << \"The HEX of color BLACK is:[\" << u[\"BLACK\"] << \"]\\n\";\n \n    return 0;\n}",
            "output": "Key:[RED] Value:[#FF0000]\nKey:[BLUE] Value:[#0000FF]\nKey:[GREEN] Value:[#00FF00]\nThe HEX of color RED is:[#FF0000]\nThe HEX of color BLACK is:[#000000]"
        }
    },
    "unordered_multimap": {
        "description": {
            "texte": "Unordered multimap is an unordered associative container that supports equivalent keys (an unordered_multimap may contain multiple copies of each key value) and that associates values of another type with the keys. The unordered_multimap class supports forward iterators. Search, insertion, and removal have average constant-time complexity.Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its key. This allows fast access to individual elements, since once the hash is computed, it refers to the exact bucket the element is placed into.The iteration order of this container is not required to be stable (so, for example, std::equal cannot be used to compare two std::unordered_multimaps), except that every group of elements whose keys compare equivalent (compare equal with key_eq() as the comparator) forms a contiguous subrange in the iteration order, also accessible with equal_range().std::unordered_multimap meets the requirements of Container, AllocatorAwareContainer, UnorderedAssociativeContainer."
        }
    },
    "stack": {
        "description": {
            "texte": "The std::stack class is a container adapter that gives the programmer the functionality of a stack - specifically, a LIFO (last-in, first-out) data structure.The class template acts as a wrapper to the underlying container - only a specific set of functions is provided. The stack pushes and pops the element from the back of the underlying container, known as the top of the stack."
        }
    },
    "queue": {
        "description": {
            "texte": "The std::queue class is a container adapter that gives the programmer the functionality of a queue - specifically, a FIFO (first-in, first-out) data structure.The class template acts as a wrapper to the underlying container - only a specific set of functions is provided. The queue pushes the elements on the back of the underlying container and pops them from the front."
        }
    },
    "priority_queue": {
        "description": {
            "texte": "A priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction.A user-provided Compare can be supplied to change the ordering, e.g. using std::greater<T> would cause the smallest element to appear as the top().Working with a priority_queue is similar to managing a  heap in some random access container, with the benefit of not being able to accidentally invalidate the heap."
        },
        "exemple": {
            "input": "#include <functional>\n#include <queue>\n#include <vector>\n#include <iostream>\n \ntemplate<typename T> void print_queue(T& q) {\n    while(!q.empty()) {\n        std::cout << q.top() << \" \";\n        q.pop();\n    }\n    std::cout << '\\n';\n}\n \nint main() {\n    std::priority_queue<int> q;\n \n    for(int n : {1,8,5,6,3,4,0,9,7,2})\n        q.push(n);\n \n    print_queue(q);\n \n    std::priority_queue<int, std::vector<int>, std::greater<int> > q2;\n \n    for(int n : {1,8,5,6,3,4,0,9,7,2})\n        q2.push(n);\n \n    print_queue(q2);\n \n    // Using lambda to compare elements.\n    auto cmp = [](int left, int right) { return (left ^ 1) < (right ^ 1);};\n    std::priority_queue<int, std::vector<int>, decltype(cmp)> q3(cmp);\n \n    for(int n : {1,8,5,6,3,4,0,9,7,2})\n        q3.push(n);\n \n    print_queue(q3);\n \n}",
            "output": "9 8 7 6 5 4 3 2 1 0 \n0 1 2 3 4 5 6 7 8 9 \n8 9 6 7 4 5 2 3 0 1"
        }
    },
    "complex": {
        "description": {
            "texte": "The specializations std::complex<float>, std::complex<double>, and std::complex<long double> are LiteralTypes for representing and manipulating complex numbers.The effect of instantiating the template complex for any other type is unspecified."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <cmath>\n \nint main()\n{\n    using namespace std::complex_literals;\n    std::cout << std::fixed << std::setprecision(1);\n \n    std::complex<double> z1 = 1i * 1i;     // imaginary unit squared\n    std::cout << \"i * i = \" << z1 << '\\n';\n \n    std::complex<double> z2 = std::pow(1i, 2); // imaginary unit squared\n    std::cout << \"pow(i, 2) = \" << z2 << '\\n';\n \n    double PI = std::acos(-1);\n    std::complex<double> z3 = std::exp(1i * PI); // Euler's formula\n    std::cout << \"exp(i * pi) = \" << z3 << '\\n';\n \n    std::complex<double> z4 = 1. + 2i, z5 = 1. - 2i; // conjugates\n    std::cout << \"(1+2i)*(1-2i) = \" << z4*z5 << '\\n';\n}",
            "output": "i * i = (-1.0,0.0)\npow(i, 2) = (-1.0,0.0)\nexp(i * pi) = (-1.0,0.0)\n(1+2i)*(1-2i) = (5.0,0.0)"
        }
    },
    "valarray": {
        "description": {
            "texte": "std::valarray is the class for representing and manipulating arrays of values. It supports element-wise mathematical operations and various forms of generalized subscript operators, slicing and indirect access."
        }
    },
    "Compile-time rational arithmetic": {
        "description": {
            "texte": "The class template std::ratio and associated templates provide compile-time rational arithmetic support. Each instantiation of this template exactly represents any finite rational number."
        }
    },
    "Floating-point environment": {
        "description": {
            "texte": "The floating-point environment is the set of floating-point status flags and control modes supported by the implementation. It is thread-local, each thread inherits the initial state of its floating-point environment from the parent thread. Floating-point operations modify the floating-point status flags to indicate abnormal results or auxiliary information. The state of floating-point control modes affects the outcomes of some floating-point operations.The floating-point environment access and modification is only meaningful when  #pragma STDC FENV_ACCESS is supported and is set to ON. Otherwise the implementation is free to assume that floating-point control modes are always the default ones and that floating-point status flags are never tested or modified. In practice, few current compilers, such as HP aCC, Oracle Studio, or IBM XL, support the #pragma explicitly, but most compilers allow meaningful access to the floating-point environment anyway."
        }
    },
    "ios_base": {
        "description": {
            "texte": "The class ios_base is a multipurpose class that serves as the base class for all I/O stream classes. It maintains several kinds of data:Typical implementation holds member constants corresponding to all values of fmtflags, iostate, openmode, and seekdir shown below, member variables to maintain current precision, width, and formatting flags, the exception mask, the buffer error state, a resizeable container holding the callbacks, the currently imbued locale, the private storage, and a static integer variable for xalloc()."
        }
    },
    "basic_ios": {
        "description": {
            "texte": "The class std::basic_ios provides facilities for interfacing with objects that have std::basic_streambuf interface. Several std::basic_ios objects can refer to one actual std::basic_streambuf object.Two specializations for common character types are also provided:"
        }
    },
    "basic_istream": {
        "description": {
            "texte": "The class template basic_istream provides support for high level input operations on character streams. The supported operations include formatted input (e.g. integer values or whitespace-separated characters and characters strings) and unformatted input (e.g. raw characters and character arrays). This functionality is implemented in terms of the interface provided by the underlying basic_streambuf class, accessed through the basic_ios base class. The only non-inherited data member of basic_istream, in most implementations, is the value returned by basic_istream::gcount().Two specializations for common character types are defined:"
        }
    },
    "basic_ostream": {
        "description": {
            "texte": "The class template basic_ostream provides support for high level output operations on character streams. The supported operations include formatted output (e.g. integer values) and unformatted output (e.g. raw characters and character arrays). This functionality is implemented in terms of the interface provided by the basic_streambuf class, accessed through the basic_ios base class. In typical implementations, basic_ostream has no non-inherited data members.Two specializations for common character types are also defined:"
        }
    },
    "basic_iostream": {
        "description": {
            "texte": "The class template basic_iostream provides support for high level input/output operations on streams. The supported operations include sequential reading or writing and formatting. This functionality is implemented over the interface provided by the basic_streambuf class. It is accessed through basic_ios class.Two specializations for common character types are defined:"
        }
    },
    "basic_fstream": {
        "description": {
            "texte": "The class template basic_fstream implements high-level input/output operations on file based streams. It interfaces a file-based streambuffer (std::basic_filebuf) with the high-level interface of (std::basic_iostream).A typical implementation of std::basic_fstream holds only one non-derived data member: an instance of std::basic_filebuf<CharT, Traits>.Two specializations for common character types are also defined:"
        },
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <string>\n \nint main() {\n  std::string filename = \"test.bin\";\n  std::fstream s(filename, s.binary | s.trunc | s.in | s.out);\n  if (!s.is_open()) {\n    std::cout << \"failed to open \" << filename << '\\n';\n  } else {\n    // write\n    double d = 3.14;\n    s.write(reinterpret_cast<char*>(&d), sizeof d); // binary output\n    s << 123 << \"abc\";                              // text output\n \n    // for fstream, this moves the file position pointer (both put and get)\n    s.seekp(0);\n \n    // read\n    s.read(reinterpret_cast<char*>(&d), sizeof d); // binary input\n    int n;\n    std::string str;\n    if (s >> n >> str)                             // text input\n      std::cout << \"read back from file: \" << d << ' ' << n << ' ' << str << '\\n';\n  }\n}",
            "output": "read back from file: 3.14 123 abc"
        }
    },
    "basic_ifstream": {
        "description": {
            "texte": "The class template basic_ifstream implements high-level input operations on file based streams. It interfaces a file-based streambuffer (std::basic_filebuf) with the high-level interface of (std::basic_istream).A typical implementation of std::basic_ifstream holds only one non-derived data member: an instance of std::basic_filebuf<CharT, Traits>.Two specializations for common character types are also defined:"
        },
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <string>\n \nint main() {\n  std::string filename = \"Test.b\";\n  // prepare a file to read\n  double d = 3.14;\n  std::ofstream(filename, std::ios::binary).write(reinterpret_cast<char*>(&d), sizeof d)\n     << 123 << \"abc\";\n  // open file for reading\n  std::ifstream istrm(filename, std::ios::binary);\n  if (!istrm.is_open()) {\n    std::cout << \"failed to open \" << filename << '\\n';\n  } else {\n    double d;\n    istrm.read(reinterpret_cast<char*>(&d), sizeof d); // binary input\n    int n;\n    std::string s;\n    if (istrm >> n >> s)                               // text input\n      std::cout << \"read back from file: \" << d << ' ' << n << ' ' << s << '\\n';\n  }\n}",
            "output": "read back from file: 3.14 123 abc"
        }
    },
    "basic_ofstream": {
        "description": {
            "texte": "The class template basic_ofstream implements high-level output operations on file based streams. It interfaces a file-based streambuffer (std::basic_filebuf) with the high-level interface of (std::basic_ostream).A typical implementation of std::basic_ofstream holds only one non-derived data member: an instance of std::basic_filebuf<CharT, Traits>.Two specializations for common character types are also defined:"
        },
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <string>\n \nint main() {\n    std::string filename = \"Test.b\";\n    {\n        std::ofstream ostrm(filename, std::ios::binary);\n        double d = 3.14;\n        ostrm.write(reinterpret_cast<char*>(&d), sizeof d); // binary output\n        ostrm << 123 << \"abc\" << '\\n';                      // text output\n    }\n    // read back\n    std::ifstream istrm(filename, std::ios::binary);\n    double d;\n    istrm.read(reinterpret_cast<char*>(&d), sizeof d);\n    int n;\n    std::string s;\n    istrm >> n >> s;\n    std::cout << \" read back: \" << d << \" \" << n << \" \" << s << '\\n';\n}",
            "output": "read back: 3.14 123 abc"
        }
    },
    "basic_stringstream": {
        "description": {
            "texte": "The class template std::basic_stringstream implements input/output operations on memory (std::basic_string) based streams. It essentially wraps a raw string device implementation (std::basic_stringbuf) into a higher-level interface (std::basic_iostream). The complete interface to unique std::basic_stringbuf members is provided.Two specializations for common character types are also defined:"
        }
    },
    "basic_istringstream": {
        "description": {
            "texte": "The class template std::basic_istringstream implements input operations on memory (std::basic_string) based streams. It essentially wraps a raw string device implementation (std::basic_stringbuf) into a higher-level interface (std::basic_istream). The complete interface to unique std::basic_stringbuf members is provided.Two specializations for common character types are also defined:"
        }
    },
    "basic_ostringstream": {
        "description": {
            "texte": "The class template std::basic_ostringstream implements output operations on memory (std::basic_string) based streams. It essentially wraps a raw string device implementation (std::basic_stringbuf) into a higher-level interface (std::basic_ostream). The complete interface to unique std::basic_stringbuf members is provided.Two specializations for common character types are also defined:"
        }
    },
    "strstream": {
        "description": {
            "texte": "The class strstream implements input and output operations on array-backed streams. It essentially wraps a raw array I/O device implementation (std::strstreambuf) into the higher-level interface of std::basic_iostream.The typical implementation of strstream holds only one non-derived data member: an object of type std::strstreambuf."
        }
    },
    "istrstream": {
        "description": {
            "texte": "The class istrstream implements input operations on array-backed streams. It essentially wraps a raw array I/O device implementation (std::strstreambuf) into the higher-level interface of std::basic_istream.The typical implementation of istrstream holds only one non-derived data member: an object of type std::strstreambuf."
        }
    },
    "ostrstream": {
        "description": {
            "texte": "The class ostrstream implements output operations on array-backed streams. It essentially wraps a raw array I/O device implementation (std::strstreambuf) into the higher-level interface of std::basic_ostream.The typical implementation of ostrstream holds only one non-derived data member: an object of type std::strstreambuf."
        }
    },
    "basic_streambuf": {
        "description": {
            "texte": "The class basic_streambuf controls input and output to a character sequence. It includes and provides access to.The I/O stream objects std::basic_istream and std::basic_ostream, as well as all objects derived from them (std::ofstream, std::stringstream, etc), are implemented entirely in terms of std::basic_streambuf.The controlled character sequence is an array of CharT which, at all times, represents a subsequence, or a \"window\" into the associated character sequence. Its state is described by three pointers:A basic_streambuf object may support input (in which case the buffer described by the beginning, next, and end pointers is called get area), output (put area), or input and output simultaneously. In latter case, six pointers are tracked, which may all point to elements of the same character array or two individual arrays.If the next pointer is less than the end pointer in the put area, a write position is available. The next pointer can be dereferenced and assigned to.If the next pointer is less than the end pointer in the get area, a read position is available. The next pointer can be dereferenced and read from.If the next pointer is greater than the beginning pointer in a get area, a putback position is available, and the next pointer may be decremented, dereferenced, and assigned to, in order to put a character back into the get area.The character representation and encoding in the controlled sequence may be different from the character representations in the associated sequence, in which case a std::codecvt locale facet is typically used to perform the conversion. Common examples are UTF-8 (or other multibyte) files accessed through std::wfstream objects: the controlled sequence consists of wchar_t characters, but the associated sequence consists of bytes.Typical implementation of the std::basic_streambuf base class holds only the six CharT* pointers and a copy of std::locale as data members. In addition, implementations may keep cached copies of locale facets, which are invalidated whenever imbue() is called. The concrete buffers such as std::basic_filebuf or std::basic_stringbuf are derived from std::basic_streambuf.Two convenience typedefs are provided by the standard library."
        }
    },
    "C-style file input/output": {
        "description": {
            "texte": "The C I/O subset of the C++ standard library implements C-style stream input/output operations. The <cstdio> header provides generic file operation support and supplies functions with narrow and multibyte character input/output capabilities, and the <cwchar> header provides functions with wide character input/output capabilities.C streams are objects of type std::FILE that can only be accessed and manipulated through pointers of type std::FILE* (Note: while it may be possible to create a local object of type std::FILE by dereferencing and copying a valid std::FILE*, using the address of such copy in the I/O functions is undefined behavior). Each C stream is associated with an external physical device (file, standard input stream, printer, serial port, etc).C streams can be used for both unformatted and formatted input and output. They are locale-sensitive and may perform wide/multibyte conversions as necessary. Unlike C++ streams, where each stream is associated with its own locale, all C streams access the same locale object: the one most recently installed with std::setlocale.Besides the system-specific information necessary to access the device (e.g. a POSIX file descriptor), each C stream object holds the following:A newly opened stream has no orientation. The first call to std::fwide or to any I/O function establishes the orientation: wide I/O function makes the stream wide-oriented, narrow I/O function makes the stream narrow-oriented. Once set, orientation can only be changed with std::freopen. Narrow I/O functions cannot be called on a wide-oriented stream, wide I/O functions cannot be called on a narrow-oriented stream. Wide I/O functions convert between wide and multibyte characters as if by calling std::mbrtowc and std::wcrtomb. Unlike the multibyte character strings that are valid in a program, multibyte characters in the file may contain embedded nulls and do not have to begin or end in the initial shift state.POSIX requires that the LC_CTYPE facet of the currently installed C locale is stored within the stream object the moment its orientation becomes wide, and is used for all future I/O on this stream until the orientation is changed, regardless of any subsequent calls to std::setlocale.A text stream is an ordered sequence of characters composed into lines (zero or more characters plus a terminating '\\n'). Whether the last line requires a terminating '\\n' is implementation-defined. Characters may have to be added, altered, or deleted on input and output to conform to the conventions for representing text in the OS (in particular, C streams on Windows OS convert \\n to \\r\\n on output, and convert \\r\\n to \\n on input).Data read in from a text stream is guaranteed to compare equal to the data that were earlier written out to that stream only if all of the following is true:A binary stream is an ordered sequence of characters that can transparently record internal data. Data read in from a binary stream always equals to the data that were earlier written out to that stream. Implementations are only allowed to append a number of null characters to the end of the stream. A wide binary stream doesn't need to end in the initial shift state.POSIX implementations do not distinguish between text and binary streams (there is no special mapping for \\n or any other characters)."
        }
    },
    "thread": {
        "description": {
            "texte": "The class thread represents a single thread of execution. Threads allow multiple functions to execute concurrently.Threads begin execution immediately upon construction of the associated thread object (pending any OS scheduling delays), starting at the top-level function provided as a constructor argument. The return value of the top-level function is ignored and if it terminates by throwing an exception, std::terminate is called. The top-level function may communicate its return value or an exception to the caller via std::promise or by modifying shared variables (which may require synchronization, see std::mutex and std::atomic).std::thread objects may also be in the state that does not represent any thread (after default construction, move from, detach, or join), and a thread of execution may be not associated with any thread objects (after detach).No two std::thread objects may represent the same thread of execution; std::thread is not CopyConstructible or CopyAssignable, although it is MoveConstructible and MoveAssignable."
        }
    },
    "malloc": {
        "description": {
            "texte": "Allocates size bytes of uninitialized storage.If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any scalar type.If size is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage, but has to be passed to std::free)."
        },
        "parametres": "   size   -   number of bytes to allocate \n\n",
        "exemple": {
            "input": "#include <iostream>   \n#include <cstdlib> \n#include <string>\n \nint main() \n{\n    // allocates enough for an array of 4 strings\n    if(auto p = (std::string*)std::malloc(4 * sizeof(std::string)))\n    {\n        int i = 0;\n        try\n        {\n            for(; i != 4; ++i) // populate the array\n                new(p + i) std::string(5, 'a' + i);\n \n            for(int j = 0; j != 4; ++j) // print it back out\n                std::cout << \"p[\" << j << \"] == \" << p[j] << '\\n';\n        }\n        catch(...) {}\n \n        for(; i != 0; --i) // clean up\n            p[i - 1].~basic_string();\n \n        std::free(p);\n    }\n}",
            "output": "p[0] == aaaaa\np[1] == bbbbb\np[2] == ccccc\np[3] == ddddd"
        }
    },
    "Mathematical special functions": {
        "description": {
            "texte": "The Mathematical Special Functions library was originally part of Library TR1 ISO/IEC TR 19768:2007, then published as an independent ISO standard, ISO/IEC 29124:2010, and finally merged to ISO C++ as of C++17.See Mathematical special functions for the ISO/IEC 29124:2010 version of this library."
        }
    },
    "byte": {
        "description": {
            "texte": "std::byte is a distinct type that implements the concept of byte as specified in the C++ language definition.Like char and unsigned char, it can be used to access raw memory occupied by other objects (object representation), but unlike those types, it is not a character type and is not an arithmetic type. A byte is only a collection of bits, and the only operators defined for it are the bitwise ones."
        }
    },
    "Preprocessor": {
        "description": {
            "texte": "The preprocessor is executed at translation phase 4, before the compilation. The result of preprocessing is a single file which is then passed to the actual compiler."
        }
    },
    "Comments": {
        "description": {
            "texte": "Comments serve as a sort of in-code documentation. When inserted into a program, they are effectively ignored by the compiler; they are solely intended to be used as notes by the humans that read source code. Although specific documentation is not part of the C++ standard, several utilities exist that parse comments with different documentation formats."
        },
        "exemple": {
            "input": "/* C-style comments can contain\nmultiple lines */\n/* or just one */\n \n// C++-style comments can comment one line\n \n// or, they can\n// be strung together\n \nint main()\n{\n  // The below code won't be run\n  // return 1;\n \n  // The below code will be run\n  return 0;\n}"
        }
    },
    "C++ keywords": {
        "description": {
            "texte": "This is a list of reserved keywords in C++. Since they are used by the language, these keywords are not available for re-definition or overloading.Note that and, bitor, or, xor, compl, bitand, and_eq, or_eq, xor_eq, not, and not_eq (along with the digraphs <%, %>, <:, :>, %:, and %:%:) provide an alternative way to represent standard tokens.In addition to keywords, there are identifiers with special meaning, which may be used as names of objects or functions, but have special meaning in certain contexts.Also, all identifiers that contain a double underscore __ in any position and each identifier that begins with an underscore followed by an uppercase letter is always reserved and all identifiers that begin with an underscore are reserved for use as names in the global namespace. See identifiers for more details.The namespace std is used to place names of the standard C++ library. See Extending namespace std for the rules about adding names to it.The following tokens are recognized by the preprocessor when in context of a preprocessor directive:The following tokens are recognized by the preprocessor outside the context of a preprocessor directive:"
        }
    },
    "Conditional inclusion": {
        "description": {
            "texte": "The preprocessor supports conditional compilation of parts of source file. This behavior is controlled by #if, #else, #elif, #ifdef, #ifndef and #endif directives."
        },
        "exemple": {
            "input": "#define ABCD 2\n#include <iostream>\n \nint main()\n{\n \n#ifdef ABCD\n    std::cout << \"1: yes\\n\";\n#else\n    std::cout << \"1: no\\n\";\n#endif\n \n#ifndef ABCD\n    std::cout << \"2: no1\\n\";\n#elif ABCD == 2\n    std::cout << \"2: yes\\n\";\n#else\n    std::cout << \"2: no2\\n\";\n#endif\n \n#if !defined(DCBA) && (ABCD < 2*4-3)\n    std::cout << \"3: yes\\n\";\n#endif\n}",
            "output": "1: yes\n2: yes\n3: yes"
        }
    },
    "Replacing text macros": {
        "description": {
            "texte": "The preprocessor supports text macro replacement. Function-like text macro replacement is also supported."
        },
        "exemple": {
            "input": "#include <iostream>\n \n// Make function factory and use it\n#define FUNCTION(name, a) int fun_##name() { return a;}\n \nFUNCTION(abcd, 12)\nFUNCTION(fff, 2)\nFUNCTION(qqq, 23)\n \n#undef FUNCTION\n#define FUNCTION 34\n#define OUTPUT(a) std::cout << \"output: \" #a << '\\n'\n \n// Using a macro in the definition of a later macro\n#define WORD \"Hello \"\n#define OUTER(...) WORD #__VA_ARGS__\n \nint main()\n{\n    std::cout << \"abcd: \" << fun_abcd() << '\\n';\n    std::cout << \"fff: \" << fun_fff() << '\\n';\n    std::cout << \"qqq: \" << fun_qqq() << '\\n';\n \n    std::cout << FUNCTION << '\\n';\n    OUTPUT(million);               //note the lack of quotes\n \n    std::cout << OUTER(World) << '\\n';\n    std::cout << OUTER(WORD World) << '\\n';\n}",
            "output": "abcd: 12\nfff: 2\nqqq: 23\n34\noutput: million\nHello World\nHello WORD World"
        }
    },
    "Source file inclusion": {
        "description": {
            "texte": "Includes other source file into current source file at the line immediately after the directive."
        },
        "exemple": {
            "input": "#if __has_include(<optional>)\n#  include <optional>\n#  define have_optional 1\n#elif __has_include(<experimental/optional>)\n#  include <experimental/optional>\n#  define have_optional 1\n#  define experimental_optional 1\n#else\n#  define have_optional 0\n#endif\n \n#include <iostream>\n \nint main()\n{\n    if (have_optional)\n        std::cout << \"<optional> is present.\\n\";\n \n    int x = 42;\n#if have_optional == 1\n    std::optional<int> i = x;\n#else\n    int* i = &x;\n#endif\n    std::cout << \"i = \" << *i << '\\n';\n}",
            "output": "<optional> is present.\ni = 42"
        }
    },
    "Error directive": {
        "description": {
            "texte": "Shows the given error message and renders the program ill-formed."
        }
    },
    "Implementation defined behavior control": {
        "description": {
            "texte": "Implementation defined behavior is controlled by #pragma directive."
        }
    },
    "Filename and line information": {
        "description": {
            "texte": "Changes the current file name and number in the preprocessor."
        },
        "exemple": {
            "input": "#include <cassert>\n#define FNAME \"test.cc\"\nint main()\n{\n#line 777 FNAME\n        assert(2+2 == 5);\n}",
            "output": "test: test.cc:777: int main(): Assertion `2+2 == 5' failed."
        }
    },
    "abort": {
        "description": {
            "texte": "Causes abnormal program termination unless SIGABRT is being caught by a signal handler passed to std::signal and the handler does not return.Destructors of variables with automatic, thread local (since C++11) and static  storage durations are not called. Functions registered with std::atexit() and std::at_quick_exit (since C++11) are also not called. Whether open resources such as files are closed is implementation defined. An implementation defined status is returned to the host environment that indicates unsuccessful execution."
        },
        "exemple": {
            "input": "#include <csignal>\n#include <iostream>\n#include <cstdlib>\n \nclass Tester {\npublic:\n    Tester()  { std::cout << \"Tester ctor\\n\"; }\n    ~Tester() { std::cout << \"Tester dtor\\n\"; }\n};\n \nTester static_tester; // Destructor not called\n \nvoid signal_handler(int signal) \n{\n    if (signal == SIGABRT) {\n        std::cerr << \"SIGABRT received\\n\";\n    } else {\n        std::cerr << \"Unexpected signal \" << signal << \" received\\n\";\n    }\n    std::_Exit(EXIT_FAILURE);\n}\n \nint main()\n{\n    Tester automatic_tester; // Destructor not called\n \n    // Setup handler\n    auto previous_handler = std::signal(SIGABRT, signal_handler);\n    if (previous_handler == SIG_ERR) {\n        std::cerr << \"Setup failed\\n\";\n        return EXIT_FAILURE;\n    }\n \n    std::abort();  // Raise SIGABRT\n    std::cout << \"This code is unreachable\\n\";\n}",
            "output": "Tester ctor\nTester ctor\nSIGABRT received"
        }
    },
    "atexit": {
        "description": {
            "texte": "Registers the function pointed to by func to be called on normal program termination (via std::exit() or returning from the main function).The same function may be registered more than once.If a function exits via an exception, std::terminate is called.atexit is thread-safe: calling the function from several threads does not induce a data race.The implementation is guaranteed to support the registration of at least 32 functions. The exact limit is implementation-defined."
        },
        "parametres": "   func   -   pointer to a function to be called on normal program termination \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstdlib>\n \nvoid atexit_handler_1() \n{\n    std::cout << \"at exit #1\\n\";\n}\n \nvoid atexit_handler_2() \n{\n    std::cout << \"at exit #2\\n\";\n}\n \nint main() \n{\n    const int result_1 = std::atexit(atexit_handler_1);\n    const int result_2 = std::atexit(atexit_handler_2);\n \n    if ((result_1 != 0) or (result_2 != 0)) {\n        std::cerr << \"Registration failed\\n\";\n        return EXIT_FAILURE;\n    }\n \n    std::cout << \"returning from main\\n\";\n    return EXIT_SUCCESS;\n}",
            "output": "returning from main\nat exit #2\nat exit #1"
        }
    },
    "exit": {
        "description": {
            "texte": "Causes normal program termination to occur.Several cleanup steps are performed:Stack is not unwound: destructors of variables with automatic  storage duration are not called."
        },
        "parametres": "   exit_code   -   exit status of the program \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstdlib>\n \nclass Static {\npublic:\n \n    ~Static() \n    {\n        std::cout << \"Static dtor\\n\";\n    }\n};\n \nclass Local {\npublic:\n    ~Local() \n    {\n        std::cout << \"Local dtor\\n\";\n    }\n};\n \nStatic static_variable; // dtor of this object *will* be called\n \nvoid atexit_handler()\n{\n    std::cout << \"atexit handler\\n\";\n}\n \nint main()\n{\n    Local local_variable; // dtor of this object will *not* be called\n    const int result = std::atexit(atexit_handler); // handler will be called\n \n    if (result != 0) {\n        std::cerr << \"atexit registration failed\\n\";\n        return EXIT_FAILURE;\n    }\n \n    std::cout << \"test\\n\";\n    std::exit(EXIT_FAILURE);\n}",
            "output": "test\natexit handler\nStatic dtor"
        }
    },
    "at_quick_exit": {
        "description": {
            "texte": "Registers the function pointed to by func to be called on quick program termination (via std::quick_exit).Calling the function from several threads does not induce a data race. The implementation shall support the registration of at least 32 functions.The registered functions will not be called on normal program termination. If a function need to be called in that case, std::atexit must be used."
        },
        "parametres": "   func   -   pointer to a function to be called on quick program termination \n\n"
    },
    "quick_exit": {
        "description": {
            "texte": "Causes normal program termination to occur without completely cleaning the resources.Functions passed to std::at_quick_exit are called in reverse order of their registration. If an exception tries to propagate out of any of the functions, std::terminate is called. After calling the registered functions, calls std::_Exit(exit_code).Functions passed to std::atexit are not called."
        },
        "parametres": "   exit_code   -   exit status of the program \n\n"
    },
    "C++ named requirements: DefaultConstructible": {
        "description": {
            "texte": "Specifies that an instance of the type can be default constructed."
        }
    },
    "C++ named requirements: CopyAssignable": {
        "description": {
            "texte": "Specifies that an instance of the type can be copy-assigned from an lvalue expression."
        }
    },
    "C++ named requirements: CopyConstructible": {
        "description": {
            "texte": "Specifies that an instance of the type can be copy-constructed from an lvalue expression."
        }
    },
    "C++ named requirements: MoveAssignable (since C++11)\n": {
        "description": {
            "texte": "Specifies that an instance of the type can be assigned from an rvalue argument."
        }
    },
    "C++ named requirements: MoveConstructible (since C++11)\n": {
        "description": {
            "texte": "Specifies that an instance of the type can be constructed from an rvalue argument."
        }
    },
    "C++ named requirements: Destructible": {
        "description": {
            "texte": "Specifies that an instance of the type can be destructed."
        }
    },
    "C++ named requirements: TrivialType": {
        "description": {
            "texte": "Specifies that a type is a trivial type.Note: the standard doesn't define a named requirement with this name. This is a type category defined by the core language. It is included here as a named requirement only for consistency."
        }
    },
    "C++ named requirements: TriviallyCopyable": {
        "description": {
            "texte": "This implies that the class has no virtual functions or virtual base classes.Scalar types and arrays of TriviallyCopyable objects are TriviallyCopyable as well, as well as the const-qualified (but not volatile-qualified) versions of such types."
        }
    },
    "C++ named requirements: StandardLayoutType": {
        "description": {
            "texte": "Specifies that a type is standard layout type. Standard layout types are useful for communicating with code written in other programming languages.Note: the standard doesn't define a named requirement with this name. This is a type category defined by the core language. It is included here as a named requirement only for consistency."
        }
    },
    "C++ named requirements: PODType": {
        "description": {
            "texte": "Specifies that the type is POD (Plain Old Data) type. This means the type is compatible with the types used in the C programming language, that is, can be exchanged with C libraries directly, in its binary form.Note: the standard doesn't define a named requirement with this name. This is a type category defined by the core language. It is included here as a named requirement only for consistency."
        }
    },
    "C++ named requirements: EqualityComparable": {
        "description": {
            "texte": "The type must work with == operator and the result should have standard semantics."
        }
    },
    "C++ named requirements: LessThanComparable": {
        "description": {
            "texte": "The type must work with < operator and the result should have standard semantics."
        }
    },
    "C++ named requirements: Swappable": {
        "description": {
            "texte": "Any lvalue or rvalue of this type can be swapped with any lvalue or rvalue of some other type, using unqualified function call swap() in the context where both std::swap and the user-defined swap()s are visible."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n \nclass IntVector {\n    std::vector<int> v;\n    IntVector& operator=(IntVector) = delete; // not assignable\n public:\n    void swap(IntVector& other) {\n        v.swap(other.v);\n    }\n};\nvoid swap(IntVector& v1, IntVector& v2) {\n    v1.swap(v2);\n}\n \nint main()\n{\n    IntVector v1, v2;\n//  std::swap(v1, v2); // compiler error! std::swap requires MoveAssignable\n    std::iter_swap(&v1, &v2); // OK: library calls unqualified swap()\n}"
        }
    },
    "C++ named requirements: ValueSwappable": {
        "description": {
            "texte": "Two objects of this type can be dereferenced and the resulting values can be swapped using unqualified function call swap() in the context where both std::swap and the user-defined swap()s are visible."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n \nclass IntVector {\n    std::vector<int> v;\n    IntVector& operator=(IntVector); // not assignable\n public:\n    void swap(IntVector& other) {\n        v.swap(other.v);\n    }\n};\nvoid swap(IntVector& v1, IntVector& v2) {\n    v1.swap(v2);\n}\n \nint main()\n{\n    IntVector v1, v2;    // IntVector is Swappable, but not MoveAssignable\n    IntVector* p1 = &v1;\n    IntVector* p2 = &v2; // IntVector* is ValueSwappable\n    std::iter_swap(p1, p2); // OK: iter_swap requires ValueSwappable\n//  std::swap(v1, v2); // compiler error! std::swap requires MoveAssignable\n}"
        }
    },
    "C++ named requirements: NullablePointer (since C++11)\n": {
        "description": {
            "texte": "Specifies that the type is a pointer-like object which can be compared to std::nullptr_t objects."
        }
    },
    "C++ named requirements: Hash": {
        "description": {
            "texte": "A Hash is a function object for which the output depends only on the input and has a very low probability of yielding the same output given different input values."
        }
    },
    "C++ named requirements: Allocator": {
        "description": {
            "texte": "Encapsulates strategies for access/addressing, allocation/deallocation and construction/destruction of objects.Every standard library component that may need to allocate or release storage, from std::string, std::vector, and every container except std::array, to std::shared_ptr and std::function, does so through an Allocator: an object of a class type that satisfies the following requirements.Some requirements are optional: the template std::allocator_traits supplies the default implementations for all optional requirements, and all standard library containers and other allocator-aware classes access the allocator through std::allocator_traits, not directly."
        },
        "exemple": {
            "input": "#include <cstdlib>\n#include <new>\ntemplate <class T>\nstruct Mallocator {\n  typedef T value_type;\n  Mallocator() = default;\n  template <class U> constexpr Mallocator(const Mallocator<U>&) noexcept {}\n  [[nodiscard]] T* allocate(std::size_t n) {\n    if(n > std::size_t(-1) / sizeof(T)) throw std::bad_alloc();\n    if(auto p = static_cast<T*>(std::malloc(n*sizeof(T)))) return p;\n    throw std::bad_alloc();\n  }\n  void deallocate(T* p, std::size_t) noexcept { std::free(p); }\n};\ntemplate <class T, class U>\nbool operator==(const Mallocator<T>&, const Mallocator<U>&) { return true; }\ntemplate <class T, class U>\nbool operator!=(const Mallocator<T>&, const Mallocator<U>&) { return false; }"
        }
    },
    "C++ named requirements: FunctionObject": {
        "description": {
            "texte": "A FunctionObject type is the type of an object that can be used on the left of the function call operator."
        }
    },
    "C++ named requirements: Callable": {
        "description": {
            "texte": "A Callable type is a type for which the INVOKE operation (used by, e.g., std::function, std::bind, and std::thread::thread) is applicable. This operation may be performed explicitly using the library function std::invoke. (since C++17)."
        }
    },
    "C++ named requirements: Predicate": {
        "description": {
            "texte": "The Predicate requirements describe a callable that returns a value testable as a bool.Predicate is typically used with algorithms that take input data (individual objects/containers) and a predicate, which is then called on input data to decide on further course of action. Some examples of predicate usage in C++ standard library are:Description of algorithm facilities, given above, is crude and intended to explain Predicate in simple terms. For detailed info, refer to individual pages.In other words, if an algorithm takes a Predicate pred and an iterator first, it should be able to test the object of the type pointed to by the iterator first using the given predicate via a construct like if(pred(*first)) {...}.The function object pred shall not apply any non-constant function through the dereferenced iterator. This function object may be a pointer to function or an object of a type with an appropriate function call operator."
        }
    },
    "C++ named requirements: BinaryPredicate": {
        "description": {
            "texte": "BinaryPredicate is a set of requirements expected by some of the standard library facilities from the user-provided arguments.Given a BinaryPredicate bin_pred and a pair of iterators iter1 and iter2 or an iterator iter and a value value, the expression bin_pred(*iter1, *iter2) or, respectively, bin_pred(*iter, value), must be contextually convertible to bool.In addition, evaluation of that expression is not allowed to call non-const member functions of the dereferenced iterators."
        }
    },
    "C++ named requirements: Compare": {
        "description": {
            "texte": "Compare is a set of requirements expected by some of the standard library facilities from the user-provided function object types.The return value of the function call operation applied to an object of a type satisfying Compare, when contextually converted to bool, yields true if the first argument of the call appears before the second in the strict weak ordering relation induced by this type, and false otherwise.As with any BinaryPredicate, evaluation of that expression is not allowed to call non-const functions through the dereferenced iterators."
        }
    },
    "C++ named requirements: Container": {
        "description": {
            "texte": "A Container is an object used to store other objects and taking care of the management of the memory used by the objects it contains."
        }
    },
    "C++ named requirements: SequenceContainer": {
        "description": {
            "texte": "A SequenceContainer is a Container that stores objects of the same type in a linear arrangement."
        }
    },
    "C++ named requirements: ContiguousContainer": {
        "description": {
            "texte": "A ContiguousContainer is a Container that stores objects in contiguous memory locations."
        }
    },
    "C++ named requirements: ReversibleContainer": {
        "description": {
            "texte": "A ReversibleContainer is a Container that has iterators that meet the requirements of either LegacyBidirectionalIterator or LegacyRandomAccessIterator. Such iterators allow a ReversibleContainer to be iterated over in reverse."
        },
        "exemple": {
            "input": "#include <vector>\n#include <iostream>\n \nint main()\n{\n    std::vector<int> v = {3, 1, 4, 1, 5, 9};\n \n    for(std::vector<int>::reverse_iterator i = v.rbegin(); i != v.rend(); ++i) {\n        std::cout << *i << '\\n';\n    }\n}",
            "output": "9\n5\n1\n4\n1\n3"
        }
    },
    "C++ named requirements: AssociativeContainer": {
        "description": {
            "texte": "An AssociativeContainer is an ordered Container that provides fast lookup of objects based on keys."
        }
    },
    "C++ named requirements: AllocatorAwareContainer": {
        "description": {
            "texte": "An AllocatorAwareContainer is a Container that holds an instance of an Allocator and uses that instance in all its member functions to allocate and deallocate memory and to construct and destroy objects in that memory (such objects may be container elements, nodes, or, for unordered containers, bucket arrays).The following rules apply to container construction.The only way to replace an allocator is copy-assignment, move-assignment, and swap:Note: swapping two containers with unequal allocators if propagate_on_container_swap is false is undefined behavior."
        }
    },
    "C++ named requirements: UnorderedAssociativeContainer": {
        "description": {
            "texte": "Unordered associative containers are Containers that provide fast lookup of objects based on keys. Worst case complexity is linear but on average much faster for most of the operations.Unordered associative containers are parametrized by Key; Hash, a Hash function object which acts as hash function on Key; and Pred, a BinaryPredicate evaluating equivalence between Keys. std::unordered_map and std::unordered_multimap also have a mapped type T associated with the Key.If two Keys are equal according to Pred, Hash must return the same value for both keys.std::unordered_map and std::unordered_set can contain at most one element with a given key, std::unordered_multiset and std::unordered_multimap instead can have multiple elements with the same key (which must always be adjacent on iterations).For std::unordered_set and std::unordered_multiset the value type is the same as the key type and both iterator and const_iterator are constant iterators. For std::unordered_map and std::unordered_multimap the value type is std::pair<const Key, T>.Elements in an unordered associative container are organized into buckets, keys with the same hash will end up in the same bucket. The number of buckets is increased when the size of the container increases to keep the average number of elements in each bucket under a certain value.Rehashing invalidates iterator and might cause the elements to be re-arranged in different buckets but it doesn't invalidate references to the elements.Unordered associative containers meet the requirements of AllocatorAwareContainer. For std::unordered_map and std::unordered_multimap the requirements of value_type in AllocatorAwareContainer apply to key_type and mapped_type (not to value_type)."
        }
    },
    "C++ named requirements: DefaultInsertable": {
        "description": {
            "texte": "Specifies that an instance of the type can be default-constructed in-place by a given allocator."
        }
    },
    "C++ named requirements: CopyInsertable": {
        "description": {
            "texte": "Specifies that an instance of the type can be copy-constructed in-place by a given allocator."
        }
    },
    "C++ named requirements: MoveInsertable (since C++11)\n": {
        "description": {
            "texte": "Specifies that an object of the type can be constructed into uninitialized storage from an rvalue of that type by a given allocator."
        }
    },
    "C++ named requirements: EmplaceConstructible (since C++11)\n": {
        "description": {
            "texte": "Specifies that an object of the type can be constructed from a given set of arguments in uninitialized storage by a given allocator."
        }
    },
    "C++ named requirements: Erasable": {
        "description": {
            "texte": "Specifies that an object of the type can be destroyed by a given Allocator."
        }
    },
    "C++ named requirements: LegacyIterator": {
        "description": {
            "texte": "The LegacyIterator requirements describe types that can be used to identify and traverse the elements of a container.LegacyIterator is the base set of requirements used by other iterator types: LegacyInputIterator, LegacyOutputIterator, LegacyForwardIterator, LegacyBidirectionalIterator, and LegacyRandomAccessIterator. Iterators can be thought of as an abstraction of pointers."
        }
    },
    "C++ named requirements: LegacyOutputIterator": {
        "description": {
            "texte": "A LegacyOutputIterator is a LegacyIterator that can write to the pointed-to element.An example of a type that implements LegacyOutputIterator is std::ostream_iterator.When LegacyForwardIterator, LegacyBidirectionalIterator, or LegacyRandomAccessIterator satisfies the LegacyOutputIterator requirements in addition to its own requirements, it is described as mutable."
        }
    },
    "C++ named requirements: LegacyInputIterator": {
        "description": {
            "texte": "An LegacyInputIterator is an LegacyIterator that can read from the pointed-to element. LegacyInputIterators only guarantee validity for single pass algorithms: once an LegacyInputIterator i has been incremented, all copies of its previous value may be invalidated."
        }
    },
    "C++ named requirements: LegacyForwardIterator": {
        "description": {
            "texte": "A LegacyForwardIterator is an LegacyIterator that can read data from the pointed-to element.Unlike LegacyInputIterator and LegacyOutputIterator, it can be used in multipass algorithms."
        }
    },
    "C++ named requirements: LegacyBidirectionalIterator": {
        "description": {
            "texte": "A LegacyBidirectionalIterator is a LegacyForwardIterator that can be moved in both directions (i.e. incremented and decremented)."
        }
    },
    "C++ named requirements: LegacyRandomAccessIterator": {
        "description": {
            "texte": "A LegacyRandomAccessIterator is a LegacyBidirectionalIterator that can be moved to point to any element in constant time.A pointer to an element of an array satisfies all requirements of LegacyRandomAccessIterator."
        }
    },
    "C++ named requirements: LegacyContiguousIterator": {
        "description": {
            "texte": "A LegacyContiguousIterator is an LegacyIterator whose logically adjacent elements are also physically adjacent in memory.A pointer to an element of an array satisfies all requirements of LegacyContiguousIterator."
        }
    },
    "C++ named requirements: ConstexprIterator": {
        "description": {
            "texte": "A ConstexprIterator is an LegacyIterator that can be used during constant expression evaluation."
        }
    },
    "C++ named requirements: FormattedInputFunction": {
        "description": {
            "texte": "A FormattedInputFunction is a stream input function that performs the following:"
        }
    },
    "C++ named requirements: UnformattedInputFunction": {
        "description": {
            "texte": "An UnformattedInputFunction is a stream input function that performs the following:"
        }
    },
    "C++ named requirements: FormattedOutputFunction": {
        "description": {
            "texte": "A FormattedOutputFunction is a stream output function that performs the following:"
        }
    },
    "C++ named requirements: UnformattedOutputFunction": {
        "description": {
            "texte": "A UnformattedOutputFunction is a stream output function that performs the following:"
        }
    },
    "C++ named requirements: SeedSequence": {
        "description": {
            "texte": "A SeedSequence is an object that produces unsigned integer values i in the range 0 \u2264 i < 232 based on a consumed range of integer data."
        }
    },
    "C++ named requirements: RandomNumberEngine": {
        "description": {
            "texte": "A random number engine is a function object returning unsigned integer values such that each value in the range of possible results has (ideally) equal probability.Any random number engine is also a UniformRandomBitGenerator, and therefore may be plugged into any random number distribution in order to obtain a random number (formally, a random variate)."
        }
    },
    "C++ named requirements: RandomNumberDistribution": {
        "description": {
            "texte": "A RandomNumberDistribution is a function object returning random numbers according to a probability density function p(x) or a discrete probability distribution P(xi)."
        }
    },
    "C++ named requirements: UniformRandomBitGenerator": {
        "description": {
            "texte": "A uniform random bit generator is a function object returning unsigned integer values such that each value in the range of possible results has (ideally) equal probability.Uniform random bit generators are not intended to be used as random number generators: they are used as the source of random bits (generated in bulk, for efficiency). Any uniform random bit generator may be plugged into any random number distribution in order to obtain a random number (formally, a random variate)."
        }
    },
    "C++ named requirements: RandomNumberEngineAdaptor": {
        "description": {
            "texte": "A RandomNumberEngineAdaptor is a RandomNumberEngine that transforms the output of another RandomNumberEngine, the latter of which is termed a base engine."
        }
    },
    "C++ named requirements: BasicLockable": {
        "description": {
            "texte": "The BasicLockable requirements describe the minimal characteristics of types that provide exclusive blocking semantics for execution agents (i.e. threads)."
        }
    },
    "C++ named requirements: Lockable": {
        "description": {
            "texte": "The Lockable requirements extends the BasicLockable requirements to include attempted locking."
        }
    },
    "C++ named requirements: TimedLockable": {
        "description": {
            "texte": "The TimedLockable requirements describe the characteristics of types that provide timed exclusive blocking semantics for execution agents (threads, processes, tasks)."
        }
    },
    "C++ named requirements: Mutex": {
        "description": {
            "texte": "The Mutex requirements extends the Lockable requirements to include inter-thread synchronization."
        }
    },
    "C++ named requirements: TimedMutex": {
        "description": {
            "texte": "The TimedMutex requirements extend the TimedLockable requirements to include inter-thread synchronization."
        }
    },
    "C++ named requirements: SharedMutex": {
        "description": {
            "texte": "The SharedMutex requirements extend the Mutex requirements to include shared lock ownership mode."
        }
    },
    "C++ named requirements: SharedTimedMutex": {
        "description": {
            "texte": "The SharedTimedMutex requirements extend the TimedMutex requirements to include shared lock ownership mode."
        }
    },
    "C++ named requirements: CharTraits": {
        "description": {
            "texte": "CharTraits is a traits class that abstracts basic character and string operations for a given character type. Most standard library string and input/output classes require a CharTraits template type parameter alongside a corresponding character template type parameter."
        }
    },
    "C++ named requirements: RegexTraits": {
        "description": {
            "texte": "RegexTraits is a traits class that abstracts operations needed for a given character type when as template type parameters for std::basic_regex."
        }
    },
    "C++ named requirements: BitmaskType": {
        "description": {
            "texte": "Defines a type that can be used to represent a set of constant values or any combination of those values. This trait is typically implemented by integer types, std::bitset, or enumerations (scoped and unscoped) with additional operator overloads."
        }
    },
    "C++ named requirements: NumericType": {
        "description": {
            "texte": "Specifies that the type can be used as the template argument of std::valarray."
        }
    },
    "C++ named requirements: LiteralType": {
        "description": {
            "texte": "Specifies that a type is a literal type. Literal types are the types of constexpr variables and they can be constructed, manipulated, and returned from constexpr functions.Note: the standard doesn't define a named requirement with this name. This is a type category defined by the core language. It is included here as a named requirement only for consistency."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <stdexcept>\n \nclass conststr\n{\n    const char* p;\n    std::size_t sz;\npublic:\n    template<std::size_t N>\n    constexpr conststr(const char(&a)[N]) : p(a), sz(N - 1) {}\n \n    constexpr char operator[](std::size_t n) const\n    {\n        return n < sz ? p[n] : throw std::out_of_range(\"\");\n    }\n    constexpr std::size_t size() const { return sz; }\n};\n \nconstexpr std::size_t countlower(conststr s, std::size_t n = 0,\n                                             std::size_t c = 0)\n{\n    return n == s.size() ? c :\n           s[n] >= 'a' && s[n] <= 'z' ? countlower(s, n + 1, c + 1) :\n                                        countlower(s, n + 1, c);\n}\n \n// output function that requires a compile-time constant, for testing\ntemplate<int n>\nstruct constN\n{\n    constN() { std::cout << n << '\\n'; }\n};\n \nint main()\n{\n    std::cout << \"the number of lowercase letters in \\\"Hello, world!\\\" is \";\n    constN<countlower(\"Hello, world!\")>(); // implicitly converted to conststr\n}",
            "output": "the number of lowercase letters in \"Hello, world!\" is 9"
        }
    },
    "C++ named requirements: UnaryTypeTrait": {
        "description": {
            "texte": "A UnaryTypeTrait is a class template that describes a property of its template type parameter with a intergral_constant (typically bool_constant) specialization."
        }
    },
    "C++ named requirements: BinaryTypeTrait": {
        "description": {
            "texte": "A BinaryTypeTrait is a class template that describes a relationship between its two template type parameters with a intergral_constant (typically bool_constant) specialization."
        }
    },
    "C++ named requirements: TransformationTrait": {
        "description": {
            "texte": "A TransformationTrait is a class template that provides a transformation of its template type parameter."
        }
    },
    "C++ named requirements: Clock": {
        "description": {
            "texte": "The Clock requirements describe a bundle consisting of a std::chrono::duration, a std::chrono::time_point, and a function now() to get the current time_point. The origin of the clock's time_point is referred to as the clock's epoch."
        }
    },
    "C++ named requirements: TrivialClock": {
        "description": {
            "texte": "The TrivialClock requirements describe the requirements satisfied by several clocks in the chrono library."
        }
    },
    "integer_sequence": {
        "description": {
            "texte": "The class template std::integer_sequence represents a compile-time sequence of integers. When used as an argument to a function template, the parameter pack Ints can be deduced and used in pack expansion."
        },
        "exemple": {
            "input": "#include <tuple>\n#include <iostream>\n#include <array>\n#include <utility>\n \n// Convert array into a tuple\ntemplate<typename Array, std::size_t... I>\nauto a2t_impl(const Array& a, std::index_sequence<I...>)\n{\n    return std::make_tuple(a[I]...);\n}\n \ntemplate<typename T, std::size_t N, typename Indices = std::make_index_sequence<N>>\nauto a2t(const std::array<T, N>& a)\n{\n    return a2t_impl(a, Indices{});\n}\n \n// pretty-print a tuple\n \ntemplate<class Ch, class Tr, class Tuple, std::size_t... Is>\nvoid print_tuple_impl(std::basic_ostream<Ch,Tr>& os,\n                      const Tuple& t,\n                      std::index_sequence<Is...>)\n{\n    ((os << (Is == 0? \"\" : \", \") << std::get<Is>(t)), ...);\n}\n \ntemplate<class Ch, class Tr, class... Args>\nauto& operator<<(std::basic_ostream<Ch, Tr>& os,\n                 const std::tuple<Args...>& t)\n{\n    os << \"(\";\n    print_tuple_impl(os, t, std::index_sequence_for<Args...>{});\n    return os << \")\";\n}\n \nint main()\n{\n    std::array<int, 4> array = {1,2,3,4};\n \n    // convert an array into a tuple\n    auto tuple = a2t(array);\n    static_assert(std::is_same<decltype(tuple),\n                               std::tuple<int, int, int, int>>::value, \"\");\n \n    // print it to cout\n    std::cout << tuple << '\\n';\n}",
            "output": "(1, 2, 3, 4)"
        }
    },
    "rel_ops::operator!=,>,=": {
        "description": {
            "texte": "Given a user-defined operator== and operator< for objects of type T, implements the usual semantics of other comparison operators.1) Implements operator!= in terms of operator==.2) Implements operator> in terms of operator<.3) Implements operator<= in terms of operator<.4) Implements operator>= in terms of operator<."
        },
        "parametres": "   lhs   -   left-hand argument \n   rhs   -   right-hand argument \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <utility>\n \nstruct Foo {\n    int n;\n};\n \nbool operator==(const Foo& lhs, const Foo& rhs)\n{\n    return lhs.n == rhs.n;\n}\n \nbool operator<(const Foo& lhs, const Foo& rhs)\n{\n    return lhs.n < rhs.n;\n}\n \nint main()\n{\n    Foo f1 = {1};\n    Foo f2 = {2};\n    using namespace std::rel_ops;\n \n    std::cout << std::boolalpha;\n    std::cout << \"not equal?     : \" << (f1 != f2) << '\\n';\n    std::cout << \"greater?       : \" << (f1 > f2) << '\\n';\n    std::cout << \"less equal?    : \" << (f1 <= f2) << '\\n';\n    std::cout << \"greater equal? : \" << (f1 >= f2) << '\\n';\n}",
            "output": "not equal?     : true\ngreater?       : false\nless equal?    : true\ngreater equal? : false"
        }
    },
    "strong_order": {
        "description": {
            "texte": "Compares two values using 3-way comparison and produces a result of type std::strong_ordering.Specifically,"
        },
        "parametres": "   a, b   -   values to compare \n\n"
    },
    "weak_order": {
        "description": {
            "texte": "Compares two values using 3-way comparison and produces a result of type std::weak_ordering.Specifically,"
        },
        "parametres": "   a, b   -   values to compare \n\n"
    },
    "partial_order": {
        "description": {
            "texte": "Compares two values using 3-way comparison and produces a result of type std::partial_ordering.Specifically,"
        },
        "parametres": "   a, b   -   values to compare \n\n"
    },
    "strong_equal": {
        "description": {
            "texte": "Compares two values using 3-way comparison and produces a result of type std::strong_equality.Specifically,"
        },
        "parametres": "   a, b   -   values to compare \n\n"
    },
    "weak_equal": {
        "description": {
            "texte": "Compares two values using 3-way comparison and produces a result of type std::weak_equality.Specifically,"
        },
        "parametres": "   a, b   -   values to compare \n\n"
    },
    "strong_ordering": {
        "description": {
            "texte": "The class type std::strong_ordering is the result type of a three-way comparison that."
        },
        "parametres": "   v   -   a std::strong_ordering value to check \n   u   -   an unused parameter of any type that accepts literal zero argument \n\n"
    },
    "weak_ordering": {
        "description": {
            "texte": "The class type std::weak_ordering is the result type of a three-way comparison that."
        },
        "parametres": "   v   -   a std::weak_ordering value to check \n   u   -   an unused parameter of any type that accepts literal zero argument \n\n"
    },
    "partial_ordering": {
        "description": {
            "texte": "The class type std::partial_ordering is the result type of a three-way comparison that."
        },
        "parametres": "   v   -   a std::partial_ordering value to check \n   u   -   an unused parameter of any type that accepts literal zero argument \n\n"
    },
    "strong_equality": {
        "description": {
            "texte": "The class type std::strong_equality is the result type of a three-way comparison that."
        },
        "parametres": "   v   -   a std::strong_equality value to check \n   u   -   an unused parameter of any type that accepts literal zero argument \n\n"
    },
    "weak_equality": {
        "description": {
            "texte": "The class type std::weak_equality is the result type of a three-way comparison that.std::weak_equality is the weakest comparison category type: it is not implicitly-convertible to any other comparison category, but the other four comparison categories (std::strong_equality, std::partial_ordering, std::weak_ordering, std::strong_ordering) are implicitly-convertible to std::weak_equality."
        },
        "parametres": "   v   -   a std::weak_equality value to check \n   u   -   an unused parameter of any type that accepts literal zero argument \n\n"
    },
    "is_eq, std::is_neq, std::is_lt, std::is_gt, std::is_lteq, std::is_gteq": {
        "description": {
            "texte": "These functions take a result of 3-way comparison and convert it to the result of one of the six relational operators.Specifically, these functions return."
        },
        "parametres": "   cmp   -   result of 3-way comparison \n\n"
    },
    "common_comparison_category": {
        "description": {
            "texte": "The class template std::common_comparison_category provides an alias (as the member typedef type) for the strongest comparison category to which all of the template arguments Ts... can be converted. In detail, the common comparison type of a list of n types T0...Tn-1 is defined as follows:"
        }
    },
    "pair": {
        "description": {
            "texte": "std::pair is a struct template that provides a way to store two heterogeneous objects as a single unit. A pair is a specific case of a std::tuple with two elements."
        }
    },
    "apply": {
        "description": {
            "texte": "Invoke the Callable object f with a tuple of arguments."
        },
        "parametres": "   f   -   Callable object to be invoked \n   t   -   tuple whose elements to be used as arguments to f \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <tuple>\n#include <utility>\n \nint add(int first, int second) { return first + second; }\n \ntemplate<typename T>\nT add_generic(T first, T second) { return first + second; }\n \nauto add_lambda = [](auto first, auto second) { return first + second; };\n \nint main()\n{\n    // OK\n    std::cout << std::apply(add, std::make_pair(1, 2)) << '\\n';\n \n   // Error: can't deduce the function type\n   // std::cout << std::apply(add_generic, std::make_pair(2.0f, 3.0f)) << '\\n'; \n \n   // OK\n   std::cout << std::apply(add_lambda, std::make_pair(2.0f, 3.0f)) << '\\n'; \n}",
            "output": "3\n5"
        }
    },
    "make_from_tuple": {
        "description": {
            "texte": "Construct an object of type T, using the elements of the tuple t as the arguments to the constructor."
        },
        "parametres": "   t   -   tuple whose elements to be used as arguments to the constructor of T \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <tuple>\n \nstruct Foo {\n    Foo(int first, float second, int third) {\n        std::cout << first << \", \" << second << \", \" << third << \"\\n\";\n    }\n};\n \nint main()\n{\n   auto tuple = std::make_tuple(42, 3.14f, 0);\n   std::make_from_tuple<Foo>(std::move(tuple));\n}",
            "output": "42, 3.14, 0"
        }
    },
    "swap": {
        "description": {
            "texte": "Exchanges the given values."
        },
        "parametres": "   a, b   -   the values to be swapped \n   Type requirements \n   -T must meet the requirements of MoveAssignable and MoveConstructible. \n   -T2 must meet the requirements of Swappable. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n \nint main()\n{\n   int a = 5, b = 3;\n \n   // before\n   std::cout << a << ' ' << b << '\\n';\n \n   std::swap(a,b);\n \n   // after\n   std::cout << a << ' ' << b << '\\n';\n}",
            "output": "5 3\n3 5"
        }
    },
    "exchange": {
        "description": {
            "texte": "Replaces the value of obj with new_value and returns the old value of obj."
        },
        "parametres": "   obj   -   object whose value to replace \n   new_value   -   the value to assign to obj \n   Type requirements \n   -T must meet the requirements of MoveConstructible. Also, it must be possible to move-assign objects of type U to objects of type T \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <iterator>\n \nclass stream\n{\n  public:\n \n   using flags_type = int;\n \n  public:\n \n    flags_type flags() const\n    { return flags_; }\n \n    ///Replaces flags_ by newf, and returns the old value.\n    flags_type flags(flags_type newf)\n    { return std::exchange(flags_, newf); }\n \n  private:\n \n    flags_type flags_ = 0;\n};\n \nvoid f() { std::cout << \"f()\"; }\n \nint main()\n{\n   stream s;\n \n   std::cout << s.flags() << '\\n';\n   std::cout << s.flags(12) << '\\n';\n   std::cout << s.flags() << \"\\n\\n\";\n \n   std::vector<int> v;\n \n   //Since the second template parameter has a default value, it is possible\n   //to use a braced-init-list as second argument. The expression below\n   //is equivalent to std::exchange(v, std::vector<int>{1,2,3,4});\n \n   std::exchange(v, {1,2,3,4});\n \n   std::copy(begin(v),end(v), std::ostream_iterator<int>(std::cout,\", \"));\n \n   std::cout << \"\\n\\n\";\n \n   void (*fun)();\n \n   //the default value of template parameter also makes possible to use a\n   //normal function as second argument. The expression below is equivalent to\n   //std::exchange(fun, static_cast<void(*)()>(f))\n   std::exchange(fun,f);\n   fun();\n}",
            "output": "0\n0\n12\n \n1, 2, 3, 4, \n \nf()"
        }
    },
    "forward": {
        "description": {
            "texte": "When t is a forwarding reference (a function argument that is declared as an rvalue reference to a cv-unqualified function template parameter), this overload forwards the argument to another function with the value category it had when passed to the calling function.For example, if used in wrapper such as the following, the template behaves as described below:This overload makes it possible to forward a result of an expression (such as function call), which may be rvalue or lvalue, as the original value category of a forwarding reference argument.For example, if a wrapper does not just forward its argument, but calls a member function on the argument, and forwards its result:where the type of arg may be.Attempting to forward an rvalue as an lvalue, such as by instantiating the form (2) with lvalue reference type T, is a compile-time error.",
            "code": "struct Arg\n{\n    int i = 1;\n    int  get() && { return i; } // call to this overload is rvalue\n    int& get() &  { return i; } // call to this overload is lvalue\n};"
        },
        "parametres": "   t   -   the object to be forwarded \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n#include <utility>\n \nstruct A {\n    A(int&& n) { std::cout << \"rvalue overload, n=\" << n << \"\\n\"; }\n    A(int& n)  { std::cout << \"lvalue overload, n=\" << n << \"\\n\"; }\n};\n \nclass B {\npublic:\n    template<class T1, class T2, class T3>\n    B(T1&& t1, T2&& t2, T3&& t3) :\n        a1_{std::forward<T1>(t1)},\n        a2_{std::forward<T2>(t2)},\n        a3_{std::forward<T3>(t3)}\n    {\n    }\n \nprivate:\n    A a1_, a2_, a3_;\n};\n \ntemplate<class T, class U>\nstd::unique_ptr<T> make_unique1(U&& u)\n{\n    return std::unique_ptr<T>(new T(std::forward<U>(u)));\n}\n \ntemplate<class T, class... U>\nstd::unique_ptr<T> make_unique2(U&&... u)\n{\n    return std::unique_ptr<T>(new T(std::forward<U>(u)...));\n}\n \nint main()\n{   \n    auto p1 = make_unique1<A>(2); // rvalue\n    int i = 1;\n    auto p2 = make_unique1<A>(i); // lvalue\n \n    std::cout << \"B\\n\";\n    auto t = make_unique2<B>(2, i, 3);\n}",
            "output": "rvalue overload, n=2\nlvalue overload, n=1\nB\nrvalue overload, n=2\nlvalue overload, n=1\nrvalue overload, n=3"
        }
    },
    "move": {
        "description": {
            "texte": "Output iterator to the element past the last element moved (d_first + (last - first))."
        },
        "parametres": "   first, last   -   the range of elements to move \n   d_first   -   the beginning of the destination range. The behavior is undefined if d_first is within the range [first, last). In this case, std::move_backward may be used instead of  std::move. \n   policy   -   the execution policy to use. See execution policy for details. \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n   -ForwardIt1, ForwardIt2 must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <list>\n#include <iterator>\n#include <thread>\n#include <chrono>\n \nvoid f(int n)\n{\n    std::this_thread::sleep_for(std::chrono::seconds(n));\n    std::cout << \"thread \" << n << \" ended\" << '\\n';\n}\n \nint main() \n{\n    std::vector<std::thread> v;\n    v.emplace_back(f, 1);\n    v.emplace_back(f, 2);\n    v.emplace_back(f, 3);\n    std::list<std::thread> l;\n    // copy() would not compile, because std::thread is noncopyable\n \n    std::move(v.begin(), v.end(), std::back_inserter(l)); \n    for (auto& t : l) t.join();\n}",
            "output": "thread 1 ended\nthread 2 ended\nthread 3 ended"
        }
    },
    "move_if_noexcept": {
        "description": {
            "texte": "move_if_noexcept obtains an rvalue reference to its argument if its move constructor does not throw exceptions or if there is no copy constructor (move-only type), otherwise obtains an lvalue reference to its argument. It is typically used to combine move semantics with strong exception guarantee."
        },
        "parametres": "   x   -   the object to be moved or copied \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <utility>\n \nstruct Bad\n{\n    Bad() {}\n    Bad(Bad&&)  // may throw\n    {\n        std::cout << \"Throwing move constructor called\\n\";\n    }\n    Bad(const Bad&) // may throw as well\n    {\n        std::cout << \"Throwing copy constructor called\\n\";\n    }\n};\n \nstruct Good\n{\n    Good() {}\n    Good(Good&&) noexcept // will NOT throw\n    {\n        std::cout << \"Non-throwing move constructor called\\n\";\n    }\n    Good(const Good&) noexcept // will NOT throw\n    {\n        std::cout << \"Non-throwing copy constructor called\\n\";\n    }\n};\n \nint main()\n{\n    Good g;\n    Bad b;\n    Good g2 = std::move_if_noexcept(g);\n    Bad b2 = std::move_if_noexcept(b);\n}",
            "output": "Non-throwing move constructor called\nThrowing copy constructor called"
        }
    },
    "to_chars": {
        "description": {
            "texte": "Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range."
        },
        "parametres": "   first, last   -   character range to write to \n   value   -   the value to convert to its string representation \n   base   -   integer base to use: a value between 2 and 36 (inclusive). \n   fmt   -   floating-point formatting to use, a bitmask of type std::chars_format \n   precision   -   floating-point precision to use \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <charconv>\n#include <system_error>\n#include <string_view>\n#include <array>\n \nint main()\n{\n    std::array<char, 10> str;\n \n    if(auto [p, ec] = std::to_chars(str.data(), str.data() + str.size(), 42);\n       ec == std::errc())\n        std::cout << std::string_view(str.data(), p - str.data());\n}",
            "output": "42"
        }
    },
    "from_chars": {
        "description": {
            "texte": "Analyzes the character sequence [first,last) for a pattern described below. If no characters match the pattern or if the value obtained by parsing the matched characters is not representable in the type of value, value is unmodified, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value."
        },
        "parametres": "   first, last   -   valid character range to parse \n   value   -   the out-parameter where the parsed value is stored if successful \n   base   -   integer base to use: a value between 2 and 36 (inclusive). \n   fmt   -   floating-point formatting to use, a bitmask of type std::chars_format \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <charconv>\n#include <array>\n \nint main()\n{\n    std::array<char, 10> str{\"42\"};\n    int result;\n    if(auto [p, ec] = std::from_chars(str.data(), str.data()+str.size(), result);\n       ec == std::errc())\n        std::cout << result;\n}",
            "output": "42"
        }
    },
    "chars_format": {
        "description": {
            "texte": "A BitmaskType used to specify floating-point formatting for std::to_chars and std::from_chars."
        }
    },
    "declval": {
        "description": {
            "texte": "Converts any type T to a reference type, making it possible to use member functions in decltype expressions without the need to go through constructors.declval is commonly used in templates where acceptable template parameters may have no constructor in common, but have the same member function whose return type is needed.Note that because no definition exists for declval, it can only be used in unevaluated contexts; it is an error to evaluate an expression that contains this function. Formally, the program is ill-formed if this function is odr-used."
        },
        "exemple": {
            "input": "#include <utility>\n#include <iostream>\n \nstruct Default { int foo() const { return 1; } };\n \nstruct NonDefault\n{\n    NonDefault(const NonDefault&) { }\n    int foo() const { return 1; }\n};\n \nint main()\n{\n    decltype(Default().foo()) n1 = 1;                   // type of n1 is int\n//  decltype(NonDefault().foo()) n2 = n1;               // error: no default constructor\n    decltype(std::declval<NonDefault>().foo()) n2 = n1; // type of n2 is int\n    std::cout << \"n1 = \" << n1 << '\\n'\n              << \"n2 = \" << n2 << '\\n';\n}",
            "output": "n1 = 1\nn2 = 1"
        }
    },
    "launder": {
        "description": {
            "texte": "Obtains a pointer to the object located at the address represented by p.Formally, given.Then std::launder(p) returns a value of type T* that points to the object X. Otherwise, the behavior is undefined.The program is ill-formed if T is a function type or (possibly cv-qualified) void.std::launder may be used in a core constant expression if the value of its argument may be used in a core constant expression."
        },
        "exemple": {
            "input": "#include <new>\n#include <cstddef>\n#include <cassert>\n \nstruct X {\n  const int n; // note: X has a const member\n  int m;\n};\n \nstruct Y {\n  int z;\n};\n \nstruct A { \n    virtual int transmogrify();\n};\n \nstruct B : A {\n    int transmogrify() override { new(this) A; return 2; }\n};\n \nint A::transmogrify() { new(this) B; return 1; }\n \nstatic_assert(sizeof(B) == sizeof(A));\n \nint main()\n{\n  X *p = new X{3, 4};\n  const int a = p->n;\n  X* np = new (p) X{5, 6};    // p does not point to new object because X::n is const; np does\n  const int b = p->n; // undefined behavior\n  const int c = p->m; // undefined behavior (even though m is non-const, p can't be used)\n  const int d = std::launder(p)->n; // OK, std::launder(p) points to new object\n  const int e = np->n; // OK\n \n  alignas(Y) std::byte s[sizeof(Y)];\n  Y* q = new(&s) Y{2};\n  const int f = reinterpret_cast<Y*>(&s)->z; // Class member access is undefined behavior:\n                                             // reinterpret_cast<Y*>(&s) has value \"pointer to s\"\n                                             // and does not point to a Y object \n  const int g = q->z; // OK\n  const int h = std::launder(reinterpret_cast<Y*>(&s))->z; // OK\n \n  A i;\n  int n = i.transmogrify();\n  // int m = i.transmogrify(); // undefined behavior\n  int m = std::launder(&i)->transmogrify(); // OK\n  assert(m + n == 3);\n}"
        }
    },
    "bind": {
        "description": {
            "texte": "The function template bind generates a forwarding call wrapper for f. Calling this wrapper is equivalent to invoking f with some of its arguments bound to args."
        },
        "parametres": "   f   -   Callable object (function object, pointer to function, reference to function, pointer to member function, or pointer to data member) that will be bound to some arguments \n   args   -   list of arguments to bind, with the unbound arguments replaced by the placeholders _1, _2, _3... of namespace std::placeholders \n\n",
        "exemple": {
            "input": "#include <random>\n#include <iostream>\n#include <memory>\n#include <functional>\n \nvoid f(int n1, int n2, int n3, const int& n4, int n5)\n{\n    std::cout << n1 << ' ' << n2 << ' ' << n3 << ' ' << n4 << ' ' << n5 << '\\n';\n}\n \nint g(int n1)\n{\n    return n1;\n}\n \nstruct Foo {\n    void print_sum(int n1, int n2)\n    {\n        std::cout << n1+n2 << '\\n';\n    }\n    int data = 10;\n};\n \nint main()\n{\n    using namespace std::placeholders;  // for _1, _2, _3...\n \n    // demonstrates argument reordering and pass-by-reference\n    int n = 7;\n    // (_1 and _2 are from std::placeholders, and represent future\n    // arguments that will be passed to f1)\n    auto f1 = std::bind(f, _2, _1, 42, std::cref(n), n);\n    n = 10;\n    f1(1, 2, 1001); // 1 is bound by _1, 2 is bound by _2, 1001 is unused\n                    // makes a call to f(2, 1, 42, n, 7)\n \n    // nested bind subexpressions share the placeholders\n    auto f2 = std::bind(f, _3, std::bind(g, _3), _3, 4, 5);\n    f2(10, 11, 12); // makes a call to f(12, g(12), 12, 4, 5);\n \n    // common use case: binding a RNG with a distribution\n    std::default_random_engine e;\n    std::uniform_int_distribution<> d(0, 10);\n    auto rnd = std::bind(d, e); // a copy of e is stored in rnd\n    for(int n=0; n<10; ++n)\n        std::cout << rnd() << ' ';\n    std::cout << '\\n';\n \n    // bind to a pointer to member function\n    Foo foo;\n    auto f3 = std::bind(&Foo::print_sum, &foo, 95, _1);\n    f3(5);\n \n    // bind to a pointer to data member\n    auto f4 = std::bind(&Foo::data, _1);\n    std::cout << f4(foo) << '\\n';\n \n    // smart pointers can be used to call members of the referenced objects, too\n    std::cout << f4(std::make_shared<Foo>(foo)) << '\\n'\n              << f4(std::make_unique<Foo>(foo)) << '\\n';\n}",
            "output": "2 1 42 10 7\n12 12 12 4 5\n1 5 0 2 0 8 2 2 10 8\n100\n10\n10\n10"
        }
    },
    "size_t": {
        "description": {
            "texte": "std::size_t is the unsigned integer type of the result of the sizeof operator as well as the sizeof... operator and the alignof operator (since C++11)."
        },
        "exemple": {
            "input": "#include <cstddef>\n#include <iostream>\n#include <array>\n \nint main()\n{\n    std::array<std::size_t,10> a;\n    for (std::size_t i = 0; i != a.size(); ++i)\n        a[i] = i;\n    for (std::size_t i = a.size()-1; i < a.size(); --i)\n        std::cout << a[i] << \" \";\n}",
            "output": "9 8 7 6 5 4 3 2 1 0"
        }
    },
    "nullptr_t": {
        "description": {
            "texte": "std::nullptr_t is the type of the null pointer literal, nullptr. It is a distinct type that is not itself a pointer type or a pointer to member type."
        },
        "exemple": {
            "input": "#include <cstddef>\n#include <iostream>\n \nvoid f(int* pi)\n{\n   std::cout << \"Pointer to integer overload\\n\";\n}\n \nvoid f(double* pd)\n{\n   std::cout << \"Pointer to double overload\\n\";\n}\n \nvoid f(std::nullptr_t nullp)\n{\n   std::cout << \"null pointer overload\\n\";\n}\n \nint main()\n{\n    int* pi; double* pd;\n \n    f(pi);\n    f(pd);\n    f(nullptr);  // would be ambiguous without void f(nullptr_t)\n    // f(0);  // ambiguous call: all three functions are candidates\n    // f(NULL); // ambiguous if NULL is an integral null pointer constant \n                // (as is the case in most implementations)\n}",
            "output": "Pointer to integer overload\nPointer to double overload\nnull pointer overload"
        }
    },
    "type_info": {
        "description": {
            "texte": "The class type_info holds implementation-specific information about a type, including the name of the type and means to compare two types for equality or collating order. This is the class returned by the typeid operator.The type_info class is neither CopyConstructible nor CopyAssignable."
        }
    },
    "is_integral": {
        "description": {
            "texte": "Checks whether T is an integral type. Provides the member constant value which is equal to true, if T is the type bool, char, char8_t, char16_t, char32_t, wchar_t, short, int, long, long long, or any implementation-defined extended integer types, including any signed, unsigned, and cv-qualified variants. Otherwise, value is equal to false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nenum E : int {};\n \ntemplate <class T>\nT f(T i)\n{\n    static_assert(std::is_integral<T>::value, \"Integral required.\");\n    return i;\n}\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_integral<A>::value << '\\n';\n    std::cout << std::is_integral<E>::value << '\\n';\n    std::cout << std::is_integral<float>::value << '\\n';\n    std::cout << std::is_integral<int>::value << '\\n';\n    std::cout << std::is_integral<bool>::value << '\\n';\n    std::cout << f(123) << '\\n';\n}",
            "output": "false\nfalse\nfalse\ntrue\ntrue\n123"
        }
    },
    "rank": {
        "description": {
            "texte": "If T is an array type, provides the member constant value equal to the number of dimensions of the array. For any other type, value is 0."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nint main()\n{\n    std::cout << std::rank<int>{} << \"\\n\\n\";\n \n    std::cout << std::rank<int[5]>{} << '\\n';\n    std::cout << std::rank<int[5][5]>{} << '\\n';\n    std::cout << std::rank<int[][5][5]>{} << '\\n';\n}",
            "output": "0\n \n1\n2\n3"
        }
    },
    "shared_ptr": {
        "description": {
            "texte": "std::shared_ptr is a smart pointer that retains shared ownership of an object through a pointer. Several shared_ptr objects may own the same object. The object is destroyed and its memory deallocated when either of the following happens:The object is destroyed using delete-expression or a custom deleter that is supplied to shared_ptr during construction.A shared_ptr can share ownership of an object while storing a pointer to another object. This feature can be used to point to member objects while owning the object they belong to. The stored pointer is the one accessed by get(), the dereference and the comparison operators. The managed pointer is the one passed to the deleter when use count reaches zero.A shared_ptr may also own no objects, in which case it is called empty (an empty shared_ptr may have a non-null stored pointer if the aliasing constructor was used to create it).All specializations of shared_ptr meet the requirements of CopyConstructible, CopyAssignable, and LessThanComparable and are contextually convertible to bool.All member functions (including copy constructor and copy assignment) can be called by multiple threads on different instances of shared_ptr without additional synchronization even if these instances are copies and share ownership of the same object. If multiple threads of execution access the same shared_ptr without synchronization and any of those accesses uses a non-const member function of shared_ptr then a data race will occur; the shared_ptr overloads of atomic functions can be used to prevent the data race."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n#include <thread>\n#include <chrono>\n#include <mutex>\n \nstruct Base\n{\n    Base() { std::cout << \"  Base::Base()\\n\"; }\n    // Note: non-virtual destructor is OK here\n    ~Base() { std::cout << \"  Base::~Base()\\n\"; }\n};\n \nstruct Derived: public Base\n{\n    Derived() { std::cout << \"  Derived::Derived()\\n\"; }\n    ~Derived() { std::cout << \"  Derived::~Derived()\\n\"; }\n};\n \nvoid thr(std::shared_ptr<Base> p)\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    std::shared_ptr<Base> lp = p; // thread-safe, even though the\n                                  // shared use_count is incremented\n    {\n        static std::mutex io_mutex;\n        std::lock_guard<std::mutex> lk(io_mutex);\n        std::cout << \"local pointer in a thread:\\n\"\n                  << \"  lp.get() = \" << lp.get()\n                  << \", lp.use_count() = \" << lp.use_count() << '\\n';\n    }\n}\n \nint main()\n{\n    std::shared_ptr<Base> p = std::make_shared<Derived>();\n \n    std::cout << \"Created a shared Derived (as a pointer to Base)\\n\"\n              << \"  p.get() = \" << p.get()\n              << \", p.use_count() = \" << p.use_count() << '\\n';\n    std::thread t1(thr, p), t2(thr, p), t3(thr, p);\n    p.reset(); // release ownership from main\n    std::cout << \"Shared ownership between 3 threads and released\\n\"\n              << \"ownership from main:\\n\"\n              << \"  p.get() = \" << p.get()\n              << \", p.use_count() = \" << p.use_count() << '\\n';\n    t1.join(); t2.join(); t3.join();\n    std::cout << \"All threads completed, the last one deleted Derived\\n\";\n}",
            "output": "Base::Base()\n  Derived::Derived()\nCreated a shared Derived (as a pointer to Base)\n  p.get() = 0xc99028, p.use_count() = 1\nShared ownership between 3 threads and released\nownership from main:\n  p.get() = (nil), p.use_count() = 0\nlocal pointer in a thread:\n  lp.get() = 0xc99028, lp.use_count() = 3\nlocal pointer in a thread:\n  lp.get() = 0xc99028, lp.use_count() = 4\nlocal pointer in a thread:\n  lp.get() = 0xc99028, lp.use_count() = 2\n  Derived::~Derived()\n  Base::~Base()\nAll threads completed, the last one deleted Derived"
        }
    },
    "allocator": {
        "description": {
            "texte": "The std::allocator class template is the default Allocator used by all standard library containers if no user-specified allocator is provided. The default allocator is stateless, that is, all instances of the given allocator are interchangeable, compare equal and can deallocate memory allocated by any other instance of the same allocator type."
        },
        "exemple": {
            "input": "#include <memory>\n#include <iostream>\n#include <string>\n \nint main()\n{\n    std::allocator<int> a1;   // default allocator for ints\n    int* a = a1.allocate(1);  // space for one int\n    a1.construct(a, 7);       // construct the int\n    std::cout << a[0] << '\\n';\n    a1.deallocate(a, 1);      // deallocate space for one int\n \n    // default allocator for strings\n    std::allocator<std::string> a2;\n \n    // same, but obtained by rebinding from the type of a1\n    decltype(a1)::rebind<std::string>::other a2_1;\n \n    // same, but obtained by rebinding from the type of a1 via allocator_traits\n    std::allocator_traits<decltype(a1)>::rebind_alloc<std::string> a2_2;\n \n    std::string* s = a2.allocate(2); // space for 2 strings\n \n    a2.construct(s, \"foo\");\n    a2.construct(s + 1, \"bar\");\n \n    std::cout << s[0] << ' ' << s[1] << '\\n';\n \n    a2.destroy(s);\n    a2.destroy(s + 1);\n    a2.deallocate(s, 2);\n}",
            "output": "7\nfoo bar"
        }
    },
    "exception": {
        "description": {
            "texte": "Provides consistent interface to handle errors through the throw expression.All exceptions generated by the standard library inherit from std::exception."
        }
    },
    "terminate": {
        "description": {
            "texte": "std::terminate() is called by the C++ runtime when exception handling fails for any of the following reasons:std::terminate() may also be called directly from the program. In any case, std::terminate calls the currently installed std::terminate_handler. The default std::terminate_handler calls std::abort."
        }
    },
    "va_start": {
        "description": {
            "texte": "The va_start macro enables access to the variable arguments following the named argument parm_n.va_start should be invoked with an instance to a valid va_list object ap before any calls to va_arg.If parm_n is declared with reference type or with a type not compatible with the type that results from default argument promotions, the behavior is undefined."
        },
        "parametres": "   ap   -   an instance of the va_list type \n   parm_n   -   the named parameter preceding the first variable parameter \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstdarg>\n \nint add_nums(int count, ...) \n{\n    int result = 0;\n    va_list args;\n    va_start(args, count);\n    for (int i = 0; i < count; ++i) {\n        result += va_arg(args, int);\n    }\n    va_end(args);\n    return result;\n}\n \nint main() \n{\n    std::cout << add_nums(4, 25, 25, 50, 50) << '\\n';\n}",
            "output": "150"
        }
    },
    "va_arg": {
        "description": {
            "texte": "The va_arg macro expands to an expression of type T that corresponds to the next parameter from the va_list ap.Prior to calling va_arg, ap must be initialized by a call to either va_start or va_copy, with no intervening call to va_end. Each invocation of the va_arg macro modifies ap to point to the next variable argument.If the type of the next argument in ap (after promotions) is not compatible with T, the behavior is undefined, unless:If va_arg is called when there are no more arguments in ap, the behavior is undefined."
        },
        "parametres": "   ap   -   an instance of the va_list type \n   T   -   the type of the next parameter in ap \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstdarg>\n#include <cmath>\n \ndouble stddev(int count, ...) \n{\n    double sum = 0;\n    double sum_sq = 0;\n    va_list args;\n    va_start(args, count);\n    for (int i = 0; i < count; ++i) {\n        double num = va_arg(args, double);\n        sum += num;\n        sum_sq += num*num;\n    }\n    va_end(args);\n    return std::sqrt(sum_sq/count - (sum/count)*(sum/count));\n}\n \nint main() \n{\n    std::cout << stddev(4, 25.0, 27.3, 26.9, 25.7) << '\\n';\n}",
            "output": "0.920258"
        }
    },
    "va_end": {
        "description": {
            "texte": "The va_end macro performs cleanup for an ap object initialized by a call to va_start or va_copy. va_end may modify ap so that it is no longer usable.If there is no corresponding call to va_start or va_copy, or if va_end is not called before a function that calls va_start or va_copy returns, the behavior is undefined."
        },
        "parametres": "   ap   -   an instance of the va_list type to clean up \n\n"
    },
    "system": {
        "description": {
            "texte": "Calls the host environment's command processor (e.g. /bin/sh, cmd.exe, command.com) with the parameter command. Returns an implementation-defined value (usually the value that the invoked program returns).If command is a null pointer, checks if the host environment has a command processor and returns a nonzero value if and only if the command processor exists."
        },
        "parametres": "   command   -   character string identifying the command to be run in the command processor. If a null pointer is given, command processor is checked for existence \n\n",
        "exemple": {
            "input": "#include <cstdlib>\n#include <fstream>\n#include <iostream>\n \nint main()\n{\n    std::system(\"ls -l >test.txt\"); // execute the UNIX command \"ls -l >test.txt\"\n    std::cout << std::ifstream(\"test.txt\").rdbuf();\n}",
            "output": "total 16\n-rwxr-xr-x 1 2001 2000 8859 Sep 30 20:52 a.out\n-rw-rw-rw- 1 2001 2000  161 Sep 30 20:52 main.cpp\n-rw-r--r-- 1 2001 2000    0 Sep 30 20:52 test.txt"
        }
    },
    "raise": {
        "description": {
            "texte": "Sends signal sig to the program. The signal handler (specified using the std::signal() function) is invoked.If the user-defined signal handling strategy is not set using std::signal() yet, it is implementation-defined whether the signal will be ignored or default handler will be invoked."
        },
        "parametres": "   sig   -   the signal to be sent. It can be an implementation-defined value or one of the following values:     SIGABRTSIGFPESIGILLSIGINTSIGSEGVSIGTERM   defines signal types  (macro constant) \n  \n\n",
        "exemple": {
            "input": "#include <csignal>\n#include <iostream>\n \nvoid signal_handler(int signal)\n{\n    std::cout << \"Received signal \" << signal << '\\n';\n}\n \nint main()\n{\n    // Install a signal handler\n    std::signal(SIGTERM, signal_handler);\n \n    std::cout << \"Sending signal \" << SIGTERM << '\\n';\n    std::raise(SIGTERM);\n}",
            "output": "Sending signal 15\nReceived signal 15"
        }
    },
    "chrono::time_point": {
        "description": {
            "texte": "Class template std::chrono::time_point represents a point in time. It is implemented as if it stores a value of type Duration indicating the time interval from the start of the Clock's epoch.Clock must meet the requirements for Clock or be std::chrono::local_t (since C++20)."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <ctime>\n#include <chrono>\n \nint main()\n{\n    std::chrono::system_clock::time_point now = std::chrono::system_clock::now();\n    std::time_t now_c = std::chrono::system_clock::to_time_t(now - std::chrono::hours(24));\n    std::cout << \"24 hours ago, the time was \"\n              << std::put_time(std::localtime(&now_c), \"%F %T\") << '\\n';\n \n    std::chrono::steady_clock::time_point start = std::chrono::steady_clock::now();\n    std::cout << \"Hello World\\n\";\n    std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();\n    std::cout << \"Printing took \"\n              << std::chrono::duration_cast<std::chrono::microseconds>(end - start).count()\n              << \"us.\\n\";\n}",
            "output": "24 hours ago, the time was 2011-10-25 12:00:08\nHello World\nPrinting took 84us."
        }
    },
    "chrono::duration": {
        "description": {
            "texte": "Class template std::chrono::duration represents a time interval.It consists of a count of ticks of type Rep and a tick period, where the tick period is a compile-time rational constant representing the number of seconds from one tick to the next.The only data stored in a duration is a tick count of type Rep. If Rep is floating point, then the duration can represent fractions of ticks. Period is included as part of the duration's type, and is only used when converting between different durations."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n \nconstexpr auto year = 31556952ll; // seconds in average Gregorian year\n \nint main()\n{\n    using shakes = std::chrono::duration<int, std::ratio<1, 100000000>>;\n    using jiffies = std::chrono::duration<int, std::centi>;\n    using microfortnights = std::chrono::duration<float, std::ratio<14*24*60*60, 1000000>>;\n    using nanocenturies = std::chrono::duration<float, std::ratio<100*year, 1000000000>>;\n \n    std::chrono::seconds sec(1);\n \n    std::cout << \"1 second is:\\n\";\n \n    // integer scale conversion with no precision loss: no cast\n    std::cout << std::chrono::microseconds(sec).count() << \" microseconds\\n\"\n              << shakes(sec).count() << \" shakes\\n\"\n              << jiffies(sec).count() << \" jiffies\\n\";\n \n    // integer scale conversion with precision loss: requires a cast\n    std::cout << std::chrono::duration_cast<std::chrono::minutes>(sec).count()\n              << \" minutes\\n\";\n \n    // floating-point scale conversion: no cast\n    std::cout << microfortnights(sec).count() << \" microfortnights\\n\"\n              << nanocenturies(sec).count() << \" nanocenturies\\n\";\n}",
            "output": "1 second is:\n1000000 microseconds\n100000000 shakes\n100 jiffies\n0 minutes\n0.82672 microfortnights\n0.316887 nanocenturies"
        }
    },
    "time": {
        "description": {
            "texte": "Returns the current calendar time encoded as a std::time_t object, and also stores it in the object pointed to by arg, unless arg is a null pointer."
        },
        "parametres": "   arg   -   pointer to a std::time_t object to store the time, or a null pointer \n\n",
        "exemple": {
            "input": "#include <ctime>\n#include <iostream>\n \nint main()\n{\n    std::time_t result = std::time(nullptr);\n    std::cout << std::asctime(std::localtime(&result))\n              << result << \" seconds since the Epoch\\n\";\n}",
            "output": "Wed Sep 21 10:27:52 2011\n1316615272 seconds since the Epoch"
        }
    },
    "clock": {
        "description": {
            "texte": "Returns the approximate processor time used by the process since the beginning of an implementation-defined era related to the program's execution. To convert result value to seconds divide it by CLOCKS_PER_SEC.Only the difference between two values returned by different calls to std::clock is meaningful, as the beginning of the std::clock era does not have to coincide with the start of the program. std::clock time may advance faster or slower than the wall clock, depending on the execution resources given to the program by the operating system. For example, if the CPU is shared by other processes, std::clock time may advance slower than wall clock. On the other hand, if the current process is multithreaded and more than one execution core is available, std::clock time may advance faster than wall clock."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <chrono>\n#include <ctime>\n#include <thread>\n \n// the function f() does some time-consuming work\nvoid f()\n{\n    volatile double d = 0;\n    for(int n=0; n<10000; ++n)\n       for(int m=0; m<10000; ++m)\n           d += d*n*m;\n}\n \nint main()\n{\n    std::clock_t c_start = std::clock();\n    auto t_start = std::chrono::high_resolution_clock::now();\n    std::thread t1(f);\n    std::thread t2(f); // f() is called on two threads\n    t1.join();\n    t2.join();\n    std::clock_t c_end = std::clock();\n    auto t_end = std::chrono::high_resolution_clock::now();\n \n    std::cout << std::fixed << std::setprecision(2) << \"CPU time used: \"\n              << 1000.0 * (c_end-c_start) / CLOCKS_PER_SEC << \" ms\\n\"\n              << \"Wall clock time passed: \"\n              << std::chrono::duration<double, std::milli>(t_end-t_start).count()\n              << \" ms\\n\";\n}",
            "output": "CPU time used: 1590.00 ms\nWall clock time passed: 808.23 ms"
        }
    },
    "ref, std::cref": {
        "description": {
            "texte": "Function templates ref and cref are helper functions that generate an object of type std::reference_wrapper, using template argument deduction to determine the template argument of the result."
        },
        "parametres": "   t   -   lvalue reference to object that needs to be wrapped or an instance of std::reference_wrapper \n\n",
        "exemple": {
            "input": "#include <functional>\n#include <iostream>\n \nvoid f(int& n1, int& n2, const int& n3)\n{\n    std::cout << \"In function: \" << n1 << ' ' << n2 << ' ' << n3 << '\\n';\n    ++n1; // increments the copy of n1 stored in the function object\n    ++n2; // increments the main()'s n2\n    // ++n3; // compile error\n}\n \nint main()\n{\n    int n1 = 1, n2 = 2, n3 = 3;\n    std::function<void()> bound_f = std::bind(f, n1, std::ref(n2), std::cref(n3));\n    n1 = 10;\n    n2 = 11;\n    n3 = 12;\n    std::cout << \"Before function: \" << n1 << ' ' << n2 << ' ' << n3 << '\\n';\n    bound_f();\n    std::cout << \"After function: \" << n1 << ' ' << n2 << ' ' << n3 << '\\n';\n}",
            "output": "Before function: 10 11 12\nIn function: 1 11 12\nAfter function: 10 12 12"
        }
    },
    "placeholders::_1, std::placeholders::_2, ..., std::placeholders::_N": {
        "description": {
            "texte": "The std::placeholders namespace contains the placeholder objects [_1, . . . _N] where N is an implementation defined maximum number.When used as an argument in a std::bind expression, the placeholder objects are stored in the generated function object, and when that function object is invoked with unbound arguments, each placeholder _N is replaced by the corresponding Nth unbound argument.The types of the placeholder objects are DefaultConstructible and CopyConstructible, their default copy/move constructors do not throw exceptions, and for any placeholder _N, the type std::is_placeholder<decltype(_N)> is defined and is derived from std::integral_constant<int, N>."
        },
        "exemple": {
            "input": "#include <functional>\n#include <string>\n#include <iostream>\n \nvoid goodbye(const std::string& s)\n{\n    std::cout << \"Goodbye \" << s << '\\n';\n}\n \nclass Object {\npublic:\n    void hello(const std::string& s)\n    {\n        std::cout << \"Hello \" << s << '\\n';\n    }\n};\n \nint main()\n{\n    typedef std::function<void(const std::string&)> ExampleFunction;\n    Object instance;\n    std::string str(\"World\");\n    ExampleFunction f = std::bind(&Object::hello, &instance, \n                                  std::placeholders::_1);\n \n    // equivalent to instance.hello(str)\n    f(str);\n    f = std::bind(&goodbye, std::placeholders::_1);\n \n    // equivalent to goodbye(str)\n    f(str);    \n    return 0;\n}",
            "output": "Hello World\nGoodbye World"
        }
    },
    "function": {
        "description": {
            "texte": "Class template std::function is a general-purpose polymorphic function wrapper. Instances of std::function can store, copy, and invoke any Callable target -- functions, lambda expressions, bind expressions, or other function objects, as well as pointers to member functions and pointers to data members.The stored callable object is called the target of std::function. If a std::function contains no target, it is called empty. Invoking the target of an empty std::function results in std::bad_function_call exception being thrown.std::function satisfies the requirements of CopyConstructible and CopyAssignable."
        },
        "exemple": {
            "input": "#include <functional>\n#include <iostream>\n \nstruct Foo {\n    Foo(int num) : num_(num) {}\n    void print_add(int i) const { std::cout << num_+i << '\\n'; }\n    int num_;\n};\n \nvoid print_num(int i)\n{\n    std::cout << i << '\\n';\n}\n \nstruct PrintNum {\n    void operator()(int i) const\n    {\n        std::cout << i << '\\n';\n    }\n};\n \nint main()\n{\n    // store a free function\n    std::function<void(int)> f_display = print_num;\n    f_display(-9);\n \n    // store a lambda\n    std::function<void()> f_display_42 = []() { print_num(42); };\n    f_display_42();\n \n    // store the result of a call to std::bind\n    std::function<void()> f_display_31337 = std::bind(print_num, 31337);\n    f_display_31337();\n \n    // store a call to a member function\n    std::function<void(const Foo&, int)> f_add_display = &Foo::print_add;\n    const Foo foo(314159);\n    f_add_display(foo, 1);\n    f_add_display(314159, 1);\n \n    // store a call to a data member accessor\n    std::function<int(Foo const&)> f_num = &Foo::num_;\n    std::cout << \"num_: \" << f_num(foo) << '\\n';\n \n    // store a call to a member function and object\n    using std::placeholders::_1;\n    std::function<void(int)> f_add_display2 = std::bind( &Foo::print_add, foo, _1 );\n    f_add_display2(2);\n \n    // store a call to a member function and object ptr\n    std::function<void(int)> f_add_display3 = std::bind( &Foo::print_add, &foo, _1 );\n    f_add_display3(3);\n \n    // store a call to a function object\n    std::function<void(int)> f_display_obj = PrintNum();\n    f_display_obj(18);\n}",
            "output": "-9\n42\n31337\n314160\n314160\nnum_: 314159\n314161\n314162\n18"
        }
    },
    "plus": {
        "description": {
            "texte": "std::plus<> is a specialization of std::plus with parameter and return type deduced."
        },
        "parametres": "   lhs, rhs   -   values to sum \n\n",
        "exemple": {
            "input": "#include <functional>\n#include <iostream>\n \nint main()\n{\n    std::string a = \"Hello \";\n    const char* b = \"world\";\n    std::cout << std::plus<>{}(a, b) << '\\n';\n}",
            "output": "Hello world"
        }
    },
    "equal_to": {
        "description": {
            "texte": "std::equal_to<> is a specialization of std::equal_to with parameter and return type deduced."
        },
        "parametres": "   lhs, rhs   -   values to compare \n\n"
    },
    "mem_fn": {
        "description": {
            "texte": "Function template std::mem_fn generates wrapper objects for pointers to members, which can store, copy, and invoke a pointer to member. Both references and pointers (including smart pointers) to an object can be used when invoking a std::mem_fn."
        },
        "parametres": "   pm   -   pointer to member that will be wrapped \n\n",
        "exemple": {
            "input": "#include <functional>\n#include <iostream>\n \nstruct Foo {\n    void display_greeting() {\n        std::cout << \"Hello, world.\\n\";\n    }\n    void display_number(int i) {\n        std::cout << \"number: \" << i << '\\n';\n    }\n    int data = 7;\n};\n \nint main() {\n    Foo f;\n \n    auto greet = std::mem_fn(&Foo::display_greeting);\n    greet(f);\n \n    auto print_num = std::mem_fn(&Foo::display_number);\n    print_num(f, 42);\n \n    auto access_data = std::mem_fn(&Foo::data);\n    std::cout << \"data: \" << access_data(f) << '\\n';\n}",
            "output": "Hello, world.\nnumber: 42\ndata: 7"
        }
    },
    "in_place, std::in_place_type, std::in_place_index, std::in_place_t, std::in_place_type_t, std::in_place_index_t": {
        "description": {
            "texte": "std::in_place, std::in_place_type, and std::in_place_index are disambiguation tags that can be passed to the constructors of std::optional, std::variant, and std::any to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed.The corresponding type/type templates std::in_place_t, std::in_place_type_t and std::in_place_index_t can be used in the constructor's parameter list to match the intended tag."
        }
    },
    "piecewise_construct_t": {
        "description": {
            "texte": "std::piecewise_construct_t is an empty struct tag type used to disambiguate between different functions that take two tuple arguments.The overloads that do not use std::piecewise_construct_t assume that each tuple argument becomes the element of a pair. The overloads that use std::piecewise_construct_t assume that each tuple argument is used to construct, piecewise, a new object of specified type, which will become the element of the pair."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <utility>\n#include <tuple>\n \nstruct Foo {\n    Foo(std::tuple<int, float>) \n    {\n        std::cout << \"Constructed a Foo from a tuple\\n\";\n    }\n    Foo(int, float) \n    {\n        std::cout << \"Constructed a Foo from an int and a float\\n\";\n    }\n};\n \nint main()\n{\n    std::tuple<int, float> t(1, 3.14);\n    std::pair<Foo, Foo> p1(t, t);\n    std::pair<Foo, Foo> p2(std::piecewise_construct, t, t);\n}",
            "output": "Constructed a Foo from a tuple\nConstructed a Foo from a tuple\nConstructed a Foo from an int and a float\nConstructed a Foo from an int and a float"
        }
    },
    "piecewise_construct": {
        "description": {
            "texte": "The constant std::piecewise_construct is an instance of an empty struct tag type std::piecewise_construct_t."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <utility>\n#include <tuple>\n \nstruct Foo {\n    Foo(std::tuple<int, float>) \n    {\n        std::cout << \"Constructed a Foo from a tuple\\n\";\n    }\n    Foo(int, float) \n    {\n        std::cout << \"Constructed a Foo from an int and a float\\n\";\n    }\n};\n \nint main()\n{\n    std::tuple<int, float> t(1, 3.14);\n    std::pair<Foo, Foo> p1(t, t);\n    std::pair<Foo, Foo> p2(std::piecewise_construct, t, t);\n}",
            "output": "Constructed a Foo from a tuple\nConstructed a Foo from a tuple\nConstructed a Foo from an int and a float\nConstructed a Foo from an int and a float"
        }
    },
    "ranges::swap": {
        "description": {
            "texte": "Exchanges the values referenced by t and u.A call to ranges::swap is equivalent to:ranges::swap can be used in a constant expression if every function it calls (as specified above) can be so used."
        }
    },
    "Same": {
        "description": {
            "texte": "The concept Same<T, U> is satisfied if and only if T and U denote the same type.std::Same<T, U> subsumes std::Same<U, T> and vice versa."
        }
    },
    "DerivedFrom": {
        "description": {
            "texte": "The concept DerivedFrom<Derived, Base> is satisfied if and only if Base is a class type that is either Derived or a public and unambiguous base of Derived, ignoring cv-qualifiers.Note that this behaviour is different to std::is_base_of when Base is a private or protected base of Derived."
        }
    },
    "ConvertibleTo": {
        "description": {
            "texte": "The concept ConvertibleTo<From, To> specifies that an expression of the type and value category specified by From can be implicitly and explicitly converted to the type To, and the two forms of conversion are equivalent.Specifically, ConvertibleTo<From, To> is satisfied only if, given a function fun of type From () such that the expression fun() is equality-preserving (see below),"
        }
    },
    "CommonReference": {
        "description": {
            "texte": "The concept CommonReference<T, U> specifies that two types T and U share a common reference type (as computed by std::common_reference_t) to which both can be converted.T and U model CommonReference<T, U> only if, given equality-preserving expressions t1, t2, u1 and u2 such that decltype((t1)) and decltype((t2)) are both T and decltype((u1)) and decltype((u2)) are both U,In other words, the conversion to the common reference type must preserve equality."
        }
    },
    "Common": {
        "description": {
            "texte": "The concept Common<T, U> specifies that two types T and U share a common type (as computed by std::common_type_t) to which both can be converted.T and U model Common<T, U> only if, given equality-preserving expressions t1, t2, u1 and u2 such that decltype((t1)) and decltype((t2)) are both T and decltype((u1)) and decltype((u2)) are both U,In other words, the conversion to the common type must preserve equality."
        }
    },
    "Integral": {
        "description": {
            "texte": "The concept Integral<T> is satisfied if and only if T is an integral type."
        }
    },
    "SignedIntegral": {
        "description": {
            "texte": "The concept SignedIntegral<T> is satisfied if and only if T is an integral type and std::is_signed_v<T> is true."
        }
    },
    "UnsignedIntegral": {
        "description": {
            "texte": "The concept UnsignedIntegral<T> is satisfied if and only if T is an integral type and std::is_signed_v<T> is false."
        }
    },
    "Assignable": {
        "description": {
            "texte": "The concept Assignable<LHS, RHS> specifies that an expression of the type and value category specified by RHS can be assigned to an lvalue expression whose type is specified by LHS.Given.Assignable<LHS, RHS> is satisfied only if."
        }
    },
    "Swappable, std::SwappableWith": {
        "description": {
            "texte": "The concept Swappable<T> specifies that lvalues of type T are swappable.The concept SwappableWith<T, U> specifies that expressions of the type and value category encoded by T and U are swappable with each other. SwappableWith<T, U> is satisfied only if a call to ranges::swap(t, u) exchanges the value of t and u, that is, given distinct objects t2 equal to t and u2 equal to u, after evaluating either ranges::swap(t, u) or ranges::swap(u, t), t2 is equal to u and u2 is equal to t."
        }
    },
    "Destructible": {
        "description": {
            "texte": "The concept Destructible specifies the concept of all types whose instances can safely be destroyed at the end of their lifetime (including reference types)."
        }
    },
    "Constructible": {
        "description": {
            "texte": "The Constructible concept specifies that a variable of type T can be initialized with the given set of argument types Args...."
        }
    },
    "DefaultConstructible": {
        "description": {
            "texte": "The DefaultConstructible concept provides a shorthand for the common case when the question is whether a type can be constructed with no arguments."
        }
    },
    "MoveConstructible": {
        "description": {
            "texte": "The concept MoveConstructible is satisfied if T is a reference type, or if it is an object type where an object of that type can constructed from an rvalue of that type in both direct- and copy-initialization contexts, with the usual semantics.More precisely, if T is an object type, then MoveConstructible<T> is satisfied only if given.the following are true:"
        }
    },
    "CopyConstructible": {
        "description": {
            "texte": "The concept CopyConstructible is satisfied if T is an lvalue reference type, or if it is a MoveConstructible object type where an object of that type can constructed from a (possibly const) lvalue or const rvalue of that type in both direct- and copy-initialization contexts with the usual semantics (a copy is constructed with the source unchanged).More precisely, if T is an object type, then CopyConstructible<T> is satisfied only if given.the following are true:"
        }
    },
    "Boolean": {
        "description": {
            "texte": "The concept Boolean<B> specifies the requirements for a type usable in Boolean contexts. For Boolean to be satisfied, the logical operators must have the usual behavior (including short-circuiting). More precisely, given.Boolean<B> is satisfied only if:"
        }
    },
    "StrictTotallyOrdered, std::StrictTotallyOrderedWith": {
        "description": {
            "texte": "StrictTotallyOrdered<T> is satisfied only if, given lvalues a, b and c of type const std::remove_reference_t<T>:Formally, StrictTotallyOrderedWith<T, U> is satisfied only if, given any lvalue t of type const std::remove_reference_t<T> and any lvalue u of type const std::remove_reference_t<U>, and let C be std::common_reference_t<const std::remove_reference_t<T>&, const std::remove_reference_t<U>&> :"
        }
    },
    "Movable": {
        "description": {
            "texte": "The concept Movable<T> specifies that T is an object type that can moved (that is, it can be move constructed, move assigned, and lvalues of type T can be swapped)."
        }
    },
    "Copyable": {
        "description": {
            "texte": "The concept Copyable<T> specifies that T is an Movable object type that can also copied (that is, it supports copy construction and copy assignment)."
        }
    },
    "Invocable, std::RegularInvocable": {
        "description": {
            "texte": "The Invocable concept specifies that a callable type F can be called with a set of argument types Args... using the function template std::invoke.The RegularInvocable concept adds to the Invocable concept by requiring the invoke expression to be equality preserving and not modify either the function object or the arguments."
        }
    },
    "Predicate": {
        "description": {
            "texte": "The concept Predicate<F, Args...> specifies that F is a predicate that accepts arguments whose types and value categories are encoded by Args..., i.e., it can be invoked with these arguments to produce a Boolean result.Note that RegularInvocable requires the invocation to not modify either the callable object or the arguments and be equality-preserving."
        }
    },
    "StrictWeakOrder": {
        "description": {
            "texte": "The concept StrictWeakOrder<R, T, U> specifies that the Relation R imposes a strict weak ordering on its arguments. A relation r is a strict weak ordering if.Under these conditions, it can be shown that e is an equivalence relation, and r induces a strict total ordering on the equivalence classes determined by e."
        }
    },
    "Constrained algorithms (since C++20)\n": {
        "description": {
            "texte": "C++20 provides constrained versions of most algorithms in the namespace std::ranges. In these algorithms, a range can be specified as either a Iterator-Sentinel pair or as a single Range argument, and projections and pointer-to-member callables are supported. Additionally, the return type of most algorithms have been changed to return all potentially useful information computed during the execution of the algorithm."
        }
    },
    "uncaught_exception, std::uncaught_exceptions": {
        "description": {
            "texte": "Sometimes it's safe to throw an exception even while std::uncaught_exception() == true. For example, if stack unwinding causes an object to be destructed, the destructor for that object could run code that throws an exception as long as the exception is caught by some catch block before escaping the destructor."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <exception>\n#include <stdexcept>\n \nstruct Foo {\n    int count = std::uncaught_exceptions();\n    ~Foo() {\n        std::cout << (count == std::uncaught_exceptions()\n            ? \"~Foo() called normally\\n\"\n            : \"~Foo() called during stack unwinding\\n\");\n    }\n};\nint main()\n{\n    Foo f;\n    try {\n        Foo f;\n        std::cout << \"Exception thrown\\n\";\n        throw std::runtime_error(\"test exception\");\n    } catch (const std::exception& e) {\n        std::cout << \"Exception caught: \" << e.what() << '\\n';\n    }\n}",
            "output": "Exception thrown\n~Foo() called during stack unwinding\nException caught: test exception\n~Foo() called normally"
        }
    },
    "exception_ptr": {
        "description": {
            "texte": "std::exception_ptr is a nullable pointer-like type that manages an exception object which has been thrown and captured with std::current_exception. An instance of std::exception_ptr may be passed to another function, possibly on another thread, where the exception may be rethrown and handled with a catch clause.A default-constructed std::exception_ptr is a null pointer; it does not point to an exception object.Two instances of std::exception_ptr compare equal only if they are both null or both point at the same exception object.std::exception_ptr is not implicitly convertible to any arithmetic, enumeration, or pointer type. It is contextually convertible to bool, and will evaluate to false if it is null, true otherwise.The exception object referenced by an std::exception_ptr remains valid as long as there remains at least one std::exception_ptr that is referencing it: std::exception_ptr is a shared-ownership smart pointer (note; this is in addition to the usual exception object lifetime rules).std::exception_ptr meets the requirements of NullablePointer."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <exception>\n#include <stdexcept>\n \nvoid handle_eptr(std::exception_ptr eptr) // passing by value is ok\n{\n    try {\n        if (eptr) {\n            std::rethrow_exception(eptr);\n        }\n    } catch(const std::exception& e) {\n        std::cout << \"Caught exception \\\"\" << e.what() << \"\\\"\\n\";\n    }\n}\n \nint main()\n{\n    std::exception_ptr eptr;\n    try {\n        std::string().at(1); // this generates an std::out_of_range\n    } catch(...) {\n        eptr = std::current_exception(); // capture\n    }\n    handle_eptr(eptr);\n} // destructor for std::out_of_range called here, when the eptr is destructed",
            "output": "Caught exception \"basic_string::at\""
        }
    },
    "make_exception_ptr": {
        "description": {
            "texte": "Creates an std::exception_ptr that holds a reference to a copy of e. This is done as if executing the following code:",
            "code": "try {\n    throw e;\n} catch(...) {\n    return std::current_exception();\n}"
        }
    },
    "current_exception": {
        "description": {
            "texte": "If called during exception handling (typically, in a catch clause), captures the current exception object and creates an std::exception_ptr that holds either a copy or a reference to that exception object (depending on the implementation). The referenced object remains valid at least as long as there is an exception_ptr object that refers to it.If the implementation of this function requires a call to new and the call fails, the returned pointer will hold a reference to an instance of std::bad_alloc.If the implementation of this function requires copying the captured exception object and its copy constructor throws an exception, the returned pointer will hold a reference to the exception thrown. If the copy constructor of the thrown exception object also throws, the returned pointer may hold a reference to an instance of std::bad_exception to break the endless loop.If the function is called when no exception is being handled, an empty std::exception_ptr is returned."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <exception>\n#include <stdexcept>\n \nvoid handle_eptr(std::exception_ptr eptr) // passing by value is ok\n{\n    try {\n        if (eptr) {\n            std::rethrow_exception(eptr);\n        }\n    } catch(const std::exception& e) {\n        std::cout << \"Caught exception \\\"\" << e.what() << \"\\\"\\n\";\n    }\n}\n \nint main()\n{\n    std::exception_ptr eptr;\n    try {\n        std::string().at(1); // this generates an std::out_of_range\n    } catch(...) {\n        eptr = std::current_exception(); // capture\n    }\n    handle_eptr(eptr);\n} // destructor for std::out_of_range called here, when the eptr is destructed",
            "output": "Caught exception \"basic_string::at\""
        }
    },
    "rethrow_exception": {
        "description": {
            "texte": "Throws the previously captured exception object, referred to by the exception pointer p."
        },
        "parametres": "   p   -   non-null std::exception_ptr \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <exception>\n#include <stdexcept>\n \nvoid handle_eptr(std::exception_ptr eptr) // passing by value is ok\n{\n    try {\n        if (eptr) {\n            std::rethrow_exception(eptr);\n        }\n    } catch(const std::exception& e) {\n        std::cout << \"Caught exception \\\"\" << e.what() << \"\\\"\\n\";\n    }\n}\n \nint main()\n{\n    std::exception_ptr eptr;\n    try {\n        std::string().at(1); // this generates an std::out_of_range\n    } catch(...) {\n        eptr = std::current_exception(); // capture\n    }\n    handle_eptr(eptr);\n} // destructor for std::out_of_range called here, when the eptr is destructed",
            "output": "Caught exception \"basic_string::at\""
        }
    },
    "nested_exception": {
        "description": {
            "texte": "std::nested_exception is a polymorphic mixin class which can capture and store the current exception, making it possible to nest exceptions of arbitrary types within each other."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <stdexcept>\n#include <exception>\n#include <string>\n#include <fstream>\n \n// prints the explanatory string of an exception. If the exception is nested,\n// recurses to print the explanatory of the exception it holds\nvoid print_exception(const std::exception& e, int level =  0)\n{\n    std::cerr << std::string(level, ' ') << \"exception: \" << e.what() << '\\n';\n    try {\n        std::rethrow_if_nested(e);\n    } catch(const std::exception& e) {\n        print_exception(e, level+1);\n    } catch(...) {}\n}\n \n// sample function that catches an exception and wraps it in a nested exception\nvoid open_file(const std::string& s)\n{\n    try {\n        std::ifstream file(s);\n        file.exceptions(std::ios_base::failbit);\n    } catch(...) {\n        std::throw_with_nested( std::runtime_error(\"Couldn't open \" + s) );\n    }\n}\n \n// sample function that catches an exception and wraps it in a nested exception\nvoid run()\n{\n    try {\n        open_file(\"nonexistent.file\");\n    } catch(...) {\n        std::throw_with_nested( std::runtime_error(\"run() failed\") );\n    }\n}\n \n// runs the sample function above and prints the caught exception\nint main()\n{\n    try {\n        run();\n    } catch(const std::exception& e) {\n        print_exception(e);\n    }\n}",
            "output": "exception: run() failed\n exception: Couldn't open nonexistent.file\n  exception: basic_ios::clear"
        }
    },
    "throw_with_nested": {
        "description": {
            "texte": "If std::decay<T>::type is a non-final non-union class type that is neither std::nested_exception nor derived from std::nested_exception, throws an exception of an unspecified type that is publicly derived from both std::nested_exception and from std::decay<T>::type, and constructed from std::forward<T>(t). The default constructor of the nested_exception base class calls std::current_exception, capturing the currently handled exception object, if any, in a std::exception_ptr.Otherwise, throws std::forward<T>(t).Requires that std::decay<T>::type is CopyConstructible."
        },
        "parametres": "   t   -   the exception object to throw \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <stdexcept>\n#include <exception>\n#include <string>\n#include <fstream>\n \n// prints the explanatory string of an exception. If the exception is nested,\n// recurses to print the explanatory of the exception it holds\nvoid print_exception(const std::exception& e, int level =  0)\n{\n    std::cerr << std::string(level, ' ') << \"exception: \" << e.what() << '\\n';\n    try {\n        std::rethrow_if_nested(e);\n    } catch(const std::exception& e) {\n        print_exception(e, level+1);\n    } catch(...) {}\n}\n \n// sample function that catches an exception and wraps it in a nested exception\nvoid open_file(const std::string& s)\n{\n    try {\n        std::ifstream file(s);\n        file.exceptions(std::ios_base::failbit);\n    } catch(...) {\n        std::throw_with_nested( std::runtime_error(\"Couldn't open \" + s) );\n    }\n}\n \n// sample function that catches an exception and wraps it in a nested exception\nvoid run()\n{\n    try {\n        open_file(\"nonexistent.file\");\n    } catch(...) {\n        std::throw_with_nested( std::runtime_error(\"run() failed\") );\n    }\n}\n \n// runs the sample function above and prints the caught exception\nint main()\n{\n    try {\n        run();\n    } catch(const std::exception& e) {\n        print_exception(e);\n    }\n}",
            "output": "exception: run() failed\n exception: Couldn't open nonexistent.file\n  exception: basic_ios::clear"
        }
    },
    "rethrow_if_nested": {
        "description": {
            "texte": "If E is not a polymorphic class type, or if std::nested_exception is an inaccessible or ambiguous base class of E, there is no effect.Otherwise, performs.",
            "code": "if (auto p = dynamic_cast<const std::nested_exception*>(std::addressof(e)))\n    p->rethrow_nested();"
        },
        "parametres": "   e   -   the exception object to rethrow \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <stdexcept>\n#include <exception>\n#include <string>\n#include <fstream>\n \n// prints the explanatory string of an exception. If the exception is nested,\n// recurses to print the explanatory of the exception it holds\nvoid print_exception(const std::exception& e, int level =  0)\n{\n    std::cerr << std::string(level, ' ') << \"exception: \" << e.what() << '\\n';\n    try {\n        std::rethrow_if_nested(e);\n    } catch(const std::exception& e) {\n        print_exception(e, level+1);\n    } catch(...) {}\n}\n \n// sample function that catches an exception and wraps it in a nested exception\nvoid open_file(const std::string& s)\n{\n    try {\n        std::ifstream file(s);\n        file.exceptions(std::ios_base::failbit);\n    } catch(...) {\n        std::throw_with_nested( std::runtime_error(\"Couldn't open \" + s) );\n    }\n}\n \n// sample function that catches an exception and wraps it in a nested exception\nvoid run()\n{\n    try {\n        open_file(\"nonexistent.file\");\n    } catch(...) {\n        std::throw_with_nested( std::runtime_error(\"run() failed\") );\n    }\n}\n \n// runs the sample function above and prints the caught exception\nint main()\n{\n    try {\n        run();\n    } catch(const std::exception& e) {\n        print_exception(e);\n    }\n}",
            "output": "exception: run() failed\n exception: Couldn't open nonexistent.file\n  exception: basic_ios::clear"
        }
    },
    "terminate_handler": {
        "description": {
            "texte": "std::terminate_handler is the function pointer type (pointer to function that takes no arguments and returns void), which is installed and queried by the functions std::set_terminate and std::get_terminate and called by std::terminate.The C++ implementation provides a default std::terminate_handler function, which calls std::abort(). If the null pointer value is installed (by means of std::set_terminate), the implementation may restore the default handler instead."
        }
    },
    "get_terminate": {
        "description": {
            "texte": "Returns the currently installed std::terminate_handler, which may be a null pointer."
        }
    },
    "set_terminate": {
        "description": {
            "texte": "Makes f the new global terminate handler function and returns the previously installed std::terminate_handler."
        },
        "parametres": "   f   -   pointer to function of type std::terminate_handler, or null pointer \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstdlib>\n#include <exception>\n \nint main()\n{\n    std::set_terminate([](){ std::cout << \"Unhandled exception\\n\"; std::abort();});\n    throw 1;\n}",
            "output": "Unhandled exception\nbash: line 7:  7743 Aborted                 (core dumped) ./a.out"
        }
    },
    "bad_exception": {
        "description": {
            "texte": "std::bad_exception is the type of the exception thrown by the C++ runtime in the following situations:"
        },
        "exemple": {
            "input": "#include <iostream>\n#include <exception>\n#include <stdexcept>\n \nvoid my_unexp() { throw; }\n \nvoid test() throw(std::bad_exception)\n{\n    throw std::runtime_error(\"test\");\n}\n \nint main()\n{\n    std::set_unexpected(my_unexp);\n    try {\n         test();\n    } catch(const std::bad_exception& e)\n    {\n        std::cerr << \"Caught \" << e.what() << '\\n';\n    }\n}",
            "output": "Caught std::bad_exception"
        }
    },
    "unexpected": {
        "description": {
            "texte": "std::unexpected() is called by the C++ runtime when a dynamic exception specification is violated: an exception is thrown from a function whose exception specification forbids exceptions of this type.std::unexpected() may also be called directly from the program.In either case, std::unexpected calls the currently installed std::unexpected_handler. The default std::unexpected_handler calls std::terminate."
        }
    },
    "unexpected_handler": {
        "description": {
            "texte": "std::unexpected_handler is the function pointer type (pointer to function that takes no arguments and returns void), which is installed and queried by the functions std::set_unexpected and std::get_unexpected and called by std::unexpected.The C++ implementation provides a default std::unexpected_handler function, which calls std::terminate(). If the null pointer value is installed (by means of std::set_unexpected), the implementation may restore the default handler instead.A user-defined std::unexpected_handler is expected to either terminate the program or throw an exception. If it throws an exception, one of the following three situations may be encountered:1) the exception thrown by std::unexpected_handler satisfies the dynamic exception specification that was violated earlier. The new exception is allowed to escape the function and stack unwinding continues.2) the exception thrown by std::unexpected_handler still violates the exception specification:2a) however, the exception specification allows std::bad_exception: the thrown exception object is destroyed, and std::bad_exception is constructed by the C++ runtime and thrown instead.2b) the exception specification does not allow std::bad_exception: std::terminate() is called."
        }
    },
    "get_unexpected": {
        "description": {
            "texte": "Returns the currently installed std::unexpected_handler, which may be a null pointer.This function is thread-safe. Prior call to std::set_unexpected synchronizes-with (see std::memory_order) the subsequent calls to this function."
        }
    },
    "set_unexpected": {
        "description": {
            "texte": "Makes f the new global std::unexpected_handler and returns the previously installed std::unexpected_handler."
        },
        "parametres": "   f   -   pointer to function of type std::unexpected_handler, or null pointer \n\n"
    },
    "logic_error": {
        "description": {
            "texte": "Defines a type of object to be thrown as exception. It reports errors that are a consequence of faulty logic within the program such as violating logical preconditions or class invariants and may be preventable.No standard library components throw this exception directly, but the exception types std::invalid_argument, std::domain_error, std::length_error, std::out_of_range, std::future_error, and std::experimental::bad_optional_access are derived from std::logic_error."
        },
        "parametres": "   what_arg   -   explanatory string \n\n"
    },
    "invalid_argument": {
        "description": {
            "texte": "Defines a type of object to be thrown as exception. It reports errors that arise because an argument value has not been accepted.This exception is thrown by std::bitset::bitset, and the std::stoi and std::stof families of functions."
        },
        "parametres": "   what_arg   -   explanatory string \n\n"
    },
    "domain_error": {
        "description": {
            "texte": "Defines a type of object to be thrown as exception. It may be used by the implementation to report domain errors, that is, situations where the inputs are outside of the domain on which an operation is defined.The standard library components do not throw this exception (mathematical functions report domain errors as specified in math_errhandling). Third-party libraries, however, use this. For example, boost.math throws std::domain_error if boost::math::policies::throw_on_error is enabled (the default setting)."
        },
        "parametres": "   what_arg   -   explanatory string \n\n"
    },
    "length_error": {
        "description": {
            "texte": "Defines a type of object to be thrown as exception. It reports errors that result from attempts to exceed implementation defined length limits for some object.This exception is thrown by member functions of std::basic_string and std::vector::reserve."
        },
        "parametres": "   what_arg   -   explanatory string \n\n"
    },
    "out_of_range": {
        "description": {
            "texte": "Defines a type of object to be thrown as exception. It reports errors that are consequence of attempt to access elements out of defined range.It may be thrown by the member functions of std::bitset and std::basic_string, by std::stoi and std::stod families of functions, and by the bounds-checked member access functions (e.g. std::vector::at and std::map::at)."
        },
        "parametres": "   what_arg   -   explanatory string \n\n"
    },
    "runtime_error": {
        "description": {
            "texte": "Defines a type of object to be thrown as exception. It reports errors that are due to events beyond the scope of the program and can not be easily predicted.Exceptions of type std::runtime_error are thrown by the following standard library components: std::locale::locale and std::locale::combine.In addition, the standard exception types std::range_error, std::overflow_error, std::underflow_error, std::regex_error, and std::system_error are derived from std::runtime_error."
        },
        "parametres": "   what_arg   -   explanatory string \n\n"
    },
    "range_error": {
        "description": {
            "texte": "Defines a type of object to be thrown as exception. It can be used to report range errors (that is, situations where a result of a computation cannot be represented by the destination type).The only standard library components that throw this exception are std::wstring_convert::from_bytes and std::wstring_convert::to_bytes.The mathematical functions in the standard library components do not throw this exception (mathematical functions report range errors as specified in math_errhandling)."
        },
        "parametres": "   what_arg   -   explanatory string \n\n"
    },
    "overflow_error": {
        "description": {
            "texte": "Defines a type of object to be thrown as exception. It can be used to report arithmetic overflow errors (that is, situations where a result of a computation is too large for the destination type).The only standard library components that throw this exception are std::bitset::to_ulong and std::bitset::to_ullong.The mathematical functions of the standard library components do not throw this exception (mathematical functions report overflow errors as specified in math_errhandling). Third-party libraries, however, use this. For example, boost.math throws std::overflow_error if boost::math::policies::throw_on_error is enabled (the default setting)."
        },
        "parametres": "   what_arg   -   explanatory string \n\n"
    },
    "underflow_error": {
        "description": {
            "texte": "Defines a type of object to be thrown as exception. It may be used to report arithmetic underflow errors (that is, situations where the result of a computation is a subnormal floating-point value).The standard library components do not throw this exception (mathematical functions report underflow errors as specified in math_errhandling). Third-party libraries, however, use this. For example, boost.math throws std::underflow_error if boost::math::policies::throw_on_error is enabled (the default setting)."
        },
        "parametres": "   what_arg   -   explanatory string \n\n"
    },
    "tx_exception": {
        "description": {
            "texte": "Defines an exception type that can be used to cancel and roll back an atomic transaction initiated by the keyword atomic_cancel.If T is not TriviallyCopyable, the program that specializes std::tx_exception<T> is ill-formed."
        },
        "parametres": "   value   -   payload object \n   what_arg   -   explanatory string \n\n"
    },
    "Error numbers": {
        "description": {
            "texte": "Each of the macros defined in <cerrno> expands to integer constant expressions with type int, each with a positive value, matching most of the POSIX error codes. The following constants are defined (the implementation may define more, as long as they begin with 'E' followed by digits or uppercase letters).All values are required to be unique except that the values of EOPNOTSUPP and ENOTSUP may be identical and the values of EAGAIN and EWOULDBLOCK may be identical."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <clocale>\n \nint main()\n{\n    double not_a_number = std::log(-1.0);\n    if (errno == EDOM) {\n        std::cout << \"log(-1) failed: \" << std::strerror(errno) << '\\n';\n        std::setlocale(LC_MESSAGES, \"de_DE.utf8\");\n        std::cout << \"Or, in German, \" << std::strerror(errno) << '\\n';\n    }\n}",
            "output": "log(-1) failed: Numerical argument out of domain\nOr, in German, Das numerische Argument ist ausserhalb des Definitionsbereiches"
        }
    },
    "errno": {
        "description": {
            "texte": "errno is a preprocessor macro used for error indication. It expands to a  static (until C++11) thread-local (since C++11) modifiable lvalue of type int.Several standard library functions indicate errors by writing positive integers to errno. Typically, the value of errno is set to one of the error codes, listed in <cerrno> as macro constants that begin with the letter E, followed by uppercase letters or digits.The value of errno is \u200b0\u200b at program startup, and although library functions are allowed to write positive integers to errno whether or not an error occurred, library functions never store \u200b0\u200b in errno."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <clocale>\n \nint main()\n{\n    double not_a_number = std::log(-1.0);\n    if (errno == EDOM) {\n        std::cout << \"log(-1) failed: \" << std::strerror(errno) << '\\n';\n        std::setlocale(LC_MESSAGES, \"de_DE.utf8\");\n        std::cout << \"Or, in German, \" << std::strerror(errno) << '\\n';\n    }\n}",
            "output": "log(-1) failed: Numerical argument out of domain\nOr, in German, Das numerische Argument ist ausserhalb des Definitionsbereiches"
        }
    },
    "error_category": {
        "description": {
            "texte": "std::error_category serves as the base class for specific error category types, such as std::system_category, std::iostream_category, etc. Each specific category class defines the error_code - error_condition mapping and holds the explanatory strings for all error_conditions. The objects of error category classes are treated as singletons, passed by reference."
        }
    },
    "generic_category": {
        "description": {
            "texte": "Obtains a reference to the static error category object for generic errors. The object is required to override the virtual function error_category::name() to return a pointer to the string \"generic\". It is used to identify error conditions that correspond to the POSIX errno codes."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <system_error>\n#include <cerrno>\n#include <string>\nint main()\n{\n    std::error_condition econd = std::generic_category().default_error_condition(EDOM);\n    std::cout << \"Category: \" << econd.category().name() << '\\n'\n              << \"Value: \" << econd.value() << '\\n'\n              << \"Message: \" << econd.message() << '\\n';\n}",
            "output": "Category: generic\nValue: 33\nMessage: Numerical argument out of domain"
        }
    },
    "system_category": {
        "description": {
            "texte": "Obtains a reference to the static error category object for errors reported by the operating system. The object is required to override the virtual function std::error_category::name() to return a pointer to the string \"system\". It is also required to override the virtual function std::error_category::default_error_condition() to map the error codes that match POSIX errno values to std::generic_category."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <system_error>\n#include <iomanip>\n#include <string>\n \nint main()\n{\n    std::error_condition econd = std::system_category().default_error_condition(EDOM);\n    std::cout << \"Category: \" << econd.category().name() << '\\n'\n              << \"Value: \" << econd.value() << '\\n'\n              << \"Message: \" << econd.message() << '\\n';\n \n    econd = std::system_category().default_error_condition(10001);\n    std::cout << \"Category: \" << econd.category().name() << '\\n'\n              << \"Value: \" << econd.value() << '\\n'\n              << \"Message: \" << econd.message() << '\\n';\n}",
            "output": "Category: generic\nValue: 33\nMessage: Numerical argument out of domain\nCategory: system\nValue: 10001\nMessage: Unknown error 10001"
        }
    },
    "error_condition": {
        "description": {
            "texte": "std::error_condition is a platform-independent error code. Like std::error_code, it is uniquely identified by an integer value and a std::error_category, but unlike std::error_code, the value is not platform-dependent.A typical implementation holds one integer data member (the value) and a pointer to an std::error_category."
        }
    },
    "errc": {
        "description": {
            "texte": "The scoped enumeration std::errc defines the values of portable error conditions that correspond to the POSIX error codes."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <system_error>\n#include <thread>\nint main()\n{\n    try {\n        std::thread().detach(); // detaching a not-a-thread\n    } catch (const std::system_error& e) {\n        std::cout << \"Caught a system_error\\n\";\n        if(e.code() == std::errc::invalid_argument)\n            std::cout << \"The error condition is std::errc::invalid_argument\\n\";\n        std::cout << \"the error description is \" << e.what() << '\\n';\n    }\n}",
            "output": "Caught a system_error\nThe error condition is std::errc::invalid_argument\nthe error description is Invalid argument"
        }
    },
    "system_error": {
        "description": {
            "texte": "std::system_error is the type of the exception thrown by various library functions (typically the functions that interface with the OS facilities, e.g. the constructor of std::thread) when the exception has an associated std::error_code, which may be reported."
        },
        "exemple": {
            "input": "#include <thread>\n#include <iostream>\n#include <system_error>\n \nint main()\n{\n    try {\n        std::thread().detach(); // attempt to detach a non-thread\n    } catch(const std::system_error& e) {\n        std::cout << \"Caught system_error with code \" << e.code() \n                  << \" meaning \" << e.what() << '\\n';\n    }\n}",
            "output": "Caught system_error with code generic:22 meaning Invalid argument"
        }
    },
    "future": {
        "description": {
            "texte": "The class template std::future provides a mechanism to access the result of asynchronous operations:Note that std::future references shared state that is not shared with any other asynchronous return objects (as opposed to std::shared_future)."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <future>\n#include <thread>\n \nint main()\n{\n    // future from a packaged_task\n    std::packaged_task<int()> task([]{ return 7; }); // wrap the function\n    std::future<int> f1 = task.get_future();  // get a future\n    std::thread t(std::move(task)); // launch on a thread\n \n    // future from an async()\n    std::future<int> f2 = std::async(std::launch::async, []{ return 8; });\n \n    // future from a promise\n    std::promise<int> p;\n    std::future<int> f3 = p.get_future();\n    std::thread( [&p]{ p.set_value_at_thread_exit(9); }).detach();\n \n    std::cout << \"Waiting...\" << std::flush;\n    f1.wait();\n    f2.wait();\n    f3.wait();\n    std::cout << \"Done!\\nResults are: \"\n              << f1.get() << ' ' << f2.get() << ' ' << f3.get() << '\\n';\n    t.join();\n}",
            "output": "Waiting...Done!\nResults are: 7 8 9"
        }
    },
    "char_traits": {
        "description": {
            "texte": "The char_traits class is a traits class template that abstracts basic character and string operations for a given character type. The defined operation set is such that generic algorithms almost always can be implemented in terms of it. It is thus possible to use such algorithms with almost any possible character or string type, just by supplying a customized char_traits class.The char_traits class template serves as a basis for explicit instantiations. The user can provide a specialization for any custom character types. Several specializations are defined for the standard character types.If an operation on traits emits an exception, the behavior is undefined.The values of the member typedefs are as follows.The semantics of the member functions are defined are as follows.The char_traits class template satisfies the requirements of CharTraits."
        },
        "exemple": {
            "input": "#include <string>\n#include <iostream>\n#include <cctype>\n \nstruct ci_char_traits : public std::char_traits<char> {\n    static char to_upper(char ch) {\n        return std::toupper((unsigned char) ch);\n    }\n    static bool eq(char c1, char c2) {\n         return to_upper(c1) == to_upper(c2);\n     }\n    static bool lt(char c1, char c2) {\n         return to_upper(c1) <  to_upper(c2);\n    }\n    static int compare(const char* s1, const char* s2, size_t n) {\n        while ( n-- != 0 ) {\n            if ( to_upper(*s1) < to_upper(*s2) ) return -1;\n            if ( to_upper(*s1) > to_upper(*s2) ) return 1;\n            ++s1; ++s2;\n        }\n        return 0;\n    }\n    static const char* find(const char* s, int n, char a) {\n        auto const ua (to_upper(a));\n        while ( n-- != 0 ) \n        {\n            if (to_upper(*s) == ua)\n                return s;\n            s++;\n        }\n        return nullptr;\n    }\n};\n \nusing ci_string = std::basic_string<char, ci_char_traits>;\n \nstd::ostream& operator<<(std::ostream& os, const ci_string& str) {\n    return os.write(str.data(), str.size());\n}\n \nint main()\n{\n    ci_string s1 = \"Hello\";\n    ci_string s2 = \"heLLo\";\n    if (s1 == s2)\n        std::cout << s1 << \" and \" << s2 << \" are equal\\n\";\n}",
            "output": "Hello and heLLo are equal"
        }
    },
    "wstring_convert": {
        "description": {
            "texte": "Class template std::wstring_convert performs conversions between byte string std::string and wide string std::basic_string<Elem>, using an individual code conversion facet Codecvt. std::wstring_convert assumes ownership of the conversion facet, and cannot use a facet managed by a locale. The standard facets suitable for use with std::wstring_convert are std::codecvt_utf8 for UTF-8/UCS2 and UTF-8/UCS4 conversions and std::codecvt_utf8_utf16 for UTF-8/UTF-16 conversions."
        }
    },
    "span": {
        "description": {
            "texte": "The class template span describes an object that can refer to a contiguous sequence of objects with the first element of the sequence at position zero. A span can either have a static extent, in which case the number of elements in the sequence is known and encoded in the type, or a dynamic extent.A typical implementation holds only two members: a pointer to T and a size."
        }
    },
    "set::insert": {
        "description": {
            "texte": "Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.No iterators or references are invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. (since C++17)."
        },
        "parametres": "   hint   -   \n\niterator, used as a suggestion as to where to start the search (until C++11)\n\n\niterator to the position before which the new element will be inserted (since C++11)\n\n \n   value   -   element value to insert \n   first, last   -   range of elements to insert \n   ilist   -   initializer list to insert the values from \n   nh   -   a compatible node handle \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n",
        "exemple": {
            "input": "#include <set>\n#include <cassert>\n#include <iostream>\n \nint main()\n{\n  std::set<int> set;\n \n  auto result_1 = set.insert(3);\n  assert(result_1.first != set.end()); // it's a valid iterator\n  assert(*result_1.first == 3);\n  if (result_1.second)\n    std::cout << \"insert done\\n\";\n \n  auto result_2 = set.insert(3);\n  assert(result_2.first == result_1.first); // same iterator\n  assert(*result_2.first == 3);\n  if (!result_2.second)\n    std::cout << \"no insertion\\n\";\n}",
            "output": "insert done\nno insertion"
        }
    },
    "map::emplace": {
        "description": {
            "texte": "Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container.Careful use of emplace allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element (i.e. std::pair<const Key, T>) is called with exactly the same arguments as supplied to emplace, forwarded via std::forward<Args>(args).... The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately.No iterators or references are invalidated."
        },
        "parametres": "   args   -   arguments to forward to the constructor of the element \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <utility>\n#include <string>\n#include <map>\n \nint main()\n{\n    std::map<std::string, std::string> m;\n \n    // uses pair's move constructor\n    m.emplace(std::make_pair(std::string(\"a\"), std::string(\"a\")));\n \n    // uses pair's converting move constructor\n    m.emplace(std::make_pair(\"b\", \"abcd\"));\n \n    // uses pair's template constructor\n    m.emplace(\"d\", \"ddd\");\n \n    // uses pair's piecewise constructor\n    m.emplace(std::piecewise_construct,\n              std::forward_as_tuple(\"c\"),\n              std::forward_as_tuple(10, 'c'));\n    // as of C++17, m.try_emplace(\"c\", 10, 'c'); can be used\n \n    for (const auto &p : m) {\n        std::cout << p.first << \" => \" << p.second << '\\n';\n    }\n}",
            "output": "a => a\nb => abcd\nc => cccccccccc\nd => ddd"
        }
    },
    "vector::push_back": {
        "description": {
            "texte": "Appends the given element value to the end of the container.If the new size() is greater than capacity() then all iterators and references (including the past-the-end iterator) are invalidated. Otherwise only the past-the-end iterator is invalidated."
        },
        "parametres": "   value   -   the value of the element to append \n   Type requirements \n   -T must meet the requirements of CopyInsertable in order to use overload (1). \n   -T must meet the requirements of MoveInsertable in order to use overload (2). \n\n",
        "exemple": {
            "input": "#include <vector>\n#include <iostream>\n#include <iomanip>\n \nint main()\n{\n    std::vector<std::string> numbers;\n \n    numbers.push_back(\"abc\");\n    std::string s = \"def\";\n    numbers.push_back(std::move(s));\n \n    std::cout << \"vector holds: \";\n    for (auto&& i : numbers) std::cout << std::quoted(i) << ' ';\n    std::cout << \"\\nMoved-from string holds \" << std::quoted(s) << '\\n';\n}",
            "output": "vector holds: \"abc\" \"def\" \nMoved-from string holds \"\""
        }
    },
    "deque::push_front": {
        "description": {
            "texte": "Prepends the given element value to the beginning of the container.All iterators, including the past-the-end iterator, are invalidated. No references are invalidated."
        },
        "parametres": "   value   -   the value of the element to prepend \n\n"
    },
    "unordered_map::operator[]": {
        "description": {
            "texte": "Returns a reference to the value that is mapped to a key equivalent to key, performing an insertion if such key does not already exist.If an insertion occurs and results in a rehashing of the container, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than max_load_factor()*bucket_count()."
        },
        "parametres": "   key   -   the key of the element to find \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n \nint main()\n{\n    std::unordered_map<char, int> letter_counts {{'a', 27}, {'b', 3}, {'c', 1}};\n \n    std::cout << \"initially:\\n\";\n    for (const auto &pair : letter_counts) {\n        std::cout << pair.first << \": \" << pair.second << '\\n';\n    }\n \n    letter_counts['b'] = 42;  // update an existing value\n    letter_counts['x'] = 9;  // insert a new value\n \n    std::cout << \"after modifications:\\n\";\n    for (const auto &pair : letter_counts) {\n        std::cout << pair.first << \": \" << pair.second << '\\n';\n    }\n \n    // count the number of occurrences of each word\n    // (the first call to operator[] initialized the counter with zero)\n    std::unordered_map<std::string, size_t>  word_map;\n    for (const auto &w : { \"this\", \"sentence\", \"is\", \"not\", \"a\", \"sentence\",\n                           \"this\", \"sentence\", \"is\", \"a\", \"hoax\"}) {\n        ++word_map[w];\n    }\n \n    for (const auto &pair : word_map) {\n        std::cout << pair.second << \" occurrences of word '\" << pair.first << \"'\\n\";\n    }\n}",
            "output": "initially:\na: 27\nb: 3\nc: 1\nafter modifications:\na: 27\nb: 42\nc: 1\nx: 9\n2 occurrences of word 'a'\n1 occurrences of word 'hoax'\n2 occurrences of word 'is'\n1 occurrences of word 'not'\n3 occurrences of word 'sentence'\n2 occurrences of word 'this'"
        }
    },
    "set::erase": {
        "description": {
            "texte": "Removes specified elements from the container.References and iterators to the erased elements are invalidated. Other references and iterators are not affected.The iterator pos must be valid and dereferenceable. Thus the end() iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos."
        },
        "parametres": "   pos   -   iterator to the element to remove \n   first, last   -   range of elements to remove \n   key   -   key value of the elements to remove \n\n",
        "exemple": {
            "input": "#include <set>\n#include <iostream>\nint main()\n{\n    std::set<int> c = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(*it % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(int n : c)\n        std::cout << n << ' ';\n}",
            "output": "2 4 6 8"
        }
    },
    "vector::pop_back": {
        "description": {
            "texte": "Removes the last element of the container.Calling pop_back on an empty container is undefined.No iterators or references except for back() and end() are invalidated."
        },
        "exemple": {
            "input": "#include <vector>\n#include <iostream>\n \ntemplate<typename T>\nvoid print(T const & xs)\n{\n    std::cout << \"[ \";\n    for(auto const & x : xs) {\n        std::cout << x << ' ';\n    }\n    std::cout << \"]\\n\";\n}\n \nint main()\n{\n    std::vector<int> numbers;\n \n    print(numbers); \n \n    numbers.push_back(5);\n    numbers.push_back(3);\n    numbers.push_back(4);\n \n    print(numbers); \n \n    numbers.pop_back();\n \n    print(numbers); \n}",
            "output": "[ ]\n[ 5 3 4 ]\n[ 5 3 ]"
        }
    },
    "deque::pop_front": {
        "description": {
            "texte": "Removes the first element of the container. If there are no elements in the container, the behavior is undefined."
        }
    },
    "map::clear": {
        "description": {
            "texte": "Erases all elements from the container. After this call, size() returns zero.Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterator remains valid."
        }
    },
    "set::end, std::set::cend": {
        "description": {
            "texte": "Returns an iterator to the element following the last element of the container.This element acts as a placeholder; attempting to access it results in undefined behavior."
        }
    },
    "unordered_set::end, std::unordered_set::cend": {
        "description": {
            "texte": "Returns an iterator to the element following the last element of the container.This element acts as a placeholder; attempting to access it results in undefined behavior."
        }
    },
    "vector::end, std::vector::cend": {
        "description": {
            "texte": "Returns an iterator to the element following the last element of the container.This element acts as a placeholder; attempting to access it results in undefined behavior."
        }
    },
    "deque::end, std::deque::cend": {
        "description": {
            "texte": "Returns an iterator to the element following the last element of the container.This element acts as a placeholder; attempting to access it results in undefined behavior."
        }
    },
    "transform": {
        "description": {
            "texte": "std::transform applies the given function to a range and stores the result in another range, beginning at d_first."
        },
        "parametres": "   first1, last1   -   the first range of elements to transform \n   first2   -   the beginning of the second range of elements to transform \n   d_first   -   the beginning of the destination range, may be equal to first1 or first2 \n   policy   -   the execution policy to use. See execution policy for details. \n   unary_op   -   unary operation function object that will be applied.  The signature of the function should be equivalent to the following:\n Ret fun(const Type &a);\nThe signature does not need to have const &. The type Type must be such that an object of type InputIt can be dereferenced and then implicitly converted to Type. The type Ret must be such that an object of type OutputIt can be dereferenced and assigned a value of type Ret. \u200b\n\n   binary_op   -   binary operation function object that will be applied.  The signature of the function should be equivalent to the following:\n Ret fun(const Type1 &a, const Type2 &b);\nThe signature does not need to have const &. The types Type1 and Type2 must be such that objects of types InputIt1 and InputIt2 can be dereferenced and then implicitly converted to Type1 and Type2 respectively. The type Ret must be such that an object of type OutputIt can be dereferenced and assigned a value of type Ret. \u200b\n\n   Type requirements \n   -InputIt, InputIt1, InputIt2 must meet the requirements of LegacyInputIterator. \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n   -ForwardIt1, ForwardIt2, ForwardIt3 must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <cctype>\n#include <iostream>\n#include <string>\n#include <vector>\n \nint main()\n{\n    std::string s(\"hello\");\n    std::transform(s.begin(), s.end(), s.begin(),\n                   [](unsigned char c) -> unsigned char { return std::toupper(c); });\n \n    std::vector<std::size_t> ordinals;\n    std::transform(s.begin(), s.end(), std::back_inserter(ordinals),\n                   [](unsigned char c) -> std::size_t { return c; });\n \n    std::cout << s << ':';\n    for (auto ord : ordinals) {\n       std::cout << ' ' << ord;\n    }\n}",
            "output": "HELLO: 72 69 76 76 79"
        }
    },
    "for_each": {
        "description": {
            "texte": "For both overloads, if the iterator type is mutable, f may modify the elements of the range through the dereferenced iterator. If f returns a result, the result is ignored.Unlike the rest of the algorithms, for_each is not allowed to make copies of the elements in the sequence even if they are trivially copyable."
        },
        "parametres": "   first, last   -   the range to apply the function to \n   policy   -   the execution policy to use. See execution policy for details. \n   f   -   function object, to be applied to the result of dereferencing every iterator in the range [first, last)  The signature of the function should be equivalent to the following:\n void fun(const Type &a);\nThe signature does not need to have const &. The type Type must be such that an object of type InputIt can be dereferenced and then implicitly converted to Type.\n\u200b\n\n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -UnaryFunction must meet the requirements of MoveConstructible. Does not have to be CopyConstructible \n   -UnaryFunction2 must meet the requirements of CopyConstructible. \n\n",
        "exemple": {
            "input": "#include <vector>\n#include <algorithm>\n#include <iostream>\n \nstruct Sum\n{\n    Sum(): sum{0} { }\n    void operator()(int n) { sum += n; }\n    int sum;\n};\n \nint main()\n{\n    std::vector<int> nums{3, 4, 2, 8, 15, 267};\n \n    auto print = [](const int& n) { std::cout << \" \" << n; };\n \n    std::cout << \"before:\";\n    std::for_each(nums.begin(), nums.end(), print);\n    std::cout << '\\n';\n \n    std::for_each(nums.begin(), nums.end(), [](int &n){ n++; });\n \n    // calls Sum::operator() for each number\n    Sum s = std::for_each(nums.begin(), nums.end(), Sum());\n \n    std::cout << \"after: \";\n    std::for_each(nums.begin(), nums.end(), print);\n    std::cout << '\\n';\n    std::cout << \"sum: \" << s.sum << '\\n';\n}",
            "output": "before: 3 4 2 8 15 267\nafter:  4 5 3 9 16 268\nsum: 305"
        }
    },
    "vector::vector": {
        "description": {
            "texte": "Constructs a new container from a variety of data sources, optionally using a user supplied allocator alloc."
        },
        "parametres": "   alloc   -   allocator to use for all memory allocations of this container \n   count   -   the size of the container \n   value   -   the value to initialize elements of the container with \n   first, last   -   the range to copy the elements from \n   other   -   another container to be used as source to initialize the elements of the container with \n   init   -   initializer list to initialize the elements of the container with \n\n",
        "exemple": {
            "input": "#include <vector>\n#include <string>\n#include <iostream>\n \ntemplate<typename T>\nstd::ostream& operator<<(std::ostream& s, const std::vector<T>& v) {\n    s.put('[');\n    char comma[3] = {'\\0', ' ', '\\0'};\n    for (const auto& e : v) {\n        s << comma << e;\n        comma[0] = ',';\n    }\n    return s << ']';\n}\n \nint main() \n{\n    // c++11 initializer list syntax:\n    std::vector<std::string> words1 {\"the\", \"frogurt\", \"is\", \"also\", \"cursed\"};\n    std::cout << \"words1: \" << words1 << '\\n';\n \n    // words2 == words1\n    std::vector<std::string> words2(words1.begin(), words1.end());\n    std::cout << \"words2: \" << words2 << '\\n';\n \n    // words3 == words1\n    std::vector<std::string> words3(words1);\n    std::cout << \"words3: \" << words3 << '\\n';\n \n    // words4 is {\"Mo\", \"Mo\", \"Mo\", \"Mo\", \"Mo\"}\n    std::vector<std::string> words4(5, \"Mo\");\n    std::cout << \"words4: \" << words4 << '\\n';\n}",
            "output": "words1: [the, frogurt, is, also, cursed]\nwords2: [the, frogurt, is, also, cursed]\nwords3: [the, frogurt, is, also, cursed]\nwords4: [Mo, Mo, Mo, Mo, Mo]"
        }
    },
    "deque::deque": {
        "description": {
            "texte": "Constructs a new container from a variety of data sources, optionally using a user supplied allocator alloc."
        },
        "parametres": "   alloc   -   allocator to use for all memory allocations of this container \n   count   -   the size of the container \n   value   -   the value to initialize elements of the container with \n   first, last   -   the range to copy the elements from \n   other   -   another container to be used as source to initialize the elements of the container with \n   init   -   initializer list to initialize the elements of the container with \n\n",
        "exemple": {
            "input": "#include <deque>\n#include <string>\n#include <iostream>\n \ntemplate<typename T>\nstd::ostream& operator<<(std::ostream& s, const std::deque<T>& v) {\n    s.put('[');\n    char comma[3] = {'\\0', ' ', '\\0'};\n    for (const auto& e : v) {\n        s << comma << e;\n        comma[0] = ',';\n    }\n    return s << ']';\n}\n \nint main() \n{\n    // c++11 initializer list syntax:\n    std::deque<std::string> words1 {\"the\", \"frogurt\", \"is\", \"also\", \"cursed\"};\n    std::cout << \"words1: \" << words1 << '\\n';\n \n    // words2 == words1\n    std::deque<std::string> words2(words1.begin(), words1.end());\n    std::cout << \"words2: \" << words2 << '\\n';\n \n    // words3 == words1\n    std::deque<std::string> words3(words1);\n    std::cout << \"words3: \" << words3 << '\\n';\n \n    // words4 is {\"Mo\", \"Mo\", \"Mo\", \"Mo\", \"Mo\"}\n    std::deque<std::string> words4(5, \"Mo\");\n    std::cout << \"words4: \" << words4 << '\\n';\n}",
            "output": "words1: [the, frogurt, is, also, cursed]\nwords2: [the, frogurt, is, also, cursed]\nwords3: [the, frogurt, is, also, cursed]\nwords4: [Mo, Mo, Mo, Mo, Mo]"
        }
    },
    "forward_list::forward_list": {
        "description": {
            "texte": "Constructs a new container from a variety of data sources, optionally using a user supplied allocator alloc."
        },
        "parametres": "   alloc   -   allocator to use for all memory allocations of this container \n   count   -   the size of the container \n   value   -   the value to initialize elements of the container with \n   first, last   -   the range to copy the elements from \n   other   -   another container to be used as source to initialize the elements of the container with \n   init   -   initializer list to initialize the elements of the container with \n\n",
        "exemple": {
            "input": "#include <forward_list>\n#include <string>\n#include <iostream>\n \ntemplate<typename T>\nstd::ostream& operator<<(std::ostream& s, const std::forward_list<T>& v) {\n    s.put('[');\n    char comma[3] = {'\\0', ' ', '\\0'};\n    for (const auto& e : v) {\n        s << comma << e;\n        comma[0] = ',';\n    }\n    return s << ']';\n}\n \nint main() \n{\n    // c++11 initializer list syntax:\n    std::forward_list<std::string> words1 {\"the\", \"frogurt\", \"is\", \"also\", \"cursed\"};\n    std::cout << \"words1: \" << words1 << '\\n';\n \n    // words2 == words1\n    std::forward_list<std::string> words2(words1.begin(), words1.end());\n    std::cout << \"words2: \" << words2 << '\\n';\n \n    // words3 == words1\n    std::forward_list<std::string> words3(words1);\n    std::cout << \"words3: \" << words3 << '\\n';\n \n    // words4 is {\"Mo\", \"Mo\", \"Mo\", \"Mo\", \"Mo\"}\n    std::forward_list<std::string> words4(5, \"Mo\");\n    std::cout << \"words4: \" << words4 << '\\n';\n}",
            "output": "words1: [the, frogurt, is, also, cursed]\nwords2: [the, frogurt, is, also, cursed]\nwords3: [the, frogurt, is, also, cursed]\nwords4: [Mo, Mo, Mo, Mo, Mo]"
        }
    },
    "list::list": {
        "description": {
            "texte": "Constructs a new container from a variety of data sources, optionally using a user supplied allocator alloc."
        },
        "parametres": "   alloc   -   allocator to use for all memory allocations of this container \n   count   -   the size of the container \n   value   -   the value to initialize elements of the container with \n   first, last   -   the range to copy the elements from \n   other   -   another container to be used as source to initialize the elements of the container with \n   init   -   initializer list to initialize the elements of the container with \n\n",
        "exemple": {
            "input": "#include <list>\n#include <string>\n#include <iostream>\n \ntemplate<typename T>\nstd::ostream& operator<<(std::ostream& s, const std::list<T>& v) {\n    s.put('[');\n    char comma[3] = {'\\0', ' ', '\\0'};\n    for (const auto& e : v) {\n        s << comma << e;\n        comma[0] = ',';\n    }\n    return s << ']';\n}\n \nint main() \n{\n    // c++11 initializer list syntax:\n    std::list<std::string> words1 {\"the\", \"frogurt\", \"is\", \"also\", \"cursed\"};\n    std::cout << \"words1: \" << words1 << '\\n';\n \n    // words2 == words1\n    std::list<std::string> words2(words1.begin(), words1.end());\n    std::cout << \"words2: \" << words2 << '\\n';\n \n    // words3 == words1\n    std::list<std::string> words3(words1);\n    std::cout << \"words3: \" << words3 << '\\n';\n \n    // words4 is {\"Mo\", \"Mo\", \"Mo\", \"Mo\", \"Mo\"}\n    std::list<std::string> words4(5, \"Mo\");\n    std::cout << \"words4: \" << words4 << '\\n';\n}",
            "output": "words1: [the, frogurt, is, also, cursed]\nwords2: [the, frogurt, is, also, cursed]\nwords3: [the, frogurt, is, also, cursed]\nwords4: [Mo, Mo, Mo, Mo, Mo]"
        }
    },
    "set::set": {
        "description": {
            "texte": "Constructs new container from a variety of data sources and optionally using user supplied allocator alloc or comparison function object comp."
        },
        "parametres": "   alloc   -   allocator to use for all memory allocations of this container \n   comp   -   comparison function object to use for all comparisons of keys \n   first, last   -   the range to copy the elements from \n   other   -   another container to be used as source to initialize the elements of the container with \n   init   -   initializer list to initialize the elements of the container with \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -Compare must meet the requirements of Compare. \n   -Allocator must meet the requirements of Allocator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <set>\n#include <cmath>\n \nstruct Point { double x, y; };\nstruct PointCmp {\n    bool operator()(const Point& lhs, const Point& rhs) const { \n        return std::hypot(lhs.x, lhs.y) < std::hypot(rhs.x, rhs.y); \n    }\n};\n \nint main()\n{\n  // (1) Default constructor\n  std::set<std::string> a;\n  a.insert(\"cat\");\n  a.insert(\"dog\");\n  a.insert(\"horse\");\n  for(auto& str: a) std::cout << str << ' ';\n  std::cout << '\\n';\n \n  // (2) Iterator constructor\n  std::set<std::string> b(a.find(\"dog\"), a.end());\n  for(auto& str: b) std::cout << str << ' ';\n  std::cout << '\\n';\n \n  // (3) Copy constructor\n  std::set<std::string> c(a);\n  c.insert(\"another horse\");\n  for(auto& str: c) std::cout << str << ' ';\n  std::cout << '\\n';\n \n  // (4) Move constructor\n  std::set<std::string> d(std::move(a));\n  for(auto& str: d) std::cout << str << ' ';\n  std::cout << '\\n';\n  std::cout << \"moved-from set is \";\n  for(auto& str: a) std::cout << str << ' ';\n  std::cout << '\\n';\n \n  // (5) Initializer list constructor\n  std::set<std::string> e {\"one\", \"two\", \"three\", \"five\", \"eight\"};\n  for(auto& str: e) std::cout << str << ' ';\n  std::cout << '\\n';\n \n  // custom comparison\n  std::set<Point, PointCmp> z = {{2, 5}, {3, 4}, {1, 1}};\n  z.insert({1, -1}); // this fails because the magnitude of 1,-1 equals 1,1\n  for(auto& p: z) std::cout << '(' << p.x << ',' << p.y << \") \";\n  std::cout << '\\n';\n}",
            "output": "cat dog horse \ndog horse \nanother horse cat dog horse \ncat dog horse \nmoved-from set is \neight five one three two \n(1,1) (3,4) (2,5)"
        }
    },
    "multiset::multiset": {
        "description": {
            "texte": "Constructs new container from a variety of data sources and optionally using user supplied allocator alloc or comparison function object comp."
        },
        "parametres": "   alloc   -   allocator to use for all memory allocations of this container \n   comp   -   comparison function object to use for all comparisons of keys \n   first, last   -   the range to copy the elements from \n   other   -   another container to be used as source to initialize the elements of the container with \n   init   -   initializer list to initialize the elements of the container with \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -Compare must meet the requirements of Compare. \n   -Allocator must meet the requirements of Allocator. \n\n"
    },
    "map::map": {
        "description": {
            "texte": "Constructs new container from a variety of data sources and optionally using user supplied allocator alloc or comparison function object comp."
        },
        "parametres": "   alloc   -   allocator to use for all memory allocations of this container \n   comp   -   comparison function object to use for all comparisons of keys \n   first, last   -   the range to copy the elements from \n   other   -   another container to be used as source to initialize the elements of the container with \n   init   -   initializer list to initialize the elements of the container with \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -Compare must meet the requirements of Compare. \n   -Allocator must meet the requirements of Allocator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <iomanip>\n#include <map>\n \ntemplate<typename Map>\nvoid print_map(Map& m)\n{\n   std::cout << '{';\n   for(auto& p: m)\n        std::cout << p.first << ':' << p.second << ' ';\n   std::cout << \"}\\n\";\n}\n \nstruct Point { double x, y; };\nstruct PointCmp {\n    bool operator()(const Point& lhs, const Point& rhs) const { \n        return lhs.x < rhs.x; // NB. intentionally ignores y\n    }\n};\n \nint main()\n{\n  // (1) Default constructor\n  std::map<std::string, int> map1;\n  map1[\"something\"] = 69;\n  map1[\"anything\"] = 199;\n  map1[\"that thing\"] = 50;\n  std::cout << \"map1 = \"; print_map(map1);\n \n  // (2) Range constructor\n  std::map<std::string, int> iter(map1.find(\"anything\"), map1.end());\n  std::cout << \"\\niter = \"; print_map(iter);\n  std::cout << \"map1 = \"; print_map(map1);\n \n  // (3) Copy constructor\n  std::map<std::string, int> copied(map1);\n  std::cout << \"\\ncopied = \"; print_map(copied);\n  std::cout << \"map1 = \"; print_map(map1);\n \n  // (4) Move constructor\n  std::map<std::string, int> moved(std::move(map1));\n  std::cout << \"\\nmoved = \"; print_map(moved);\n  std::cout << \"map1 = \"; print_map(map1);\n \n  // (5) Initializer list constructor\n  const std::map<std::string, int> init {\n    {\"this\", 100},\n    {\"can\", 100},\n    {\"be\", 100},\n    {\"const\", 100},\n  };\n  std::cout << \"\\ninit = \"; print_map(init);\n \n \n  // Custom Key class option 1:\n  // Use a comparison struct\n  std::map<Point, double, PointCmp> mag = {\n      { {5, -12}, 13 },\n      { {3, 4},   5 },\n      { {-8, -15}, 17 }\n  };\n \n  for(auto p : mag)\n      std::cout << \"The magnitude of (\" << p.first.x\n                << \", \" << p.first.y << \") is \"\n                << p.second << '\\n';\n \n  // Custom Key class option 2:    \n  // Use a comparison lambda\n  // This lambda sorts points according to their magnitudes, where note that\n  //  these magnitudes are taken from the local variable mag\n  auto cmpLambda = [&mag](const Point &lhs, const Point &rhs) { return mag[lhs] < mag[rhs]; };\n  //You could also use a lambda that is not dependent on local variables, like this:\n  //auto cmpLambda = [](const Point &lhs, const Point &rhs) { return lhs.y < rhs.y; };\n  std::map<Point, double, decltype(cmpLambda)> magy(cmpLambda);\n \n  //Various ways of inserting elements:\n  magy.insert(std::pair<Point, double>({5, -12}, 13));\n  magy.insert({ {3, 4}, 5});\n  magy.insert({Point{-8.0, -15.0}, 17});\n \n  std::cout << '\\n';\n  for(auto p : magy)\n      std::cout << \"The magnitude of (\" << p.first.x\n                << \", \" << p.first.y << \") is \"\n                << p.second << '\\n';\n}",
            "output": "map1 = {anything:199 something:69 that thing:50 }\n \niter = {anything:199 something:69 that thing:50 }\nmap1 = {anything:199 something:69 that thing:50 }\n \ncopied = {anything:199 something:69 that thing:50 }\nmap1 = {anything:199 something:69 that thing:50 }\n \nmoved = {anything:199 something:69 that thing:50 }\nmap1 = {}\n \ninit = {be:100 can:100 const:100 this:100 }\nThe magnitude of (-8, -15) is 17\nThe magnitude of (3, 4) is 5\nThe magnitude of (5, -12) is 13\n \nThe magnitude of (3, 4) is 5\nThe magnitude of (5, -12) is 13\nThe magnitude of (-8, -15) is 17"
        }
    },
    "multimap::multimap": {
        "description": {
            "texte": "Constructs new container from a variety of data sources and optionally using user supplied allocator alloc or comparison function object comp."
        },
        "parametres": "   alloc   -   allocator to use for all memory allocations of this container \n   comp   -   comparison function object to use for all comparisons of keys \n   first, last   -   the range to copy the elements from \n   other   -   another container to be used as source to initialize the elements of the container with \n   init   -   initializer list to initialize the elements of the container with \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -Compare must meet the requirements of Compare. \n   -Allocator must meet the requirements of Allocator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <map>\n \nstruct Point { double x, y; };\nstruct PointCmp {\n    bool operator()(const Point& lhs, const Point& rhs) const { \n        return lhs.x < rhs.x; // NB. ignores y on purpose\n    }\n};\n \nint main() {\n    std::multimap<int, int> m = {{1,1},{2,2},{3,3},{4,4},{5,5},{4,4},{3,3},{2,2},{1,1}};\n    for(auto& p: m) std::cout << p.first << ' ' << p.second << '\\n';\n \n    // custom comparison\n    std::multimap<Point, double, PointCmp> mag{\n        { {5, 12}, 13 },\n        { {3, 4}, 5 },\n        { {8, 15}, 17 },\n        { {3, -3}, -1 },\n    };\n \n  for(auto p : mag)\n      std::cout << \"The magnitude of (\" << p.first.x\n                << \", \" << p.first.y << \") is \"\n                << p.second << '\\n';\n}",
            "output": "1 1\n1 1\n2 2\n2 2\n3 3\n3 3\n4 4\n4 4\n5 5\nThe magnitude of (3, 4) is 5\nThe magnitude of (3, -3) is -1\nThe magnitude of (5, 12) is 13\nThe magnitude of (8, 15) is 17"
        }
    },
    "unordered_set::unordered_set": {
        "description": {
            "texte": "Constructs new container from a variety of data sources. Optionally uses user supplied bucket_count as a minimal number of buckets to create, hash as the hash function, equal as the function to compare keys and alloc as the allocator."
        },
        "parametres": "   alloc   -   allocator to use for all memory allocations of this container \n   bucket_count   -   minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used \n   hash   -   hash function to use \n   equal   -   comparison function to use for all key comparisons of this container \n   first, last   -   the range to copy the elements from \n   other   -   another container to be used as source to initialize the elements of the container with \n   init   -   initializer list to initialize the elements of the container with \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n"
    },
    "unordered_multiset::unordered_multiset": {
        "description": {
            "texte": "Constructs new container from a variety of data sources. Optionally uses user supplied bucket_count as a minimal number of buckets to create, hash as the hash function, equal as the function to compare keys and alloc as the allocator."
        },
        "parametres": "   alloc   -   allocator to use for all memory allocations of this container \n   bucket_count   -   minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used \n   hash   -   hash function to use \n   equal   -   comparison function to use for all key comparisons of this container \n   first, last   -   the range to copy the elements from \n   other   -   another container to be used as source to initialize the elements of the container with \n   init   -   initializer list to initialize the elements of the container with \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n"
    },
    "unordered_map::unordered_map": {
        "description": {
            "texte": "Constructs new container from a variety of data sources. Optionally uses user supplied bucket_count as a minimal number of buckets to create, hash as the hash function, equal as the function to compare keys and alloc as the allocator."
        },
        "parametres": "   alloc   -   allocator to use for all memory allocations of this container \n   bucket_count   -   minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used \n   hash   -   hash function to use \n   equal   -   comparison function to use for all key comparisons of this container \n   first, last   -   the range to copy the elements from \n   other   -   another container to be used as source to initialize the elements of the container with \n   init   -   initializer list to initialize the elements of the container with \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n",
        "exemple": {
            "input": "#include <unordered_map>\n#include <vector>\n#include <bitset>\n#include <string>\n#include <utility>\n \nstruct Key {\n    std::string first;\n    std::string second;\n};\n \nstruct KeyHash {\n std::size_t operator()(const Key& k) const\n {\n     return std::hash<std::string>()(k.first) ^\n            (std::hash<std::string>()(k.second) << 1);\n }\n};\n \nstruct KeyEqual {\n bool operator()(const Key& lhs, const Key& rhs) const\n {\n    return lhs.first == rhs.first && lhs.second == rhs.second;\n }\n};\n \nstruct Foo {\n    Foo(int val_) : val(val_) {}\n    int val;\n    bool operator==(const Foo &rhs) const { return val == rhs.val; }\n};\n \nnamespace std {\n    template<> struct hash<Foo> {\n        std::size_t operator()(const Foo &f) const {\n            return std::hash<int>{}(f.val);\n        }  \n    };\n}\n \nint main()\n{\n    // default constructor: empty map\n    std::unordered_map<std::string, std::string> m1;\n \n    // list constructor\n    std::unordered_map<int, std::string> m2 =\n    {\n        {1, \"foo\"},\n        {3, \"bar\"},\n        {2, \"baz\"},\n    };\n \n    // copy constructor\n    std::unordered_map<int, std::string> m3 = m2;\n \n    // move constructor\n    std::unordered_map<int, std::string> m4 = std::move(m2);\n \n    // range constructor\n    std::vector<std::pair<std::bitset<8>, int>> v = { {0x12, 1}, {0x01,-1} };\n    std::unordered_map<std::bitset<8>, double> m5(v.begin(), v.end());\n \n    //Option 1 for a constructor with a custom Key type\n    // Define the KeyHash and KeyEqual structs and use them in the template\n    std::unordered_map<Key, std::string, KeyHash, KeyEqual> m6 = {\n            { {\"John\", \"Doe\"}, \"example\"},\n            { {\"Mary\", \"Sue\"}, \"another\"}\n    };\n \n    //Option 2 for a constructor with a custom Key type\n    // Define a const == operator for the class/struct and specialize std::hash\n    // structure in the std namespace\n    std::unordered_map<Foo, std::string> m7 = {\n        { Foo(1), \"One\"}, { 2, \"Two\"}, { 3, \"Three\"}\n    };\n \n    //Option 3: Use lambdas\n    // Note that the initial bucket count has to be passed to the constructor\n    struct Goo {int val; };\n    auto hash = [](const Goo &g){ return std::hash<int>{}(g.val); };\n    auto comp = [](const Goo &l, const Goo &r){ return l.val == r.val; };\n    std::unordered_map<Goo, double, decltype(hash), decltype(comp)> m8(10, hash, comp);\n}"
        }
    },
    "unordered_multimap::unordered_multimap": {
        "description": {
            "texte": "Constructs new container from a variety of data sources. Optionally uses user supplied bucket_count as a minimal number of buckets to create, hash as the hash function, equal as the function to compare keys and alloc as the allocator."
        },
        "parametres": "   alloc   -   allocator to use for all memory allocations of this container \n   bucket_count   -   minimal number of buckets to use on initialization. If it is not specified, implementation-defined default value is used \n   hash   -   hash function to use \n   equal   -   comparison function to use for all key comparisons of this container \n   first, last   -   the range to copy the elements from \n   other   -   another container to be used as source to initialize the elements of the container with \n   init   -   initializer list to initialize the elements of the container with \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n"
    },
    "stack::stack": {
        "description": {
            "texte": "Constructs new underlying container of the container adaptor from a variety of data sources."
        },
        "parametres": "   alloc   -   allocator to use for all memory allocations of the underlying container \n   other   -   another container adaptor to be used as source to initialize the underlying container \n   cont   -   container to be used as source to initialize the underlying container \n   first, last   -   range of elements to initialize with \n   Type requirements \n   -Alloc must meet the requirements of Allocator. \n   -Container must meet the requirements of Container. The constructors (5-10) are only defined if Container meets the requirements of AllocatorAwareContainer \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n",
        "exemple": {
            "input": "#include <stack>\n#include <deque>\n#include <iostream>\n \nint main()\n{\n    std::stack<int> c1;\n    c1.push(5);\n    std::cout << c1.size() << '\\n';\n \n    std::stack<int> c2(c1);\n    std::cout << c2.size() << '\\n';\n \n    std::deque<int> deq {3, 1, 4, 1, 5};\n    std::stack<int> c3(deq);\n    std::cout << c3.size() << '\\n';\n}",
            "output": "1\n1\n5"
        }
    },
    "queue::queue": {
        "description": {
            "texte": "Constructs new underlying container of the container adaptor from a variety of data sources."
        },
        "parametres": "   alloc   -   allocator to use for all memory allocations of the underlying container \n   other   -   another container adaptor to be used as source to initialize the underlying container \n   cont   -   container to be used as source to initialize the underlying container \n   first, last   -   range of elements to initialize with \n   Type requirements \n   -Alloc must meet the requirements of Allocator. \n   -Container must meet the requirements of Container. The constructors (5-10) are only defined if Container meets the requirements of AllocatorAwareContainer \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n",
        "exemple": {
            "input": "#include <queue>\n#include <deque>\n#include <iostream>\n \nint main()\n{\n    std::queue<int> c1;\n    c1.push(5);\n    std::cout << c1.size() << '\\n';\n \n    std::queue<int> c2(c1);\n    std::cout << c2.size() << '\\n';\n \n    std::deque<int> deq {3, 1, 4, 1, 5};\n    std::queue<int> c3(deq);\n    std::cout << c3.size() << '\\n';\n}",
            "output": "1\n1\n5"
        }
    },
    "priority_queue::priority_queue": {
        "description": {
            "texte": "Constructs new underlying container of the container adaptor from a variety of data sources."
        },
        "parametres": "   alloc   -   allocator to use for all memory allocations of the underlying container \n   other   -   another container adaptor to be used as source to initialize the underlying container \n   cont   -   container to be used as source to initialize the underlying container \n   compare   -   the comparison function object to initialize the underlying comparison functor \n   first, last   -   range of elements to initialize with \n   Type requirements \n   -Alloc must meet the requirements of Allocator. \n   -Container must meet the requirements of Container. The constructors (5-10) are only defined if Container meets the requirements of AllocatorAwareContainer \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n",
        "exemple": {
            "input": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\n \nint main()\n{\n    std::priority_queue<int> c1;\n    c1.push(5);\n    std::cout << c1.size() << '\\n';\n \n    std::priority_queue<int> c2(c1);\n    std::cout << c2.size() << '\\n';\n \n    std::vector<int> vec={3, 1, 4, 1, 5};\n    std::priority_queue<int> c3(std::less<int>(), vec);\n    std::cout << c3.size() << '\\n';\n}",
            "output": "1\n1\n5"
        }
    },
    "vector::~vector": {
        "description": {
            "texte": "Destructs the container. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed."
        }
    },
    "deque::~deque": {
        "description": {
            "texte": "Destructs the container. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed."
        }
    },
    "forward_list::~forward_list": {
        "description": {
            "texte": "Destructs the container. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed."
        }
    },
    "list::~list": {
        "description": {
            "texte": "Destructs the container. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed."
        }
    },
    "set::~set": {
        "description": {
            "texte": "Destructs the container. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed."
        }
    },
    "multiset::~multiset": {
        "description": {
            "texte": "Destructs the container. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed."
        }
    },
    "map::~map": {
        "description": {
            "texte": "Destructs the container. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed."
        }
    },
    "multimap::~multimap": {
        "description": {
            "texte": "Destructs the container. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed."
        }
    },
    "unordered_set::~unordered_set": {
        "description": {
            "texte": "Destructs the container. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed."
        }
    },
    "unordered_multiset::~unordered_multiset": {
        "description": {
            "texte": "Destructs the container. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed."
        }
    },
    "unordered_map::~unordered_map": {
        "description": {
            "texte": "Destructs the container. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed."
        }
    },
    "unordered_multimap::~unordered_multimap": {
        "description": {
            "texte": "Destructs the container. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed."
        }
    },
    "stack::~stack": {
        "description": {
            "texte": "Destructs the container adaptor. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed."
        }
    },
    "queue::~queue": {
        "description": {
            "texte": "Destructs the container adaptor. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed."
        }
    },
    "priority_queue::~priority_queue": {
        "description": {
            "texte": "Destructs the container adaptor. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed."
        }
    },
    "vector::operator=": {
        "description": {
            "texte": "Replaces the contents of the container."
        },
        "parametres": "   other   -   another container to use as data source \n   ilist   -   initializer list to use as data source \n\n",
        "exemple": {
            "input": "#include <vector>\n#include <iostream>\n \nvoid display_sizes(const std::vector<int>& nums1,\n                   const std::vector<int>& nums2,\n                   const std::vector<int>& nums3)\n{\n    std::cout << \" nums1: \" << nums1.size() \n              << \" nums2: \" << nums2.size()\n              << \" nums3: \" << nums3.size() << '\\n';\n}\n \nint main()\n{\n    std::vector<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::vector<int> nums2; \n    std::vector<int> nums3;\n \n    std::cout << \"Initially:\\n\";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << \"After assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << \"After move assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n}",
            "output": "Initially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6"
        }
    },
    "deque::operator=": {
        "description": {
            "texte": "Replaces the contents of the container."
        },
        "parametres": "   other   -   another container to use as data source \n   ilist   -   initializer list to use as data source \n\n",
        "exemple": {
            "input": "#include <deque>\n#include <iostream>\n \nvoid display_sizes(const std::deque<int>& nums1,\n                   const std::deque<int>& nums2,\n                   const std::deque<int>& nums3)\n{\n    std::cout << \"nums1: \" << nums1.size() \n              << \" nums2: \" << nums2.size()\n              << \" nums3: \" << nums3.size() << '\\n';\n}\n \nint main()\n{\n    std::deque<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::deque<int> nums2; \n    std::deque<int> nums3;\n \n    std::cout << \"Initially:\\n\";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << \"After assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << \"After move assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n}",
            "output": "Initially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6"
        }
    },
    "forward_list::operator=": {
        "description": {
            "texte": "Replaces the contents of the container."
        },
        "parametres": "   other   -   another container to use as data source \n   ilist   -   initializer list to use as data source \n\n",
        "exemple": {
            "input": "#include <forward_list>\n#include <iostream>\n \nvoid display_sizes(const std::forward_list<int> &nums1,\n                   const std::forward_list<int> &nums2,\n                   const std::forward_list<int> &nums3)\n{\n    std::cout << \"nums1: \" << std::distance(nums1.begin(), nums1.end()) \n              << \" nums2: \" << std::distance(nums2.begin(), nums2.end())\n              << \" nums3: \" << std::distance(nums3.begin(), nums3.end()) << '\\n';\n}\n \nint main()\n{\n    std::forward_list<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::forward_list<int> nums2; \n    std::forward_list<int> nums3;\n \n    std::cout << \"Initially:\\n\";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << \"After assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << \"After move assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n}",
            "output": "Initially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6"
        }
    },
    "list::operator=": {
        "description": {
            "texte": "Replaces the contents of the container."
        },
        "parametres": "   other   -   another container to use as data source \n   ilist   -   initializer list to use as data source \n\n",
        "exemple": {
            "input": "#include <list>\n#include <iostream>\n \nvoid display_sizes(const std::list<int>& nums1,\n                   const std::list<int>& nums2,\n                   const std::list<int>& nums3)\n{\n    std::cout << \"nums1: \" << nums1.size() \n              << \" nums2: \" << nums2.size()\n              << \" nums3: \" << nums3.size() << '\\n';\n}\n \nint main()\n{\n    std::list<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::list<int> nums2; \n    std::list<int> nums3;\n \n    std::cout << \"Initially:\\n\";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << \"After assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << \"After move assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n}",
            "output": "Initially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6"
        }
    },
    "set::operator=": {
        "description": {
            "texte": "Replaces the contents of the container."
        },
        "parametres": "   other   -   another container to use as data source \n   ilist   -   initializer list to use as data source \n\n",
        "exemple": {
            "input": "#include <set>\n#include <iostream>\n \nvoid display_sizes(const std::set<int> &nums1,\n                   const std::set<int> &nums2,\n                   const std::set<int> &nums3)\n{\n    std::cout << \"nums1: \" << nums1.size() \n              << \" nums2: \" << nums2.size()\n              << \" nums3: \" << nums3.size() << '\\n';\n}\n \nint main()\n{\n    std::set<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::set<int> nums2; \n    std::set<int> nums3;\n \n    std::cout << \"Initially:\\n\";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << \"After assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << \"After move assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n}",
            "output": "Initially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6"
        }
    },
    "multiset::operator=": {
        "description": {
            "texte": "Replaces the contents of the container."
        },
        "parametres": "   other   -   another container to use as data source \n   ilist   -   initializer list to use as data source \n\n",
        "exemple": {
            "input": "#include <set>\n#include <iostream>\n \nvoid display_sizes(const std::multiset<int> &nums1,\n                   const std::multiset<int> &nums2,\n                   const std::multiset<int> &nums3)\n{\n    std::cout << \"nums1: \" << nums1.size() \n              << \" nums2: \" << nums2.size()\n              << \" nums3: \" << nums3.size() << '\\n';\n}\n \nint main()\n{\n    std::multiset<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::multiset<int> nums2; \n    std::multiset<int> nums3;\n \n    std::cout << \"Initially:\\n\";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << \"After assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << \"After move assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n}",
            "output": "Initially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6"
        }
    },
    "map::operator=": {
        "description": {
            "texte": "Replaces the contents of the container."
        },
        "parametres": "   other   -   another container to use as data source \n   ilist   -   initializer list to use as data source \n\n",
        "exemple": {
            "input": "#include <map>\n#include <iostream>\n \nvoid display_sizes(const std::map<int, int> &nums1,\n                   const std::map<int, int> &nums2,\n                   const std::map<int, int> &nums3)\n{\n    std::cout << \"nums1: \" << nums1.size() \n              << \" nums2: \" << nums2.size()\n              << \" nums3: \" << nums3.size() << '\\n';\n}\n \nint main()\n{\n    std::map<int, int> nums1 {{3, 1}, {4, 1}, {5, 9}, \n                              {6, 1}, {7, 1}, {8, 9}};\n    std::map<int, int> nums2; \n    std::map<int, int> nums3;\n \n    std::cout << \"Initially:\\n\";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << \"After assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << \"After move assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n}",
            "output": "Initially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6"
        }
    },
    "multimap::operator=": {
        "description": {
            "texte": "Replaces the contents of the container."
        },
        "parametres": "   other   -   another container to use as data source \n   ilist   -   initializer list to use as data source \n\n",
        "exemple": {
            "input": "#include <map>\n#include <iostream>\n \nvoid display_sizes(const std::multimap<int, int> &nums1,\n                   const std::multimap<int, int> &nums2,\n                   const std::multimap<int, int> &nums3)\n{\n    std::cout << \"nums1: \" << nums1.size() \n              << \" nums2: \" << nums2.size()\n              << \" nums3: \" << nums3.size() << '\\n';\n}\n \nint main()\n{\n    std::multimap<int, int> nums1 {{3, 1}, {4, 1}, {5, 9}, \n                                   {6, 1}, {7, 1}, {8, 9}};\n    std::multimap<int, int> nums2; \n    std::multimap<int, int> nums3;\n \n    std::cout << \"Initially:\\n\";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << \"After assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << \"After move assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n}",
            "output": "Initially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6"
        }
    },
    "unordered_set::operator=": {
        "description": {
            "texte": "Replaces the contents of the container."
        },
        "parametres": "   other   -   another container to use as data source \n   ilist   -   initializer list to use as data source \n\n",
        "exemple": {
            "input": "#include <unordered_set>\n#include <iostream>\n \nvoid display_sizes(const std::unordered_set<int> &nums1,\n                   const std::unordered_set<int> &nums2,\n                   const std::unordered_set<int> &nums3)\n{\n    std::cout << \"nums1: \" << nums1.size() \n              << \" nums2: \" << nums2.size()\n              << \" nums3: \" << nums3.size() << '\\n';\n}\n \nint main()\n{\n    std::unordered_set<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::unordered_set<int> nums2; \n    std::unordered_set<int> nums3;\n \n    std::cout << \"Initially:\\n\";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << \"After assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << \"After move assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n}",
            "output": "Initially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6"
        }
    },
    "unordered_multiset::operator=": {
        "description": {
            "texte": "Replaces the contents of the container."
        },
        "parametres": "   other   -   another container to use as data source \n   ilist   -   initializer list to use as data source \n\n",
        "exemple": {
            "input": "#include <unordered_set>\n#include <iostream>\n \nvoid display_sizes(const std::unordered_multiset<int> &nums1,\n                   const std::unordered_multiset<int> &nums2,\n                   const std::unordered_multiset<int> &nums3)\n{\n    std::cout << \"nums1: \" << nums1.size() \n              << \" nums2: \" << nums2.size()\n              << \" nums3: \" << nums3.size() << '\\n';\n}\n \nint main()\n{\n    std::unordered_multiset<int> nums1 {3, 1, 4, 6, 5, 9};\n    std::unordered_multiset<int> nums2; \n    std::unordered_multiset<int> nums3;\n \n    std::cout << \"Initially:\\n\";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << \"After assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << \"After move assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n}",
            "output": "Initially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6"
        }
    },
    "unordered_map::operator=": {
        "description": {
            "texte": "Replaces the contents of the container."
        },
        "parametres": "   other   -   another container to use as data source \n   ilist   -   initializer list to use as data source \n\n",
        "exemple": {
            "input": "#include <unordered_map>\n#include <iostream>\n \nvoid display_sizes(const std::unordered_map<int, int> &nums1,\n                   const std::unordered_map<int, int> &nums2,\n                   const std::unordered_map<int, int> &nums3)\n{\n    std::cout << \"nums1: \" << nums1.size() \n              << \" nums2: \" << nums2.size()\n              << \" nums3: \" << nums3.size() << '\\n';\n}\n \nint main()\n{\n    std::unordered_map<int, int> nums1 {{3, 1}, {4, 1}, {5, 9}, \n                                        {6, 1}, {7, 1}, {8, 9}};\n    std::unordered_map<int, int> nums2; \n    std::unordered_map<int, int> nums3;\n \n    std::cout << \"Initially:\\n\";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << \"After assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << \"After move assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n}",
            "output": "Initially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6"
        }
    },
    "unordered_multimap::operator=": {
        "description": {
            "texte": "Replaces the contents of the container."
        },
        "parametres": "   other   -   another container to use as data source \n   ilist   -   initializer list to use as data source \n\n",
        "exemple": {
            "input": "#include <unordered_map>\n#include <iostream>\n \nvoid display_sizes(const std::unordered_multimap<int, int> &nums1,\n                   const std::unordered_multimap<int, int> &nums2,\n                   const std::unordered_multimap<int, int> &nums3)\n{\n    std::cout << \"nums1: \" << nums1.size() \n              << \" nums2: \" << nums2.size()\n              << \" nums3: \" << nums3.size() << '\\n';\n}\n \nint main()\n{\n    std::unordered_multimap<int, int> nums1 {{3, 1}, {4, 1}, {5, 9}, \n                                   {6, 1}, {7, 1}, {8, 9}};\n    std::unordered_multimap<int, int> nums2; \n    std::unordered_multimap<int, int> nums3;\n \n    std::cout << \"Initially:\\n\";\n    display_sizes(nums1, nums2, nums3);\n \n    // copy assignment copies data from nums1 to nums2\n    nums2 = nums1;\n \n    std::cout << \"After assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n \n    // move assignment moves data from nums1 to nums3,\n    // modifying both nums1 and nums3\n    nums3 = std::move(nums1);\n \n    std::cout << \"After move assigment:\\n\"; \n    display_sizes(nums1, nums2, nums3);\n}",
            "output": "Initially:\nnums1: 6 nums2: 0 nums3: 0\nAfter assigment:\nnums1: 6 nums2: 6 nums3: 0\nAfter move assigment:\nnums1: 0 nums2: 6 nums3: 6"
        }
    },
    "stack::operator=": {
        "description": {
            "texte": "Replaces the contents of the container adaptor with those of other."
        },
        "parametres": "   other   -   another container adaptor to be used as source \n\n"
    },
    "queue::operator=": {
        "description": {
            "texte": "Replaces the contents of the container adaptor with those of other."
        },
        "parametres": "   other   -   another container adaptor to be used as source \n\n"
    },
    "priority_queue::operator=": {
        "description": {
            "texte": "Replaces the contents of the container adaptor with those of other."
        },
        "parametres": "   other   -   another container adaptor to be used as source \n\n"
    },
    "vector::assign": {
        "description": {
            "texte": "Replaces the contents of the container.All iterators, pointers and references to the elements of the container are invalidated. The past-the-end iterator is also invalidated."
        },
        "parametres": "   count   -   the new size of the container \n   value   -   the value to initialize elements of the container with \n   first, last   -   the range to copy the elements from \n   ilist   -   initializer list to copy the values from \n\n",
        "exemple": {
            "input": "#include <vector>\n#include <iostream>\n \nint main()\n{\n    std::vector<char> characters;\n \n    characters.assign(5, 'a');\n \n    for (char c : characters) {\n        std::cout << c << '\\n';\n    } \n \n    return 0;\n}",
            "output": "a\na\na\na\na"
        }
    },
    "deque::assign": {
        "description": {
            "texte": "Replaces the contents of the container.All iterators, pointers and references to the elements of the container are invalidated. The past-the-end iterator is also invalidated."
        },
        "parametres": "   count   -   the new size of the container \n   value   -   the value to initialize elements of the container with \n   first, last   -   the range to copy the elements from \n   ilist   -   initializer list to copy the values from \n\n",
        "exemple": {
            "input": "#include <deque>\n#include <iostream>\n \nint main()\n{\n    std::deque<char> characters;\n \n    characters.assign(5, 'a');\n \n    for (char c : characters) {\n        std::cout << c << '\\n';\n    } \n \n    return 0;\n}",
            "output": "a\na\na\na\na"
        }
    },
    "forward_list::assign": {
        "description": {
            "texte": "Replaces the contents of the container.All iterators, pointers and references to the elements of the container are invalidated."
        },
        "parametres": "   count   -   the new size of the container \n   value   -   the value to initialize elements of the container with \n   first, last   -   the range to copy the elements from \n   ilist   -   initializer list to copy the values from \n\n",
        "exemple": {
            "input": "#include <forward_list>\n#include <iostream>\n \nint main()\n{\n    std::forward_list<char> characters;\n \n    characters.assign(5, 'a');\n \n    for (char c : characters) {\n        std::cout << c << '\\n';\n    } \n \n    return 0;\n}",
            "output": "a\na\na\na\na"
        }
    },
    "list::assign": {
        "description": {
            "texte": "Replaces the contents of the container.All iterators, pointers and references to the elements of the container are invalidated."
        },
        "parametres": "   count   -   the new size of the container \n   value   -   the value to initialize elements of the container with \n   first, last   -   the range to copy the elements from \n   ilist   -   initializer list to copy the values from \n\n",
        "exemple": {
            "input": "#include <list>\n#include <iostream>\n \nint main()\n{\n    std::list<char> characters;\n \n    characters.assign(5, 'a');\n \n    for (char c : characters) {\n        std::cout << c << '\\n';\n    } \n \n    return 0;\n}",
            "output": "a\na\na\na\na"
        }
    },
    "array::begin, std::array::cbegin": {
        "description": {
            "texte": "Returns an iterator to the first element of the container.If the container is empty, the returned iterator will be equal to end()."
        }
    },
    "vector::begin, std::vector::cbegin": {
        "description": {
            "texte": "Returns an iterator to the first element of the container.If the container is empty, the returned iterator will be equal to end()."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <string>\n \nint main()\n{\n        std::vector<int> ints {1, 2, 4, 8, 16};\n        std::vector<std::string> fruits {\"orange\", \"apple\", \"raspberry\"};\n        std::vector<char> empty;\n \n        // Sums all integers in the vector ints (if any), printing only the result.\n        int sum = 0;\n        for (auto it = ints.cbegin(); it != ints.cend(); it++)\n                sum += *it;\n        std::cout << \"Sum of ints: \" << sum << \"\\n\";\n \n        // Prints the first fruit in the vector fruits, without checking if there is one.\n        std::cout << \"First fruit: \" << *fruits.begin() << \"\\n\";\n \n        if (empty.begin() == empty.end())\n                std::cout << \"vector 'empty' is indeed empty.\\n\";\n}",
            "output": "Sum of ints: 31\nFirst fruit: orange\nvector 'empty' is indeed empty."
        }
    },
    "deque::begin, std::deque::cbegin": {
        "description": {
            "texte": "Returns an iterator to the first element of the container.If the container is empty, the returned iterator will be equal to end()."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <deque>\n#include <string>\n \nint main()\n{\n        std::deque<int> ints {1, 2, 4, 8, 16};\n        std::deque<std::string> fruits {\"orange\", \"apple\", \"raspberry\"};\n        std::deque<char> empty;\n \n        // Sums all integers in the deque ints (if any), printing only the result.\n        int sum = 0;\n        for (auto it = ints.cbegin(); it != ints.cend(); it++)\n                sum += *it;\n        std::cout << \"Sum of ints: \" << sum << \"\\n\";\n \n        // Prints the first fruit in the deque fruits, without checking if there is one.\n        std::cout << \"First fruit: \" << *fruits.begin() << \"\\n\";\n \n        if (empty.begin() == empty.end())\n                std::cout << \"deque 'empty' is indeed empty.\\n\";\n}",
            "output": "Sum of ints: 31\nFirst fruit: orange\ndeque 'empty' is indeed empty."
        }
    },
    "forward_list::begin, std::forward_list::cbegin": {
        "description": {
            "texte": "Returns an iterator to the first element of the container.If the container is empty, the returned iterator will be equal to end()."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <forward_list>\n#include <string>\n \nint main()\n{\n        std::forward_list<int> ints {1, 2, 4, 8, 16};\n        std::forward_list<std::string> fruits {\"orange\", \"apple\", \"raspberry\"};\n        std::forward_list<char> empty;\n \n        // Sums all integers in the forward_list ints (if any), printing only the result.\n        int sum = 0;\n        for (auto it = ints.cbegin(); it != ints.cend(); it++)\n                sum += *it;\n        std::cout << \"Sum of ints: \" << sum << \"\\n\";\n \n        // Prints the first fruit in the forward_list fruits, without checking if there is one.\n        std::cout << \"First fruit: \" << *fruits.begin() << \"\\n\";\n \n        if (empty.begin() == empty.end())\n                std::cout << \"forward_list 'empty' is indeed empty.\\n\";\n}",
            "output": "Sum of ints: 31\nFirst fruit: orange\nforward_list 'empty' is indeed empty."
        }
    },
    "list::begin, std::list::cbegin": {
        "description": {
            "texte": "Returns an iterator to the first element of the container.If the container is empty, the returned iterator will be equal to end()."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <list>\n#include <string>\n \nint main()\n{\n        std::list<int> ints {1, 2, 4, 8, 16};\n        std::list<std::string> fruits {\"orange\", \"apple\", \"raspberry\"};\n        std::list<char> empty;\n \n        // Sums all integers in the list ints (if any), printing only the result.\n        int sum = 0;\n        for (auto it = ints.cbegin(); it != ints.cend(); it++)\n                sum += *it;\n        std::cout << \"Sum of ints: \" << sum << \"\\n\";\n \n        // Prints the first fruit in the list fruits, without checking if there is one.\n        std::cout << \"First fruit: \" << *fruits.begin() << \"\\n\";\n \n        if (empty.begin() == empty.end())\n                std::cout << \"list 'empty' is indeed empty.\\n\";\n}",
            "output": "Sum of ints: 31\nFirst fruit: orange\nlist 'empty' is indeed empty."
        }
    },
    "set::begin, std::set::cbegin": {
        "description": {
            "texte": "Returns an iterator to the first element of the container.If the container is empty, the returned iterator will be equal to end()."
        }
    },
    "multiset::begin, std::multiset::cbegin": {
        "description": {
            "texte": "Returns an iterator to the first element of the container.If the container is empty, the returned iterator will be equal to end()."
        }
    },
    "map::begin, std::map::cbegin": {
        "description": {
            "texte": "Returns an iterator to the first element of the container.If the container is empty, the returned iterator will be equal to end()."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <map>\n \nint main() {\n  std::map<int, float> num_map;\n  num_map[4] = 4.13;\n  num_map[9] = 9.24;\n  num_map[1] = 1.09;\n  // calls a_map.begin() and a_map.end()\n  for (auto it = num_map.begin(); it != num_map.end(); ++it) {\n    std::cout << it->first << \", \" << it->second << '\\n';\n  }\n}",
            "output": "1, 1.09\n4, 4.13\n9, 9.24"
        }
    },
    "multimap::begin, std::multimap::cbegin": {
        "description": {
            "texte": "Returns an iterator to the first element of the container.If the container is empty, the returned iterator will be equal to end()."
        }
    },
    "unordered_set::begin, std::unordered_set::cbegin": {
        "description": {
            "texte": "Returns an iterator to the first element of the container.If the container is empty, the returned iterator will be equal to end()."
        }
    },
    "unordered_multiset::begin, std::unordered_multiset::cbegin": {
        "description": {
            "texte": "Returns an iterator to the first element of the container.If the container is empty, the returned iterator will be equal to end()."
        }
    },
    "unordered_map::begin, std::unordered_map::cbegin": {
        "description": {
            "texte": "Returns an iterator to the first element of the container.If the container is empty, the returned iterator will be equal to end()."
        }
    },
    "unordered_multimap::begin, std::unordered_multimap::cbegin": {
        "description": {
            "texte": "Returns an iterator to the first element of the container.If the container is empty, the returned iterator will be equal to end()."
        }
    },
    "array::end, std::array::cend": {
        "description": {
            "texte": "Returns an iterator to the element following the last element of the container.This element acts as a placeholder; attempting to access it results in undefined behavior."
        }
    },
    "forward_list::end, std::forward_list::cend": {
        "description": {
            "texte": "Returns an iterator to the element following the last element of the container.This element acts as a placeholder; attempting to access it results in undefined behavior."
        }
    },
    "list::end, std::list::cend": {
        "description": {
            "texte": "Returns an iterator to the element following the last element of the container.This element acts as a placeholder; attempting to access it results in undefined behavior."
        }
    },
    "multiset::end, std::multiset::cend": {
        "description": {
            "texte": "Returns an iterator to the element following the last element of the container.This element acts as a placeholder; attempting to access it results in undefined behavior."
        }
    },
    "map::end, std::map::cend": {
        "description": {
            "texte": "Returns an iterator to the element following the last element of the container.This element acts as a placeholder; attempting to access it results in undefined behavior."
        }
    },
    "multimap::end, std::multimap::cend": {
        "description": {
            "texte": "Returns an iterator to the element following the last element of the container.This element acts as a placeholder; attempting to access it results in undefined behavior."
        }
    },
    "unordered_multiset::end, std::unordered_multiset::cend": {
        "description": {
            "texte": "Returns an iterator to the element following the last element of the container.This element acts as a placeholder; attempting to access it results in undefined behavior."
        }
    },
    "unordered_map::end, std::unordered_map::cend": {
        "description": {
            "texte": "Returns an iterator to the element following the last element of the container.This element acts as a placeholder; attempting to access it results in undefined behavior."
        }
    },
    "unordered_multimap::end, std::unordered_multimap::cend": {
        "description": {
            "texte": "Returns an iterator to the element following the last element of the container.This element acts as a placeholder; attempting to access it results in undefined behavior."
        }
    },
    "array::rbegin, std::array::crbegin": {
        "description": {
            "texte": "Returns a reverse iterator to the first element of the reversed container. It corresponds to the last element of the non-reversed container. If the container is empty, the returned iterator is equal to rend()."
        }
    },
    "vector::rbegin, std::vector::crbegin": {
        "description": {
            "texte": "Returns a reverse iterator to the first element of the reversed container. It corresponds to the last element of the non-reversed container. If the container is empty, the returned iterator is equal to rend()."
        }
    },
    "deque::rbegin, std::deque::crbegin": {
        "description": {
            "texte": "Returns a reverse iterator to the first element of the reversed container. It corresponds to the last element of the non-reversed container. If the container is empty, the returned iterator is equal to rend()."
        }
    },
    "list::rbegin, std::list::crbegin": {
        "description": {
            "texte": "Returns a reverse iterator to the first element of the reversed container. It corresponds to the last element of the non-reversed container. If the container is empty, the returned iterator is equal to rend()."
        }
    },
    "set::rbegin, std::set::crbegin": {
        "description": {
            "texte": "Returns a reverse iterator to the first element of the reversed container. It corresponds to the last element of the non-reversed container. If the container is empty, the returned iterator is equal to rend()."
        }
    },
    "multiset::rbegin, std::multiset::crbegin": {
        "description": {
            "texte": "Returns a reverse iterator to the first element of the reversed container. It corresponds to the last element of the non-reversed container. If the container is empty, the returned iterator is equal to rend()."
        }
    },
    "map::rbegin, std::map::crbegin": {
        "description": {
            "texte": "Returns a reverse iterator to the first element of the reversed container. It corresponds to the last element of the non-reversed container. If the container is empty, the returned iterator is equal to rend()."
        }
    },
    "multimap::rbegin, std::multimap::crbegin": {
        "description": {
            "texte": "Returns a reverse iterator to the first element of the reversed container. It corresponds to the last element of the non-reversed container. If the container is empty, the returned iterator is equal to rend()."
        }
    },
    "array::rend, std::array::crend": {
        "description": {
            "texte": "Returns a reverse iterator to the element following the last element of the reversed container. It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behavior."
        }
    },
    "vector::rend, std::vector::crend": {
        "description": {
            "texte": "Returns a reverse iterator to the element following the last element of the reversed container. It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behavior."
        }
    },
    "deque::rend, std::deque::crend": {
        "description": {
            "texte": "Returns a reverse iterator to the element following the last element of the reversed container. It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behavior."
        }
    },
    "list::rend, std::list::crend": {
        "description": {
            "texte": "Returns a reverse iterator to the element following the last element of the reversed container. It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behavior."
        }
    },
    "set::rend, std::set::crend": {
        "description": {
            "texte": "Returns a reverse iterator to the element following the last element of the reversed container. It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behavior."
        }
    },
    "multiset::rend, std::multiset::crend": {
        "description": {
            "texte": "Returns a reverse iterator to the element following the last element of the reversed container. It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behavior."
        }
    },
    "map::rend, std::map::crend": {
        "description": {
            "texte": "Returns a reverse iterator to the element following the last element of the reversed container. It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behavior."
        }
    },
    "multimap::rend, std::multimap::crend": {
        "description": {
            "texte": "Returns a reverse iterator to the element following the last element of the reversed container. It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behavior."
        }
    },
    "array::at": {
        "description": {
            "texte": "Returns a reference to the element at specified location pos, with bounds checking.If pos is not within the range of the container, an exception of type std::out_of_range is thrown."
        },
        "parametres": "   pos   -   position of the element to return \n\n"
    },
    "vector::at": {
        "description": {
            "texte": "Returns a reference to the element at specified location pos, with bounds checking.If pos is not within the range of the container, an exception of type std::out_of_range is thrown."
        },
        "parametres": "   pos   -   position of the element to return \n\n"
    },
    "deque::at": {
        "description": {
            "texte": "Returns a reference to the element at specified location pos, with bounds checking.If pos is not within the range of the container, an exception of type std::out_of_range is thrown."
        },
        "parametres": "   pos   -   position of the element to return \n\n"
    },
    "map::at": {
        "description": {
            "texte": "Returns a reference to the mapped value of the element with key equivalent to key. If no such element exists, an exception of type std::out_of_range is thrown."
        },
        "parametres": "   key   -   the key of the element to find \n\n"
    },
    "unordered_map::at": {
        "description": {
            "texte": "Returns a reference to the mapped value of the element with key equivalent to key. If no such element exists, an exception of type std::out_of_range is thrown."
        },
        "parametres": "   key   -   the key of the element to find \n\n"
    },
    "array::operator[]": {
        "description": {
            "texte": "Returns a reference to the element at specified location pos. No bounds checking is performed."
        },
        "parametres": "   pos   -   position of the element to return \n\n",
        "exemple": {
            "input": "#include <array>\n#include <iostream>\n \nint main()\n{\n    std::array<int,4> numbers {2, 4, 6, 8};\n \n    std::cout << \"Second element: \" << numbers[1] << '\\n';\n \n    numbers[0] = 5;\n \n    std::cout << \"All numbers:\";\n    for (auto i : numbers) {\n        std::cout << ' ' << i;\n    }\n    std::cout << '\\n';\n}",
            "output": "Second element: 4\nAll numbers: 5 4 6 8"
        }
    },
    "vector::operator[]": {
        "description": {
            "texte": "Returns a reference to the element at specified location pos. No bounds checking is performed."
        },
        "parametres": "   pos   -   position of the element to return \n\n",
        "exemple": {
            "input": "#include <vector>\n#include <iostream>\n \nint main()\n{\n    std::vector<int> numbers {2, 4, 6, 8};\n \n    std::cout << \"Second element: \" << numbers[1] << '\\n';\n \n    numbers[0] = 5;\n \n    std::cout << \"All numbers:\";\n    for (auto i : numbers) {\n        std::cout << ' ' << i;\n    }\n    std::cout << '\\n';\n}",
            "output": "Second element: 4\nAll numbers: 5 4 6 8"
        }
    },
    "deque::operator[]": {
        "description": {
            "texte": "Returns a reference to the element at specified location pos. No bounds checking is performed."
        },
        "parametres": "   pos   -   position of the element to return \n\n",
        "exemple": {
            "input": "#include <deque>\n#include <iostream>\n \nint main()\n{\n    std::deque<int> numbers {2, 4, 6, 8};\n \n    std::cout << \"Second element: \" << numbers[1] << '\\n';\n \n    numbers[0] = 5;\n \n    std::cout << \"All numbers:\";\n    for (auto i : numbers) {\n        std::cout << ' ' << i;\n    }\n    std::cout << '\\n';\n}",
            "output": "Second element: 4\nAll numbers: 5 4 6 8"
        }
    },
    "map::operator[]": {
        "description": {
            "texte": "Returns a reference to the value that is mapped to a key equivalent to key, performing an insertion if such key does not already exist.No iterators or references are invalidated."
        },
        "parametres": "   key   -   the key of the element to find \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n \nint main()\n{\n    std::map<char, int> letter_counts {{'a', 27}, {'b', 3}, {'c', 1}};\n \n    std::cout << \"initially:\\n\";\n    for (const auto &pair : letter_counts) {\n        std::cout << pair.first << \": \" << pair.second << '\\n';\n    }\n \n    letter_counts['b'] = 42;  // update an existing value\n    letter_counts['x'] = 9;  // insert a new value\n \n    std::cout << \"after modifications:\\n\";\n    for (const auto &pair : letter_counts) {\n        std::cout << pair.first << \": \" << pair.second << '\\n';\n    }\n \n    // count the number of occurrences of each word\n    // (the first call to operator[] initialized the counter with zero)\n    std::map<std::string, size_t>  word_map;\n    for (const auto &w : { \"this\", \"sentence\", \"is\", \"not\", \"a\", \"sentence\",\n                           \"this\", \"sentence\", \"is\", \"a\", \"hoax\"}) {\n        ++word_map[w];\n    }\n \n    for (const auto &pair : word_map) {\n        std::cout << pair.second << \" occurrences of word '\" << pair.first << \"'\\n\";\n    }\n}",
            "output": "initially:\na: 27\nb: 3\nc: 1\nafter modifications:\na: 27\nb: 42\nc: 1\nx: 9\n2 occurrences of word 'a'\n1 occurrences of word 'hoax'\n2 occurrences of word 'is'\n1 occurrences of word 'not'\n3 occurrences of word 'sentence'\n2 occurrences of word 'this'"
        }
    },
    "array::data": {
        "description": {
            "texte": "Returns pointer to the underlying array serving as element storage. The pointer is such that range [data(); data() + size()) is always a valid range, even if the container is empty (data() is not dereferenceable in that case)."
        }
    },
    "vector::data": {
        "description": {
            "texte": "Returns pointer to the underlying array serving as element storage. The pointer is such that range [data(); data() + size()) is always a valid range, even if the container is empty (data() is not dereferenceable in that case)."
        }
    },
    "array::front": {
        "description": {
            "texte": "Returns a reference to the first element in the container.Calling front on an empty container is undefined."
        },
        "exemple": {
            "input": "#include <array>\n#include <iostream>\n \nint main()\n{\n    std::array<char, 6> letters {'o', 'm', 'g', 'w', 't', 'f'};\n \n    if (!letters.empty()) {\n        std::cout << \"The first character is: \" << letters.front() << '\\n';\n    }  \n}",
            "output": "The first character is o"
        }
    },
    "vector::front": {
        "description": {
            "texte": "Returns a reference to the first element in the container.Calling front on an empty container is undefined."
        },
        "exemple": {
            "input": "#include <vector>\n#include <iostream>\n \nint main()\n{\n    std::vector<char> letters {'o', 'm', 'g', 'w', 't', 'f'};\n \n    if (!letters.empty()) {\n        std::cout << \"The first character is: \" << letters.front() << '\\n';\n    }  \n}",
            "output": "The first character is o"
        }
    },
    "deque::front": {
        "description": {
            "texte": "Returns a reference to the first element in the container.Calling front on an empty container is undefined."
        },
        "exemple": {
            "input": "#include <deque>\n#include <iostream>\n \nint main()\n{\n    std::deque<char> letters {'o', 'm', 'g', 'w', 't', 'f'};\n \n    if (!letters.empty()) {\n        std::cout << \"The first character is: \" << letters.front() << '\\n';\n    }  \n}",
            "output": "The first character is o"
        }
    },
    "forward_list::front": {
        "description": {
            "texte": "Returns a reference to the first element in the container.Calling front on an empty container is undefined."
        },
        "exemple": {
            "input": "#include <forward_list>\n#include <iostream>\n \nint main()\n{\n    std::forward_list<char> letters {'o', 'm', 'g', 'w', 't', 'f'};\n \n    if (!letters.empty()) {\n        std::cout << \"The first character is: \" << letters.front() << '\\n';\n    }  \n}",
            "output": "The first character is o"
        }
    },
    "list::front": {
        "description": {
            "texte": "Returns a reference to the first element in the container.Calling front on an empty container is undefined."
        },
        "exemple": {
            "input": "#include <list>\n#include <iostream>\n \nint main()\n{\n    std::list<char> letters {'o', 'm', 'g', 'w', 't', 'f'};\n \n    if (!letters.empty()) {\n        std::cout << \"The first character is: \" << letters.front() << '\\n';\n    }  \n}",
            "output": "The first character is o"
        }
    },
    "queue::front": {
        "description": {
            "texte": "Returns reference to the first element in the queue. This element will be the first element to be removed on a call to pop(). Effectively calls c.front()."
        }
    },
    "priority_queue::top": {
        "description": {
            "texte": "Returns reference to the top element in the priority queue. This element will be removed on a call to pop(). If default comparison function is used, the returned element is also the greatest among the elements in the queue."
        }
    },
    "array::back": {
        "description": {
            "texte": "Returns reference to the last element in the container.Calling back on an empty container is undefined."
        },
        "exemple": {
            "input": "#include <array>\n#include <iostream>\n \nint main()\n{\n    std::array<char, 6> letters {'a', 'b', 'c', 'd', 'e', 'f'};\n    if (!letters.empty()) {\n        std::cout << \"The last character is: \" << letters.back() << '\\n';\n    }  \n}",
            "output": "The last character is f"
        }
    },
    "vector::back": {
        "description": {
            "texte": "Returns reference to the last element in the container.Calling back on an empty container is undefined."
        },
        "exemple": {
            "input": "#include <vector>\n#include <iostream>\n \nint main()\n{\n    std::vector<char> letters {'a', 'b', 'c', 'd', 'e', 'f'};\n    if (!letters.empty()) {\n        std::cout << \"The last character is: \" << letters.back() << '\\n';\n    }  \n}",
            "output": "The last character is f"
        }
    },
    "deque::back": {
        "description": {
            "texte": "Returns reference to the last element in the container.Calling back on an empty container is undefined."
        },
        "exemple": {
            "input": "#include <deque>\n#include <iostream>\n \nint main()\n{\n    std::deque<char> letters {'a', 'b', 'c', 'd', 'e', 'f'};\n    if (!letters.empty()) {\n        std::cout << \"The last character is: \" << letters.back() << '\\n';\n    }  \n}",
            "output": "The last character is f"
        }
    },
    "list::back": {
        "description": {
            "texte": "Returns reference to the last element in the container.Calling back on an empty container is undefined."
        },
        "exemple": {
            "input": "#include <list>\n#include <iostream>\n \nint main()\n{\n    std::list<char> letters {'a', 'b', 'c', 'd', 'e', 'f'};\n    if (!letters.empty()) {\n        std::cout << \"The last character is: \" << letters.back() << '\\n';\n    }  \n}",
            "output": "The last character is f"
        }
    },
    "stack::top": {
        "description": {
            "texte": "Returns reference to the top element in the stack. This is the most recently pushed element. This element will be removed on a call to pop(). Effectively calls c.back()."
        },
        "exemple": {
            "input": "#include <stack>\n#include <iostream>\n \nint main()\n{\n    std::stack<int>   s;\n \n    s.push( 2 );\n    s.push( 6 );\n    s.push( 51 );\n \n    std::cout << s.size() << \" elements on stack\\n\";\n    std::cout << \"Top element: \"\n              << s.top()         // Leaves element on stack\n              << \"\\n\";\n    std::cout << s.size() << \" elements on stack\\n\";\n    s.pop();\n    std::cout << s.size() << \" elements on stack\\n\";\n    std::cout << \"Top element: \" << s.top() << \"\\n\";\n \n    return 0;\n}",
            "output": "3 elements on stack\nTop element: 51\n3 elements on stack\n2 elements on stack\nTop element: 6"
        }
    },
    "queue::back": {
        "description": {
            "texte": "Returns reference to the last element in the queue. This is the most recently pushed element. Effectively calls c.back()."
        }
    },
    "array::empty": {
        "description": {
            "texte": "Checks if the container has no elements, i.e. whether begin() == end()."
        },
        "exemple": {
            "input": "#include <array>\n#include <iostream>\n \nint main()\n{\n    std::array<int, 4> numbers {3, 1, 4, 1};\n    std::array<int, 0> no_numbers;\n \n    std::cout << \"numbers.empty(): \" << numbers.empty() << '\\n';\n    std::cout << \"no_numbers.empty(): \" << no_numbers.empty() << '\\n';\n}",
            "output": "numbers.empty(): 0\nno_numbers.empty(): 1"
        }
    },
    "vector::empty": {
        "description": {
            "texte": "Checks if the container has no elements, i.e. whether begin() == end()."
        },
        "exemple": {
            "input": "#include <vector>\n#include <iostream>\n \nint main()\n{\n    std::cout << std::boolalpha;\n    std::vector<int> numbers;\n    std::cout << \"Initially, numbers.empty(): \" << numbers.empty() << '\\n';\n \n    numbers.push_back(42);\n    std::cout << \"After adding elements, numbers.empty(): \" << numbers.empty() << '\\n';\n}",
            "output": "Initially, numbers.empty(): true\nAfter adding elements, numbers.empty(): false"
        }
    },
    "deque::empty": {
        "description": {
            "texte": "Checks if the container has no elements, i.e. whether begin() == end()."
        },
        "exemple": {
            "input": "#include <deque>\n#include <iostream>\n \nint main()\n{\n    std::deque<int> numbers;\n    std::cout << \"Initially, numbers.empty(): \" << numbers.empty() << '\\n';\n \n    numbers.push_back(42);\n    numbers.push_back(13317); \n    std::cout << \"After adding elements, numbers.empty(): \" << numbers.empty() << '\\n';\n}",
            "output": "Initially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0"
        }
    },
    "forward_list::empty": {
        "description": {
            "texte": "Checks if the container has no elements, i.e. whether begin() == end()."
        },
        "exemple": {
            "input": "#include <forward_list>\n#include <iostream>\n \nint main()\n{\n    std::forward_list<int> numbers;\n    std::cout << \"Initially, numbers.empty(): \" << numbers.empty() << '\\n';\n \n    numbers.push_front(42);\n    numbers.push_front(13317); \n    std::cout << \"After adding elements, numbers.empty(): \" << numbers.empty() << '\\n';\n}",
            "output": "Initially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0"
        }
    },
    "list::empty": {
        "description": {
            "texte": "Checks if the container has no elements, i.e. whether begin() == end()."
        },
        "exemple": {
            "input": "#include <list>\n#include <iostream>\n \nint main()\n{\n    std::list<int> numbers;\n    std::cout << \"Initially, numbers.empty(): \" << numbers.empty() << '\\n';\n \n    numbers.push_back(42);\n    numbers.push_back(13317); \n    std::cout << \"After adding elements, numbers.empty(): \" << numbers.empty() << '\\n';\n}",
            "output": "Initially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0"
        }
    },
    "set::empty": {
        "description": {
            "texte": "Checks if the container has no elements, i.e. whether begin() == end()."
        },
        "exemple": {
            "input": "#include <set>\n#include <iostream>\n \nint main()\n{\n    std::set<int> numbers;\n    std::cout << \"Initially, numbers.empty(): \" << numbers.empty() << '\\n';\n \n    numbers.insert(42);\n    numbers.insert(13317); \n    std::cout << \"After adding elements, numbers.empty(): \" << numbers.empty() << '\\n';\n}",
            "output": "Initially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0"
        }
    },
    "multiset::empty": {
        "description": {
            "texte": "Checks if the container has no elements, i.e. whether begin() == end()."
        },
        "exemple": {
            "input": "#include <set>\n#include <iostream>\n \nint main()\n{\n    std::multiset<int> numbers;\n    std::cout << \"Initially, numbers.empty(): \" << numbers.empty() << '\\n';\n \n    numbers.insert(42);\n    numbers.insert(13317); \n    std::cout << \"After adding elements, numbers.empty(): \" << numbers.empty() << '\\n';\n}",
            "output": "Initially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0"
        }
    },
    "map::empty": {
        "description": {
            "texte": "Checks if the container has no elements, i.e. whether begin() == end()."
        },
        "exemple": {
            "input": "#include <map>\n#include <iostream>\n#include <utility>\n \nint main()\n{\n    std::map<int,int> numbers;\n    std::cout << \"Initially, numbers.empty(): \" << numbers.empty() << '\\n';\n \n    numbers.emplace(42, 13);\n    numbers.insert(std::make_pair(13317, 123)); \n    std::cout << \"After adding elements, numbers.empty(): \" << numbers.empty() << '\\n';\n}",
            "output": "Initially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0"
        }
    },
    "multimap::empty": {
        "description": {
            "texte": "Checks if the container has no elements, i.e. whether begin() == end()."
        },
        "exemple": {
            "input": "#include <map>\n#include <iostream>\n#include <utility>\n \nint main()\n{\n    std::multimap<int, int> numbers;\n    std::cout << \"Initially, numbers.empty(): \" << numbers.empty() << '\\n';\n \n    numbers.emplace(42, 13);\n    numbers.insert(std::make_pair(13317, 123));  \n    std::cout << \"After adding elements, numbers.empty(): \" << numbers.empty() << '\\n';\n}",
            "output": "Initially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0"
        }
    },
    "unordered_set::empty": {
        "description": {
            "texte": "Checks if the container has no elements, i.e. whether begin() == end()."
        },
        "exemple": {
            "input": "#include <unordered_set>\n#include <iostream>\n \nint main()\n{\n    std::unordered_set<int> numbers;\n    std::cout << \"Initially, numbers.empty(): \" << numbers.empty() << '\\n';\n \n    numbers.insert(42);\n    numbers.insert(13317); \n    std::cout << \"After adding elements, numbers.empty(): \" << numbers.empty() << '\\n';\n}",
            "output": "Initially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0"
        }
    },
    "unordered_multiset::empty": {
        "description": {
            "texte": "Checks if the container has no elements, i.e. whether begin() == end()."
        },
        "exemple": {
            "input": "#include <unordered_set>\n#include <iostream>\n \nint main()\n{\n    std::unordered_multiset<int> numbers;\n    std::cout << \"Initially, numbers.empty(): \" << numbers.empty() << '\\n';\n \n    numbers.insert(42);\n    numbers.insert(13317); \n    std::cout << \"After adding elements, numbers.empty(): \" << numbers.empty() << '\\n';\n}",
            "output": "Initially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0"
        }
    },
    "unordered_map::empty": {
        "description": {
            "texte": "Checks if the container has no elements, i.e. whether begin() == end()."
        },
        "exemple": {
            "input": "#include <unordered_map>\n#include <iostream>\n#include <utility>\n \nint main()\n{\n    std::unordered_map<int, int> numbers;\n    std::cout << \"Initially, numbers.empty(): \" << numbers.empty() << '\\n';\n \n    numbers.emplace(42, 13);\n    numbers.insert(std::make_pair(13317, 123));  \n    std::cout << \"After adding elements, numbers.empty(): \" << numbers.empty() << '\\n';\n}",
            "output": "Initially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0"
        }
    },
    "unordered_multimap::empty": {
        "description": {
            "texte": "Checks if the container has no elements, i.e. whether begin() == end()."
        },
        "exemple": {
            "input": "#include <unordered_map>\n#include <iostream>\n#include <utility>\n \nint main()\n{\n    std::unordered_multimap<int, int> numbers;\n    std::cout << \"Initially, numbers.empty(): \" << numbers.empty() << '\\n';\n \n    numbers.emplace(42, 13);\n    numbers.insert(std::make_pair(13317, 123)); \n    std::cout << \"After adding elements, numbers.empty(): \" << numbers.empty() << '\\n';\n}",
            "output": "Initially, numbers.empty(): 1\nAfter adding elements, numbers.empty(): 0"
        }
    },
    "stack::empty": {
        "description": {
            "texte": "Checks if the underlying container has no elements, i.e. whether c.empty()."
        }
    },
    "queue::empty": {
        "description": {
            "texte": "Checks if the underlying container has no elements, i.e. whether c.empty()."
        }
    },
    "priority_queue::empty": {
        "description": {
            "texte": "Checks if the underlying container has no elements, i.e. whether c.empty()."
        }
    },
    "array::size": {
        "description": {
            "texte": "Returns the number of elements in the container, i.e. std::distance(begin(), end())."
        },
        "exemple": {
            "input": "#include <array>\n#include <iostream>\n \nint main()\n{ \n    std::array<int, 4> nums {1, 3, 5, 7};\n \n    std::cout << \"nums contains \" << nums.size() << \" elements.\\n\";\n}",
            "output": "nums contains 4 elements."
        }
    },
    "vector::size": {
        "description": {
            "texte": "Returns the number of elements in the container, i.e. std::distance(begin(), end())."
        },
        "exemple": {
            "input": "#include <vector>\n#include <iostream>\n \nint main()\n{ \n    std::vector<int> nums {1, 3, 5, 7};\n \n    std::cout << \"nums contains \" << nums.size() << \" elements.\\n\";\n}",
            "output": "nums contains 4 elements."
        }
    },
    "deque::size": {
        "description": {
            "texte": "Returns the number of elements in the container, i.e. std::distance(begin(), end())."
        },
        "exemple": {
            "input": "#include <deque>\n#include <iostream>\n \nint main()\n{ \n    std::deque<int> nums {1, 3, 5, 7};\n \n    std::cout << \"nums contains \" << nums.size() << \" elements.\\n\";\n}",
            "output": "nums contains 4 elements."
        }
    },
    "list::size": {
        "description": {
            "texte": "Returns the number of elements in the container, i.e. std::distance(begin(), end())."
        },
        "exemple": {
            "input": "#include <list>\n#include <iostream>\n \nint main()\n{ \n    std::list<int> nums {1, 3, 5, 7};\n \n    std::cout << \"nums contains \" << nums.size() << \" elements.\\n\";\n}",
            "output": "nums contains 4 elements."
        }
    },
    "set::size": {
        "description": {
            "texte": "Returns the number of elements in the container, i.e. std::distance(begin(), end())."
        },
        "exemple": {
            "input": "#include <set>\n#include <iostream>\n \nint main()\n{ \n    std::set<int> nums {1, 3, 5, 7};\n \n    std::cout << \"nums contains \" << nums.size() << \" elements.\\n\";\n}",
            "output": "nums contains 4 elements."
        }
    },
    "multiset::size": {
        "description": {
            "texte": "Returns the number of elements in the container, i.e. std::distance(begin(), end())."
        },
        "exemple": {
            "input": "#include <set>\n#include <iostream>\n \nint main()\n{ \n    std::multiset<int> nums {1, 3, 5, 7};\n \n    std::cout << \"nums contains \" << nums.size() << \" elements.\\n\";\n}",
            "output": "nums contains 4 elements."
        }
    },
    "map::size": {
        "description": {
            "texte": "Returns the number of elements in the container, i.e. std::distance(begin(), end())."
        },
        "exemple": {
            "input": "#include <map>\n#include <iostream>\n \nint main()\n{ \n    std::map<int,char> nums {{1, 'a'}, {3, 'b'}, {5, 'c'}, {7, 'd'}};\n \n    std::cout << \"nums contains \" << nums.size() << \" elements.\\n\";\n}",
            "output": "nums contains 4 elements."
        }
    },
    "multimap::size": {
        "description": {
            "texte": "Returns the number of elements in the container, i.e. std::distance(begin(), end())."
        },
        "exemple": {
            "input": "#include <map>\n#include <iostream>\n \nint main()\n{ \n    std::multimap<int,char> nums {{1, 'a'}, {3, 'b'}, {5, 'c'}, {7, 'd'}};\n \n    std::cout << \"nums contains \" << nums.size() << \" elements.\\n\";\n}",
            "output": "nums contains 4 elements."
        }
    },
    "unordered_set::size": {
        "description": {
            "texte": "Returns the number of elements in the container, i.e. std::distance(begin(), end())."
        },
        "exemple": {
            "input": "#include <unordered_set>\n#include <iostream>\n \nint main()\n{ \n    std::unordered_set<int> nums {1, 3, 5, 7};\n \n    std::cout << \"nums contains \" << nums.size() << \" elements.\\n\";\n}",
            "output": "nums contains 4 elements."
        }
    },
    "unordered_multiset::size": {
        "description": {
            "texte": "Returns the number of elements in the container, i.e. std::distance(begin(), end())."
        },
        "exemple": {
            "input": "#include <unordered_set>\n#include <iostream>\n \nint main()\n{ \n    std::unordered_multiset<int> nums {1, 3, 5, 7};\n \n    std::cout << \"nums contains \" << nums.size() << \" elements.\\n\";\n}",
            "output": "nums contains 4 elements."
        }
    },
    "unordered_map::size": {
        "description": {
            "texte": "Returns the number of elements in the container, i.e. std::distance(begin(), end())."
        },
        "exemple": {
            "input": "#include <unordered_map>\n#include <iostream>\n \nint main()\n{ \n    std::unordered_map<int,char> nums {{1, 'a'}, {3, 'b'}, {5, 'c'}, {7, 'd'}};\n \n    std::cout << \"nums contains \" << nums.size() << \" elements.\\n\";\n}",
            "output": "nums contains 4 elements."
        }
    },
    "unordered_multimap::size": {
        "description": {
            "texte": "Returns the number of elements in the container, i.e. std::distance(begin(), end())."
        },
        "exemple": {
            "input": "#include <unordered_map>\n#include <iostream>\n \nint main()\n{ \n    std::unordered_multimap<int,char> nums {{1, 'a'}, {3, 'b'}, {5, 'c'}, {7, 'd'}};\n \n    std::cout << \"nums contains \" << nums.size() << \" elements.\\n\";\n}",
            "output": "nums contains 4 elements."
        }
    },
    "stack::size": {
        "description": {
            "texte": "Returns the number of elements in the underlying container, that is, c.size()."
        }
    },
    "queue::size": {
        "description": {
            "texte": "Returns the number of elements in the underlying container, that is, c.size()."
        }
    },
    "priority_queue::size": {
        "description": {
            "texte": "Returns the number of elements in the underlying container, that is, c.size()."
        }
    },
    "array::max_size": {
        "description": {
            "texte": "Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(begin(), end()) for the largest container."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <array>\n \nint main()\n{\n    std::array<char, 10> s;\n    std::cout << \"Maximum size of a 'array' is \" << s.max_size() << \"\\n\";\n}",
            "output": "Maximum size of a 'array' is 10"
        }
    },
    "vector::max_size": {
        "description": {
            "texte": "Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(begin(), end()) for the largest container."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n \nint main()\n{\n    std::vector<char> s;\n    std::cout << \"Maximum size of a 'vector' is \" << s.max_size() << \"\\n\";\n}",
            "output": "Maximum size of a 'vector' is 9223372036854775807"
        }
    },
    "deque::max_size": {
        "description": {
            "texte": "Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(begin(), end()) for the largest container."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <deque>\n \nint main()\n{\n    std::deque<char> s;\n    std::cout << \"Maximum size of a 'deque' is \" << s.max_size() << \"\\n\";\n}",
            "output": "Maximum size of a 'deque' is 9223372036854775807"
        }
    },
    "forward_list::max_size": {
        "description": {
            "texte": "Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(begin(), end()) for the largest container."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <forward_list>\n \nint main()\n{\n    std::forward_list<char> s;\n    std::cout << \"Maximum size of a 'forward_list' is \" << s.max_size() << \"\\n\";\n}",
            "output": "Maximum size of a 'forward_list' is 1152921504606846975"
        }
    },
    "list::max_size": {
        "description": {
            "texte": "Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(begin(), end()) for the largest container."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <list>\n \nint main()\n{\n    std::list<char> s;\n    std::cout << \"Maximum size of a 'list' is \" << s.max_size() << \"\\n\";\n}",
            "output": "Maximum size of a 'list' is 768614336404564650"
        }
    },
    "set::max_size": {
        "description": {
            "texte": "Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(begin(), end()) for the largest container."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <set>\n \nint main()\n{\n    std::set<char> s;\n    std::cout << \"Maximum size of a 'set' is \" << s.max_size() << \"\\n\";\n}",
            "output": "Maximum size of a 'set' is 576460752303423487"
        }
    },
    "multiset::max_size": {
        "description": {
            "texte": "Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(begin(), end()) for the largest container."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <set>\n \nint main()\n{\n    std::multiset<char> s;\n    std::cout << \"Maximum size of a 'multiset' is \" << s.max_size() << \"\\n\";\n}",
            "output": "Maximum size of a 'multiset' is 576460752303423487"
        }
    },
    "map::max_size": {
        "description": {
            "texte": "Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(begin(), end()) for the largest container."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <map>\n \nint main()\n{\n    std::map<char,char> s;\n    std::cout << \"Maximum size of a 'map' is \" << s.max_size() << \"\\n\";\n}",
            "output": "Maximum size of a 'map' is 576460752303423487"
        }
    },
    "multimap::max_size": {
        "description": {
            "texte": "Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(begin(), end()) for the largest container."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <map>\n \nint main()\n{\n    std::multimap<char,char> s;\n    std::cout << \"Maximum size of a 'multimap' is \" << s.max_size() << \"\\n\";\n}",
            "output": "Maximum size of a 'multimap' is 576460752303423487"
        }
    },
    "unordered_set::max_size": {
        "description": {
            "texte": "Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(begin(), end()) for the largest container."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <unordered_set>\n \nint main()\n{\n    std::unordered_set<char> s;\n    std::cout << \"Maximum size of a 'unordered_set' is \" << s.max_size() << \"\\n\";\n}",
            "output": "Maximum size of a 'unordered_set' is 768614336404564650"
        }
    },
    "unordered_multiset::max_size": {
        "description": {
            "texte": "Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(begin(), end()) for the largest container."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <unordered_set>\n \nint main()\n{\n    std::unordered_multiset<char> s;\n    std::cout << \"Maximum size of a 'unordered_multiset' is \" << s.max_size() << \"\\n\";\n}",
            "output": "Maximum size of a 'unordered_multiset' is 768614336404564650"
        }
    },
    "unordered_map::max_size": {
        "description": {
            "texte": "Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(begin(), end()) for the largest container."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <unordered_map>\n \nint main()\n{\n    std::unordered_map<char,char> s;\n    std::cout << \"Maximum size of a 'unordered_map' is \" << s.max_size() << \"\\n\";\n}",
            "output": "Maximum size of a 'unordered_map' is 768614336404564650"
        }
    },
    "unordered_multimap::max_size": {
        "description": {
            "texte": "Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(begin(), end()) for the largest container."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <unordered_map>\n \nint main()\n{\n    std::unordered_multimap<char,char> s;\n    std::cout << \"Maximum size of a 'unordered_multimap' is \" << s.max_size() << \"\\n\";\n}",
            "output": "Maximum size of a 'unordered_multimap' is 768614336404564650"
        }
    },
    "vector::resize": {
        "description": {
            "texte": "Resizes the container to contain count elements.If the current size is greater than count, the container is reduced to its first count elements."
        },
        "parametres": "   count   -   new size of the container \n   value   -   the value to initialize the new elements with \n   Type requirements \n   -T must meet the requirements of MoveInsertable and DefaultInsertable in order to use overload (1). \n   -T must meet the requirements of CopyInsertable in order to use overload (2). \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\nint main()\n{\n    std::vector<int> c = {1, 2, 3};\n    std::cout << \"The vector holds: \";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\\n';\n    c.resize(5);\n    std::cout << \"After resize up to 5: \";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\\n';\n    c.resize(2);\n    std::cout << \"After resize down to 2: \";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\\n';\n}",
            "output": "The vector holds: 1 2 3\nAfter resize up to 5: 1 2 3 0 0\nAfter resize down to 2: 1 2"
        }
    },
    "deque::resize": {
        "description": {
            "texte": "Resizes the container to contain count elements.If the current size is greater than count, the container is reduced to its first count elements."
        },
        "parametres": "   count   -   new size of the container \n   value   -   the value to initialize the new elements with \n   Type requirements \n   -T must meet the requirements of MoveInsertable and DefaultInsertable in order to use overload (1). \n   -T must meet the requirements of CopyInsertable in order to use overload (2). \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <deque>\nint main()\n{\n    std::deque<int> c = {1, 2, 3};\n    std::cout << \"The deque holds: \";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\\n';\n    c.resize(5);\n    std::cout << \"After resize up to 5: \";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\\n';\n    c.resize(2);\n    std::cout << \"After resize down to 2: \";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\\n';\n}",
            "output": "The deque holds: 1 2 3\nAfter resize up to 5: 1 2 3 0 0\nAfter resize down to 2: 1 2"
        }
    },
    "forward_list::resize": {
        "description": {
            "texte": "Resizes the container to contain count elements.If the current size is greater than count, the container is reduced to its first count elements.If the current size is less than count,"
        },
        "parametres": "   count   -   new size of the container \n   value   -   the value to initialize the new elements with \n   Type requirements \n   -T must meet the requirements of DefaultInsertable in order to use overload (1). \n   -T must meet the requirements of CopyInsertable in order to use overload (2). \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <forward_list>\nint main()\n{\n    std::forward_list<int> c = {1, 2, 3};\n    std::cout << \"The forward_list holds: \";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\\n';\n    c.resize(5);\n    std::cout << \"After resize up to 5: \";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\\n';\n    c.resize(2);\n    std::cout << \"After resize down to 2: \";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\\n';\n}",
            "output": "The forward_list holds: 1 2 3\nAfter resize up to 5: 1 2 3 0 0\nAfter resize down to 2: 1 2"
        }
    },
    "list::resize": {
        "description": {
            "texte": "Resizes the container to contain count elements.If the current size is greater than count, the container is reduced to its first count elements."
        },
        "parametres": "   count   -   new size of the container \n   value   -   the value to initialize the new elements with \n   Type requirements \n   -T must meet the requirements of DefaultInsertable in order to use overload (1). \n   -T must meet the requirements of CopyInsertable in order to use overload (2). \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <list>\nint main()\n{\n    std::list<int> c = {1, 2, 3};\n    std::cout << \"The list holds: \";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\\n';\n    c.resize(5);\n    std::cout << \"After resize up to 5: \";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\\n';\n    c.resize(2);\n    std::cout << \"After resize down to 2: \";\n    for(auto& el: c) std::cout << el << ' ';\n    std::cout << '\\n';\n}",
            "output": "The list holds: 1 2 3\nAfter resize up to 5: 1 2 3 0 0\nAfter resize down to 2: 1 2"
        }
    },
    "vector::capacity": {
        "description": {
            "texte": "Returns the number of elements that the container has currently allocated space for."
        }
    },
    "unordered_set::bucket_count": {
        "description": {
            "texte": "Returns the number of buckets in the container."
        }
    },
    "unordered_multiset::bucket_count": {
        "description": {
            "texte": "Returns the number of buckets in the container."
        }
    },
    "unordered_map::bucket_count": {
        "description": {
            "texte": "Returns the number of buckets in the container."
        }
    },
    "unordered_multimap::bucket_count": {
        "description": {
            "texte": "Returns the number of buckets in the container."
        }
    },
    "vector::reserve": {
        "description": {
            "texte": "Increase the capacity of the vector to a value that's greater or equal to new_cap. If new_cap is greater than the current capacity(), new storage is allocated, otherwise the method does nothing.reserve() does not change the size of the vector.If new_cap is greater than capacity(), all iterators, including the past-the-end iterator, and all references to the elements are invalidated. Otherwise, no iterators or references are invalidated."
        },
        "parametres": "   new_cap   -   new capacity of the vector \n   Type requirements \n   -T must meet the requirements of MoveInsertable. \n\n",
        "exemple": {
            "input": "#include <cstddef>\n#include <new>\n#include <vector>\n#include <iostream>\n \n// minimal C++11 allocator with debug output\ntemplate <class Tp>\nstruct NAlloc {\n    typedef Tp value_type;\n    NAlloc() = default;\n    template <class T> NAlloc(const NAlloc<T>&) {}\n    Tp* allocate(std::size_t n) {\n        n *= sizeof(Tp);\n        std::cout << \"allocating \" << n << \" bytes\\n\";\n        return static_cast<Tp*>(::operator new(n));\n    }\n    void deallocate(Tp* p, std::size_t n) {\n        std::cout << \"deallocating \" << n*sizeof*p << \" bytes\\n\";\n        ::operator delete(p);\n    }\n};\ntemplate <class T, class U>\nbool operator==(const NAlloc<T>&, const NAlloc<U>&) { return true; }\ntemplate <class T, class U>\nbool operator!=(const NAlloc<T>&, const NAlloc<U>&) { return false; }\n \nint main()\n{\n    int sz = 100;\n    std::cout << \"using reserve: \\n\";\n    {\n        std::vector<int, NAlloc<int>> v1;\n        v1.reserve(sz);\n        for(int n = 0; n < sz; ++n)\n            v1.push_back(n);\n    }\n    std::cout << \"not using reserve: \\n\";\n    {\n        std::vector<int, NAlloc<int>> v1;\n        for(int n = 0; n < sz; ++n)\n            v1.push_back(n);\n    }\n}",
            "output": "using reserve: \nallocating 400 bytes\ndeallocating 400 bytes\nnot using reserve: \nallocating 4 bytes\nallocating 8 bytes\ndeallocating 4 bytes\nallocating 16 bytes\ndeallocating 8 bytes\nallocating 32 bytes\ndeallocating 16 bytes\nallocating 64 bytes\ndeallocating 32 bytes\nallocating 128 bytes\ndeallocating 64 bytes\nallocating 256 bytes\ndeallocating 128 bytes\nallocating 512 bytes\ndeallocating 256 bytes\ndeallocating 512 bytes"
        }
    },
    "unordered_set::reserve": {
        "description": {
            "texte": "Sets the number of buckets to the number needed to accomodate at least count elements without exceeding maximum load factor and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. Effectively calls rehash(std::ceil(count / max_load_factor()))."
        },
        "parametres": "   count   -   new capacity of the container \n\n"
    },
    "unordered_multiset::reserve": {
        "description": {
            "texte": "Sets the number of buckets to the number needed to accomodate at least count elements without exceeding maximum load factor and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. Effectively calls rehash(std::ceil(count / max_load_factor()))."
        },
        "parametres": "   count   -   new capacity of the container \n\n"
    },
    "unordered_map::reserve": {
        "description": {
            "texte": "Sets the number of buckets to the number needed to accomodate at least count elements without exceeding maximum load factor and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. Effectively calls rehash(std::ceil(count / max_load_factor()))."
        },
        "parametres": "   count   -   new capacity of the container \n\n"
    },
    "unordered_multimap::reserve": {
        "description": {
            "texte": "Sets the number of buckets to the number needed to accomodate at least count elements without exceeding maximum load factor and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. Effectively calls rehash(std::ceil(count / max_load_factor()))."
        },
        "parametres": "   count   -   new capacity of the container \n\n"
    },
    "vector::shrink_to_fit": {
        "description": {
            "texte": "Requests the removal of unused capacity.It is a non-binding request to reduce capacity() to size(). It depends on the implementation whether the request is fulfilled.If reallocation occurs, all iterators, including the past the end iterator, and all references to the elements are invalidated. If no reallocation takes place, no iterators or references are invalidated."
        },
        "parametres": "   Type requirements \n   -T must meet the requirements of MoveInsertable. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v;\n    std::cout << \"Default-constructed capacity is \" << v.capacity() << '\\n';\n    v.resize(100);\n    std::cout << \"Capacity of a 100-element vector is \" << v.capacity() << '\\n';\n    v.clear();\n    std::cout << \"Capacity after clear() is \" << v.capacity() << '\\n';\n    v.shrink_to_fit();\n    std::cout << \"Capacity after shrink_to_fit() is \" << v.capacity() << '\\n';\n}",
            "output": "Default-constructed capacity is 0\nCapacity of a 100-element vector is 100\nCapacity after clear() is 100\nCapacity after shrink_to_fit() is 0"
        }
    },
    "deque::shrink_to_fit": {
        "description": {
            "texte": "Requests the removal of unused capacity.It is a non-binding request to reduce the memory usage without changing the size of the sequence. It depends on the implementation whether the request is fulfilled.All iterators and references are invalidated. Past-the-end iterator is also invalidated."
        },
        "parametres": "   Type requirements \n   -T must meet the requirements of MoveInsertable. \n\n",
        "exemple": {
            "input": "#include <deque>\n \nint main() {\n    std::deque<int> nums(1000, 42);\n    nums.push_front(1);\n    nums.pop_front();\n \n    nums.clear();\n \n    // nums now contains no items, but it may still be holding allocated memory. \n    // Calling shrink_to_fit may free any unused memory.\n    nums.shrink_to_fit();\n}"
        }
    },
    "vector::clear": {
        "description": {
            "texte": "Erases all elements from the container. After this call, size() returns zero.Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterators are also invalidated.Leaves the capacity() of the vector unchanged (note: the standard's restriction on the changes to capacity is in the specification of vector::reserve, see [1])."
        }
    },
    "deque::clear": {
        "description": {
            "texte": "Erases all elements from the container. After this call, size() returns zero.Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterators are also invalidated."
        }
    },
    "forward_list::clear": {
        "description": {
            "texte": "Erases all elements from the container. After this call, size() returns zero.Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterator remains valid."
        }
    },
    "list::clear": {
        "description": {
            "texte": "Erases all elements from the container. After this call, size() returns zero.Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterator remains valid."
        }
    },
    "set::clear": {
        "description": {
            "texte": "Erases all elements from the container. After this call, size() returns zero.Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterator remains valid."
        }
    },
    "multiset::clear": {
        "description": {
            "texte": "Erases all elements from the container. After this call, size() returns zero.Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterator remains valid."
        }
    },
    "multimap::clear": {
        "description": {
            "texte": "Erases all elements from the container. After this call, size() returns zero.Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterator remains valid."
        }
    },
    "unordered_set::clear": {
        "description": {
            "texte": "Erases all elements from the container. After this call, size() returns zero.Invalidates any references, pointers, or iterators referring to contained elements. May also invalidate past-the-end iterators."
        }
    },
    "unordered_multiset::clear": {
        "description": {
            "texte": "Erases all elements from the container. After this call, size() returns zero.Invalidates any references, pointers, or iterators referring to contained elements. May also invalidate past-the-end iterators."
        }
    },
    "unordered_map::clear": {
        "description": {
            "texte": "Erases all elements from the container. After this call, size() returns zero.Invalidates any references, pointers, or iterators referring to contained elements. May also invalidate past-the-end iterators."
        }
    },
    "unordered_multimap::clear": {
        "description": {
            "texte": "Erases all elements from the container. After this call, size() returns zero.Invalidates any references, pointers, or iterators referring to contained elements. May also invalidate past-the-end iterators."
        }
    },
    "vector::insert": {
        "description": {
            "texte": "Inserts elements at the specified location in the container.Causes reallocation if the new size() is greater than the old capacity(). If the new size() is greater than capacity(), all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated."
        },
        "parametres": "   pos   -   iterator before which the content will be inserted. pos may be the end() iterator \n   value   -   element value to insert \n   first, last   -   the range of elements to insert, can't be iterators into container for which insert is called \n   ilist   -   initializer list to insert the values from \n   Type requirements \n   -T must meet the requirements of CopyAssignable and CopyInsertable in order to use overload (1). \n   -T must meet the requirements of MoveAssignable and MoveInsertable in order to use overload (2). \n   -T must meet the requirements of CopyAssignable and CopyInsertable in order to use overload (3). \n   -T must meet the requirements of EmplaceConstructible in order to use overload (4,5). \n   -T must meet the requirements of MoveAssignable and MoveInsertable in order to use overload (4). required only if InputIt satisfies LegacyInputIterator but not LegacyForwardIterator. (until C++17) \n   -T must meet the requirements of Swappable, MoveAssignable, MoveConstructible and MoveInsertable in order to use overload (4,5). (since C++17) \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n \nvoid print_vec(const std::vector<int>& vec)\n{\n    for (auto x: vec) {\n         std::cout << ' ' << x;\n    }\n    std::cout << '\\n';\n}\n \nint main ()\n{\n    std::vector<int> vec(3,100);\n    print_vec(vec);\n \n    auto it = vec.begin();\n    it = vec.insert(it, 200);\n    print_vec(vec);\n \n    vec.insert(it,2,300);\n    print_vec(vec);\n \n    // \"it\" no longer valid, get a new one:\n    it = vec.begin();\n \n    std::vector<int> vec2(2,400);\n    vec.insert(it+2, vec2.begin(), vec2.end());\n    print_vec(vec);\n \n    int arr[] = { 501,502,503 };\n    vec.insert(vec.begin(), arr, arr+3);\n    print_vec(vec);\n}",
            "output": "100 100 100\n200 100 100 100\n300 300 200 100 100 100\n300 300 400 400 200 100 100 100\n501 502 503 300 300 400 400 200 100 100 100"
        }
    },
    "deque::insert": {
        "description": {
            "texte": "Inserts elements at the specified location in the container.All iterators, including the past-the-end iterator, are invalidated. References are invalidated too, unless pos == begin() or pos == end(), in which case they are not invalidated."
        },
        "parametres": "   pos   -   iterator before which the content will be inserted. pos may be the end() iterator \n   value   -   element value to insert \n   first, last   -   the range of elements to insert, can't be iterators into container for which insert is called \n   ilist   -   initializer list to insert the values from \n   Type requirements \n   -T must meet the requirements of CopyAssignable and CopyInsertable in order to use overload (1). \n   -T must meet the requirements of MoveAssignable and MoveInsertable in order to use overload (2). \n   -T must meet the requirements of CopyAssignable and CopyInsertable in order to use overload (3). \n   -T must meet the requirements of EmplaceConstructible in order to use overload (4,5). \n   -T must meet the requirements of Swappable, MoveAssignable, MoveConstructible and MoveInsertable in order to use overload (4,5). (since C++17) \n\n"
    },
    "forward_list::insert_after": {
        "description": {
            "texte": "Inserts elements after the specified position in the container.No iterators or references are invalidated."
        },
        "parametres": "   pos   -   iterator after which the content will be inserted \n   value   -   element value to insert \n   count   -   number of copies to insert \n   first, last   -   the range of elements to insert \n   ilist   -   initializer list to insert the values from \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n",
        "exemple": {
            "input": "#include <forward_list>                                                         \n#include <string>                                                               \n#include <iostream>                                                             \n#include <vector>                                                               \n \ntemplate<typename T>                                                            \nstd::ostream& operator<<(std::ostream& s, const std::forward_list<T>& v) {      \n    s.put('[');                                                                 \n    char comma[3] = {'\\0', ' ', '\\0'};                                          \n    for (const auto& e : v) {                                                   \n        s << comma << e;                                                        \n        comma[0] = ',';                                                         \n    }                                                                           \n    return s << ']';                                                            \n}                                                                               \n \nint main()                                                                      \n{                                                                               \n    std::forward_list<std::string> words {\"the\", \"frogurt\", \"is\", \"also\", \"cursed\"};\n    std::cout << \"words: \" << words << '\\n';                                    \n \n    // insert_after (2)                                                         \n    auto beginIt = words.begin();                                               \n    words.insert_after(beginIt, \"strawberry\");                                  \n    std::cout << \"words: \" << words << '\\n';                                    \n \n    // insert_after (3)                                                         \n    auto anotherIt = beginIt;                                                   \n    ++anotherIt;                                                                \n    anotherIt = words.insert_after(anotherIt, 2, \"strawberry\");                 \n    std::cout << \"words: \" << words << '\\n';                                    \n \n    // insert_after (4)\n    std::vector<std::string> V = { \"apple\", \"banana\", \"cherry\"};                \n    anotherIt = words.insert_after(anotherIt, V.begin(), V.end());              \n    std::cout << \"words: \" << words << '\\n';                                    \n \n    // insert_after (5)                                                         \n    words.insert_after(anotherIt, {\"jackfruit\", \"kiwifruit\", \"lime\", \"mango\"});\n    std::cout << \"words: \" << words << '\\n';                                    \n}",
            "output": "words: [the, frogurt, is, also, cursed]\nwords: [the, strawberry, frogurt, is, also, cursed]\nwords: [the, strawberry, strawberry, strawberry, frogurt, is, also, cursed]\nwords: [the, strawberry, strawberry, strawberry, apple, banana, cherry, frogurt, is, also, cursed]\nwords: [the, strawberry, strawberry, strawberry, apple, banana, cherry, jackfruit, kiwifruit, lime, mango, frogurt, is, also, cursed]"
        }
    },
    "list::insert": {
        "description": {
            "texte": "Inserts elements at the specified location in the container.No iterators or references are invalidated."
        },
        "parametres": "   pos   -   iterator before which the content will be inserted. pos may be the end() iterator \n   value   -   element value to insert \n   first, last   -   the range of elements to insert, can't be iterators into container for which insert is called \n   ilist   -   initializer list to insert the values from \n   Type requirements \n   -T must meet the requirements of CopyInsertable in order to use overload (1). \n   -T must meet the requirements of MoveInsertable in order to use overload (2). \n   -T must meet the requirements of CopyAssignable and CopyInsertable in order to use overload (3). \n   -T must meet the requirements of EmplaceConstructible in order to use overload (4,5). \n\n"
    },
    "multiset::insert": {
        "description": {
            "texte": "Inserts element(s) into the container.No iterators or references are invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. (since C++17)."
        },
        "parametres": "   hint   -   \n\niterator, used as a suggestion as to where to start the search (until C++11)\n\n\niterator to the position before which the new element will be inserted (since C++11)\n\n \n   value   -   element value to insert \n   first, last   -   range of elements to insert \n   ilist   -   initializer list to insert the values from \n   nh   -   a compatible node handle \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n"
    },
    "map::insert": {
        "description": {
            "texte": "Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.No iterators or references are invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. (since C++17)."
        },
        "parametres": "   hint   -   \n\niterator, used as a suggestion as to where to start the search (until C++11)\n\n\niterator to the position before which the new element will be inserted (since C++11)\n\n \n   value   -   element value to insert \n   first, last   -   range of elements to insert \n   ilist   -   initializer list to insert the values from \n   nh   -   a compatible node handle \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n"
    },
    "multimap::insert": {
        "description": {
            "texte": "Inserts element(s) into the container.No iterators or references are invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. (since C++17)."
        },
        "parametres": "   hint   -   \n\niterator, used as a suggestion as to where to start the search (until C++11)\n\n\niterator to the position before which the new element will be inserted (since C++11)\n\n \n   value   -   element value to insert \n   first, last   -   range of elements to insert \n   ilist   -   initializer list to insert the values from \n   nh   -   a compatible node handle \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <map>\n#include <functional>\n \ntemplate<class M>\nvoid print(const M& mmap)\n{\n    for (auto & e : mmap)\n        std::cout << \"{\" << e.first << \",\" << e.second << \"} \";\n    std::cout << '\\n';\n}\n \nint main()\n{\n  // list-initialize\n  std::multimap<int, std::string, std::greater<int>> mmap \n    {{2, \"foo\"}, {2, \"bar\"}, {3, \"baz\"}, {1, \"abc\"}, {5, \"def\"}};\n \n  // insert using value_type\n  mmap.insert(decltype(mmap)::value_type(5, \"pqr\"));\n  print(mmap);\n \n  // insert using make_pair\n  mmap.insert(std::make_pair(6, \"uvw\"));\n  print(mmap);\n \n  mmap.insert({7, \"xyz\"});\n  print(mmap);\n \n  // insert using initialization_list\n  mmap.insert({{5, \"one\"}, {5, \"two\"}});\n  print(mmap);\n \n  // erase all entries with key 5\n  mmap.erase(5);\n  print(mmap);\n \n  // find and erase a specific entry\n  auto pos = mmap.begin();\n  while (pos->second != \"bar\" && pos != mmap.end()) ++pos;\n  mmap.erase(pos);\n  print(mmap);\n}",
            "output": "{5,def} {5,pqr} {3,baz} {2,foo} {2,bar} {1,abc} \n{6,uvw} {5,def} {5,pqr} {3,baz} {2,foo} {2,bar} {1,abc} \n{7,xyz} {6,uvw} {5,def} {5,pqr} {3,baz} {2,foo} {2,bar} {1,abc} \n{7,xyz} {6,uvw} {5,def} {5,pqr} {5,one} {5,two} {3,baz} {2,foo} {2,bar} {1,abc} \n{7,xyz} {6,uvw} {3,baz} {2,foo} {2,bar} {1,abc} \n{7,xyz} {6,uvw} {3,baz} {2,foo} {1,abc}"
        }
    },
    "unordered_set::insert": {
        "description": {
            "texte": "Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than max_load_factor()*bucket_count(). If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. (since C++17)."
        },
        "parametres": "   hint   -   iterator, used as a suggestion as to where to insert the content \n   value   -   element value to insert \n   first, last   -   range of elements to insert \n   ilist   -   initializer list to insert the values from \n   nh   -   a compatible node handle \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n"
    },
    "unordered_multiset::insert": {
        "description": {
            "texte": "Inserts element(s) into the container.If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than max_load_factor()*bucket_count(). If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. (since C++17)."
        },
        "parametres": "   hint   -   iterator, used as a suggestion as to where to insert the content \n   value   -   element value to insert \n   first, last   -   range of elements to insert \n   ilist   -   initializer list to insert the values from \n   nh   -   a compatible node handle \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n"
    },
    "unordered_map::insert": {
        "description": {
            "texte": "Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than max_load_factor()*bucket_count(). If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. (since C++17)."
        },
        "parametres": "   hint   -   iterator, used as a suggestion as to where to insert the content \n   value   -   element value to insert \n   first, last   -   range of elements to insert \n   ilist   -   initializer list to insert the values from \n   nh   -   a compatible node handle \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n",
        "exemple": {
            "input": "#include <string>\n#include <iostream>\n#include <unordered_map>\n \nint main ()\n{\n    std::unordered_map<int, std::string> dict = {{1, \"one\"}, {2, \"two\"}};\n    dict.insert({3, \"three\"});\n    dict.insert(std::make_pair(4, \"four\"));\n    dict.insert({{4, \"another four\"}, {5, \"five\"}});\n \n    bool ok = dict.insert({1, \"another one\"}).second;\n    std::cout << \"inserting 1 -> \\\"another one\\\" \" \n              << (ok ? \"succeeded\" : \"failed\") << '\\n';\n \n    std::cout << \"contents:\\n\";\n    for(auto& p: dict)\n        std::cout << \" \" << p.first << \" => \" << p.second << '\\n';\n}",
            "output": "inserting 1 -> \"another one\" failed\ncontents:\n 5 => five\n 1 => one\n 2 => two\n 3 => three\n 4 => four"
        }
    },
    "unordered_multimap::insert": {
        "description": {
            "texte": "Inserts element(s) into the container.If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than max_load_factor()*bucket_count(). If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid. (since C++17)."
        },
        "parametres": "   hint   -   iterator, used as a suggestion as to where to insert the content \n   value   -   element value to insert \n   first, last   -   range of elements to insert \n   ilist   -   initializer list to insert the values from \n   nh   -   a compatible node handle \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n"
    },
    "map::insert_or_assign": {
        "description": {
            "texte": "No iterators or references are invalidated."
        },
        "parametres": "   k   -   the key used both to look up and to insert if not found \n   hint   -   iterator to the position before which the new element will be inserted \n   obj   -   the value to insert or assign \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <map>\n#include <string>\n \nint main()\n{\n    std::map<std::string, std::string> myMap;\n    myMap.insert_or_assign(\"a\", \"apple\"     );\n    myMap.insert_or_assign(\"b\", \"bannana\"   );\n    myMap.insert_or_assign(\"c\", \"cherry\"    );\n    myMap.insert_or_assign(\"c\", \"clementine\");\n \n    for (const auto &pair : myMap) {\n        std::cout << pair.first << \" : \" << pair.second << '\\n';\n    }\n}",
            "output": "a : apple\nb : bannana\nc : clementine"
        }
    },
    "unordered_map::insert_or_assign": {
        "description": {
            "texte": "If an insertion occurs and results in a rehashing of the container, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than max_load_factor()*bucket_count()."
        },
        "parametres": "   k   -   the key used both to look up and to insert if not found \n   hint   -   iterator to the position before which the new element will be inserted \n   obj   -   the value to insert or assign \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <unordered_map>\n#include <string>\n \nint main()\n{\n    std::unordered_map<std::string, std::string> myMap;\n    myMap.insert_or_assign(\"a\", \"apple\"     );\n    myMap.insert_or_assign(\"b\", \"bannana\"   );\n    myMap.insert_or_assign(\"c\", \"cherry\"    );\n    myMap.insert_or_assign(\"c\", \"clementine\");\n \n    for (const auto &pair : myMap) {\n        std::cout << pair.first << \" : \" << pair.second << '\\n';\n    }\n}",
            "output": "c : clementine\na : apple\nb : bannana"
        }
    },
    "vector::emplace": {
        "description": {
            "texte": "Inserts a new element into the container directly before pos. The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place at a location provided by the container. The arguments args... are forwarded to the constructor as std::forward<Args>(args)....If the new size() is greater than capacity(), all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated."
        },
        "parametres": "   pos   -   iterator before which the new element will be constructed \n   args   -   arguments to forward to the constructor of the element \n   Type requirements \n   -T (the container's element type) must meet the requirements of MoveAssignable, MoveInsertable and EmplaceConstructible. \n\n"
    },
    "deque::emplace": {
        "description": {
            "texte": "Inserts a new element into the container directly before pos. The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place at a location provided by the container. The arguments args... are forwarded to the constructor as std::forward<Args>(args)....All iterators, including the past-the-end iterator, are invalidated. References are invalidated too, unless pos == begin() or pos == end(), in which case they are not invalidated."
        },
        "parametres": "   pos   -   iterator before which the new element will be constructed \n   args   -   arguments to forward to the constructor of the element \n   Type requirements \n   -T (the container's element type) must meet the requirements of MoveAssignable, MoveInsertable and EmplaceConstructible. \n\n"
    },
    "forward_list::emplace_after": {
        "description": {
            "texte": "Inserts a new element into a position after the specified position in the container. The element is constructed in-place, i.e. no copy or move operations are performed. The constructor of the element is called with exactly the same arguments, as supplied to the function.No iterators or references are invalidated."
        },
        "parametres": "   pos   -   iterator after which the new element will be constructed \n   args   -   arguments to forward to the constructor of the element \n\n"
    },
    "list::emplace": {
        "description": {
            "texte": "Inserts a new element into the container directly before pos. The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place at a location provided by the container. The arguments args... are forwarded to the constructor as std::forward<Args>(args)....No iterators or references are invalidated."
        },
        "parametres": "   pos   -   iterator before which the new element will be constructed \n   args   -   arguments to forward to the constructor of the element \n   Type requirements \n   -T (the container's element type) must meet the requirements of EmplaceConstructible. \n\n"
    },
    "set::emplace": {
        "description": {
            "texte": "Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container.Careful use of emplace allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to emplace, forwarded via std::forward<Args>(args).... The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately.No iterators or references are invalidated."
        },
        "parametres": "   args   -   arguments to forward to the constructor of the element \n\n",
        "exemple": {
            "input": "#include <chrono>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <string>\n \nclass Dew\n{\n  private:\n    int a;\n    int b;\n    int c;\n \n  public:\n    Dew(int _a, int _b, int _c)\n      : a(_a), b(_b), c(_c)\n    {}\n \n    bool operator<(const Dew &other) const\n    {\n      if (a < other.a)\n        return true;\n      if (a == other.a && b < other.b)\n        return true;\n      return (a == other.a && b == other.b && c < other.c);\n    }\n};\n \nconst int nof_operations = 120;\n \nint set_emplace() {\n    std::set<Dew> set;\n    for(int i = 0; i < nof_operations; ++i)\n        for(int j = 0; j < nof_operations; ++j)\n            for(int k = 0; k < nof_operations; ++k)\n              set.emplace(i, j, k);\n \n    return set.size();\n}\n \nint set_insert() {\n    std::set<Dew> set;\n    for(int i = 0; i < nof_operations; ++i)\n        for(int j = 0; j < nof_operations; ++j)\n            for(int k = 0; k < nof_operations; ++k)\n              set.insert(Dew(i, j, k));\n \n    return set.size();\n}\n \nvoid timeit(std::function<int()> set_test, std::string what = \"\") {\n  auto start = std::chrono::system_clock::now();\n  int setsize = set_test();\n  auto stop = std::chrono::system_clock::now();\n  std::chrono::duration<double, std::milli> time = stop - start;\n  if (what.size() > 0 && setsize > 0) {\n    std::cout << std::fixed << std::setprecision(2)\n        << time.count() << \"  ms for \" << what << '\\n';\n  }\n}\n \nint main()\n{\n  set_insert();\n  timeit(set_insert, \"insert\");\n  timeit(set_emplace, \"emplace\");\n  timeit(set_insert, \"insert\");\n  timeit(set_emplace, \"emplace\");\n}",
            "output": "638.45  ms for insert\n619.44  ms for emplace\n609.43  ms for insert\n652.55  ms for emplace"
        }
    },
    "multiset::emplace": {
        "description": {
            "texte": "Inserts a new element into the container constructed in-place with the given args .Careful use of emplace allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to emplace, forwarded via std::forward<Args>(args).... No iterators or references are invalidated."
        },
        "parametres": "   args   -   arguments to forward to the constructor of the element \n\n"
    },
    "multimap::emplace": {
        "description": {
            "texte": "Inserts a new element into the container constructed in-place with the given args .Careful use of emplace allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element (i.e. std::pair<const Key, T>) is called with exactly the same arguments as supplied to emplace, forwarded via std::forward<Args>(args).... No iterators or references are invalidated."
        },
        "parametres": "   args   -   arguments to forward to the constructor of the element \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <utility>\n#include <string>\n#include <map>\n \nint main()\n{\n    std::multimap<std::string, std::string> m;\n \n    // uses pair's move constructor\n    m.emplace(std::make_pair(std::string(\"a\"), std::string(\"a\")));\n \n    // uses pair's converting move constructor\n    m.emplace(std::make_pair(\"b\", \"abcd\"));\n \n    // uses pair's template constructor\n    m.emplace(\"d\", \"ddd\");\n \n    // uses pair's piecewise constructor\n    m.emplace(std::piecewise_construct,\n              std::forward_as_tuple(\"c\"),\n              std::forward_as_tuple(10, 'c'));\n \n \n    for (const auto &p : m) {\n        std::cout << p.first << \" => \" << p.second << '\\n';\n    }\n}",
            "output": "a => a\nb => abcd\nc => cccccccccc\nd => ddd"
        }
    },
    "unordered_set::emplace": {
        "description": {
            "texte": "Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container.Careful use of emplace allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to emplace, forwarded via std::forward<Args>(args).... The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately.If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than max_load_factor()*bucket_count()."
        },
        "parametres": "   args   -   arguments to forward to the constructor of the element \n\n"
    },
    "unordered_multiset::emplace": {
        "description": {
            "texte": "Inserts a new element into the container constructed in-place with the given args .Careful use of emplace allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to emplace, forwarded via std::forward<Args>(args).... If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than max_load_factor()*bucket_count()."
        },
        "parametres": "   args   -   arguments to forward to the constructor of the element \n\n"
    },
    "unordered_map::emplace": {
        "description": {
            "texte": "Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container.Careful use of emplace allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element (i.e. std::pair<const Key, T>) is called with exactly the same arguments as supplied to emplace, forwarded via std::forward<Args>(args).... The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately.If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than max_load_factor()*bucket_count()."
        },
        "parametres": "   args   -   arguments to forward to the constructor of the element \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <utility>\n#include <string>\n#include <unordered_map>\n \nint main()\n{\n    std::unordered_map<std::string, std::string> m;\n \n    // uses pair's move constructor\n    m.emplace(std::make_pair(std::string(\"a\"), std::string(\"a\")));\n \n    // uses pair's converting move constructor\n    m.emplace(std::make_pair(\"b\", \"abcd\"));\n \n    // uses pair's template constructor\n    m.emplace(\"d\", \"ddd\");\n \n    // uses pair's piecewise constructor\n    m.emplace(std::piecewise_construct,\n              std::forward_as_tuple(\"c\"),\n              std::forward_as_tuple(10, 'c'));\n    // as of C++17, m.try_emplace(\"c\", 10, 'c'); can be used\n \n    for (const auto &p : m) {\n        std::cout << p.first << \" => \" << p.second << '\\n';\n    }\n}",
            "output": "a => a\nb => abcd\nc => cccccccccc\nd => ddd"
        }
    },
    "unordered_multimap::emplace": {
        "description": {
            "texte": "Inserts a new element into the container constructed in-place with the given args .Careful use of emplace allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element (i.e. std::pair<const Key, T>) is called with exactly the same arguments as supplied to emplace, forwarded via std::forward<Args>(args).... If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than max_load_factor()*bucket_count()."
        },
        "parametres": "   args   -   arguments to forward to the constructor of the element \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <utility>\n#include <string>\n#include <unordered_map>\n \nint main()\n{\n    std::unordered_multimap<std::string, std::string> m;\n \n    // uses pair's move constructor\n    m.emplace(std::make_pair(std::string(\"a\"), std::string(\"a\")));\n \n    // uses pair's converting move constructor\n    m.emplace(std::make_pair(\"b\", \"abcd\"));\n \n    // uses pair's template constructor\n    m.emplace(\"d\", \"ddd\");\n \n    // uses pair's piecewise constructor\n    m.emplace(std::piecewise_construct,\n              std::forward_as_tuple(\"c\"),\n              std::forward_as_tuple(10, 'c'));\n \n \n    for (const auto &p : m) {\n        std::cout << p.first << \" => \" << p.second << '\\n';\n    }\n}",
            "output": "a => a\nb => abcd\nc => cccccccccc\nd => ddd"
        }
    },
    "set::emplace_hint": {
        "description": {
            "texte": "Inserts a new element into the container as close as possible to the position just before hint. The element is constructed in-place, i.e. no copy or move operations are performed.The constructor of the element is called with exactly the same arguments as supplied to the function, forwarded with std::forward<Args>(args)....No iterators or references are invalidated."
        },
        "parametres": "   hint   -   iterator to the position before which the new element will be inserted \n   args   -   arguments to forward to the constructor of the element \n\n",
        "exemple": {
            "input": "#include <set>\n#include <chrono>\n#include <iostream>\n#include <iomanip>\n#include <functional>\n \nconst int nof_operations = 100500;\n \nint set_emplace() {\n  std::set<int> set;\n  for(int i = 0; i < nof_operations; ++i) {\n    set.emplace(i);\n  }\n  return set.size();\n}\n \nint set_emplace_hint() {\n  std::set<int> set;\n  auto it = set.begin();\n  for(int i = 0; i < nof_operations; ++i) {\n    set.emplace_hint(it, i);\n    it = set.end();\n  }\n  return set.size();\n}\n \nint set_emplace_hint_wrong() {\n  std::set<int> set;\n  auto it = set.begin();\n  for(int i = nof_operations; i > 0; --i) {\n    set.emplace_hint(it, i);\n    it = set.end();\n  }\n  return set.size();\n}\n \nint set_emplace_hint_corrected() {\n  std::set<int> set;\n  auto it = set.begin();\n  for(int i = nof_operations; i > 0; --i) {\n    set.emplace_hint(it, i);\n    it = set.begin();\n  }\n  return set.size();\n}\n \nint set_emplace_hint_closest() {\n  std::set<int> set;\n  auto it = set.begin();\n  for(int i = 0; i < nof_operations; ++i) {\n    it = set.emplace_hint(it, i);\n  }\n  return set.size();\n}\n \nvoid timeit(std::function<int()> set_test, std::string what = \"\") {\n  auto start = std::chrono::system_clock::now();\n  int setsize = set_test();\n  auto stop = std::chrono::system_clock::now();\n  std::chrono::duration<double, std::milli> time = stop - start;\n  if (what.size() > 0 && setsize > 0) {\n    std::cout << std::fixed << std::setprecision(2)\n              << time.count() << \"  ms for \" << what << '\\n';\n  }\n}\n \nint main() {\n   timeit(set_emplace); // stack warmup\n   timeit(set_emplace, \"plain emplace\");\n   timeit(set_emplace_hint, \"emplace with correct hint\");\n   timeit(set_emplace_hint_wrong, \"emplace with wrong hint\");\n   timeit(set_emplace_hint_corrected, \"corrected emplace\");\n   timeit(set_emplace_hint_closest, \"emplace using returned iterator\");\n}",
            "output": "18.96  ms for plain emplace\n7.95  ms for emplace with correct hint\n19.39  ms for emplace with wrong hint\n8.39  ms for corrected emplace\n7.90  ms for emplace using returned iterator"
        }
    },
    "multiset::emplace_hint": {
        "description": {
            "texte": "Inserts a new element to the container as close as possible to the position just before hint. The element is constructed in-place, i.e. no copy or move operations are performed.The constructor of the element is called with exactly the same arguments as supplied to the function, forwarded with std::forward<Args>(args)....No iterators or references are invalidated."
        },
        "parametres": "   hint   -   iterator to the position before which the new element will be inserted \n   args   -   arguments to forward to the constructor of the element \n\n"
    },
    "map::emplace_hint": {
        "description": {
            "texte": "Inserts a new element to the container as close as possible to the position just before hint. The element is constructed in-place, i.e. no copy or move operations are performed.The constructor of the element type (value_type, that is, std::pair<const Key, T>) is called with exactly the same arguments as supplied to the function, forwarded with std::forward<Args>(args)....No iterators or references are invalidated."
        },
        "parametres": "   hint   -   iterator to the position before which the new element will be inserted \n   args   -   arguments to forward to the constructor of the element \n\n"
    },
    "multimap::emplace_hint": {
        "description": {
            "texte": "Inserts a new element into the container as close as possible to the position just before hint. The element is constructed in-place, i.e. no copy or move operations are performed.The constructor of the element type (value_type, that is, std::pair<const Key, T>) is called with exactly the same arguments as supplied to the function, forwarded with std::forward<Args>(args)....No iterators or references are invalidated."
        },
        "parametres": "   hint   -   iterator to the position before which the new element will be inserted \n   args   -   arguments to forward to the constructor of the element \n\n"
    },
    "unordered_set::emplace_hint": {
        "description": {
            "texte": "Inserts a new element to the container, using hint as a suggestion where the element should go. The element is constructed in-place, i.e. no copy or move operations are performed.The constructor of the element is called with exactly the same arguments as supplied to the function, forwarded with std::forward<Args>(args)....If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than max_load_factor()*bucket_count()."
        },
        "parametres": "   hint   -   iterator, used as a suggestion as to where to insert the new element \n   args   -   arguments to forward to the constructor of the element \n\n"
    },
    "unordered_multiset::emplace_hint": {
        "description": {
            "texte": "Inserts a new element to the container, using hint as a suggestion where the element should go. The element is constructed in-place, i.e. no copy or move operations are performed.The constructor of the element is called with exactly the same arguments as supplied to the function, forwarded with std::forward<Args>(args)....If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than max_load_factor()*bucket_count()."
        },
        "parametres": "   hint   -   iterator, used as a suggestion as to where to insert the new element \n   args   -   arguments to forward to the constructor of the element \n\n"
    },
    "unordered_map::emplace_hint": {
        "description": {
            "texte": "Inserts a new element to the container, using hint as a suggestion where the element should go. The element is constructed in-place, i.e. no copy or move operations are performed.The constructor of the element type (value_type, that is, std::pair<const Key, T>) is called with exactly the same arguments as supplied to the function, forwarded with std::forward<Args>(args)....If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than max_load_factor()*bucket_count()."
        },
        "parametres": "   hint   -   iterator, used as a suggestion as to where to insert the new element \n   args   -   arguments to forward to the constructor of the element \n\n"
    },
    "unordered_multimap::emplace_hint": {
        "description": {
            "texte": "Inserts a new element to the container, using hint as a suggestion where the element should go. The element is constructed in-place, i.e. no copy or move operations are performed.The constructor of the element type (value_type, that is, std::pair<const Key, T>) is called with exactly the same arguments as supplied to the function, forwarded with std::forward<Args>(args)....If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than max_load_factor()*bucket_count()."
        },
        "parametres": "   hint   -   iterator, used as a suggestion as to where to insert the new element \n   args   -   arguments to forward to the constructor of the element \n\n"
    },
    "map::try_emplace": {
        "description": {
            "texte": "No iterators or references are invalidated."
        },
        "parametres": "   k   -   the key used both to look up and to insert if not found \n   hint   -   iterator to the position before which the new element will be inserted \n   args   -   arguments to forward to the constructor of the element \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <utility>\n#include <string>\n \n#include <map>\nint main()\n{\n    using namespace std::literals;\n    std::map<std::string, std::string> m;\n \n    m.try_emplace(\"a\", \"a\"s);\n    m.try_emplace(\"b\", \"abcd\");\n    m.try_emplace(\"c\", 10, 'c');\n    m.try_emplace(\"c\", \"Won't be inserted\");\n \n    for (const auto &p : m) {\n        std::cout << p.first << \" => \" << p.second << '\\n';\n    }\n}",
            "output": "a => a\nb => abcd\nc => cccccccccc"
        }
    },
    "unordered_map::try_emplace": {
        "description": {
            "texte": "If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than max_load_factor()*bucket_count()."
        },
        "parametres": "   k   -   the key used both to look up and to insert if not found \n   hint   -   iterator to the position before which the new element will be inserted \n   args   -   arguments to forward to the constructor of the element \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <utility>\n#include <string>\n \n#include <unordered_map>\nint main()\n{\n    using namespace std::literals;\n    std::unordered_map<std::string, std::string> m;\n \n    m.try_emplace(\"a\", \"a\"s);\n    m.try_emplace(\"b\", \"abcd\");\n    m.try_emplace(\"c\", 10, 'c');\n    m.try_emplace(\"c\", \"Won't be inserted\");\n \n    for (const auto &p : m) {\n        std::cout << p.first << \" => \" << p.second << '\\n';\n    }\n}",
            "output": "a => a\nb => abcd\nc => cccccccccc"
        }
    },
    "vector::erase": {
        "description": {
            "texte": "Erases the specified elements from the container.Invalidates iterators and references at or after the point of the erase, including the end() iterator.The iterator pos must be valid and dereferenceable. Thus the end() iterator (which is valid, but is not dereferencable) cannot be used as a value for pos.The iterator first does not need to be dereferenceable if first==last: erasing an empty range is a no-op."
        },
        "parametres": "   pos   -   iterator to the element to remove \n   first, last   -   range of elements to remove \n   Type requirements \n   -T must meet the requirements of MoveAssignable. \n\n",
        "exemple": {
            "input": "#include <vector>\n#include <iostream>\n \n \nint main( )\n{\n    std::vector<int> c{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    for (auto &i : c) {\n        std::cout << i << \" \";\n    }\n    std::cout << '\\n';\n \n    c.erase(c.begin());\n \n    for (auto &i : c) {\n        std::cout << i << \" \";\n    }\n    std::cout << '\\n';\n \n    c.erase(c.begin()+2, c.begin()+5);\n \n    for (auto &i : c) {\n        std::cout << i << \" \";\n    }\n    std::cout << '\\n';\n \n    // Erase all even numbers (C++11 and later)\n    for (auto it = c.begin(); it != c.end(); ) {\n        if (*it % 2 == 0) {\n            it = c.erase(it);\n        } else {\n            ++it;\n        }\n    }\n \n    for (auto &i : c) {\n        std::cout << i << \" \";\n    }\n    std::cout << '\\n';\n}",
            "output": "0 1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n1 2 6 7 8 9\n1 7 9"
        }
    },
    "deque::erase": {
        "description": {
            "texte": "Erases the specified elements from the container.All iterators and references are invalidated, unless the erased elements are at the end or the beginning of the container, in which case only the iterators and references to the erased elements are invalidated.The iterator pos must be valid and dereferenceable. Thus the end() iterator (which is valid, but is not dereferencable) cannot be used as a value for pos.The iterator first does not need to be dereferenceable if first==last: erasing an empty range is a no-op."
        },
        "parametres": "   pos   -   iterator to the element to remove \n   first, last   -   range of elements to remove \n   Type requirements \n   -T must meet the requirements of MoveAssignable. \n\n",
        "exemple": {
            "input": "#include <deque>\n#include <iostream>\n \n \nint main( )\n{\n    std::deque<int> c{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    for (auto &i : c) {\n        std::cout << i << \" \";\n    }\n    std::cout << '\\n';\n \n    c.erase(c.begin());\n \n    for (auto &i : c) {\n        std::cout << i << \" \";\n    }\n    std::cout << '\\n';\n \n    c.erase(c.begin()+2, c.begin()+5);\n \n    for (auto &i : c) {\n        std::cout << i << \" \";\n    }\n    std::cout << '\\n';\n \n    // Erase all even numbers (C++11 and later)\n    for (auto it = c.begin(); it != c.end(); ) {\n        if (*it % 2 == 0) {\n            it = c.erase(it);\n        } else {\n            ++it;\n        }\n    }\n \n    for (auto &i : c) {\n        std::cout << i << \" \";\n    }\n    std::cout << '\\n';\n}",
            "output": "0 1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n1 2 6 7 8 9\n1 7 9"
        }
    },
    "forward_list::erase_after": {
        "description": {
            "texte": "Removes specified elements from the container."
        },
        "parametres": "   pos   -   iterator to the element preceding the element to remove \n   first, last   -   range of elements to remove \n\n",
        "exemple": {
            "input": "#include <forward_list>\n#include <iterator>\n#include <iostream>\nint main()\n{\n    std::forward_list<int> l = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n \n    //    l.erase( l.begin() ); // ERROR: No function erase\n \n    l.erase_after( l.before_begin() ); // Removes first element\n \n    for( auto n : l ) std::cout << n << \" \";\n    std::cout << '\\n';\n \n    auto fi= std::next( l.begin() );\n    auto la= std::next( fi, 3 );\n \n    l.erase_after( fi, la );\n \n    for( auto n : l ) std::cout << n << \" \";\n    std::cout << '\\n';\n}",
            "output": "2 3 4 5 6 7 8 9\n2 3 6 7 8 9"
        }
    },
    "list::erase": {
        "description": {
            "texte": "Erases the specified elements from the container.References and iterators to the erased elements are invalidated. Other references and iterators are not affected.The iterator pos must be valid and dereferenceable. Thus the end() iterator (which is valid, but is not dereferencable) cannot be used as a value for pos.The iterator first does not need to be dereferenceable if first==last: erasing an empty range is a no-op."
        },
        "parametres": "   pos   -   iterator to the element to remove \n   first, last   -   range of elements to remove \n\n",
        "exemple": {
            "input": "#include <list>\n#include <iostream>\n#include <iterator>\n \nint main( )\n{\n    std::list<int> c{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    for (auto &i : c) {\n        std::cout << i << \" \";\n    }\n    std::cout << '\\n';\n \n    c.erase(c.begin());\n \n    for (auto &i : c) {\n        std::cout << i << \" \";\n    }\n    std::cout << '\\n';\n \n    std::list<int>::iterator range_begin = c.begin();\n    std::list<int>::iterator range_end = c.begin();\n    std::advance(range_begin,2);\n    std::advance(range_end,5);\n \n    c.erase(range_begin, range_end);\n \n    for (auto &i : c) {\n        std::cout << i << \" \";\n    }\n    std::cout << '\\n';\n \n    // Erase all even numbers (C++11 and later)\n    for (auto it = c.begin(); it != c.end(); ) {\n        if (*it % 2 == 0) {\n            it = c.erase(it);\n        } else {\n            ++it;\n        }\n    }\n \n    for (auto &i : c) {\n        std::cout << i << \" \";\n    }\n    std::cout << '\\n';\n}",
            "output": "0 1 2 3 4 5 6 7 8 9\n1 2 3 4 5 6 7 8 9\n1 2 6 7 8 9\n1 7 9"
        }
    },
    "multiset::erase": {
        "description": {
            "texte": "Removes specified elements from the container.References and iterators to the erased elements are invalidated. Other references and iterators are not affected.The iterator pos must be valid and dereferenceable. Thus the end() iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos."
        },
        "parametres": "   pos   -   iterator to the element to remove \n   first, last   -   range of elements to remove \n   key   -   key value of the elements to remove \n\n",
        "exemple": {
            "input": "#include <set>\n#include <iostream>\nint main()\n{\n    std::multiset<int> c = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(*it % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(int n : c)\n        std::cout << n << ' ';\n}",
            "output": "2 4 6 8"
        }
    },
    "map::erase": {
        "description": {
            "texte": "Removes specified elements from the container.References and iterators to the erased elements are invalidated. Other references and iterators are not affected.The iterator pos must be valid and dereferenceable. Thus the end() iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos."
        },
        "parametres": "   pos   -   iterator to the element to remove \n   first, last   -   range of elements to remove \n   key   -   key value of the elements to remove \n\n",
        "exemple": {
            "input": "#include <map>\n#include <iostream>\nint main()\n{\n    std::map<int, std::string> c = {{1, \"one\"}, {2, \"two\"}, {3, \"three\"},\n                                    {4, \"four\"}, {5, \"five\"}, {6, \"six\"}};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(it->first % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(auto& p : c)\n        std::cout << p.second << ' ';\n}",
            "output": "two four six"
        }
    },
    "multimap::erase": {
        "description": {
            "texte": "Removes specified elements from the container.References and iterators to the erased elements are invalidated. Other references and iterators are not affected.The iterator pos must be valid and dereferenceable. Thus the end() iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos."
        },
        "parametres": "   pos   -   iterator to the element to remove \n   first, last   -   range of elements to remove \n   key   -   key value of the elements to remove \n\n",
        "exemple": {
            "input": "#include <map>\n#include <iostream>\nint main()\n{\n    std::multimap<int, std::string> c = {{1, \"one\"}, {2, \"two\"}, {3, \"three\"},\n                                    {4, \"four\"}, {5, \"five\"}, {6, \"six\"}};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(it->first % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(auto& p : c)\n        std::cout << p.second << ' ';\n}",
            "output": "two four six"
        }
    },
    "unordered_set::erase": {
        "description": {
            "texte": "Removes specified elements from the container.References and iterators to the erased elements are invalidated. Other iterators and references are not invalidated.The iterator pos must be valid and dereferenceable. Thus the end() iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos."
        },
        "parametres": "   pos   -   iterator to the element to remove \n   first, last   -   range of elements to remove \n   key   -   key value of the elements to remove \n\n",
        "exemple": {
            "input": "#include <unordered_set>\n#include <iostream>\nint main()\n{\n    std::unordered_set<int> c = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(*it % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(int n : c)\n        std::cout << n << ' ';\n}",
            "output": "2 4 6 8"
        }
    },
    "unordered_multiset::erase": {
        "description": {
            "texte": "Removes specified elements from the container.References and iterators to the erased elements are invalidated. Other iterators and references are not invalidated.The iterator pos must be valid and dereferenceable. Thus the end() iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos."
        },
        "parametres": "   pos   -   iterator to the element to remove \n   first, last   -   range of elements to remove \n   key   -   key value of the elements to remove \n\n",
        "exemple": {
            "input": "#include <unordered_set>\n#include <iostream>\nint main()\n{\n    std::unordered_multiset<int> c = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(*it % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(int n : c)\n        std::cout << n << ' ';\n}",
            "output": "2 4 6 8"
        }
    },
    "unordered_map::erase": {
        "description": {
            "texte": "Removes specified elements from the container.References and iterators to the erased elements are invalidated. Other iterators and references are not invalidated.The iterator pos must be valid and dereferenceable. Thus the end() iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos."
        },
        "parametres": "   pos   -   iterator to the element to remove \n   first, last   -   range of elements to remove \n   key   -   key value of the elements to remove \n\n",
        "exemple": {
            "input": "#include <unordered_map>\n#include <iostream>\nint main()\n{\n    std::unordered_map<int, std::string> c = {{1, \"one\"}, {2, \"two\"}, {3, \"three\"},\n                                    {4, \"four\"}, {5, \"five\"}, {6, \"six\"}};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(it->first % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(auto& p : c)\n        std::cout << p.second << ' ';\n}",
            "output": "two four six"
        }
    },
    "unordered_multimap::erase": {
        "description": {
            "texte": "Removes specified elements from the container.References and iterators to the erased elements are invalidated. Other iterators and references are not invalidated.The iterator pos must be valid and dereferenceable. Thus the end() iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos."
        },
        "parametres": "   pos   -   iterator to the element to remove \n   first, last   -   range of elements to remove \n   key   -   key value of the elements to remove \n\n",
        "exemple": {
            "input": "#include <unordered_map>\n#include <iostream>\nint main()\n{\n    std::unordered_multimap<int, std::string> c = {{1, \"one\"}, {2, \"two\"}, {3, \"three\"},\n                                    {4, \"four\"}, {5, \"five\"}, {6, \"six\"}};\n    // erase all odd numbers from c\n    for(auto it = c.begin(); it != c.end(); )\n        if(it->first % 2 == 1)\n            it = c.erase(it);\n        else\n            ++it;\n    for(auto& p : c)\n        std::cout << p.second << ' ';\n}",
            "output": "two four six"
        }
    },
    "forward_list::push_front": {
        "description": {
            "texte": "Prepends the given element value to the beginning of the container.No iterators or references are invalidated."
        },
        "parametres": "   value   -   the value of the element to prepend \n\n"
    },
    "list::push_front": {
        "description": {
            "texte": "Prepends the given element value to the beginning of the container.No iterators or references are invalidated."
        },
        "parametres": "   value   -   the value of the element to prepend \n\n"
    },
    "deque::emplace_front": {
        "description": {
            "texte": "Inserts a new element to the beginning of the container. The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place at the location provided by the container. The arguments args... are forwarded to the constructor as std::forward<Args>(args)....All iterators, including the past-the-end iterator, are invalidated. No references are invalidated."
        },
        "parametres": "   args   -   arguments to forward to the constructor of the element \n   Type requirements \n   -T (the container's element type) must meet the requirements of EmplaceConstructible. \n\n"
    },
    "forward_list::emplace_front": {
        "description": {
            "texte": "Inserts a new element to the beginning of the container. The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place at the location provided by the container. The arguments args... are forwarded to the constructor as std::forward<Args>(args)....No iterators or references are invalidated."
        },
        "parametres": "   args   -   arguments to forward to the constructor of the element \n   Type requirements \n   -T (the container's element type) must meet the requirements of EmplaceConstructible. \n\n"
    },
    "list::emplace_front": {
        "description": {
            "texte": "Inserts a new element to the beginning of the container. The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place at the location provided by the container. The arguments args... are forwarded to the constructor as std::forward<Args>(args)....No iterators or references are invalidated."
        },
        "parametres": "   args   -   arguments to forward to the constructor of the element \n   Type requirements \n   -T (the container's element type) must meet the requirements of EmplaceConstructible. \n\n"
    },
    "forward_list::pop_front": {
        "description": {
            "texte": "Removes the first element of the container. If there are no elements in the container, the behavior is undefined.References and iterators to the erased element are invalidated."
        }
    },
    "list::pop_front": {
        "description": {
            "texte": "Removes the first element of the container. If there are no elements in the container, the behavior is undefined.References and iterators to the erased element are invalidated."
        }
    },
    "queue::pop": {
        "description": {
            "texte": "Removes an element from the front of the queue. Effectively calls c.pop_front()."
        }
    },
    "priority_queue::pop": {
        "description": {
            "texte": "Removes the top element from the priority queue. Effectively calls std::pop_heap(c.begin(), c.end(), comp); c.pop_back();"
        }
    },
    "deque::push_back": {
        "description": {
            "texte": "Appends the given element value to the end of the container.All iterators, including the past-the-end iterator, are invalidated. No references are invalidated."
        },
        "parametres": "   value   -   the value of the element to append \n   Type requirements \n   -T must meet the requirements of CopyInsertable in order to use overload (1). \n   -T must meet the requirements of MoveInsertable in order to use overload (2). \n\n",
        "exemple": {
            "input": "#include <deque>\n#include <iostream>\n#include <iomanip>\n \nint main()\n{\n    std::deque<std::string> numbers;\n \n    numbers.push_back(\"abc\");\n    std::string s = \"def\";\n    numbers.push_back(std::move(s));\n \n    std::cout << \"deque holds: \";\n    for (auto&& i : numbers) std::cout << std::quoted(i) << ' ';\n    std::cout << \"\\nMoved-from string holds \" << std::quoted(s) << '\\n';\n}",
            "output": "deque holds: \"abc\" \"def\" \nMoved-from string holds \"\""
        }
    },
    "list::push_back": {
        "description": {
            "texte": "Appends the given element value to the end of the container.No iterators or references are invalidated."
        },
        "parametres": "   value   -   the value of the element to append \n   Type requirements \n   -T must meet the requirements of CopyInsertable in order to use overload (1). \n   -T must meet the requirements of MoveInsertable in order to use overload (2). \n\n",
        "exemple": {
            "input": "#include <list>\n#include <iostream>\n#include <iomanip>\n \nint main()\n{\n    std::list<std::string> numbers;\n \n    numbers.push_back(\"abc\");\n    std::string s = \"def\";\n    numbers.push_back(std::move(s));\n \n    std::cout << \"list holds: \";\n    for (auto&& i : numbers) std::cout << std::quoted(i) << ' ';\n    std::cout << \"\\nMoved-from string holds \" << std::quoted(s) << '\\n';\n}",
            "output": "list holds: \"abc\" \"def\" \nMoved-from string holds \"\""
        }
    },
    "stack::push": {
        "description": {
            "texte": "Pushes the given element value to the top of the stack."
        },
        "parametres": "   value   -   the value of the element to push \n\n"
    },
    "queue::push": {
        "description": {
            "texte": "Pushes the given element value to the end of the queue."
        },
        "parametres": "   value   -   the value of the element to push \n\n"
    },
    "priority_queue::push": {
        "description": {
            "texte": "Pushes the given element value to the priority queue."
        },
        "parametres": "   value   -   the value of the element to push \n\n"
    },
    "vector::emplace_back": {
        "description": {
            "texte": "Appends a new element to the end of the container. The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place at the location provided by the container. The arguments args... are forwarded to the constructor as std::forward<Args>(args)....If the new size() is greater than capacity() then all iterators and references (including the past-the-end iterator) are invalidated. Otherwise only the past-the-end iterator is invalidated."
        },
        "parametres": "   args   -   arguments to forward to the constructor of the element \n   Type requirements \n   -T (the container's element type) must meet the requirements of MoveInsertable and EmplaceConstructible. \n\n",
        "exemple": {
            "input": "#include <vector>\n#include <string>\n#include <iostream>\n \nstruct President\n{\n    std::string name;\n    std::string country;\n    int year;\n \n    President(std::string p_name, std::string p_country, int p_year)\n        : name(std::move(p_name)), country(std::move(p_country)), year(p_year)\n    {\n        std::cout << \"I am being constructed.\\n\";\n    }\n    President(President&& other)\n        : name(std::move(other.name)), country(std::move(other.country)), year(other.year)\n    {\n        std::cout << \"I am being moved.\\n\";\n    }\n    President& operator=(const President& other) = default;\n};\n \nint main()\n{\n    std::vector<President> elections;\n    std::cout << \"emplace_back:\\n\";\n    elections.emplace_back(\"Nelson Mandela\", \"South Africa\", 1994);\n \n    std::vector<President> reElections;\n    std::cout << \"\\npush_back:\\n\";\n    reElections.push_back(President(\"Franklin Delano Roosevelt\", \"the USA\", 1936));\n \n    std::cout << \"\\nContents:\\n\";\n    for (President const& president: elections) {\n        std::cout << president.name << \" was elected president of \"\n                  << president.country << \" in \" << president.year << \".\\n\";\n    }\n    for (President const& president: reElections) {\n        std::cout << president.name << \" was re-elected president of \"\n                  << president.country << \" in \" << president.year << \".\\n\";\n    }\n}",
            "output": "emplace_back:\nI am being constructed.\n \npush_back:\nI am being constructed.\nI am being moved.\n \nContents:\nNelson Mandela was elected president of South Africa in 1994.\nFranklin Delano Roosevelt was re-elected president of the USA in 1936."
        }
    },
    "deque::emplace_back": {
        "description": {
            "texte": "Appends a new element to the end of the container. The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place at the location provided by the container. The arguments args... are forwarded to the constructor as std::forward<Args>(args)....All iterators, including the past-the-end iterator, are invalidated. No references are invalidated."
        },
        "parametres": "   args   -   arguments to forward to the constructor of the element \n   Type requirements \n   -T (the container's element type) must meet the requirements of EmplaceConstructible. \n\n",
        "exemple": {
            "input": "#include <deque>\n#include <string>\n#include <iostream>\n \nstruct President\n{\n    std::string name;\n    std::string country;\n    int year;\n \n    President(std::string p_name, std::string p_country, int p_year)\n        : name(std::move(p_name)), country(std::move(p_country)), year(p_year)\n    {\n        std::cout << \"I am being constructed.\\n\";\n    }\n    President(President&& other)\n        : name(std::move(other.name)), country(std::move(other.country)), year(other.year)\n    {\n        std::cout << \"I am being moved.\\n\";\n    }\n    President& operator=(const President& other) = default;\n};\n \nint main()\n{\n    std::deque<President> elections;\n    std::cout << \"emplace_back:\\n\";\n    elections.emplace_back(\"Nelson Mandela\", \"South Africa\", 1994);\n \n    std::deque<President> reElections;\n    std::cout << \"\\npush_back:\\n\";\n    reElections.push_back(President(\"Franklin Delano Roosevelt\", \"the USA\", 1936));\n \n    std::cout << \"\\nContents:\\n\";\n    for (President const& president: elections) {\n        std::cout << president.name << \" was elected president of \"\n                  << president.country << \" in \" << president.year << \".\\n\";\n    }\n    for (President const& president: reElections) {\n        std::cout << president.name << \" was re-elected president of \"\n                  << president.country << \" in \" << president.year << \".\\n\";\n    }\n}",
            "output": "emplace_back:\nI am being constructed.\n \npush_back:\nI am being constructed.\nI am being moved.\n \nContents:\nNelson Mandela was elected president of South Africa in 1994.\nFranklin Delano Roosevelt was re-elected president of the USA in 1936."
        }
    },
    "list::emplace_back": {
        "description": {
            "texte": "Appends a new element to the end of the container. The element is constructed through std::allocator_traits::construct, which typically uses placement-new to construct the element in-place at the location provided by the container. The arguments args... are forwarded to the constructor as std::forward<Args>(args)....No iterators or references are invalidated."
        },
        "parametres": "   args   -   arguments to forward to the constructor of the element \n   Type requirements \n   -T (the container's element type) must meet the requirements of EmplaceConstructible. \n\n",
        "exemple": {
            "input": "#include <list>\n#include <string>\n#include <iostream>\n \nstruct President\n{\n    std::string name;\n    std::string country;\n    int year;\n \n    President(std::string p_name, std::string p_country, int p_year)\n        : name(std::move(p_name)), country(std::move(p_country)), year(p_year)\n    {\n        std::cout << \"I am being constructed.\\n\";\n    }\n    President(President&& other)\n        : name(std::move(other.name)), country(std::move(other.country)), year(other.year)\n    {\n        std::cout << \"I am being moved.\\n\";\n    }\n    President& operator=(const President& other) = default;\n};\n \nint main()\n{\n    std::list<President> elections;\n    std::cout << \"emplace_back:\\n\";\n    elections.emplace_back(\"Nelson Mandela\", \"South Africa\", 1994);\n \n    std::list<President> reElections;\n    std::cout << \"\\npush_back:\\n\";\n    reElections.push_back(President(\"Franklin Delano Roosevelt\", \"the USA\", 1936));\n \n    std::cout << \"\\nContents:\\n\";\n    for (President const& president: elections) {\n        std::cout << president.name << \" was elected president of \"\n                  << president.country << \" in \" << president.year << \".\\n\";\n    }\n    for (President const& president: reElections) {\n        std::cout << president.name << \" was re-elected president of \"\n                  << president.country << \" in \" << president.year << \".\\n\";\n    }\n}",
            "output": "emplace_back:\nI am being constructed.\n \npush_back:\nI am being constructed.\nI am being moved.\n \nContents:\nNelson Mandela was elected president of South Africa in 1994.\nFranklin Delano Roosevelt was re-elected president of the USA in 1936."
        }
    },
    "stack::emplace": {
        "description": {
            "texte": "Pushes a new element on top of the stack. The element is constructed in-place, i.e. no copy or move operations are performed. The constructor of the element is called with exactly the same arguments as supplied to the function.Effectively calls c.emplace_back(std::forward<Args>(args)...);"
        },
        "parametres": "   args   -   arguments to forward to the constructor of the element \n\n"
    },
    "queue::emplace": {
        "description": {
            "texte": "Pushes a new element to the end of the queue. The element is constructed in-place, i.e. no copy or move operations are performed. The constructor of the element is called with exactly the same arguments as supplied to the function.Effectively calls c.emplace_back(std::forward<Args>(args)...);"
        },
        "parametres": "   args   -   arguments to forward to the constructor of the element \n\n"
    },
    "priority_queue::emplace": {
        "description": {
            "texte": "Pushes a new element to the priority queue. The element is constructed in-place, i.e. no copy or move operations are performed. The constructor of the element is called with exactly the same arguments as supplied to the function.Effectively calls c.emplace_back(std::forward<Args>(args)...); std::push_heap(c.begin(), c.end(), comp);"
        },
        "parametres": "   args   -   arguments to forward to the constructor of the element \n\n"
    },
    "deque::pop_back": {
        "description": {
            "texte": "Removes the last element of the container.Calling pop_back on an empty container is undefined."
        },
        "exemple": {
            "input": "#include <deque>\n#include <iostream>\n \ntemplate<typename T>\nvoid print(T const & xs)\n{\n    std::cout << \"[ \";\n    for(auto const & x : xs) {\n        std::cout << x << ' ';\n    }\n    std::cout << \"]\\n\";\n}\n \nint main()\n{\n    std::deque<int> numbers;\n \n    print(numbers); \n \n    numbers.push_back(5);\n    numbers.push_back(3);\n    numbers.push_back(4);\n \n    print(numbers); \n \n    numbers.pop_back();\n \n    print(numbers); \n}",
            "output": "[ ]\n[ 5 3 4 ]\n[ 5 3 ]"
        }
    },
    "list::pop_back": {
        "description": {
            "texte": "Removes the last element of the container.Calling pop_back on an empty container is undefined.References and iterators to the erased element are invalidated."
        },
        "exemple": {
            "input": "#include <list>\n#include <iostream>\n \ntemplate<typename T>\nvoid print(T const & xs)\n{\n    std::cout << \"[ \";\n    for(auto const & x : xs) {\n        std::cout << x << ' ';\n    }\n    std::cout << \"]\\n\";\n}\n \nint main()\n{\n    std::list<int> numbers;\n \n    print(numbers); \n \n    numbers.push_back(5);\n    numbers.push_back(3);\n    numbers.push_back(4);\n \n    print(numbers); \n \n    numbers.pop_back();\n \n    print(numbers); \n}",
            "output": "[ ]\n[ 5 3 4 ]\n[ 5 3 ]"
        }
    },
    "stack::pop": {
        "description": {
            "texte": "Removes the top element from the stack. Effectively calls c.pop_back()."
        }
    },
    "array::swap": {
        "description": {
            "texte": "Exchanges the contents of the container with those of other. Does not cause iterators and references to associate with the other container."
        },
        "parametres": "   other   -   container to exchange the contents with \n\n"
    },
    "vector::swap": {
        "description": {
            "texte": "Swaps the contents of x and y."
        },
        "parametres": "   x   -   std::vector<bool>::reference value to swap with y \n   y   -   std::vector<bool>::reference value to swap with x \n\n",
        "exemple": {
            "input": "#include <vector>\n#include <iostream>\n \nint main()\n{\n    std::vector<bool> vb1{ 1,0 };\n \n    for (auto e : vb1) { std::cout << e << \" \"; }\n    std::cout << '\\n';\n \n    vb1.swap(vb1[0], vb1[1]);\n \n    for (auto e : vb1) { std::cout << e << \" \"; }\n}",
            "output": "1 0 \n0 1"
        }
    },
    "deque::swap": {
        "description": {
            "texte": "Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.All iterators and references remain valid. The past-the-end iterator is invalidated."
        },
        "parametres": "   other   -   container to exchange the contents with \n\n"
    },
    "forward_list::swap": {
        "description": {
            "texte": "Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.All iterators and references remain valid. It is unspecified whether an iterator holding the past-the-end value in this container will refer to this or the other container after the operation."
        },
        "parametres": "   other   -   container to exchange the contents with \n\n"
    },
    "list::swap": {
        "description": {
            "texte": "Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.All iterators and references remain valid. It is unspecified whether an iterator holding the past-the-end value in this container will refer to this or the other container after the operation."
        },
        "parametres": "   other   -   container to exchange the contents with \n\n"
    },
    "set::swap": {
        "description": {
            "texte": "Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.All iterators and references remain valid. The past-the-end iterator is invalidated.The Pred objects must be Swappable, and they are exchanged using unqualified call to non-member swap."
        },
        "parametres": "   other   -   container to exchange the contents with \n\n"
    },
    "multiset::swap": {
        "description": {
            "texte": "Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.All iterators and references remain valid. The past-the-end iterator is invalidated.The Pred objects must be Swappable, and they are exchanged using unqualified call to non-member swap."
        },
        "parametres": "   other   -   container to exchange the contents with \n\n"
    },
    "map::swap": {
        "description": {
            "texte": "Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.All iterators and references remain valid. The past-the-end iterator is invalidated.The Pred objects must be Swappable, and they are exchanged using unqualified call to non-member swap."
        },
        "parametres": "   other   -   container to exchange the contents with \n\n"
    },
    "multimap::swap": {
        "description": {
            "texte": "Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.All iterators and references remain valid. The past-the-end iterator is invalidated.The Pred objects must be Swappable, and they are exchanged using unqualified call to non-member swap."
        },
        "parametres": "   other   -   container to exchange the contents with \n\n"
    },
    "unordered_set::swap": {
        "description": {
            "texte": "Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.All iterators and references remain valid. The past-the-end iterator is invalidated.The Hash and KeyEqual objects must be Swappable, and they are exchanged using unqualified calls to non-member swap."
        },
        "parametres": "   other   -   container to exchange the contents with \n\n"
    },
    "unordered_multiset::swap": {
        "description": {
            "texte": "Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.All iterators and references remain valid. The past-the-end iterator is invalidated.The Hash and KeyEqual objects must be Swappable, and they are exchanged using unqualified calls to non-member swap."
        },
        "parametres": "   other   -   container to exchange the contents with \n\n"
    },
    "unordered_map::swap": {
        "description": {
            "texte": "Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.All iterators and references remain valid. The past-the-end iterator is invalidated.The Hash and KeyEqual objects must be Swappable, and they are exchanged using unqualified calls to non-member swap."
        },
        "parametres": "   other   -   container to exchange the contents with \n\n"
    },
    "unordered_multimap::swap": {
        "description": {
            "texte": "Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.All iterators and references remain valid. The past-the-end iterator is invalidated.The Hash and KeyEqual objects must be Swappable, and they are exchanged using unqualified calls to non-member swap."
        },
        "parametres": "   other   -   container to exchange the contents with \n\n"
    },
    "stack::swap": {
        "description": {
            "texte": "Exchanges the contents of the container adaptor with those of other. Effectively calls using std::swap; swap(c, other.c);"
        },
        "parametres": "   other   -   container adaptor to exchange the contents with \n\n"
    },
    "queue::swap": {
        "description": {
            "texte": "Exchanges the contents of the container adaptor with those of other. Effectively calls using std::swap; swap(c, other.c);"
        },
        "parametres": "   other   -   container adaptor to exchange the contents with \n\n"
    },
    "priority_queue::swap": {
        "description": {
            "texte": "Exchanges the contents of the container adaptor with those of other. Effectively calls using std::swap; swap(c, other.c); swap(comp, other.comp);"
        },
        "parametres": "   other   -   container adaptor to exchange the contents with \n\n"
    },
    "forward_list::merge": {
        "description": {
            "texte": "Merges two sorted lists into one. The lists should be sorted into ascending order.No elements are copied. The container other becomes empty after the operation. The function does nothing if other refers to the same object as *this. If get_allocator() != other.get_allocator(), the behavior is undefined. No iterators or references become invalidated, except that the iterators of moved elements now refer into *this, not into other. The first version uses operator< to compare the elements, the second version uses the given comparison function comp.This operation is stable: for equivalent elements in the two lists, the elements from *this shall always precede the elements from other, and the order of equivalent elements of *this and other does not change."
        },
        "parametres": "   other   -   another container to merge \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type forward_list<T,Allocator>::const_iterator can be dereferenced and then implicitly converted to both of them. \u200b\n\n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <forward_list>\n \nstd::ostream& operator<<(std::ostream& ostr, const std::forward_list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << \" \" << i;\n    }\n    return ostr;\n}\n \nint main()\n{\n    std::forward_list<int> list1 = { 5,9,0,1,3 };\n    std::forward_list<int> list2 = { 8,7,2,6,4 };\n \n    list1.sort();\n    list2.sort();\n    std::cout << \"list1:  \" << list1 << \"\\n\";\n    std::cout << \"list2:  \" << list2 << \"\\n\";\n    list1.merge(list2);\n    std::cout << \"merged: \" << list1 << \"\\n\";\n}",
            "output": "list1:   0 1 3 5 9\nlist2:   2 4 6 7 8\nmerged:  0 1 2 3 4 5 6 7 8 9"
        }
    },
    "list::merge": {
        "description": {
            "texte": "Merges two sorted lists into one. The lists should be sorted into ascending order.No elements are copied. The container other becomes empty after the operation. The function does nothing if other refers to the same object as *this. If get_allocator() != other.get_allocator(), the behavior is undefined. No iterators or references become invalidated, except that the iterators of moved elements now refer into *this, not into other. The first version uses operator< to compare the elements, the second version uses the given comparison function comp.This operation is stable: for equivalent elements in the two lists, the elements from *this shall always precede the elements from other, and the order of equivalent elements of *this and other does not change."
        },
        "parametres": "   other   -   another container to merge \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type list<T,Allocator>::const_iterator can be dereferenced and then implicitly converted to both of them. \u200b\n\n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <list>\n \nstd::ostream& operator<<(std::ostream& ostr, const std::list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << \" \" << i;\n    }\n    return ostr;\n}\n \nint main()\n{\n    std::list<int> list1 = { 5,9,0,1,3 };\n    std::list<int> list2 = { 8,7,2,6,4 };\n \n    list1.sort();\n    list2.sort();\n    std::cout << \"list1:  \" << list1 << \"\\n\";\n    std::cout << \"list2:  \" << list2 << \"\\n\";\n    list1.merge(list2);\n    std::cout << \"merged: \" << list1 << \"\\n\";\n}",
            "output": "list1:   0 1 3 5 9\nlist2:   2 4 6 7 8\nmerged:  0 1 2 3 4 5 6 7 8 9"
        }
    },
    "set::merge": {
        "description": {
            "texte": "Attempts to extract (\"splice\") each element in source and insert it into *this using the comparison object of *this. If there is an element in *this with key equivalent to the key of an element from source, then that element is not extracted from source. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into *this, not into source.The behavior is undefined if get_allocator() != source.get_allocator()."
        },
        "parametres": "   source   -   compatible container to transfer the nodes from \n\n"
    },
    "multiset::merge": {
        "description": {
            "texte": "Attempts to extract (\"splice\") each element in source and insert it into *this using the comparison object of *this.No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into *this, not into source.The behavior is undefined if get_allocator() != source.get_allocator()."
        },
        "parametres": "   source   -   compatible container to transfer the nodes from \n\n"
    },
    "map::merge": {
        "description": {
            "texte": "Attempts to extract (\"splice\") each element in source and insert it into *this using the comparison object of *this. If there is an element in *this with key equivalent to the key of an element from source, then that element is not extracted from source. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into *this, not into source.The behavior is undefined if get_allocator() != source.get_allocator()."
        },
        "parametres": "   source   -   compatible container to transfer the nodes from \n\n"
    },
    "multimap::merge": {
        "description": {
            "texte": "Attempts to extract (\"splice\") each element in source and insert it into *this using the comparison object of *this.No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into *this, not into source.The behavior is undefined if get_allocator() != source.get_allocator()."
        },
        "parametres": "   source   -   compatible container to transfer the nodes from \n\n"
    },
    "unordered_set::merge": {
        "description": {
            "texte": "Attempts to extract (\"splice\") each element in source and insert it into *this using the hash function and key equality predicate of *this. If there is an element in *this with key equivalent to the key of an element from source, then that element is not extracted from source. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into *this, not into source. Iterators referring to the transferred elements and all iterators referring to *this are invalidated. Iterators to elements remaining in source remain valid.The behavior is undefined if get_allocator() != source.get_allocator()."
        },
        "parametres": "   source   -   compatible container to transfer the nodes from \n\n"
    },
    "unordered_multiset::merge": {
        "description": {
            "texte": "Attempts to extract (\"splice\") each element in source and insert it into *this using the hash function and key equality predicate of *this.No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into *this, not into source. Iterators referring to the transferred elements and all iterators referring to *this are invalidated.The behavior is undefined if get_allocator() != source.get_allocator()."
        },
        "parametres": "   source   -   compatible container to transfer the nodes from \n\n"
    },
    "unordered_map::merge": {
        "description": {
            "texte": "Attempts to extract (\"splice\") each element in source and insert it into *this using the hash function and key equality predicate of *this. If there is an element in *this with key equivalent to the key of an element from source, then that element is not extracted from source. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into *this, not into source. Iterators referring to the transferred elements and all iterators referring to *this are invalidated. Iterators to elements remaining in source remain valid.The behavior is undefined if get_allocator() != source.get_allocator()."
        },
        "parametres": "   source   -   compatible container to transfer the nodes from \n\n"
    },
    "unordered_multimap::merge": {
        "description": {
            "texte": "Attempts to extract (\"splice\") each element in source and insert it into *this using the hash function and key equality predicate of *this.No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into *this, not into source. Iterators referring to the transferred elements and all iterators referring to *this are invalidated.The behavior is undefined if get_allocator() != source.get_allocator()."
        },
        "parametres": "   source   -   compatible container to transfer the nodes from \n\n"
    },
    "set::extract": {
        "description": {
            "texte": "In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed (rebalancing may occur, as with erase()).Extracting a node invalidates the iterators to the extracted element. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container."
        },
        "parametres": "   position   -   a valid iterator into this container \n   x   -   a key to identify the node to be extracted \n\n"
    },
    "multiset::extract": {
        "description": {
            "texte": "In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed (rebalancing may occur, as with erase()).Extracting a node invalidates the iterators to the extracted element. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container."
        },
        "parametres": "   position   -   a valid iterator into this container \n   x   -   a key to identify the node to be extracted \n\n"
    },
    "map::extract": {
        "description": {
            "texte": "In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed (rebalancing may occur, as with erase()).Extracting a node invalidates the iterators to the extracted element. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container."
        },
        "parametres": "   position   -   a valid iterator into this container \n   x   -   a key to identify the node to be extracted \n\n"
    },
    "multimap::extract": {
        "description": {
            "texte": "In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed (rebalancing may occur, as with erase()).Extracting a node invalidates the iterators to the extracted element. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container."
        },
        "parametres": "   position   -   a valid iterator into this container \n   x   -   a key to identify the node to be extracted \n\n"
    },
    "unordered_set::extract": {
        "description": {
            "texte": "In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed. Extracting a node invalidates only the iterators to the extracted element, and preserves the relative order of the elements that are not erased. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container."
        },
        "parametres": "   position   -   a valid iterator into this container \n   x   -   a key to identify the node to be extracted \n\n"
    },
    "unordered_multiset::extract": {
        "description": {
            "texte": "In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed. Extracting a node invalidates only the iterators to the extracted element, and preserves the relative order of the elements that are not erased. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container."
        },
        "parametres": "   position   -   a valid iterator into this container \n   x   -   a key to identify the node to be extracted \n\n"
    },
    "unordered_map::extract": {
        "description": {
            "texte": "In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed. Extracting a node invalidates only the iterators to the extracted element, and preserves the relative order of the elements that are not erased. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container."
        },
        "parametres": "   position   -   a valid iterator into this container \n   x   -   a key to identify the node to be extracted \n\n"
    },
    "unordered_multimap::extract": {
        "description": {
            "texte": "In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed. Extracting a node invalidates only the iterators to the extracted element, and preserves the relative order of the elements that are not erased. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container."
        },
        "parametres": "   position   -   a valid iterator into this container \n   x   -   a key to identify the node to be extracted \n\n"
    },
    "forward_list::splice_after": {
        "description": {
            "texte": "Moves elements from another forward_list to *this.No elements are copied. pos must be either a deferenceable valid iterator into *this or the before_begin() iterator (in particular, end() is not a valid argument for pos). The behavior is undefined if get_allocator() != other.get_allocator(). No iterators or references become invalidated, the iterators to the moved elements now refer into *this, not into other."
        },
        "parametres": "   pos   -   element after which the content will be inserted \n   other   -   another container to move the content from \n   it   -   iterator preceding the iterator to the element to move from other to *this \n   first, last   -   the range of elements to move from other to *this \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <forward_list>\n \nint main()\n{\n    std::forward_list<int> l1 = {1,2,3,4,5};\n    std::forward_list<int> l2 = {10,11,12};\n \n    l2.splice_after(l2.cbegin(), l1, l1.cbegin(), l1.cend());\n    // not equivalent to l2.splice_after(l2.cbegin(), l1);\n \n    for(int n : l1)\n        std::cout << n << ' ';\n    std::cout << '\\n';\n \n    for(int n : l2)\n        std::cout << n << ' ';\n    std::cout << '\\n';\n}",
            "output": "1\n10 2 3 4 5 11 12"
        }
    },
    "list::splice": {
        "description": {
            "texte": "Transfers elements from one list to another.No elements are copied or moved, only the internal pointers of the list nodes are re-pointed. The behavior is undefined if: get_allocator() != other.get_allocator(). No iterators or references become invalidated, the iterators to moved elements remain valid, but now refer into *this, not into other."
        },
        "parametres": "   pos   -   element before which the content will be inserted \n   other   -   another container to transfer the content from \n   it   -   the element to transfer from other to *this \n   first, last   -   the range of elements to transfer from other to *this \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <list>\n \nstd::ostream& operator<<(std::ostream& ostr, const std::list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << \" \" << i;\n    }\n    return ostr;\n}\n \nint main ()\n{\n    std::list<int> list1 = { 1, 2, 3, 4, 5 };\n    std::list<int> list2 = { 10, 20, 30, 40, 50 };\n \n    auto it = list1.begin();\n    std::advance(it, 2);\n \n    list1.splice(it, list2);\n \n    std::cout << \"list1: \" << list1 << \"\\n\";\n    std::cout << \"list2: \" << list2 << \"\\n\";\n \n    list2.splice(list2.begin(), list1, it, list1.end());\n \n    std::cout << \"list1: \" << list1 << \"\\n\";\n    std::cout << \"list2: \" << list2 << \"\\n\";\n}",
            "output": "list1:  1 2 10 20 30 40 50 3 4 5\nlist2: \nlist1:  1 2 10 20 30 40 50\nlist2:  3 4 5"
        }
    },
    "forward_list::remove, remove_if": {
        "description": {
            "texte": "Removes all elements satisfying specific criteria. The first version removes all elements that are equal to value, the second version removes all elements for which predicate p returns true."
        },
        "parametres": "   value   -   value of the elements to remove \n   p   -   unary predicate which returns \u200btrue if the element should be removed.  The expression p(v) must be convertible to bool for every argument v of type (possibly const) T, regardless of value category, and must not modify v. Thus, a parameter type of T&is not allowed, nor is T unless for T a move is equivalent to a copy (since C++11). \u200b\n\n\n",
        "exemple": {
            "input": "#include <forward_list>\n#include <iostream>\n \nint main()\n{\n    std::forward_list<int> l = { 1,100,2,3,10,1,11,-1,12 };\n \n    l.remove(1); // remove both elements equal to 1\n    l.remove_if([](int n){ return n > 10; }); // remove all elements greater than 10\n \n    for (int n : l) {\n        std::cout << n << ' '; \n    }\n    std::cout << '\\n';\n}",
            "output": "2 3 10 -1"
        }
    },
    "list::remove, remove_if": {
        "description": {
            "texte": "Removes all elements satisfying specific criteria. The first version removes all elements that are equal to value, the second version removes all elements for which predicate p returns true."
        },
        "parametres": "   value   -   value of the elements to remove \n   p   -   unary predicate which returns \u200btrue if the element should be removed.  The expression p(v) must be convertible to bool for every argument v of type (possibly const) T, regardless of value category, and must not modify v. Thus, a parameter type of T&is not allowed, nor is T unless for T a move is equivalent to a copy (since C++11). \u200b\n\n\n",
        "exemple": {
            "input": "#include <list>\n#include <iostream>\n \nint main()\n{\n    std::list<int> l = { 1,100,2,3,10,1,11,-1,12 };\n \n    l.remove(1); // remove both elements equal to 1\n    l.remove_if([](int n){ return n > 10; }); // remove all elements greater than 10\n \n    for (int n : l) {\n        std::cout << n << ' '; \n    }\n    std::cout << '\\n';\n}",
            "output": "2 3 10 -1"
        }
    },
    "forward_list::reverse": {
        "description": {
            "texte": "Reverses the order of the elements in the container. No references or iterators become invalidated."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <forward_list>\n \nstd::ostream& operator<<(std::ostream& ostr, const std::forward_list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << \" \" << i;\n    }\n    return ostr;\n}\n \nint main()\n{\n    std::forward_list<int> list = { 8,7,5,9,0,1,3,2,6,4 };\n \n    std::cout << \"before:     \" << list << \"\\n\";\n    list.sort();\n    std::cout << \"ascending:  \" << list << \"\\n\";\n    list.reverse();\n    std::cout << \"descending: \" << list << \"\\n\";\n}",
            "output": "before:      8 7 5 9 0 1 3 2 6 4\nascending:   0 1 2 3 4 5 6 7 8 9\ndescending:  9 8 7 6 5 4 3 2 1 0"
        }
    },
    "list::reverse": {
        "description": {
            "texte": "Reverses the order of the elements in the container. No references or iterators become invalidated."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <list>\n \nstd::ostream& operator<<(std::ostream& ostr, const std::list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << \" \" << i;\n    }\n    return ostr;\n}\n \nint main()\n{\n    std::list<int> list = { 8,7,5,9,0,1,3,2,6,4 };\n \n    std::cout << \"before:     \" << list << \"\\n\";\n    list.sort();\n    std::cout << \"ascending:  \" << list << \"\\n\";\n    list.reverse();\n    std::cout << \"descending: \" << list << \"\\n\";\n}",
            "output": "before:      8 7 5 9 0 1 3 2 6 4\nascending:   0 1 2 3 4 5 6 7 8 9\ndescending:  9 8 7 6 5 4 3 2 1 0"
        }
    },
    "forward_list::unique": {
        "description": {
            "texte": "Removes all consecutive duplicate elements from the container. Only the first element in each group of equal elements is left. The first version uses operator== to compare the elements, the second version uses the given binary predicate p."
        },
        "parametres": "   p   -   binary predicate which returns \u200btrue if the elements should be treated as equal.  The signature of the predicate function should be equivalent to the following:\n bool pred(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type forward_list<T,Allocator>::const_iterator can be dereferenced and then implicitly converted to both of them. \u200b\n\n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <forward_list>\n \nint main()\n{\n  std::forward_list<int> x = {1, 2, 2, 3, 3, 2, 1, 1, 2};\n \n  std::cout << \"contents before:\";\n  for (auto val : x)\n    std::cout << ' ' << val;\n  std::cout << '\\n';\n \n  x.unique();\n  std::cout << \"contents after unique():\";\n  for (auto val : x)\n    std::cout << ' ' << val;\n  std::cout << '\\n';\n \n  return 0;\n}",
            "output": "contents before: 1 2 2 3 3 2 1 1 2\ncontents after unique(): 1 2 3 2 1 2"
        }
    },
    "list::unique": {
        "description": {
            "texte": "Removes all consecutive duplicate elements from the container. Only the first element in each group of equal elements is left. The first version uses operator== to compare the elements, the second version uses the given binary predicate p."
        },
        "parametres": "   p   -   binary predicate which returns \u200btrue if the elements should be treated as equal.  The signature of the predicate function should be equivalent to the following:\n bool pred(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type list<T,Allocator>::const_iterator can be dereferenced and then implicitly converted to both of them. \u200b\n\n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <list>\n \nint main()\n{\n  std::list<int> x = {1, 2, 2, 3, 3, 2, 1, 1, 2};\n \n  std::cout << \"contents before:\";\n  for (auto val : x)\n    std::cout << ' ' << val;\n  std::cout << '\\n';\n \n  x.unique();\n  std::cout << \"contents after unique():\";\n  for (auto val : x)\n    std::cout << ' ' << val;\n  std::cout << '\\n';\n \n  return 0;\n}",
            "output": "contents before: 1 2 2 3 3 2 1 1 2\ncontents after unique(): 1 2 3 2 1 2"
        }
    },
    "forward_list::sort": {
        "description": {
            "texte": "Sorts the elements in ascending order. The order of equal elements is preserved. The first version uses operator< to compare the elements, the second version uses the given comparison function comp.If an exception is thrown, the order of elements in *this is unspecified."
        },
        "parametres": "   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type forward_list<T,Allocator>::const_iterator can be dereferenced and then implicitly converted to both of them. \u200b\n\n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <functional>\n#include <forward_list>\n \nstd::ostream& operator<<(std::ostream& ostr, const std::forward_list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << \" \" << i;\n    }\n    return ostr;\n}\n \nint main()\n{\n    std::forward_list<int> list = { 8,7,5,9,0,1,3,2,6,4 };\n \n    std::cout << \"before:     \" << list << \"\\n\";\n    list.sort();\n    std::cout << \"ascending:  \" << list << \"\\n\";\n    list.sort(std::greater<int>());\n    std::cout << \"descending: \" << list << \"\\n\";\n}",
            "output": "before:      8 7 5 9 0 1 3 2 6 4\nascending:   0 1 2 3 4 5 6 7 8 9\ndescending:  9 8 7 6 5 4 3 2 1 0"
        }
    },
    "list::sort": {
        "description": {
            "texte": "Sorts the elements in ascending order. The order of equal elements is preserved. The first version uses operator< to compare the elements, the second version uses the given comparison function comp.If an exception is thrown, the order of elements in *this is unspecified."
        },
        "parametres": "   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type list<T,Allocator>::const_iterator can be dereferenced and then implicitly converted to both of them. \u200b\n\n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <functional>\n#include <list>\n \nstd::ostream& operator<<(std::ostream& ostr, const std::list<int>& list)\n{\n    for (auto &i : list) {\n        ostr << \" \" << i;\n    }\n    return ostr;\n}\n \nint main()\n{\n    std::list<int> list = { 8,7,5,9,0,1,3,2,6,4 };\n \n    std::cout << \"before:     \" << list << \"\\n\";\n    list.sort();\n    std::cout << \"ascending:  \" << list << \"\\n\";\n    list.sort(std::greater<int>());\n    std::cout << \"descending: \" << list << \"\\n\";\n}",
            "output": "before:      8 7 5 9 0 1 3 2 6 4\nascending:   0 1 2 3 4 5 6 7 8 9\ndescending:  9 8 7 6 5 4 3 2 1 0"
        }
    },
    "set::count": {
        "description": {
            "texte": "Returns the number of elements with key that compares equivalent to the specified argument, which is either 1 or 0 since this container does not allow duplicates."
        },
        "parametres": "   key   -   key value of the elements to count \n   x   -   alternative value to compare to the keys \n\n"
    },
    "multiset::count": {
        "description": {
            "texte": "Returns the number of elements with key that compares equivalent to the specified argument."
        },
        "parametres": "   key   -   key value of the elements to count \n   x   -   alternative value to compare to the keys \n\n"
    },
    "map::count": {
        "description": {
            "texte": "Returns the number of elements with key that compares equivalent to the specified argument, which is either 1 or 0 since this container does not allow duplicates."
        },
        "parametres": "   key   -   key value of the elements to count \n   x   -   alternative value to compare to the keys \n\n"
    },
    "multimap::count": {
        "description": {
            "texte": "Returns the number of elements with key that compares equivalent to the specified argument."
        },
        "parametres": "   key   -   key value of the elements to count \n   x   -   alternative value to compare to the keys \n\n"
    },
    "set::find": {
        "description": {
            "texte": "Iterator to an element with key equivalent to key. If no such element is found, past-the-end (see end()) iterator is returned."
        },
        "parametres": "   key   -   key value of the element to search for \n   x   -   a value of any type that can be transparently compared with a key \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <set>\nstruct FatKey   { int x; int data[1000]; };\nstruct LightKey { int x; };\nbool operator<(const FatKey& fk, const LightKey& lk) { return fk.x < lk.x; }\nbool operator<(const LightKey& lk, const FatKey& fk) { return lk.x < fk.x; }\nbool operator<(const FatKey& fk1, const FatKey& fk2) { return fk1.x < fk2.x; }\nint main()\n{  \n// simple comparison demo\n    std::set<int> example = {1, 2, 3, 4};\n \n    auto search = example.find(2);\n    if (search != example.end()) {\n        std::cout << \"Found \" << (*search) << '\\n';\n    } else {\n        std::cout << \"Not found\\n\";\n    }\n \n// transparent comparison demo\n    std::set<FatKey, std::less<>> example2 = { {1, {} }, {2, {} }, {3, {} }, {4, {} } };\n \n    LightKey lk = {2};\n    auto search2 = example2.find(lk);\n    if (search2 != example2.end()) {\n        std::cout << \"Found \" << search2->x << '\\n';\n    } else {\n        std::cout << \"Not found\\n\";\n    }\n}",
            "output": "Found 2\nFound 2"
        }
    },
    "multiset::find": {
        "description": {
            "texte": "Iterator to an element with key equivalent to key. If no such element is found, past-the-end (see end()) iterator is returned."
        },
        "parametres": "   key   -   key value of the element to search for \n   x   -   a value of any type that can be transparently compared with a key \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <set>\nstruct FatKey   { int x; int data[1000]; };\nstruct LightKey { int x; };\nbool operator<(const FatKey& fk, const LightKey& lk) { return fk.x < lk.x; }\nbool operator<(const LightKey& lk, const FatKey& fk) { return lk.x < fk.x; }\nbool operator<(const FatKey& fk1, const FatKey& fk2) { return fk1.x < fk2.x; }\nint main()\n{  \n// simple comparison demo\n    std::multiset<int> example = {1, 2, 3, 4};\n \n    auto search = example.find(2);\n    if (search != example.end()) {\n        std::cout << \"Found \" << (*search) << '\\n';\n    } else {\n        std::cout << \"Not found\\n\";\n    }\n \n// transparent comparison demo\n    std::multiset<FatKey, std::less<>> example2 = { {1, {} }, {2, {} }, {3, {} }, {4, {} } };\n \n    LightKey lk = {2};\n    auto search2 = example2.find(lk);\n    if (search2 != example2.end()) {\n        std::cout << \"Found \" << search2->x << '\\n';\n    } else {\n        std::cout << \"Not found\\n\";\n    }\n}",
            "output": "Found 2\nFound 2"
        }
    },
    "map::find": {
        "description": {
            "texte": "Iterator to an element with key equivalent to key. If no such element is found, past-the-end (see end()) iterator is returned."
        },
        "parametres": "   key   -   key value of the element to search for \n   x   -   a value of any type that can be transparently compared with a key \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <map>\nstruct FatKey   { int x; int data[1000]; };\nstruct LightKey { int x; };\nbool operator<(const FatKey& fk, const LightKey& lk) { return fk.x < lk.x; }\nbool operator<(const LightKey& lk, const FatKey& fk) { return lk.x < fk.x; }\nbool operator<(const FatKey& fk1, const FatKey& fk2) { return fk1.x < fk2.x; }\nint main()\n{  \n// simple comparison demo\n    std::map<int,char> example = {{1,'a'},{2,'b'}};\n \n    auto search = example.find(2);\n    if (search != example.end()) {\n        std::cout << \"Found \" << search->first << \" \" << search->second << '\\n';\n    } else {\n        std::cout << \"Not found\\n\";\n    }\n \n// transparent comparison demo\n    std::map<FatKey, char, std::less<>> example2 = { { {1, {} },'a'}, { {2, {} },'b'} };\n \n    LightKey lk = {2};\n    auto search2 = example2.find(lk);\n    if (search2 != example2.end()) {\n        std::cout << \"Found \" << search2->first.x << \" \" << search2->second << '\\n';\n    } else {\n        std::cout << \"Not found\\n\";\n    }\n}",
            "output": "Found 2 b\nFound 2 b"
        }
    },
    "multimap::find": {
        "description": {
            "texte": "Iterator to an element with key equivalent to key. If no such element is found, past-the-end (see end()) iterator is returned."
        },
        "parametres": "   key   -   key value of the element to search for \n   x   -   a value of any type that can be transparently compared with a key \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <map>\nstruct FatKey   { int x; int data[1000]; };\nstruct LightKey { int x; };\nbool operator<(const FatKey& fk, const LightKey& lk) { return fk.x < lk.x; }\nbool operator<(const LightKey& lk, const FatKey& fk) { return lk.x < fk.x; }\nbool operator<(const FatKey& fk1, const FatKey& fk2) { return fk1.x < fk2.x; }\nint main()\n{  \n// simple comparison demo\n    std::multimap<int,char> example = {{1,'a'},{2,'b'}};\n \n    auto search = example.find(2);\n    if (search != example.end()) {\n        std::cout << \"Found \" << search->first << \" \" << search->second << '\\n';\n    } else {\n        std::cout << \"Not found\\n\";\n    }\n \n// transparent comparison demo\n    std::multimap<FatKey, char, std::less<>> example2 = { { {1, {} },'a'}, { {2, {} },'b'} };\n \n    LightKey lk = {2};\n    auto search2 = example2.find(lk);\n    if (search2 != example2.end()) {\n        std::cout << \"Found \" << search2->first.x << \" \" << search2->second << '\\n';\n    } else {\n        std::cout << \"Not found\\n\";\n    }\n}",
            "output": "Found 2 b\nFound 2 b"
        }
    },
    "set::contains": {
        "description": {
            "texte": "true if there is such an element, otherwise false."
        },
        "parametres": "   key   -   key value of the element to search for \n   x   -   a value of any type that can be transparently compared with a key \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <set>\n \nint main()\n{\n    std::set<int> example = {1, 2, 3, 4};\n \n    if(example.contains(2)) {\n        std::cout << \"Found\\n\";\n    } else {\n        std::cout << \"Not found\\n\";\n    }\n}",
            "output": "Found"
        }
    },
    "multiset::contains": {
        "description": {
            "texte": "true if there is such an element, otherwise false."
        },
        "parametres": "   key   -   key value of the element to search for \n   x   -   a value of any type that can be transparently compared with a key \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <set>\n \nint main()\n{\n    std::multiset<int> example = {1, 2, 3, 4};\n \n    if(example.contains(2)) {\n        std::cout << \"Found\\n\";\n    } else {\n        std::cout << \"Not found\\n\";\n    }\n}",
            "output": "Found"
        }
    },
    "map::contains": {
        "description": {
            "texte": "true if there is such an element, otherwise false."
        },
        "parametres": "   key   -   key value of the element to search for \n   x   -   a value of any type that can be transparently compared with a key \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <map>\n \nint main()\n{\n    std::map<int,char> example = {{1,'a'},{2,'b'}};\n \n    if(example.contains(2)) {\n        std::cout << \"Found\\n\";\n    } else {\n        std::cout << \"Not found\\n\";\n    }\n}",
            "output": "Found"
        }
    },
    "multimap::contains": {
        "description": {
            "texte": "true if there is such an element, otherwise false."
        },
        "parametres": "   key   -   key value of the element to search for \n   x   -   a value of any type that can be transparently compared with a key \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <map>\n \nint main()\n{\n    std::multimap<int,char> example = {{1,'a'},{2,'b'}};\n \n    if(example.contains(2)) {\n        std::cout << \"Found\\n\";\n    } else {\n        std::cout << \"Not found\\n\";\n    }\n}",
            "output": "Found"
        }
    },
    "unordered_set::contains": {
        "description": {
            "texte": "If present, the hash parameter may be used to pass a pre-computed hash value as an optimization. The behavior is undefined if invoking hash_function() on the key passed do not produce the same value as hash."
        },
        "parametres": "   key   -   key value of the element to search for \n   x   -   a value of any type that can be transparently compared with a key \n   hash   -   the hash value of the key \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <unordered_set>\n \nint main()\n{\n    std::unordered_set<int> example = {1, 2, 3, 4};\n \n    if(example.contains(2)) {\n        std::cout << \"Found\\n\";\n    } else {\n        std::cout << \"Not found\\n\";\n    }\n}",
            "output": "Found"
        }
    },
    "unordered_multiset::contains": {
        "description": {
            "texte": "If present, the hash parameter may be used to pass a pre-computed hash value as an optimization. The behavior is undefined if invoking hash_function() on the key passed do not produce the same value as hash."
        },
        "parametres": "   key   -   key value of the element to search for \n   x   -   a value of any type that can be transparently compared with a key \n   hash   -   the hash value of the key \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <unordered_set>\n \nint main()\n{\n    std::unordered_multiset<int> example = {1, 2, 3, 4};\n \n    if(example.contains(2)) {\n        std::cout << \"Found\\n\";\n    } else {\n        std::cout << \"Not found\\n\";\n    }\n}",
            "output": "Found"
        }
    },
    "unordered_map::contains": {
        "description": {
            "texte": "If present, the hash parameter may be used to pass a pre-computed hash value as an optimization. The behavior is undefined if invoking hash_function() on the key passed do not produce the same value as hash."
        },
        "parametres": "   key   -   key value of the element to search for \n   x   -   a value of any type that can be transparently compared with a key \n   hash   -   the hash value of the key \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <unordered_map>\n \nint main()\n{\n    std::unordered_map<int,char> example = {{1,'a'},{2,'b'}};\n \n    if(example.contains(2)) {\n        std::cout << \"Found\\n\";\n    } else {\n        std::cout << \"Not found\\n\";\n    }\n}",
            "output": "Found"
        }
    },
    "unordered_multimap::contains": {
        "description": {
            "texte": "If present, the hash parameter may be used to pass a pre-computed hash value as an optimization. The behavior is undefined if invoking hash_function() on the key passed do not produce the same value as hash."
        },
        "parametres": "   key   -   key value of the element to search for \n   x   -   a value of any type that can be transparently compared with a key \n   hash   -   the hash value of the key \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <unordered_map>\n \nint main()\n{\n    std::unordered_multimap<int,char> example = {{1,'a'},{2,'b'}};\n \n    if(example.contains(2)) {\n        std::cout << \"Found\\n\";\n    } else {\n        std::cout << \"Not found\\n\";\n    }\n}",
            "output": "Found"
        }
    },
    "set::lower_bound": {
        "description": {
            "texte": "Iterator pointing to the first element that is not less than key. If no such element is found, a past-the-end iterator (see end()) is returned."
        },
        "parametres": "   key   -   key value to compare the elements to \n   x   -   alternative value that can be compared to Key \n\n"
    },
    "multiset::lower_bound": {
        "description": {
            "texte": "Iterator pointing to the first element that is not less than key. If no such element is found, a past-the-end iterator (see end()) is returned."
        },
        "parametres": "   key   -   key value to compare the elements to \n   x   -   alternative value that can be compared to Key \n\n"
    },
    "map::lower_bound": {
        "description": {
            "texte": "Iterator pointing to the first element that is not less than key. If no such element is found, a past-the-end iterator (see end()) is returned."
        },
        "parametres": "   key   -   key value to compare the elements to \n   x   -   alternative value that can be compared to Key \n\n"
    },
    "multimap::lower_bound": {
        "description": {
            "texte": "Iterator pointing to the first element that is not less than key. If no such element is found, a past-the-end iterator (see end()) is returned."
        },
        "parametres": "   key   -   key value to compare the elements to \n   x   -   alternative value that can be compared to Key \n\n"
    },
    "set::upper_bound": {
        "description": {
            "texte": "Iterator pointing to the first element that is greater than key. If no such element is found, past-the-end (see end()) iterator is returned."
        },
        "parametres": "   key   -   key value to compare the elements to \n   x   -   alternative value that can be compared to Key \n\n"
    },
    "multiset::upper_bound": {
        "description": {
            "texte": "Iterator pointing to the first element that is greater than key. If no such element is found, past-the-end (see end()) iterator is returned."
        },
        "parametres": "   key   -   key value to compare the elements to \n   x   -   alternative value that can be compared to Key \n\n"
    },
    "map::upper_bound": {
        "description": {
            "texte": "Iterator pointing to the first element that is greater than key. If no such element is found, past-the-end (see end()) iterator is returned."
        },
        "parametres": "   key   -   key value to compare the elements to \n   x   -   alternative value that can be compared to Key \n\n"
    },
    "multimap::upper_bound": {
        "description": {
            "texte": "Iterator pointing to the first element that is greater than key. If no such element is found, past-the-end (see end()) iterator is returned."
        },
        "parametres": "   key   -   key value to compare the elements to \n   x   -   alternative value that can be compared to Key \n\n"
    },
    "set::equal_range": {
        "description": {
            "texte": "Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with lower_bound(), and the second with upper_bound()."
        },
        "parametres": "   key   -   key value to compare the elements to \n   x   -   alternative value that can be compared to Key \n\n"
    },
    "multiset::equal_range": {
        "description": {
            "texte": "Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with lower_bound(), and the second with upper_bound()."
        },
        "parametres": "   key   -   key value to compare the elements to \n   x   -   alternative value that can be compared to Key \n\n"
    },
    "map::equal_range": {
        "description": {
            "texte": "Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with lower_bound(), and the second with upper_bound()."
        },
        "parametres": "   key   -   key value to compare the elements to \n   x   -   alternative value that can be compared to Key \n\n",
        "exemple": {
            "input": "#include <map>\n#include <iostream>\n \nint main()\n{\n    const std::map<int, const char*> m{\n        { 0, \"zero\" },\n        { 1, \"one\" },\n        { 2, \"two\" },\n    };\n \n    {\n        auto p = m.equal_range(1);\n        for (auto& q = p.first; q != p.second; ++q) {\n            std::cout << \"m[\" << q->first << \"] = \" << q->second << '\\n';\n        }\n \n        if (p.second == m.find(2)) {\n            std::cout << \"end of equal_range (p.second) is one-past p.first\\n\";\n        } else {\n            std::cout << \"unexpected; p.second expected to be one-past p.first\\n\";\n        }\n    }\n \n    {\n        auto pp = m.equal_range(-1);\n        if (pp.first == m.begin()) {\n            std::cout << \"pp.first is iterator to first not-less than -1\\n\";\n        } else {\n            std::cout << \"unexpected pp.first\\n\";\n        }\n \n        if (pp.second == m.begin()) {\n            std::cout << \"pp.second is iterator to first element greater-than -1\\n\";\n        } else {\n            std::cout << \"unexpected pp.second\\n\";\n        }\n    }\n \n    {\n        auto ppp = m.equal_range(3);\n        if (ppp.first == m.end()) {\n            std::cout << \"ppp.first is iterator to first not-less than 3\\n\";\n        } else {\n            std::cout << \"unexpected ppp.first\\n\";\n        }\n \n        if (ppp.second == m.end()) {\n            std::cout << \"ppp.second is iterator to first element greater-than 3\\n\";\n        } else {\n            std::cout << \"unexpected ppp.second\\n\";\n        }\n    }\n}",
            "output": "m[1] = one\nend of equal_range (p.second) is one-past p.first\npp.first is iterator to first not-less than -1\npp.second is iterator to first element greater-than -1\nppp.first is iterator to first not-less than 3\nppp.second is iterator to first element greater-than 3"
        }
    },
    "multimap::equal_range": {
        "description": {
            "texte": "Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with lower_bound(), and the second with upper_bound()."
        },
        "parametres": "   key   -   key value to compare the elements to \n   x   -   alternative value that can be compared to Key \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <map>\n \nint main()\n{\n    std::multimap<int, char> dict {\n        {1, 'A'},\n        {2, 'B'},\n        {2, 'C'},\n        {2, 'D'},\n        {4, 'E'},\n        {3, 'F'}\n    };\n \n    auto range = dict.equal_range(2);\n \n    for (auto i = range.first; i != range.second; ++i)\n    {\n        std::cout << i->first << \": \" << i->second << '\\n';\n    }\n}",
            "output": "2: B\n2: C\n2: D"
        }
    },
    "set::key_comp": {
        "description": {
            "texte": "Returns the function object that compares the keys, which is a copy of this container's constructor argument comp. It is the same as value_comp."
        }
    },
    "multiset::key_comp": {
        "description": {
            "texte": "Returns the function object that compares the keys, which is a copy of this container's constructor argument comp. It is the same as value_comp."
        }
    },
    "map::key_comp": {
        "description": {
            "texte": "Returns the function object that compares the keys, which is a copy of this container's constructor argument comp."
        }
    },
    "multimap::key_comp": {
        "description": {
            "texte": "Returns the function object that compares the keys, which is a copy of this container's constructor argument comp."
        }
    },
    "set::value_comp": {
        "description": {
            "texte": "Returns the function object that compares the values. It is the same as key_comp."
        }
    },
    "multiset::value_comp": {
        "description": {
            "texte": "Returns the function object that compares the values. It is the same as key_comp."
        }
    },
    "map::value_comp": {
        "description": {
            "texte": "Returns a function object that compares objects of type std::map::value_type (key-value pairs) by using key_comp to compare the first components of the pairs."
        }
    },
    "multimap::value_comp": {
        "description": {
            "texte": "Returns a function object that compares objects of type std::multimap::value_type (key-value pairs) by using key_comp to compare the first components of the pairs."
        }
    },
    "unordered_set::hash_function": {
        "description": {
            "texte": "Returns the function that hashes the keys."
        }
    },
    "unordered_multiset::hash_function": {
        "description": {
            "texte": "Returns the function that hashes the keys."
        }
    },
    "unordered_map::hash_function": {
        "description": {
            "texte": "Returns the function that hashes the keys."
        }
    },
    "unordered_multimap::hash_function": {
        "description": {
            "texte": "Returns the function that hashes the keys."
        }
    },
    "unordered_set::key_eq": {
        "description": {
            "texte": "Returns the function that compares keys for equality."
        }
    },
    "unordered_multiset::key_eq": {
        "description": {
            "texte": "Returns the function that compares keys for equality."
        }
    },
    "unordered_map::key_eq": {
        "description": {
            "texte": "Returns the function that compares keys for equality."
        }
    },
    "unordered_multimap::key_eq": {
        "description": {
            "texte": "Returns the function that compares keys for equality."
        }
    },
    "vector::get_allocator": {
        "description": {
            "texte": "Returns the allocator associated with the container."
        }
    },
    "deque::get_allocator": {
        "description": {
            "texte": "Returns the allocator associated with the container."
        }
    },
    "forward_list::get_allocator": {
        "description": {
            "texte": "Returns the allocator associated with the container."
        }
    },
    "list::get_allocator": {
        "description": {
            "texte": "Returns the allocator associated with the container."
        }
    },
    "set::get_allocator": {
        "description": {
            "texte": "Returns the allocator associated with the container."
        }
    },
    "multiset::get_allocator": {
        "description": {
            "texte": "Returns the allocator associated with the container."
        }
    },
    "map::get_allocator": {
        "description": {
            "texte": "Returns the allocator associated with the container."
        }
    },
    "multimap::get_allocator": {
        "description": {
            "texte": "Returns the allocator associated with the container."
        }
    },
    "unordered_set::get_allocator": {
        "description": {
            "texte": "Returns the allocator associated with the container."
        }
    },
    "unordered_multiset::get_allocator": {
        "description": {
            "texte": "Returns the allocator associated with the container."
        }
    },
    "unordered_map::get_allocator": {
        "description": {
            "texte": "Returns the allocator associated with the container."
        }
    },
    "unordered_multimap::get_allocator": {
        "description": {
            "texte": "Returns the allocator associated with the container."
        }
    },
    "iterator_traits": {
        "description": {
            "texte": "std::iterator_traits is the type trait class that provides uniform interface to the properties of LegacyIterator types. This makes it possible to implement algorithms only in terms of iterators.The class defines the following types:The template can be specialized for user-defined iterators so that the information about the iterator can be retrieved even if the type does not provide the usual typedefs."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n#include <vector>\n#include <list>\n \ntemplate<class BidirIt>\nvoid my_reverse(BidirIt first, BidirIt last)\n{\n    typename std::iterator_traits<BidirIt>::difference_type n = std::distance(first, last);\n    --n;\n    while(n > 0) {\n        typename std::iterator_traits<BidirIt>::value_type tmp = *first;\n        *first++ = *--last;\n        *last = tmp;\n        n -= 2;\n    }\n}\n \nint main()\n{\n    std::vector<int> v{1, 2, 3, 4, 5};\n    my_reverse(v.begin(), v.end());\n    for (int n : v) {\n        std::cout << n << ' ';\n    }\n    std::cout << '\\n';\n \n    std::list<int> l{1, 2, 3, 4, 5};\n    my_reverse(l.begin(), l.end());\n    for (auto n : l) {\n        std::cout << n << ' ';\n    }\n    std::cout << '\\n';\n \n    int a[] = {1, 2, 3, 4, 5};\n    my_reverse(a, a+5);\n    for (int i=0; i<5; ++i) {\n        std::cout << a[i] << ' ';\n    }\n    std::cout << '\\n';\n \n//    std::istreambuf_iterator<char> i1(std::cin), i2;\n//    my_reverse(i1, i2); // compilation error\n \n}",
            "output": "5 4 3 2 1\n5 4 3 2 1\n5 4 3 2 1"
        }
    },
    "input_iterator_tag, std::output_iterator_tag, std::forward_iterator_tag, std::bidirectional_iterator_tag, std::random_access_iterator_tag, std::contiguous_iterator_tag": {
        "description": {
            "texte": "Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20)six (since C++20) iterator categories:Iterator category tags carry information that can be used to select the most efficient algorithms for the specific requirement set that is implied by the category.For every iterator type It, a typedef std::iterator_traits<It>::iterator_category is available, which is an alias to one of these five (until C++20)six (since C++20) tag types."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <list>\n#include <iterator>\n \ntemplate< class BDIter >\nvoid alg(BDIter, BDIter, std::bidirectional_iterator_tag)\n{\n    std::cout << \"alg() called for bidirectional iterator\\n\";\n}\n \ntemplate <class RAIter>\nvoid alg(RAIter, RAIter, std::random_access_iterator_tag)\n{\n    std::cout << \"alg() called for random-access iterator\\n\";\n}\n \ntemplate< class Iter >\nvoid alg(Iter first, Iter last)\n{\n    alg(first, last,\n        typename std::iterator_traits<Iter>::iterator_category());\n}\n \nint main()\n{\n    std::vector<int> v;\n    alg(v.begin(), v.end());\n \n    std::list<int> l;\n    alg(l.begin(), l.end());\n \n//    std::istreambuf_iterator<char> i1(std::cin), i2;\n//    alg(i1, i2); // compile error: no matching function for call\n}",
            "output": "alg() called for random-access iterator\nalg() called for bidirectional iterator"
        }
    },
    "iterator": {
        "description": {
            "texte": "std::iterator is the base class provided to simplify definitions of the required types for iterators."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <algorithm>\n \ntemplate<long FROM, long TO>\nclass Range {\npublic:\n    // member typedefs provided through inheriting from std::iterator\n    class iterator: public std::iterator<\n                        std::input_iterator_tag,   // iterator_category\n                        long,                      // value_type\n                        long,                      // difference_type\n                        const long*,               // pointer\n                        long                       // reference\n                                      >{\n        long num = FROM;\n    public:\n        explicit iterator(long _num = 0) : num(_num) {}\n        iterator& operator++() {num = TO >= FROM ? num + 1: num - 1; return *this;}\n        iterator operator++(int) {iterator retval = *this; ++(*this); return retval;}\n        bool operator==(iterator other) const {return num == other.num;}\n        bool operator!=(iterator other) const {return !(*this == other);}\n        reference operator*() const {return num;}\n    };\n    iterator begin() {return iterator(FROM);}\n    iterator end() {return iterator(TO >= FROM? TO+1 : TO-1);}\n};\n \nint main() {\n    // std::find requires an input iterator\n    auto range = Range<15, 25>();\n    auto itr = std::find(range.begin(), range.end(), 18);\n    std::cout << *itr << '\\n'; // 18\n \n    // Range::iterator also satisfies range-based for requirements\n    for(long l : Range<3, 5>()) {\n        std::cout << l << ' '; // 3 4 5\n    }\n    std::cout << '\\n';\n}",
            "output": "18\n3 4 5"
        }
    },
    "reverse_iterator": {
        "description": {
            "texte": "std::reverse_iterator is an iterator adaptor that reverses the direction of a given iterator. In other words, when provided with a bidirectional iterator, std::reverse_iterator produces a new iterator that moves from the end to the beginning of the sequence defined by the underlying bidirectional iterator.For a reverse iterator r constructed from an iterator i, the relationship &*r == &*(i-1) is always true (as long as r is dereferenceable); thus a reverse iterator constructed from a one-past-the-end iterator dereferences to the last element in a sequence.This is the iterator returned by member functions rbegin() and rend() of the standard library containers."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <iterator>\n \nint main()\n{\n    std::string s = \"Hello, world\";\n    std::reverse_iterator<std::string::iterator> r = s.rbegin();\n    r[7] = 'O'; // replaces 'o' with 'O' \n    r += 7; // iterator now points at 'O'\n    std::string rev(r, s.rend());\n    std::cout << rev << '\\n';\n}",
            "output": "OlleH"
        }
    },
    "move_iterator": {
        "description": {
            "texte": "std::move_iterator is an iterator adaptor which behaves exactly like the underlying iterator (which must be at least an LegacyInputIterator), except that dereferencing converts the value returned by the underlying iterator into an rvalue. If this iterator is used as an input iterator, the effect is that the values are moved from, rather than copied from."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <numeric>\n#include <string>\n \nint main()\n{\n    std::vector<std::string> v{\"this\", \"is\", \"an\", \"example\"};\n \n    std::cout << \"Old contents of the vector: \";\n    for (auto& s : v)\n        std::cout << '\"' << s << \"\\\" \";\n \n    typedef std::vector<std::string>::iterator iter_t;\n    std::string concat = std::accumulate(\n                             std::move_iterator<iter_t>(v.begin()),\n                             std::move_iterator<iter_t>(v.end()),\n                             std::string());  // Can be simplified with std::make_move_iterator\n \n    std::cout << \"\\nConcatenated as string: \" << concat << '\\n'\n              << \"New contents of the vector: \";\n    for (auto& s : v)\n        std::cout << '\"' << s << \"\\\" \";\n    std::cout << '\\n';\n}",
            "output": "Old contents of the vector: \"this\" \"is\" \"an\" \"example\"\nConcatenated as string: thisisanexample\nNew contents of the vector: \"\" \"\" \"\" \"\""
        }
    },
    "back_insert_iterator": {
        "description": {
            "texte": "std::back_insert_iterator is an LegacyOutputIterator that appends to a container for which it was constructed. The container's push_back() member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the std::back_insert_iterator is a no-op."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n#include <algorithm>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v;\n    std::generate_n(std::back_insert_iterator<std::vector<int>>(v), // can be simplified\n                    10, [n=0]() mutable { return ++n; });        // with std::back_inserter\n    for (int n : v)\n        std::cout << n << ' ';\n    std::cout << '\\n';\n}",
            "output": "1 2 3 4 5 6 7 8 9 10"
        }
    },
    "front_insert_iterator": {
        "description": {
            "texte": "std::front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which it was constructed. The container's push_front() member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the std::front_insert_iterator is a no-op."
        },
        "exemple": {
            "input": "#include <vector>\n#include <deque>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\nint main()\n{\n    std::vector<int> v{1,2,3,4,5};\n    std::deque<int> d;\n    std::copy(v.begin(), v.end(),\n              std::front_insert_iterator<std::deque<int>>(d)); // or std::front_inserter(d)\n    for(int n : d)\n        std::cout << n << ' ';\n    std::cout << '\\n';\n}",
            "output": "5 4 3 2 1"
        }
    },
    "insert_iterator": {
        "description": {
            "texte": "std::insert_iterator is a LegacyOutputIterator that inserts elements into a container for which it was constructed, at the position pointed to by the supplied iterator. The container's insert() member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the std::insert_iterator is a no-op."
        },
        "exemple": {
            "input": "#include <vector>\n#include <list>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n \nint main()\n{\n    std::vector<int> v{1,2,3,4,5};\n    std::list<int> l{-1,-2,-3};\n    std::copy(v.begin(), v.end(), // may be simplified with std::inserter\n              std::insert_iterator<std::list<int>>(l, std::next(l.begin()))); \n    for (int n : l)\n        std::cout << n << ' ';\n    std::cout << '\\n';\n}",
            "output": "-1 1 2 3 4 5 -2 -3"
        }
    },
    "make_reverse_iterator": {
        "description": {
            "texte": "make_reverse_iterator is a convenience function template that constructs a std::reverse_iterator for the given iterator i with the type deduced from the type of the argument."
        },
        "parametres": "   i   -   iterator to be converted to reverse iterator \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n \nint main() {\n    std::vector<int> v{ 1, 3, 10, 8, 22 };\n \n    std::sort(v.begin(), v.end());\n    std::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, \", \"));\n \n    std::cout << '\\n';\n \n    std::copy(\n        std::make_reverse_iterator(v.end()), \n        std::make_reverse_iterator(v.begin()),\n        std::ostream_iterator<int>(std::cout, \", \"));\n}",
            "output": "1, 3, 8, 10, 22, \n22, 10, 8, 3, 1,"
        }
    },
    "make_move_iterator": {
        "description": {
            "texte": "make_move_iterator is a convenience function template that constructs a std::move_iterator for the given iterator i with the type deduced from the type of the argument."
        },
        "parametres": "   i   -   input iterator to be converted to move iterator \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <list>\n#include <vector>\n#include <string>\n#include <iterator>\n \nint main()\n{\n    std::list<std::string> s{\"one\", \"two\", \"three\"};\n \n    std::vector<std::string> v1(s.begin(), s.end()); // copy\n \n    std::vector<std::string> v2(std::make_move_iterator(s.begin()),\n                                std::make_move_iterator(s.end())); // move\n \n    std::cout << \"v1 now holds: \";\n    for (auto str : v1)\n            std::cout << \"\\\"\" << str << \"\\\" \";\n    std::cout << \"\\nv2 now holds: \";\n    for (auto str : v2)\n            std::cout << \"\\\"\" << str << \"\\\" \";\n    std::cout << \"\\noriginal list now holds: \";\n    for (auto str : s)\n            std::cout << \"\\\"\" << str << \"\\\" \";\n    std::cout << '\\n';\n}",
            "output": "v1 now holds: \"one\" \"two\" \"three\"\nv2 now holds: \"one\" \"two\" \"three\"\noriginal list now holds: \"\" \"\" \"\""
        }
    },
    "back_inserter": {
        "description": {
            "texte": "back_inserter is a convenience function template that constructs a std::back_insert_iterator for the container c with the type deduced from the type of the argument."
        },
        "parametres": "   c   -   container that supports a push_back operation \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n \nint main()\n{\n    std::vector<int> v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    std::fill_n(std::back_inserter(v), 3, -1);\n    for (int n : v)\n        std::cout << n << ' ';\n}",
            "output": "1 2 3 4 5 6 7 8 9 10 -1 -1 -1"
        }
    },
    "front_inserter": {
        "description": {
            "texte": "front_inserter is a convenience function template that constructs a std::front_insert_iterator for the container c with the type deduced from the type of the argument."
        },
        "parametres": "   c   -   container that supports a push_front operation \n\n",
        "exemple": {
            "input": "#include <vector>\n#include <deque>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\nint main()\n{\n    std::vector<int> v{1,2,3,4,5};\n    std::deque<int> d;\n    std::copy(v.begin(), v.end(), std::front_inserter(d));\n    for(int n : d)\n        std::cout << n << ' ';\n}",
            "output": "5 4 3 2 1"
        }
    },
    "inserter": {
        "description": {
            "texte": "inserter is a convenience function template that constructs a std::insert_iterator for the container c and its iterator i with the type deduced from the type of the argument."
        },
        "parametres": "   c   -   container that supports a insert operation \n   i   -   iterator in c indicating the insertion position \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <vector>\n#include <set>\n \nint main()\n{\n \n    std::multiset<int> s {1, 2, 3};\n \n    // std::inserter is commonly used with sets\n    std::fill_n(std::inserter(s, s.end()), 5, 2);\n \n    for (int n : s)\n        std::cout << n << ' ';\n    std::cout << '\\n';\n \n    std::vector<int> d {100, 200, 300};\n    std::vector<int> l {1, 2, 3, 4, 5};\n \n    // when inserting in a sequence container, insertion point advances\n    // because each std::insert_iterator::operator= updates the target iterator\n    std::copy(d.begin(), d.end(), std::inserter(l, std::next(l.begin())));\n \n    for (int n : l)\n        std::cout << n << ' ';\n    std::cout << '\\n';\n}",
            "output": "1 2 2 2 2 2 2 3 \n1 100 200 300 2 3 4 5"
        }
    },
    "istream_iterator": {
        "description": {
            "texte": "std::istream_iterator is a single-pass input iterator that reads successive objects of type T from the std::basic_istream object for which it was constructed, by calling the appropriate operator>>. The actual read operation is performed when the iterator is incremented, not when it is dereferenced. The first object is read when the iterator is constructed. Dereferencing only returns a copy of the most recently read object.The default-constructed std::istream_iterator is known as the end-of-stream iterator. When a valid std::istream_iterator reaches the end of the underlying stream, it becomes equal to the end-of-stream iterator. Dereferencing or incrementing it further invokes undefined behavior.A typical implementation of std::istream_iterator holds two data members: a pointer to the associated std::basic_istream object and the most recently read value of type T.T must meet the DefaultConstructible, CopyConstructible, and CopyAssignable requirements."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n#include <iterator>\n#include <numeric>\n#include <algorithm>\n \nint main()\n{\n    std::istringstream str(\"0.1 0.2 0.3 0.4\");\n    std::partial_sum(std::istream_iterator<double>(str),\n                     std::istream_iterator<double>(),\n                     std::ostream_iterator<double>(std::cout, \" \"));\n \n    std::istringstream str2(\"1 3 5 7 8 9 10\");\n    std::cout << \"\\nThe first even number is \" <<\n        *std::find_if(std::istream_iterator<int>(str2),\n                      std::istream_iterator<int>(),\n                      [](int i){return i%2 == 0;})\n        << \".\\n\";\n    //\" 9 10\" left in the stream\n}",
            "output": "0.1 0.3 0.6 1 \nThe first even number is 8."
        }
    },
    "ostream_iterator": {
        "description": {
            "texte": "std::ostream_iterator is a single-pass LegacyOutputIterator that writes successive objects of type T into the std::basic_ostream object for which it was constructed, using operator<<. Optional delimiter string is written to the output stream after every write operation. The write operation is performed when the iterator (whether dereferenced or not) is assigned to. Incrementing the std::ostream_iterator is a no-op.In a typical implementation, the only data members of std::ostream_iterator are a pointer to the associated std::basic_ostream and a pointer to the first character in the delimiter string.When writing characters, std::ostreambuf_iterator is more efficient, since it avoids the overhead of constructing and destructing the sentry object once per character."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n#include <iterator>\n#include <numeric>\n \nint main()\n{\n    std::istringstream str(\"0.1 0.2 0.3 0.4\");\n    std::partial_sum(std::istream_iterator<double>(str),\n                      std::istream_iterator<double>(),\n                      std::ostream_iterator<double>(std::cout, \" \"));\n}",
            "output": "0.1 0.3 0.6 1"
        }
    },
    "istreambuf_iterator": {
        "description": {
            "texte": "std::istreambuf_iterator is a single-pass input iterator that reads successive characters from the std::basic_streambuf object for which it was constructed.The default-constructed std::istreambuf_iterator is known as the end-of-stream iterator. When a valid std::istreambuf_iterator reaches the end of the underlying stream, it becomes equal to the end-of-stream iterator. Dereferencing or incrementing it further invokes undefined behavior.std::istreambuf_iterator has a trivial copy constructor, a constexpr default constructor, and a trivial destructor."
        },
        "exemple": {
            "input": "#include <vector>\n#include <sstream>\n#include <iostream>\n#include <iterator>\n \nint main()\n{\n    // typical use case: an input stream represented as a pair of iterators\n    std::istringstream in(\"Hello, world\");\n    std::vector<char> v( (std::istreambuf_iterator<char>(in)),\n                          std::istreambuf_iterator<char>() );\n    std::cout << \"v has \" << v.size() << \" bytes. \";\n    v.push_back('\\0');\n    std::cout << \"it holds \\\"\" << &v[0] << \"\\\"\\n\";\n \n \n    // demonstration of the single-pass nature\n    std::istringstream s(\"abc\");\n    std::istreambuf_iterator<char> i1(s), i2(s);\n    std::cout << \"i1 returns \" << *i1 << '\\n'\n              << \"i2 returns \" << *i2 << '\\n';\n    ++i1;\n    std::cout << \"after incrementing i1, but not i2\\n\"\n              << \"i1 returns \" << *i1 << '\\n'\n              << \"i2 returns \" << *i2 << '\\n';\n    ++i2; // this makes the apparent value of *i2 to jump from 'a' to 'c'\n    std::cout << \"after incrementing i2, but not i1\\n\"\n              << \"i1 returns \" << *i1 << '\\n'\n              << \"i2 returns \" << *i2 << '\\n';\n \n}",
            "output": "v has 12 bytes. it holds \"Hello, world\"\ni1 returns a\ni2 returns a\nafter incrementing i1, but not i2\ni1 returns b\ni2 returns a\nafter incrementing i2, but not i1\ni1 returns b\ni2 returns c"
        }
    },
    "ostreambuf_iterator": {
        "description": {
            "texte": "std::ostreambuf_iterator is a single-pass LegacyOutputIterator that writes successive characters into the std::basic_streambuf object for which it was constructed. The actual write operation is performed when the iterator (whether dereferenced or not) is assigned to. Incrementing the std::ostreambuf_iterator is a no-op.In a typical implementation, the only data members of std::ostreambuf_iterator are a pointer to the associated std::basic_streambuf and a boolean flag indicating if the the end of file condition has been reached."
        },
        "exemple": {
            "input": "#include <string>\n#include <algorithm>\n#include <iterator>\n#include <iostream>\n \nint main()\n{\n    std::string s = \"This is an example\\n\";\n    std::copy(s.begin(), s.end(), std::ostreambuf_iterator<char>(std::cout));\n}",
            "output": "This is an example"
        }
    },
    "advance": {
        "description": {
            "texte": "Increments given iterator it by n elements.If n is negative, the iterator is decremented. In this case, InputIt must meet the requirements of LegacyBidirectionalIterator, otherwise the behavior is undefined."
        },
        "parametres": "   it   -   iterator to be advanced \n   n   -   number of elements it should be advanced \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n#include <vector>\n \nint main() \n{\n    std::vector<int> v{ 3, 1, 4 };\n \n    auto vi = v.begin();\n \n    std::advance(vi, 2);\n \n    std::cout << *vi << '\\n';\n}",
            "output": "4"
        }
    },
    "prev": {
        "description": {
            "texte": "Return the nth predecessor of iterator it."
        },
        "parametres": "   it   -   an iterator \n   n   -   number of elements it should be descended \n   Type requirements \n   -BidirIt must meet the requirements of LegacyBidirectionalIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n#include <vector>\n \nint main() \n{\n    std::vector<int> v{ 3, 1, 4 };\n \n    auto it = v.end();\n \n    auto pv = std::prev(it, 2);\n \n    std::cout << *pv << '\\n';\n}",
            "output": "1"
        }
    },
    "next": {
        "description": {
            "texte": "Return the nth successor of iterator it."
        },
        "parametres": "   it   -   an iterator \n   n   -   number of elements to advance \n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n#include <vector>\n \nint main() \n{\n    std::vector<int> v{ 3, 1, 4 };\n \n    auto it = v.begin();\n \n    auto nx = std::next(it, 2);\n \n    std::cout << *it << ' ' << *nx << '\\n';\n}",
            "output": "3 4"
        }
    },
    "begin, std::cbegin": {
        "description": {
            "texte": "Returns an iterator to the beginning of the given container c or array array. These templates rely on C::begin() having a reasonable implementation."
        },
        "parametres": "   c   -   a container with a begin method \n   array   -   an array of arbitrary type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <iterator>\n \nint main() \n{\n    std::vector<int> v = { 3, 1, 4 };\n    auto vi = std::begin(v);\n    std::cout << *vi << '\\n'; \n \n    int a[] = { -5, 10, 15 };\n    auto ai = std::begin(a);\n    std::cout << *ai << '\\n';\n}",
            "output": "3\n-5"
        }
    },
    "end, std::cend": {
        "description": {
            "texte": "Returns an iterator to the end (i.e. the element after the last element) of the given container c or array array. These templates rely on C::end() having a reasonable implementation."
        },
        "parametres": "   c   -   a container with an end method \n   array   -   an array of arbitrary type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <iterator>\n#include <algorithm>\n \nint main() \n{\n    std::vector<int> v = { 3, 1, 4 };\n    if (std::find(std::begin(v), std::end(v), 5) != std::end(v)) {\n        std::cout << \"found a 5 in vector v!\\n\";\n    }\n \n    int a[] = { 5, 10, 15 };\n    if (std::find(std::begin(a), std::end(a), 5) != std::end(a)) {\n        std::cout << \"found a 5 in array a!\\n\";\n    }\n}",
            "output": "found a 5 in array a!"
        }
    },
    "rbegin, std::crbegin": {
        "description": {
            "texte": "Returns an iterator to the reverse-beginning of the given container c or array array."
        },
        "parametres": "   c   -   a container with a rbegin method \n   array   -   an array of arbitrary type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <iterator>\n \nint main() \n{\n    std::vector<int> v = { 3, 1, 4 };\n    auto vi = std::rbegin(v);\n    std::cout << *vi << '\\n'; \n \n    int a[] = { -5, 10, 15 };\n    auto ai = std::rbegin(a);\n    std::cout << *ai << '\\n';\n}",
            "output": "4\n15"
        }
    },
    "rend, std::crend": {
        "description": {
            "texte": "Returns an iterator to the reverse-end of the given container c or array array."
        },
        "parametres": "   c   -   a container with a rend method \n   array   -   an array of arbitrary type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <iterator>\n#include <algorithm>\n \nint main()\n{\n    int a[] = {4, 6, -3, 9, 10};\n    std::cout << \"Array backwards: \";\n    std::copy(std::rbegin(a), std::rend(a), std::ostream_iterator<int>(std::cout, \" \"));\n \n    std::cout << \"\\nVector backwards: \";\n    std::vector<int> v = {4, 6, -3, 9, 10};\n    std::copy(std::rbegin(v), std::rend(v), std::ostream_iterator<int>(std::cout, \" \"));\n}",
            "output": "Array backwards: 10 9 -3 6 4 \nVector backwards: 10 9 -3 6 4"
        }
    },
    "size, std::ssize": {
        "description": {
            "texte": "Returns the size of the given container c or array array."
        },
        "parametres": "   c   -   a container with a size method \n   array   -   an array of arbitrary type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <iterator>\n \nint main() \n{\n    std::vector<int> v = { 3, 1, 4 };\n    std::cout << std::size(v) << '\\n'; \n \n    int a[] = { -5, 10, 15 };\n    std::cout << std::size(a) << '\\n';\n}",
            "output": "3\n3"
        }
    },
    "empty": {
        "description": {
            "texte": "Returns whether the given container is empty."
        },
        "parametres": "   c   -   a container with an empty method \n   array   -   an array of arbitrary type \n   il   -   an initializer list \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n \ntemplate <class T>\nvoid print(const T& container)\n{\n    if ( !std::empty(container) )\n    {\n         std::cout << \"Elements:\\n\";\n         for ( const auto& element : container )\n             std::cout << element << '\\n';\n    }\n    else\n    {\n        std::cout << \"Empty\\n\";\n    }\n}\n \nint main() \n{\n    std::vector<int> c = { 1, 2, 3 };\n    print(c);\n    c.clear();\n    print(c);\n \n    int array[] = { 4, 5, 6 };\n    print(array);\n \n    auto il = { 7, 8, 9 };\n    print(il);\n}",
            "output": "Elements:\n1\n2\n3\nEmpty\nElements:\n4\n5\n6\nElements:\n7\n8\n9"
        }
    },
    "data": {
        "description": {
            "texte": "Returns a pointer to the block of memory containing the elements of the container."
        },
        "parametres": "   c   -   a container with a data() method \n   array   -   an array of arbitrary type \n   il   -   an initializer list \n\n",
        "exemple": {
            "input": "#include <string> //std::data is guaranteed to be available after inclusion\n#include <cstring>\n#include <iostream>\n \nint main()\n{\n    std::string s {\"Hello world!\\n\"};\n \n    char a[20]; //storage for a C-style string\n    std::strcpy(a, std::data(s));\n    //[s.data(), s.data() + s.size()] is guaranteed to be an NTBS since C++11\n \n    std::cout << a << \"\\n\";\n}",
            "output": "Hello world!"
        }
    },
    "incrementable_traits": {
        "description": {
            "texte": "Computes the associated difference type of the type I, if any. Users may specialize incrementable_traits for a program-defined type."
        }
    },
    "readable_traits": {
        "description": {
            "texte": "Computes the associated value type of the type I, if any. Users may specialize readable_traits for a program-defined type."
        }
    },
    "iter_value_t, std::iter_reference_t, std::iter_difference_t, std::iter_rvalue_reference_t, std::iter_common_reference_t": {
        "description": {
            "texte": "Compute the associated types of an iterator. The exposition-only concept dereferenceable is satisfied if and only if the expression *std::declval<T&>() is valid and has a referenceable type (in particular, not void)."
        }
    },
    "ranges::dangling": {
        "description": {
            "texte": "dangling is a placeholder type and an empty class type, used together with the template aliases ranges::safe_iterator_t and ranges::safe_subrange_t.When some constrain algorithms that usually return an iterator or a subrange of a Range take a particular rvalue Range argument that does not models exposition-only concept __ForwardingRange, dangling will be returned instead to avoid returning potentially dangling results."
        }
    },
    "ranges::safe_iterator_t, std::ranges::safe_subrange_t": {
        "description": {
            "texte": "These two alias templates are used by some constrained algorithms to avoid returning potentially dangling iterators or views."
        }
    },
    "ranges::View, std::ranges::enable_view, std::ranges::view_base": {
        "description": {
            "texte": "For a type T, the default value of enable_view<T> is:"
        }
    },
    "Semiregular wrapper (C++20)\n": {
        "description": {
            "texte": "ranges::single_view, ranges::filter_view and ranges::transform_view are specified in terms of an exposition-only class template semiregular. The name semiregular is for exposition purposes only and not normative.semiregular<T> behaves exactly like std::optional<T> with a little differences, which makes it model Semiregular."
        }
    },
    "ranges::view::counted": {
        "description": {
            "texte": "A counted view presents a View of the elements of the counted range [i, n) for some iterator i and non-negative integer n.A counted range [i, n) is the n elements starting with the element pointed to by i and up to but not including the element, if any, pointed to by the result of n applications of ++i.If n == 0, the counted range is valid and empty. Otherwise, the counted range is only valid if n is positive, i is dereferenceable, and [++i, --n) is a valid counted range.Formally, if E and F are expressions, and T is the type std::decay_t<decltype((E))>, then."
        },
        "exemple": {
            "input": "#include <ranges>\n#include <iostream>\n \nint main()\n{\n  int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n  for(int i : std::view::counted(a, 3))\n    std::cout << i << ' ';\n}",
            "output": "1 2 3"
        }
    },
    "ranges::view::all, std::ranges::all_view": {
        "description": {
            "texte": "A range adaptor that returns a View that includes all elements of its Range argument.The expression view::all(E) is expression-equivalent (has the same effect) to:"
        },
        "exemple": {
            "input": "#include <ranges>\n#include <vector>\n#include <iostream>\n \nint main()\n{\n  std::vector<int> v{0,1,2,3,4,5};\n  for(int n : std::view::all(v) | std::view::take(2) ) {\n    std::cout << n << ' ';\n  }\n}",
            "output": "0 1"
        }
    },
    "ranges::ref_view": {
        "description": {
            "texte": "ref_\u00adview is a View of the elements of some other Range. It wraps a reference to that Range."
        },
        "parametres": "   t   -   range to reference \n\n"
    },
    "ranges::view::filter, std::ranges::filter_view": {
        "description": {
            "texte": "filter_view models the concepts BidirectionalRange, ForwardRange, InputRange, and CommonRange when the underlying view V models respective concepts."
        },
        "parametres": "   r   -   range to filter \n   pred   -   predicate to filter out elements \n\n",
        "exemple": {
            "input": "#include <vector>\n#include <ranges>\n#include <iostream>\n \nint main()\n{\n  std::vector<int> ints{0,1,2,3,4,5};\n  auto even = [](int i){ return 0 == i % 2; };\n  auto square = [](int i) { return i * i; };\n \n  for (int i : ints | std::view::filter(even) | std::view::transform(square)) {\n    std::cout << i << ' ';\n  }\n}",
            "output": "0 4 16"
        }
    },
    "is_execution_policy": {
        "description": {
            "texte": "Checks whether T is a standard or implementation-defined execution policy type.Provides the member constant value which is equal to true, if T is a standard execution policy type, or an implementation-defined execution policy type. Otherwise, value is equal to false.The behavior of a program that adds specializations for std::is_execution_policy is undefined."
        }
    },
    "execution::seq, std::execution::par, std::execution::par_unseq, std::execution::unseq": {
        "description": {
            "texte": "std::execution::seq, std::execution::par, std::execution::par_unseq, and std::execution::unseq are instances of the execution policy types std::execution::sequenced_policy, std::execution::parallel_policy, std::execution::parallel_unsequenced_policy, and std::execution::unsequenced_policy respectively. They are used to specify the execution policy of parallel algorithms - i.e., the kinds of parallelism allowed.Additional execution policies may be provided by a standard library implementation (possible future additions may include std::parallel::cuda and std::parallel::opencl)."
        }
    },
    "execution::sequenced_policy, std::execution::parallel_policy, std::execution::parallel_unsequenced_policy, std::execution::unsequenced_policy": {
        "description": {
            "texte": "During the execution of a parallel algorithm with any of these three execution policies, if the invocation of an element access function exits via an uncaught exception, std::terminate is called, but the implementations may define additional execution policies that handle exceptions differently."
        }
    },
    "for_each_n": {
        "description": {
            "texte": "For both overloads, if the iterator type is mutable, f may modify the elements of the range through the dereferenced iterator. If f returns a result, the result is ignored. If n is less than zero, the behavior is undefined."
        },
        "parametres": "   first   -   the beginning of the range to apply the function to \n   n   -   the number of elements to apply the function to \n   policy   -   the execution policy to use. See execution policy for details. \n   f   -   function object, to be applied to the result of dereferencing every iterator in the range [first, first + n)  The signature of the function should be equivalent to the following:\n void fun(const Type &a);\nThe signature does not need to have const &. The type Type must be such that an object of type InputIt can be dereferenced and then implicitly converted to Type.\n\u200b\n\n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -UnaryFunction must meet the requirements of MoveConstructible. Does not have to be CopyConstructible \n   -UnaryFunction2 must meet the requirements of CopyConstructible. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <vector>\n \nint main()\n{\n    std::vector<int> ns{1, 2, 3, 4, 5};\n    for (auto n: ns) std::cout << n << \", \";\n    std::cout << '\\n';\n    std::for_each_n(ns.begin(), 3, [](auto& n){ n *= 2; });\n    for (auto n: ns) std::cout << n << \", \";\n    std::cout << '\\n';\n}",
            "output": "1, 2, 3, 4, 5, \n2, 4, 6, 4, 5,"
        }
    },
    "count, std::count_if": {
        "description": {
            "texte": "Returns the number of elements in the range [first, last) satisfying specific criteria."
        },
        "parametres": "   first, last   -   the range of elements to examine \n   value   -   the value to search for \n   policy   -   the execution policy to use. See execution policy for details. \n   p   -   unary predicate which returns \u200btrue for the required elements.  The expression p(v) must be convertible to bool for every argument v of type (possibly const) VT, where VT is the value type of InputIt, regardless of value category, and must not modify v. Thus, a parameter type of VT&is not allowed, nor is VT unless for VT a move is equivalent to a copy (since C++11). \u200b\n\n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v{ 1, 2, 3, 4, 4, 3, 7, 8, 9, 10 };\n \n    // determine how many integers in a std::vector match a target value.\n    int target1 = 3;\n    int target2 = 5;\n    int num_items1 = std::count(v.begin(), v.end(), target1);\n    int num_items2 = std::count(v.begin(), v.end(), target2);\n    std::cout << \"number: \" << target1 << \" count: \" << num_items1 << '\\n';\n    std::cout << \"number: \" << target2 << \" count: \" << num_items2 << '\\n';\n \n    // use a lambda expression to count elements divisible by 3.\n    int num_items3 = std::count_if(v.begin(), v.end(), [](int i){return i % 3 == 0;});\n    std::cout << \"number divisible by three: \" << num_items3 << '\\n';\n}",
            "output": "number: 3 count: 2\nnumber: 5 count: 0\nnumber divisible by three: 3"
        }
    },
    "mismatch": {
        "description": {
            "texte": "Returns the first mismatching pair of elements from two ranges: one defined by [first1, last1) and another defined by [first2,last2). If last2 is not provided (overloads (1-4)), it denotes first2 + (last1 - first1)."
        },
        "parametres": "   first1, last1   -   the first range of the elements \n   first2, last2   -   the second range of the elements \n   policy   -   the execution policy to use. See execution policy for details. \n   p   -   binary predicate which returns \u200btrue if the elements should be treated as equal.  The signature of the predicate function should be equivalent to the following:\n bool pred(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that objects of types InputIt1 and InputIt2 can be dereferenced and then implicitly converted to Type1 and Type2 respectively. \u200b\n\n   Type requirements \n   -InputIt1 must meet the requirements of LegacyInputIterator. \n   -InputIt2 must meet the requirements of LegacyInputIterator. \n   -ForwardIt1 must meet the requirements of LegacyForwardIterator. \n   -ForwardIt2 must meet the requirements of LegacyForwardIterator. \n   -BinaryPredicate must meet the requirements of BinaryPredicate. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <algorithm>\n \nstd::string mirror_ends(const std::string& in)\n{\n    return std::string(in.begin(),\n                       std::mismatch(in.begin(), in.end(), in.rbegin()).first);\n}\n \nint main()\n{\n    std::cout << mirror_ends(\"abXYZba\") << '\\n'\n              << mirror_ends(\"abca\") << '\\n'\n              << mirror_ends(\"aba\") << '\\n';\n}",
            "output": "ab\na\naba"
        }
    },
    "equal": {
        "description": {
            "texte": "Two ranges are considered equal if they have the same number of elements and, for every iterator i in the range [first1,last1), *i equals *(first2 + (i - first1)). The overloads (1,2,5,6) use operator== to determine if two elements are equal, whereas overloads (3,4,7,8) use the given binary predicate p."
        },
        "parametres": "   first1, last1   -   the first range of the elements to compare \n   first2, last2   -   the second range of the elements to compare \n   policy   -   the execution policy to use. See execution policy for details. \n   p   -   binary predicate which returns \u200btrue if the elements should be treated as equal.  The signature of the predicate function should be equivalent to the following:\n bool pred(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that objects of types InputIt1 and InputIt2 can be dereferenced and then implicitly converted to Type1 and Type2 respectively. \u200b\n\n   Type requirements \n   -InputIt1, InputIt2 must meet the requirements of LegacyInputIterator. \n   -ForwardIt1, ForwardIt2 must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <string>\n \nbool is_palindrome(const std::string& s)\n{\n    return std::equal(s.begin(), s.begin() + s.size()/2, s.rbegin());\n}\n \nvoid test(const std::string& s)\n{\n    std::cout << \"\\\"\" << s << \"\\\" \"\n        << (is_palindrome(s) ? \"is\" : \"is not\")\n        << \" a palindrome\\n\";\n}\n \nint main()\n{\n    test(\"radar\");\n    test(\"hello\");\n}",
            "output": "\"radar\" is a palindrome\n\"hello\" is not a palindrome"
        }
    },
    "adjacent_find": {
        "description": {
            "texte": "Searches the range [first, last) for two consecutive identical elements."
        },
        "parametres": "   first, last   -   the range of elements to examine \n   policy   -   the execution policy to use. See execution policy for details. \n   p   -   binary predicate which returns \u200btrue if the elements should be treated as equal.  The signature of the predicate function should be equivalent to the following:\n bool pred(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type ForwardIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <functional>\n \nint main()\n{\n    std::vector<int> v1{0, 1, 2, 3, 40, 40, 41, 41, 5};\n \n    auto i1 = std::adjacent_find(v1.begin(), v1.end());\n \n    if (i1 == v1.end()) {\n        std::cout << \"no matching adjacent elements\\n\";\n    } else {\n        std::cout << \"the first adjacent pair of equal elements at: \"\n                  << std::distance(v1.begin(), i1) << '\\n';\n    }\n \n    auto i2 = std::adjacent_find(v1.begin(), v1.end(), std::greater<int>());\n    if (i2 == v1.end()) {\n        std::cout << \"The entire vector is sorted in ascending order\\n\";\n    } else {\n        std::cout << \"The last element in the non-decreasing subsequence is at: \"\n                  << std::distance(v1.begin(), i2) << '\\n';\n    }\n}",
            "output": "The first adjacent pair of equal elements at: 4\nThe last element in the non-decreasing subsequence is at: 7"
        }
    },
    "find, std::find_if, std::find_if_not": {
        "description": {
            "texte": "Returns the first element in the range [first, last) that satisfies specific criteria:"
        },
        "parametres": "   first, last   -   the range of elements to examine \n   value   -   value to compare the elements to \n   policy   -   the execution policy to use. See execution policy for details. \n   p   -   unary predicate which returns \u200btrue for the required element.  The expression p(v) must be convertible to bool for every argument v of type (possibly const) VT, where VT is the value type of InputIt, regardless of value category, and must not modify v. Thus, a parameter type of VT&is not allowed, nor is VT unless for VT a move is equivalent to a copy (since C++11). \u200b\n\n   q   -   unary predicate which returns \u200bfalse for the required element.  The expression q(v) must be convertible to bool for every argument v of type (possibly const) VT, where VT is the value type of InputIt, regardless of value category, and must not modify v. Thus, a parameter type of VT&is not allowed, nor is VT unless for VT a move is equivalent to a copy (since C++11). \u200b\n\n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -UnaryPredicate must meet the requirements of Predicate. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n \nint main()\n{\n    int n1 = 3;\n    int n2 = 5;\n \n    std::vector<int> v{0, 1, 2, 3, 4};\n \n    auto result1 = std::find(std::begin(v), std::end(v), n1);\n    auto result2 = std::find(std::begin(v), std::end(v), n2);\n \n    if (result1 != std::end(v)) {\n        std::cout << \"v contains: \" << n1 << '\\n';\n    } else {\n        std::cout << \"v does not contain: \" << n1 << '\\n';\n    }\n \n    if (result2 != std::end(v)) {\n        std::cout << \"v contains: \" << n2 << '\\n';\n    } else {\n        std::cout << \"v does not contain: \" << n2 << '\\n';\n    }\n}",
            "output": "v contains: 3\nv does not contain: 5"
        }
    },
    "find_end": {
        "description": {
            "texte": "Searches for the last occurrence of the sequence [s_first, s_last) in the range [first, last)."
        },
        "parametres": "   first, last   -   the range of elements to examine \n   s_first, s_last   -   the range of elements to search for \n   policy   -   the execution policy to use. See execution policy for details. \n   p   -   binary predicate which returns \u200btrue if the elements should be treated as equal.  The signature of the predicate function should be equivalent to the following:\n bool pred(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that objects of types ForwardIt1 and ForwardIt2 can be dereferenced and then implicitly converted to Type1 and Type2 respectively. \u200b\n\n   Type requirements \n   -ForwardIt1 must meet the requirements of LegacyForwardIterator. \n   -ForwardIt2 must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v{1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4};\n    std::vector<int>::iterator result;\n \n    std::vector<int> t1{1, 2, 3};\n \n    result = std::find_end(v.begin(), v.end(), t1.begin(), t1.end());\n    if (result == v.end()) {\n        std::cout << \"sequence not found\\n\";\n    } else {\n        std::cout << \"last occurrence is at: \"\n                  << std::distance(v.begin(), result) << \"\\n\";\n    }\n \n    std::vector<int> t2{4, 5, 6};\n    result = std::find_end(v.begin(), v.end(), t2.begin(), t2.end());\n    if (result == v.end()) {\n        std::cout << \"sequence not found\\n\";\n    } else {\n        std::cout << \"last occurrence is at: \" \n                  << std::distance(v.begin(), result) << \"\\n\";\n    }\n}",
            "output": "last occurrence is at: 8\nsequence not found"
        }
    },
    "find_first_of": {
        "description": {
            "texte": "Searches the range [first, last) for any of the elements in the range [s_first, s_last)."
        },
        "parametres": "   first, last   -   the range of elements to examine \n   s_first, s_last   -   the range of elements to search for \n   policy   -   the execution policy to use. See execution policy for details. \n   p   -   binary predicate which returns \u200btrue if the elements should be treated as equal.  The signature of the predicate function should be equivalent to the following:\n bool pred(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that objects of types ForwardIt1 and ForwardIt2 can be dereferenced and then implicitly converted to Type1 and Type2 respectively. \u200b\n\n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -ForwardIt1 must meet the requirements of LegacyForwardIterator. \n   -ForwardIt2 must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v{0, 2, 3, 25, 5};\n    std::vector<int> t{3, 19, 10, 2};\n \n    auto result = std::find_first_of(v.begin(), v.end(), t.begin(), t.end());\n \n    if (result == v.end()) {\n        std::cout << \"no elements of v were equal to 3, 19, 10 or 2\\n\";\n    } else {\n        std::cout << \"found a match at \"\n                  << std::distance(v.begin(), result) << \"\\n\";\n    }\n }",
            "output": "found a match at 1"
        }
    },
    "search_n": {
        "description": {
            "texte": "Searches the range [first, last) for the first sequence of count identical elements, each equal to the given value value."
        },
        "parametres": "   first, last   -   the range of elements to examine \n   count   -   the length of the sequence to search for \n   value   -   the value of the elements to search for \n   policy   -   the execution policy to use. See execution policy for details. \n   p   -   binary predicate which returns \u200btrue if the elements should be treated as equal.  The signature of the predicate function should be equivalent to the following:\n bool pred(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The type Type1 must be such that an object of type ForwardIt can be dereferenced and then implicitly converted to Type1. The type Type2 must be such that an object of type T can be implicitly converted to Type2. \u200b\n\n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <algorithm>\n#include <iterator>\n \ntemplate <class Container, class Size, class T>\nbool consecutive_values(const Container& c, Size count, const T& v)\n{\n  return std::search_n(std::begin(c),std::end(c),count,v) != std::end(c);\n}\n \nint main()\n{\n   const char sequence[] = \"1001010100010101001010101\";\n \n   std::cout << std::boolalpha;\n   std::cout << \"Has 4 consecutive zeros: \"\n             << consecutive_values(sequence,4,'0') << '\\n';\n   std::cout << \"Has 3 consecutive zeros: \"\n             << consecutive_values(sequence,3,'0') << '\\n';\n}",
            "output": "Has 4 consecutive zeros: false\nHas 3 consecutive zeros: true"
        }
    },
    "lexicographical_compare": {
        "description": {
            "texte": "Checks if the first range [first1, last1) is lexicographically less than the second range [first2, last2).Lexicographical comparison is a operation with the following properties:"
        },
        "parametres": "   first1, last1   -   the first range of elements to examine \n   first2, last2   -   the second range of elements to examine \n   policy   -   the execution policy to use. See execution policy for details. \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that objects of types InputIt1 and InputIt2 can be dereferenced and then implicitly converted to both Type1 and Type2. \u200b\n\n   Type requirements \n   -InputIt1, InputIt2 must meet the requirements of LegacyInputIterator. \n   -ForwardIt1, ForwardIt2 must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <random>\n \nint main()\n{\n    std::vector<char> v1 {'a', 'b', 'c', 'd'};\n    std::vector<char> v2 {'a', 'b', 'c', 'd'};\n \n    std::mt19937 g{std::random_device{}()};\n    while (!std::lexicographical_compare(v1.begin(), v1.end(),\n                                         v2.begin(), v2.end())) {\n        for (auto c : v1) std::cout << c << ' ';\n        std::cout << \">= \";\n        for (auto c : v2) std::cout << c << ' ';\n        std::cout << '\\n';\n \n        std::shuffle(v1.begin(), v1.end(), g);\n        std::shuffle(v2.begin(), v2.end(), g);\n    }\n \n    for (auto c : v1) std::cout << c << ' ';\n    std::cout << \"< \";\n    for (auto c : v2) std::cout << c << ' ';\n    std::cout << '\\n';\n}",
            "output": "a b c d >= a b c d \nd a b c >= c b d a \nb d a c >= a d c b \na c d b < c d a b"
        }
    },
    "lexicographical_compare_3way": {
        "description": {
            "texte": "Lexicographically compares two ranges [first1, last1) and [first2, last2) using three-way comparison and produces a result of the strongest applicable comparison category type."
        },
        "parametres": "   first1, last1   -   the first range of elements to examine \n   first2, last2   -   the second range of elements to examine \n   comp   -   a function object type. The behavior is undefined if its return type is not one of the five comparison category types (strong_equality, weak_equality, strong_ordering, weak_ordering, or partial_ordering) \n   Type requirements \n   -InputIt1, InputIt2 must meet the requirements of LegacyInputIterator. \n\n"
    },
    "copy, std::copy_if": {
        "description": {
            "texte": "Copies the elements in the range, defined by [first, last), to another range beginning at d_first."
        },
        "parametres": "   first, last   -   the range of elements to copy \n   d_first   -   the beginning of the destination range. \n   policy   -   the execution policy to use. See execution policy for details. \n   pred   -   unary predicate which returns \u200btrue for the required elements.  The expression pred(v) must be convertible to bool for every argument v of type (possibly const) VT, where VT is the value type of InputIt, regardless of value category, and must not modify v. Thus, a parameter type of VT&is not allowed, nor is VT unless for VT a move is equivalent to a copy (since C++11). \u200b\n\n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n   -ForwardIt1, ForwardIt2 must meet the requirements of LegacyForwardIterator. \n   -UnaryPredicate must meet the requirements of Predicate. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <iterator>\n#include <numeric>\n \nint main()\n{\n    std::vector<int> from_vector(10);\n    std::iota(from_vector.begin(), from_vector.end(), 0);\n \n    std::vector<int> to_vector;\n    std::copy(from_vector.begin(), from_vector.end(),\n              std::back_inserter(to_vector));\n// or, alternatively,\n//  std::vector<int> to_vector(from_vector.size());\n//  std::copy(from_vector.begin(), from_vector.end(), to_vector.begin());\n// either way is equivalent to\n//  std::vector<int> to_vector = from_vector;\n \n    std::cout << \"to_vector contains: \";\n \n    std::copy(to_vector.begin(), to_vector.end(),\n              std::ostream_iterator<int>(std::cout, \" \"));\n    std::cout << '\\n';\n}",
            "output": "to_vector contains: 0 1 2 3 4 5 6 7 8 9"
        }
    },
    "copy_n": {
        "description": {
            "texte": "Iterator in the destination range, pointing past the last element copied if count>0 or result otherwise."
        },
        "parametres": "   first   -   the beginning of the range of elements to copy from \n   count   -   number of the elements to copy \n   result   -   the beginning of the destination range \n   policy   -   the execution policy to use. See execution policy for details. \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n   -ForwardIt1, ForwardIt2 must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <iterator>\n \nint main()\n{\n    std::string in = \"1234567890\";\n    std::string out;\n \n    std::copy_n(in.begin(), 4, std::back_inserter(out));\n    std::cout << out << '\\n';\n}",
            "output": "1234"
        }
    },
    "copy_backward": {
        "description": {
            "texte": "Copies the elements from the range, defined by [first, last), to another range ending at d_last. The elements are copied in reverse order (the last element is copied first), but their relative order is preserved.The behavior is undefined if d_last is within (first, last]. std::copy must be used instead of std::copy_backward in that case."
        },
        "parametres": "   first, last   -   the range of the elements to copy \n   d_last   -   end of the destination range.. \n   Type requirements \n   -BidirIt must meet the requirements of LegacyBidirectionalIterator. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <vector>\n \nint main()\n{\n    std::vector<int> from_vector;\n    for (int i = 0; i < 10; i++) {\n        from_vector.push_back(i);\n    }\n \n    std::vector<int> to_vector(15);\n \n    std::copy_backward(from_vector.begin(), from_vector.end(), to_vector.end());\n \n    std::cout << \"to_vector contains: \";\n    for (auto i: to_vector) {\n        std::cout << i << \" \";\n    }\n }",
            "output": "to_vector contains: 0 0 0 0 0 0 1 2 3 4 5 6 7 8 9"
        }
    },
    "move_backward": {
        "description": {
            "texte": "Moves the elements from the range [first, last), to another range ending at d_last. The elements are moved in reverse order (the last element is moved first), but their relative order is preserved.The behavior is undefined if d_last is within (first, last].  std::move must be used instead of std::move_backward in that case."
        },
        "parametres": "   first, last   -   the range of the elements to move \n   d_last   -   end of the destination range \n   Type requirements \n   -BidirIt1, BidirIt2 must meet the requirements of LegacyBidirectionalIterator. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n \nint main()\n{\n    std::vector<std::string> src{\"foo\", \"bar\", \"baz\"};\n    std::vector<std::string> dest(src.size());\n \n    std::cout << \"src: \";\n    for (const auto &s : src)\n    {\n        std::cout << s << ' ';\n    }   \n    std::cout << \"\\ndest: \";\n    for (const auto &s : dest)\n    {\n        std::cout << s << ' ';\n    }   \n    std::cout << '\\n';\n \n    std::move_backward(src.begin(), src.end(), dest.end());\n \n    std::cout << \"src: \";                                                       \n    for (const auto &s : src)\n    {\n        std::cout << s << ' ';\n    }   \n    std::cout << \"\\ndest: \";\n    for (const auto &s : dest)\n    {\n        std::cout << s << ' ';\n    }   \n    std::cout << '\\n';\n}",
            "output": "src: foo bar baz \ndest:    \nsrc:    \ndest: foo bar baz"
        }
    },
    "shift_left, std::shift_right": {
        "description": {
            "texte": "Shifts the elements in the range [first, last) by n positions.Elements that are in the original range but not the new range are left in a valid but unspecified state."
        },
        "parametres": "   first   -   the beginning of the original range \n   last   -   the end of the original range \n   n   -   the number of positions to shift \n   policy   -   the execution policy to use. See execution policy for details. \n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -ForwardIt must meet either the requirements of LegacyBidirectionalIterator or the requirements of ValueSwappable for overloads (3-4). \n   -The type of dereferenced ForwardIt must meet the requirements of MoveAssignable. \n\n"
    },
    "fill": {
        "description": {
            "texte": "(none)."
        },
        "parametres": "   first, last   -   the range of elements to modify \n   value   -   the value to be assigned \n   policy   -   the execution policy to use. See execution policy for details. \n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <vector>\n#include <iostream>\n \nint main()\n{\n    std::vector<int> v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n \n    std::fill(v.begin(), v.end(), -1);\n \n    for (auto elem : v) {\n        std::cout << elem << \" \";\n    }\n    std::cout << \"\\n\";\n}",
            "output": "-1 -1 -1 -1 -1 -1 -1 -1 -1 -1"
        }
    },
    "fill_n": {
        "description": {
            "texte": "Exactly count assignments, for count > 0."
        },
        "parametres": "   first   -   the beginning of the range of elements to modify \n   count   -   number of elements to modify \n   value   -   the value to be assigned \n   policy   -   the execution policy to use. See execution policy for details. \n   Type requirements \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <iterator>\n \nint main()\n{\n    std::vector<int> v1{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n \n    std::fill_n(v1.begin(), 5, -1);\n \n    std::copy(begin(v1), end(v1), std::ostream_iterator<int>(std::cout, \" \"));\n    std::cout << \"\\n\";\n}",
            "output": "-1 -1 -1 -1 -1 5 6 7 8 9"
        }
    },
    "iter_swap": {
        "description": {
            "texte": "Swaps the values of the elements the given iterators are pointing to."
        },
        "parametres": "   a, b   -   iterators to the elements to swap \n   Type requirements \n   -ForwardIt1, ForwardIt2 must meet the requirements of LegacyForwardIterator. \n   -*a, *b must meet the requirements of Swappable. \n\n",
        "exemple": {
            "input": "#include <random>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n \ntemplate<class ForwardIt>\nvoid selection_sort(ForwardIt begin, ForwardIt end)\n{\n    for (ForwardIt i = begin; i != end; ++i)\n        std::iter_swap(i, std::min_element(i, end));\n}\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution<> dist(-10, 10);\n    std::vector<int> v;\n    generate_n(back_inserter(v), 20, bind(dist, gen));\n \n    std::cout << \"Before sort: \";\n    for(auto e : v) std::cout << e << \" \";\n \n    selection_sort(v.begin(), v.end());\n \n    std::cout << \"\\nAfter sort: \";\n    for(auto e : v) std::cout << e << \" \";\n    std::cout << '\\n';\n}",
            "output": "Before sort: -7 6 2 4 -1 6 -9 -1 2 -5 10 -9 -5 -3 -5 -3 6 6 1 8\nAfter sort: -9 -9 -7 -5 -5 -5 -3 -3 -1 -1 1 2 2 4 6 6 6 6 8 10"
        }
    },
    "swap_ranges": {
        "description": {
            "texte": "Iterator to the element past the last element exchanged in the range beginning with first2."
        },
        "parametres": "   first1, last1   -   the first range of elements to swap \n   first2   -   beginning of the second range of elements to swap \n   policy   -   the execution policy to use. See execution policy for details. \n   Type requirements \n   -ForwardIt1, ForwardIt2 must meet the requirements of LegacyForwardIterator. \n   -The types of dereferenced ForwardIt1 and ForwardIt2 must meet the requirements of Swappable \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <list>\n#include <vector>\n#include <iostream>\nint main()\n{\n    std::vector<int> v = {1, 2, 3, 4, 5};\n    std::list<int> l = {-1, -2, -3, -4, -5};\n \n    std::swap_ranges(v.begin(), v.begin()+3, l.begin());\n \n    for(int n : v)\n       std::cout << n << ' ';\n    std::cout << '\\n';\n    for(int n : l)\n       std::cout << n << ' ';\n    std::cout << '\\n';\n}",
            "output": "-1 -2 -3 4 5\n1 2 3 -4 -5"
        }
    },
    "sample": {
        "description": {
            "texte": "Selects n elements from the sequence [first; last) such that each possible sample has equal probability of appearance, and writes those selected elements into the output iterator out. Random numbers are generated using the random number generator g.If n is greater than the number of elements in the sequence, selects last-first elements.The algorithm is stable (preserves the relative order of the selected elements) only if PopulationIterator meets the requirements of LegacyForwardIterator."
        },
        "parametres": "   first, last   -   pair of iterators forming the range from which to make the sampling (the population) \n   out   -   the output iterator where the samples are written. Must not be in the [first;last) range \n   n   -   number of samples to make \n   g   -   the random number generator used as the source of randomness \n   -PopulationIterator must meet the requirements of LegacyInputIterator. \n   -SampleIterator must meet the requirements of LegacyOutputIterator. \n   -SampleIterator must also meet the requirements of LegacyRandomAccessIterator if PopulationIterator doesn't meet LegacyForwardIterator \n   -PopulationIterator's value type must be writeable to out \n   -Distance must be an integer type \n   -std::remove_reference_t<URBG> must meet the requirements of UniformRandomBitGenerator and its return type must be convertible to Distance \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <random>\n#include <string>\n#include <iterator>\n#include <algorithm>\n \nint main()\n{\n    std::string in = \"abcdefgh\", out;\n    std::sample(in.begin(), in.end(), std::back_inserter(out),\n                5, std::mt19937{std::random_device{}()});\n    std::cout << \"five random letters out of \" << in << \" : \" << out << '\\n';\n}",
            "output": "five random letters out of abcdefgh : adfgh"
        }
    },
    "remove, std::remove_if": {
        "description": {
            "texte": "Removes all elements satisfying specific criteria from the range [first, last) and returns a past-the-end iterator for the new end of the range.Removing is done by shifting (by means of move assignment) the elements in the range in such a way that the elements that are not to be removed appear in the beginning of the range. Relative order of the elements that remain is preserved and the physical size of the container is unchanged. Iterators pointing to an element between the new logical end and the physical end of the range are still dereferenceable, but the elements themselves have unspecified values (as per MoveAssignable post-condition). A call to remove is typically followed by a call to a container's erase method, which erases the unspecified values and reduces the physical size of the container to match its new logical size."
        },
        "parametres": "   first, last   -   the range of elements to process \n   value   -   the value of elements to remove \n   policy   -   the execution policy to use. See execution policy for details. \n   p   -   unary predicate which returns \u200btrue if the element should be removed.  The expression p(v) must be convertible to bool for every argument v of type (possibly const) VT, where VT is the value type of ForwardIt, regardless of value category, and must not modify v. Thus, a parameter type of VT&is not allowed, nor is VT unless for VT a move is equivalent to a copy (since C++11). \u200b\n\n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -The type of dereferenced ForwardIt must meet the requirements of MoveAssignable. \n   -UnaryPredicate must meet the requirements of Predicate. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <string>\n#include <iostream>\n#include <cctype>\n \nint main()\n{\n    std::string str1 = \"Text with some   spaces\";\n    str1.erase(std::remove(str1.begin(), str1.end(), ' '),\n               str1.end());\n    std::cout << str1 << '\\n';\n \n    std::string str2 = \"Text\\n with\\tsome \\t  whitespaces\\n\\n\";\n    str2.erase(std::remove_if(str2.begin(), \n                              str2.end(),\n                              [](unsigned char x){return std::isspace(x);}),\n               str2.end());\n    std::cout << str2 << '\\n';\n}",
            "output": "Textwithsomespaces\nTextwithsomewhitespaces"
        }
    },
    "replace, std::replace_if": {
        "description": {
            "texte": "Replaces all elements satisfying specific criteria with new_value in the range [first, last)."
        },
        "parametres": "   first, last   -   the range of elements to process \n   old_value   -   the value of elements to replace \n   policy   -   the execution policy to use. See execution policy for details. \n   p   -   unary predicate which returns \u200btrue if the element value should be replaced.  The expression p(v) must be convertible to bool for every argument v of type (possibly const) VT, where VT is the value type of ForwardIt, regardless of value category, and must not modify v. Thus, a parameter type of VT&is not allowed, nor is VT unless for VT a move is equivalent to a copy (since C++11). \u200b\n\n   new_value   -   the value to use as replacement \n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -UnaryPredicate must meet the requirements of Predicate. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <array>\n#include <iostream>\n#include <functional>\n \nint main()\n{\n    std::array<int, 10> s{5, 7, 4, 2, 8, 6, 1, 9, 0, 3};\n \n    std::replace(s.begin(), s.end(), 8, 88);\n \n    for (int a : s) {\n        std::cout << a << \" \";\n    }\n    std::cout << '\\n';\n \n    std::replace_if(s.begin(), s.end(), \n                    std::bind(std::less<int>(), std::placeholders::_1, 5), 55);\n    for (int a : s) {\n        std::cout << a << \" \";\n    }\n    std::cout << '\\n';\n}",
            "output": "5 7 4 2 88 6 1 9 0 3\n5 7 55 55 88 6 55 9 55 55"
        }
    },
    "reverse": {
        "description": {
            "texte": "(none)."
        },
        "parametres": "   first, last   -   the range of elements to reverse \n   policy   -   the execution policy to use. See execution policy for details. \n   Type requirements \n   -BidirIt must meet the requirements of ValueSwappable and LegacyBidirectionalIterator. \n\n",
        "exemple": {
            "input": "#include <vector>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n \nint main()\n{\n    std::vector<int> v{1,2,3};\n    std::reverse(std::begin(v), std::end(v));\n    for(auto e : v) std::cout << e;\n    std::cout << '\\n';\n \n    int a[] = {4, 5, 6, 7};\n    std::reverse(std::begin(a), std::end(a));\n    for(auto e : a) std::cout << e;\n}",
            "output": "321\n7654"
        }
    },
    "unique": {
        "description": {
            "texte": "Eliminates all but the first element from every consecutive group of equivalent elements from the range [first, last) and returns a past-the-end iterator for the new logical end of the range.Removing is done by shifting the elements in the range in such a way that elements to be erased are overwritten. Relative order of the elements that remain is preserved and the physical size of the container is unchanged. Iterators pointing to an element between the new logical end and the physical end of the range are still dereferenceable, but the elements themselves have unspecified values. A call to unique is typically followed by a call to a container's erase method, which erases the unspecified values and reduces the physical size of the container to match its new logical size."
        },
        "parametres": "   first, last   -   the range of elements to process \n   policy   -   the execution policy to use. See execution policy for details. \n   p   -   binary predicate which returns \u200btrue if the elements should be treated as equal.  The signature of the predicate function should be equivalent to the following:\n bool pred(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type ForwardIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -The type of dereferenced ForwardIt must meet the requirements of MoveAssignable. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cctype>\n \nint main() \n{\n    // remove duplicate elements\n    std::vector<int> v{1,2,3,1,2,3,3,4,5,4,5,6,7};\n    std::sort(v.begin(), v.end()); // 1 1 2 2 3 3 3 4 4 5 5 6 7 \n    auto last = std::unique(v.begin(), v.end());\n    // v now holds {1 2 3 4 5 6 7 x x x x x x}, where 'x' is indeterminate\n    v.erase(last, v.end()); \n    for (int i : v)\n      std::cout << i << \" \";\n    std::cout << \"\\n\";\n}",
            "output": "1 2 3 4 5 6 7"
        }
    },
    "random_shuffle, std::shuffle": {
        "description": {
            "texte": "Reorders the elements in the given range [first, last) such that each possible permutation of those elements has equal probability of appearance."
        },
        "parametres": "   first, last   -   the range of elements to shuffle randomly \n   r   -   function object returning a randomly chosen value of type convertible to std::iterator_traits<RandomIt>::difference_type in the interval [0,n) if invoked as r(n) \n   g   -   a UniformRandomBitGenerator whose result type is convertible to std::iterator_traits<RandomIt>::difference_type \n   Type requirements \n   -RandomIt must meet the requirements of ValueSwappable and LegacyRandomAccessIterator. \n   -std::remove_reference_t<URBG> must meet the requirements of UniformRandomBitGenerator. \n\n",
        "exemple": {
            "input": "#include <random>\n#include <algorithm>\n#include <iterator>\n#include <iostream>\n \nint main()\n{\n    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n \n    std::random_device rd;\n    std::mt19937 g(rd());\n \n    std::shuffle(v.begin(), v.end(), g);\n \n    std::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, \" \"));\n    std::cout << \"\\n\";\n}",
            "output": "8 6 10 4 2 3 7 1 9 5"
        }
    },
    "remove_copy, std::remove_copy_if": {
        "description": {
            "texte": "Copies elements from the range [first, last), to another range beginning at d_first, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap."
        },
        "parametres": "   first, last   -   the range of elements to copy \n   d_first   -   the beginning of the destination range. \n   value   -   the value of the elements not to copy \n   policy   -   the execution policy to use. See execution policy for details. \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n   -ForwardIt1, ForwardIt2 must meet the requirements of LegacyForwardIterator. \n   -UnaryPredicate must meet the requirements of Predicate. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iterator>\n#include <string>\n#include <iostream>\nint main()\n{\n    std::string str = \"Text with some   spaces\";\n    std::cout << \"before: \" << str << \"\\n\";\n \n    std::cout << \"after:  \";\n    std::remove_copy(str.begin(), str.end(),\n                     std::ostream_iterator<char>(std::cout), ' ');\n    std::cout << '\\n';\n}",
            "output": "before: Text with some   spaces\nafter:  Textwithsomespaces"
        }
    },
    "replace_copy, std::replace_copy_if": {
        "description": {
            "texte": "Copies the elements from the range [first, last) to another range beginning at d_first replacing all elements satisfying specific criteria with new_value. The source and destination ranges cannot overlap."
        },
        "parametres": "   first, last   -   the range of elements to copy \n   d_first   -   the beginning of the destination range \n   old_value   -   the value of elements to replace \n   policy   -   the execution policy to use. See execution policy for details. \n   p   -   unary predicate which returns \u200btrue if the element value should be replaced.  The expression p(v) must be convertible to bool for every argument v of type (possibly const) VT, where VT is the value type of InputIt, regardless of value category, and must not modify v. Thus, a parameter type of VT&is not allowed, nor is VT unless for VT a move is equivalent to a copy (since C++11). \u200b\n\n   new_value   -   the value to use as replacement \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n   -ForwardIt1, ForwardIt2 must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <iterator>\n#include <functional>\n \nint main()\n{\n    std::vector<int> v{5, 7, 4, 2, 8, 6, 1, 9, 0, 3};\n    std::replace_copy_if(v.begin(), v.end(),\n                         std::ostream_iterator<int>(std::cout, \" \"),\n                         [](int n){return n > 5;}, 99);\n    std::cout << '\\n';\n}",
            "output": "5 99 4 2 99 99 1 99 0 3"
        }
    },
    "reverse_copy": {
        "description": {
            "texte": "Output iterator to the element past the last element copied."
        },
        "parametres": "   first, last   -   the range of elements to copy \n   d_first   -   the beginning of the destination range \n   Type requirements \n   -BidirIt must meet the requirements of LegacyBidirectionalIterator. \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <vector>\n#include <iostream>\n#include <algorithm>\n \nint main()\n{\n    std::vector<int> v({1,2,3});\n    for (const auto& value : v) {\n        std::cout << value << \" \";\n    }\n    std::cout << '\\n';\n \n    std::vector<int> destination(3);\n    std::reverse_copy(std::begin(v), std::end(v), std::begin(destination));\n    for (const auto& value : destination) {\n        std::cout << value << \" \";\n    }\n    std::cout << '\\n';\n}",
            "output": "1 2 3 \n3 2 1"
        }
    },
    "rotate_copy": {
        "description": {
            "texte": "Output iterator to the element past the last element copied."
        },
        "parametres": "   first, last   -   the range of elements to copy \n   n_first   -   an iterator to an element in [first, last) that should appear at the beginning of the new range \n   d_first   -   beginning of the destination range \n   policy   -   the execution policy to use. See execution policy for details. \n   Type requirements \n   -ForwardIt, ForwardIt1, ForwardIt2 must meet the requirements of LegacyForwardIterator. \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <vector>\n#include <iostream>\n \nint main()\n{\n    std::vector<int> src = {1, 2, 3, 4, 5}; \n    auto pivot = std::find(src.begin(), src.end(), 3); \n    std::vector<int> dest(src.size());                                          \n \n    std::rotate_copy(src.begin(), pivot, src.end(), dest.begin());\n \n    for (const auto &i : dest) {\n        std::cout << i << ' ';\n    }   \n    std::cout << '\\n';\n}",
            "output": "3 4 5 1 2"
        }
    },
    "unique_copy": {
        "description": {
            "texte": "Copies the elements from the range [first, last), to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied."
        },
        "parametres": "   first, last   -   the range of elements to process \n   d_first   -   the beginning of the destination range \n   policy   -   the execution policy to use. See execution policy for details. \n   p   -   binary predicate which returns \u200btrue if the elements should be treated as equal.  The signature of the predicate function should be equivalent to the following:\n bool pred(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type InputIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n   -ForwardIt1, ForwardIt2 must meet the requirements of LegacyForwardIterator. \n   -The type of dereferenced InputIt must meet the requirements of CopyAssignable. if InputIt does not satisfy LegacyForwardIterator \n   -The type of dereferenced InputIt must meet the requirements of CopyConstructible. if neither InputIt nor OutputIt satisfies LegacyForwardIterator, or if InputIt does not satisfy LegacyForwardIterator and the value type of InputIt differs from that of OutputIt \n\n",
        "exemple": {
            "input": "#include <string>\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n \nint main()\n{\n    std::string s1 = \"The      string    with many       spaces!\";\n    std::cout << \"before: \" << s1 << '\\n';\n \n    std::string s2;\n    std::unique_copy(s1.begin(), s1.end(), std::back_inserter(s2),\n                     [](char c1, char c2){ return c1 == ' ' && c2 == ' '; });\n \n    std::cout << \"after:  \" << s2 << '\\n';\n}",
            "output": "before: The      string    with many       spaces!\nafter:  The string with many spaces!"
        }
    },
    "uninitialized_copy": {
        "description": {
            "texte": "Iterator to the element past the last element copied."
        },
        "parametres": "   first, last   -   the range of the elements to copy \n   d_first   -   the beginning of the destination range \n   policy   -   the execution policy to use. See execution policy for details. \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -No increment, assignment, comparison, or indirection through valid instances of ForwardIt may throw exceptions. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n#include <cstdlib>\n#include <string>\n \nint main()\n{\n    const char *v[] = {\"This\", \"is\", \"an\", \"example\"};\n \n    auto sz = std::size(v);\n \n    if(void *pbuf = std::aligned_alloc(alignof(std::string), sizeof(std::string) * sz))\n    {\n        try\n        {\n            auto first = static_cast<std::string*>(pbuf);\n            auto last = std::uninitialized_copy(std::begin(v), std::end(v), first);\n \n            for (auto it = first; it != last; ++it)\n                std::cout << *it << '_';\n \n            std::destroy(first, last);\n        }\n        catch(...) {}\n        std::free(pbuf);\n    }\n}",
            "output": "This_is_an_example_"
        }
    },
    "uninitialized_move": {
        "description": {
            "texte": "Iterator to the element past the last element moved."
        },
        "parametres": "   first, last   -   the range of the elements to move \n   d_first   -   the beginning of the destination range \n   policy   -   the execution policy to use. See execution policy for details. \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -No increment, assignment, comparison, or indirection through valid instances of ForwardIt may throw exceptions. \n\n"
    },
    "uninitialized_fill": {
        "description": {
            "texte": "(none)."
        },
        "parametres": "   first, last   -   the range of the elements to initialize \n   value   -   the value to construct the elements with \n   policy   -   the execution policy to use. See execution policy for details. \n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -No increment, assignment, comparison, or indirection through valid instances of ForwardIt may throw exceptions. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <tuple>\n \nint main()\n{\n    std::string* p;\n    std::size_t sz;\n    std::tie(p, sz) = std::get_temporary_buffer<std::string>(4);\n \n    std::uninitialized_fill(p, p+sz, \"Example\");\n \n    for (std::string* i = p; i != p+sz; ++i) {\n        std::cout << *i << '\\n';\n        i->~basic_string<char>();\n    }\n    std::return_temporary_buffer(p);\n}",
            "output": "Example\nExample\nExample\nExample"
        }
    },
    "uninitialized_copy_n": {
        "description": {
            "texte": "Iterator to the element past the last element copied."
        },
        "parametres": "   first   -   the beginning of the range of the elements to copy \n   d_first   -   the beginning of the destination range \n   policy   -   the execution policy to use. See execution policy for details. \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -No increment, assignment, comparison, or indirection through valid instances of ForwardIt may throw exceptions. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <tuple>\n#include <vector>\n \nint main()\n{\n    std::vector<std::string> v = {\"This\", \"is\", \"an\", \"example\"};\n \n    std::string* p;\n    std::size_t sz;\n    std::tie(p, sz)  = std::get_temporary_buffer<std::string>(v.size());\n    sz = std::min(sz, v.size());\n \n    std::uninitialized_copy_n(v.begin(), sz, p);\n \n    for (std::string* i = p; i != p+sz; ++i) {\n        std::cout << *i << ' ';\n        i->~basic_string<char>();\n    }\n    std::return_temporary_buffer(p);\n}",
            "output": "This is an example"
        }
    },
    "uninitialized_move_n": {
        "description": {
            "texte": "A pair whose first element is an iterator to the element past the last element moved in the source range, and whose second element is an iterator to the element past the last element moved in the destination range."
        },
        "parametres": "   first   -   the beginning of the range of the elements to move \n   d_first   -   the beginning of the destination range \n   policy   -   the execution policy to use. See execution policy for details. \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -No increment, assignment, comparison, or indirection through valid instances of ForwardIt may throw exceptions. \n\n"
    },
    "uninitialized_default_construct": {
        "description": {
            "texte": "(none)."
        },
        "parametres": "   first, last   -   the range of the elements to initialize \n   policy   -   the execution policy to use. See execution policy for details. \n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -No increment, assignment, comparison, or indirection through valid instances of ForwardIt may throw exceptions. \n\n"
    },
    "uninitialized_value_construct": {
        "description": {
            "texte": "(none)."
        },
        "parametres": "   first, last   -   the range of the elements to initialize \n   policy   -   the execution policy to use. See execution policy for details. \n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -No increment, assignment, comparison, or indirection through valid instances of ForwardIt may throw exceptions. \n\n"
    },
    "destroy": {
        "description": {
            "texte": "(none)."
        },
        "parametres": "   first, last   -   the range of elements to destroy \n   policy   -   the execution policy to use. See execution policy for details. \n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -No increment, assignment, comparison, or indirection through valid instances of ForwardIt may throw exceptions. \n\n",
        "exemple": {
            "input": "#include <memory>\n#include <new>\n#include <iostream>\n \nstruct Tracer {\n    int value;\n    ~Tracer() { std::cout << value << \" destructed\\n\"; }\n};\n \nint main()\n{\n    alignas(Tracer) unsigned char buffer[sizeof(Tracer) * 8];\n \n    for (int i = 0; i < 8; ++i)\n        new(buffer + sizeof(Tracer) * i) Tracer{i}; //manually construct objects\n \n    auto ptr = std::launder(reinterpret_cast<Tracer*>(buffer));\n \n    std::destroy(ptr, ptr + 8);\n \n}",
            "output": "0 destructed\n1 destructed\n2 destructed\n3 destructed\n4 destructed\n5 destructed\n6 destructed\n7 destructed"
        }
    },
    "uninitialized_default_construct_n": {
        "description": {
            "texte": "The end of the range of objects (i.e., std::next(first, n))."
        },
        "parametres": "   first   -   the beginning of the range of elements to initialize \n   n   -   the number of elements to initialize \n   policy   -   the execution policy to use. See execution policy for details. \n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -No increment, assignment, comparison, or indirection through valid instances of ForwardIt may throw exceptions. \n\n"
    },
    "uninitialized_value_construct_n": {
        "description": {
            "texte": "The end of the range of objects (i.e., std::next(first, n))."
        },
        "parametres": "   first   -   the beginning of the range of elements to initialize \n   n   -   the number of elements to initialize \n   policy   -   the execution policy to use. See execution policy for details. \n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -No increment, assignment, comparison, or indirection through valid instances of ForwardIt may throw exceptions. \n\n"
    },
    "destroy_n": {
        "description": {
            "texte": "The end of the range of objects that has been destroyed (i.e., std::next(first, n))."
        },
        "parametres": "   first   -   the beginning of the range of elements to destroy \n   n   -   the number of elements to destroy \n   policy   -   the execution policy to use. See execution policy for details. \n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -No increment, assignment, comparison, or indirection through valid instances of ForwardIt may throw exceptions. \n\n",
        "exemple": {
            "input": "#include <memory>\n#include <new>\n#include <iostream>\n \nstruct Tracer {\n    int value;\n    ~Tracer() { std::cout << value << \" destructed\\n\"; }\n};\n \nint main()\n{\n    alignas(Tracer) unsigned char buffer[sizeof(Tracer) * 8];\n \n    for (int i = 0; i < 8; ++i)\n        new(buffer + sizeof(Tracer) * i) Tracer{i}; //manually construct objects\n \n    auto ptr = std::launder(reinterpret_cast<Tracer*>(buffer));\n \n    std::destroy_n(ptr, 8);\n \n}",
            "output": "0 destructed\n1 destructed\n2 destructed\n3 destructed\n4 destructed\n5 destructed\n6 destructed\n7 destructed"
        }
    },
    "partition_point": {
        "description": {
            "texte": "Examines the partitioned (as if by std::partition) range [first, last) and locates the end of the first partition, that is, the first element that does not satisfy p or last if all elements satisfy p."
        },
        "parametres": "   first, last   -   the partitioned range of elements to examine \n   p   -   unary predicate which returns \u200btrue for the elements found in the beginning of the range.  The expression p(v) must be convertible to bool for every argument v of type (possibly const) VT, where VT is the value type of ForwardIt, regardless of value category, and must not modify v. Thus, a parameter type of VT&is not allowed, nor is VT unless for VT a move is equivalent to a copy (since C++11). \u200b\n\n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -UnaryPredicate must meet the requirements of Predicate. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <array>\n#include <iostream>\n#include <iterator>\n \nint main()\n{\n    std::array<int, 9> v = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n \n    auto is_even = [](int i){ return i % 2 == 0; };\n    std::partition(v.begin(), v.end(), is_even);\n \n    auto p = std::partition_point(v.begin(), v.end(), is_even);\n \n    std::cout << \"Before partition:\\n    \";\n    std::copy(v.begin(), p, std::ostream_iterator<int>(std::cout, \" \"));\n    std::cout << \"\\nAfter partition:\\n    \";\n    std::copy(p, v.end(), std::ostream_iterator<int>(std::cout, \" \"));\n}",
            "output": "Before partition:\n    8 2 6 4 \nAfter partition:\n    5 3 7 1 9"
        }
    },
    "is_sorted": {
        "description": {
            "texte": "Checks if the elements in range [first, last) are sorted in non-descending order."
        },
        "parametres": "   first, last   -   the range of elements to examine \n   policy   -   the execution policy to use. See execution policy for details. \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type ForwardIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <algorithm>\n#include <iterator>\nint main() \n{\n    int digits[] = {3, 1, 4, 1, 5};\n \n    for (auto i : digits) std::cout << i << ' ';\n    std::cout << \": is_sorted: \" << std::boolalpha\n              << std::is_sorted(std::begin(digits), std::end(digits)) << '\\n';\n \n    std::sort(std::begin(digits), std::end(digits));\n \n    for (auto i : digits) std::cout << i << ' ';\n    std::cout << \": is_sorted: \"\n              << std::is_sorted(std::begin(digits), std::end(digits)) << '\\n';\n}",
            "output": "3 1 4 1 5 : is_sorted: false\n1 1 3 4 5 : is_sorted: true"
        }
    },
    "is_sorted_until": {
        "description": {
            "texte": "Examines the range [first, last) and finds the largest range beginning at first in which the elements are sorted in ascending order."
        },
        "parametres": "   first, last   -   the range of elements to examine \n   policy   -   the execution policy to use. See execution policy for details. \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type ForwardIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 g(rd());\n    const int N = 6;\n    int nums[N] = {3, 1, 4, 1, 5, 9};\n \n    const int min_sorted_size = 4;\n    int sorted_size = 0;\n    do {\n        std::shuffle(nums, nums + N, g);\n        int *sorted_end = std::is_sorted_until(nums, nums + N);\n        sorted_size = std::distance(nums, sorted_end);\n \n        for (auto i : nums) std::cout << i << ' ';\n        std::cout << \" : \" << sorted_size << \" initial sorted elements\\n\";\n    } while (sorted_size < min_sorted_size);\n}",
            "output": "4 1 9 5 1 3  : 1 initial sorted elements\n4 5 9 3 1 1  : 3 initial sorted elements\n9 3 1 4 5 1  : 1 initial sorted elements\n1 3 5 4 1 9  : 3 initial sorted elements\n5 9 1 1 3 4  : 2 initial sorted elements\n4 9 1 5 1 3  : 2 initial sorted elements\n1 1 4 9 5 3  : 4 initial sorted elements"
        }
    },
    "sort": {
        "description": {
            "texte": "Sorts the elements in the range [first, last) in ascending order. The order of equal elements is not guaranteed to be preserved."
        },
        "parametres": "   first, last   -   the range of elements to sort \n   policy   -   the execution policy to use. See execution policy for details. \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type RandomIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -RandomIt must meet the requirements of ValueSwappable and LegacyRandomAccessIterator. \n   -The type of dereferenced RandomIt must meet the requirements of MoveAssignable and MoveConstructible. \n   -Compare must meet the requirements of Compare. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <functional>\n#include <array>\n#include <iostream>\n \nint main()\n{\n    std::array<int, 10> s = {5, 7, 4, 2, 8, 6, 1, 9, 0, 3}; \n \n    // sort using the default operator<\n    std::sort(s.begin(), s.end());\n    for (auto a : s) {\n        std::cout << a << \" \";\n    }   \n    std::cout << '\\n';\n \n    // sort using a standard library compare function object\n    std::sort(s.begin(), s.end(), std::greater<int>());\n    for (auto a : s) {\n        std::cout << a << \" \";\n    }   \n    std::cout << '\\n';\n \n    // sort using a custom function object\n    struct {\n        bool operator()(int a, int b) const\n        {   \n            return a < b;\n        }   \n    } customLess;\n    std::sort(s.begin(), s.end(), customLess);\n    for (auto a : s) {\n        std::cout << a << \" \";\n    }   \n    std::cout << '\\n';\n \n    // sort using a lambda expression \n    std::sort(s.begin(), s.end(), [](int a, int b) {\n        return a > b;   \n    });\n    for (auto a : s) {\n        std::cout << a << \" \";\n    } \n    std::cout << '\\n';\n}",
            "output": "0 1 2 3 4 5 6 7 8 9 \n9 8 7 6 5 4 3 2 1 0 \n0 1 2 3 4 5 6 7 8 9 \n9 8 7 6 5 4 3 2 1 0"
        }
    },
    "stable_sort": {
        "description": {
            "texte": "Sorts the elements in the range [first, last) in ascending order. The order of equivalent elements is guaranteed to be preserved."
        },
        "parametres": "   first, last   -   the range of elements to sort \n   policy   -   the execution policy to use. See execution policy for details. \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type RandomIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -RandomIt must meet the requirements of ValueSwappable and LegacyRandomAccessIterator. \n   -The type of dereferenced RandomIt must meet the requirements of MoveAssignable and MoveConstructible. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n \nstruct Employee\n{\n    int age;\n    std::string name;  // Does not participate in comparisons\n};\n \nbool operator<(const Employee & lhs, const Employee & rhs)\n{\n    return lhs.age < rhs.age;\n}\n \nint main()\n{\n    std::vector<Employee> v =\n    { \n        {108, \"Zaphod\"},\n        {32, \"Arthur\"},\n        {108, \"Ford\"},\n    };  \n \n    std::stable_sort(v.begin(), v.end());\n \n    for (const Employee & e : v)\n        std::cout << e.age << \", \" << e.name << '\\n';\n}",
            "output": "32, Arthur\n108, Zaphod\n108, Ford"
        }
    },
    "partial_sort": {
        "description": {
            "texte": "Rearranges elements such that the range [first, middle) contains the sorted middle - first smallest elements in the range [first, last).The order of equal elements is not guaranteed to be preserved. The order of the remaining elements in the range [middle, last) is unspecified."
        },
        "parametres": "   first, last   -   the range of elements to sort \n   policy   -   the execution policy to use. See execution policy for details. \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type RandomIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -RandomIt must meet the requirements of ValueSwappable and LegacyRandomAccessIterator. \n   -The type of dereferenced RandomIt must meet the requirements of MoveAssignable and MoveConstructible. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <functional>\n#include <array>\n#include <iostream>\n \nint main()\n{\n    std::array<int, 10> s{5, 7, 4, 2, 8, 6, 1, 9, 0, 3};\n \n    std::partial_sort(s.begin(), s.begin() + 3, s.end());\n    for (int a : s) {\n        std::cout << a << \" \";\n    } \n}",
            "output": "0 1 2 7 8 6 5 9 4 3"
        }
    },
    "partial_sort_copy": {
        "description": {
            "texte": "Sorts some of the elements in the range [first, last) in ascending order, storing the result in the range [d_first, d_last).At most d_last - d_first of the elements are placed sorted to the range [d_first, d_first + n). n is the number of elements to sort (n = min(last - first, d_last - d_first)). The order of equal elements is not guaranteed to be preserved."
        },
        "parametres": "   first, last   -   the range of elements to sort \n   d_first, d_last   -   random access iterators defining the destination range \n   policy   -   the execution policy to use. See execution policy for details. \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type RandomIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -RandomIt must meet the requirements of ValueSwappable and LegacyRandomAccessIterator. \n   -The type of dereferenced RandomIt must meet the requirements of MoveAssignable and MoveConstructible. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <vector>\n#include <functional>\n#include <iostream>\n \nint main()\n{\n    std::vector<int> v0{4, 2, 5, 1, 3};\n    std::vector<int> v1{10, 11, 12};\n    std::vector<int> v2{10, 11, 12, 13, 14, 15, 16};\n    std::vector<int>::iterator it;\n \n    it = std::partial_sort_copy(v0.begin(), v0.end(), v1.begin(), v1.end());\n \n    std::cout << \"Writing to the smaller vector in ascending order gives: \";\n    for (int a : v1) {\n        std::cout << a << \" \";\n    }\n    std::cout << '\\n';\n    if(it == v1.end())\n        std::cout << \"The return value is the end iterator\\n\";\n \n    it = std::partial_sort_copy(v0.begin(), v0.end(), v2.begin(), v2.end(), \n                                std::greater<int>());\n \n    std::cout << \"Writing to the larger vector in descending order gives: \";\n    for (int a : v2) {\n        std::cout << a << \" \";\n    }\n    std::cout << '\\n' << \"The return value is the iterator to \" << *it << '\\n';\n}",
            "output": "Writing to the smaller vector in ascending order gives: 1 2 3\nThe return value is the end iterator\nWriting to the larger vector in descending order gives: 5 4 3 2 1 15 16\nThe return value is the iterator to 15"
        }
    },
    "nth_element": {
        "description": {
            "texte": "nth_element is a partial sorting algorithm that rearranges elements in [first, last) such that:More formally, nth_element partially sorts the range [first, last) in ascending order so that the condition !(*j < *i) (for (1-2), or comp(*j, *i) == false for (3-4)) is met for any i in the range [first, nth) and for any j in the range [nth, last). The element placed in the nth position is exactly the element that would occur in this position if the range was fully sorted.nth may be the end iterator, in this case the function has no effect."
        },
        "parametres": "   first, last   -   random access iterators defining the range sort \n   nth   -   random access iterator defining the sort partition point \n   policy   -   the execution policy to use. See execution policy for details. \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type RandomIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -RandomIt must meet the requirements of ValueSwappable and LegacyRandomAccessIterator. \n   -The type of dereferenced RandomIt must meet the requirements of MoveAssignable and MoveConstructible. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n \nint main()\n{\n    std::vector<int> v{5, 6, 4, 3, 2, 6, 7, 9, 3};\n \n    std::nth_element(v.begin(), v.begin() + v.size()/2, v.end());\n    std::cout << \"The median is \" << v[v.size()/2] << '\\n';\n \n    std::nth_element(v.begin(), v.begin()+1, v.end(), std::greater<int>());\n    std::cout << \"The second largest element is \" << v[1] << '\\n';\n}",
            "output": "The median is 5\nThe second largest element is 7"
        }
    },
    "lower_bound": {
        "description": {
            "texte": "Returns an iterator pointing to the first element in the range [first, last) that is not less than (i.e. greater or equal to) value, or last if no such element is found.The range [first, last) must be partitioned with respect to the expression element < value or comp(element, value), i.e., all elements for which the expression is true must precede all elements for which the expression is false. A fully-sorted range meets this criterion.The first version uses operator< to compare the elements, the second version uses the given comparison function comp."
        },
        "parametres": "   first, last   -   iterators defining the partially-ordered range to examine \n   value   -   value to compare the elements to \n   comp   -   binary predicate which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the predicate function should be equivalent to the following:\n bool pred(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The type Type1 must be such that an object of type ForwardIt can be dereferenced and then implicitly converted to Type1. The type Type2 must be such that an object of type T can be implicitly converted to Type2. \u200b\n\n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -Compare must meet the requirements of BinaryPredicate. it is not required to satisfy Compare \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <vector>\n \ntemplate<class ForwardIt, class T, class Compare=std::less<>>\nForwardIt binary_find(ForwardIt first, ForwardIt last, const T& value, Compare comp={})\n{\n    // Note: BOTH type T and the type after ForwardIt is dereferenced \n    // must be implicitly convertible to BOTH Type1 and Type2, used in Compare. \n    // This is stricter than lower_bound requirement (see above)\n \n    first = std::lower_bound(first, last, value, comp);\n    return first != last && !comp(value, *first) ? first : last;\n}\n \nint main()\n{\n    std::vector<int> data = { 1, 1, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6 };\n \n    auto lower = std::lower_bound(data.begin(), data.end(), 4);\n    auto upper = std::upper_bound(data.begin(), data.end(), 4);\n \n    std::copy(lower, upper, std::ostream_iterator<int>(std::cout, \" \"));\n \n    std::cout << '\\n';\n \n    // classic binary search, returning a value only if it is present\n \n    data = { 1, 2, 4, 6, 9, 10 }; \n \n    auto it = binary_find(data.cbegin(), data.cend(), 4); //< choosing '5' will return end()\n \n    if(it != data.cend())\n      std::cout << *it << \" found at index \"<< std::distance(data.cbegin(), it);\n \n    return 0;\n}",
            "output": "4 4 4 \n4 found at index 2"
        }
    },
    "upper_bound": {
        "description": {
            "texte": "Returns an iterator pointing to the first element in the range [first, last) that is greater than value, or last if no such element is found.The range [first, last) must be partitioned with respect to the expression !(value < element) or !comp(value, element), i.e., all elements for which the expression is true must precede all elements for which the expression is false. A fully-sorted range meets this criterion.The first version uses operator< to compare the elements, the second version uses the given comparison function comp."
        },
        "parametres": "   first, last   -   the range of elements to examine \n   value   -   value to compare the elements to \n   comp   -   binary predicate which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the predicate function should be equivalent to the following:\n bool pred(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The type Type1 must be such that an object of type T can be implicitly converted to Type1. The type Type2 must be such that an object of type ForwardIt can be dereferenced and then implicitly converted to Type2. \u200b\n\n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -Compare must meet the requirements of BinaryPredicate. it is not required to satisfy Compare \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <vector>\n \nint main()\n{\n    std::vector<int> data = { 1, 1, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6 };\n \n    auto lower = std::lower_bound(data.begin(), data.end(), 4);\n    auto upper = std::upper_bound(data.begin(), data.end(), 4);\n \n    std::copy(lower, upper, std::ostream_iterator<int>(std::cout, \" \"));\n}",
            "output": "4 4 4"
        }
    },
    "binary_search": {
        "description": {
            "texte": "Checks if an element equivalent to value appears within the range [first, last).For std::binary_search to succeed, the range [first, last) must be at least partially ordered with respect to value, i.e. it must satisfy all of the following requirements:A fully-sorted range meets these criteria.The first version uses operator< to compare the elements, the second version uses the given comparison function comp."
        },
        "parametres": "   first, last   -   the range of elements to examine \n   value   -   value to compare the elements to \n   comp   -   binary predicate which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the predicate function should be equivalent to the following:\n bool pred(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type T can be implicitly converted to both Type1 and Type2, and an object of type ForwardIt can be dereferenced and then implicitly converted to both Type1 and Type2. \u200b\n\n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -Compare must meet the requirements of BinaryPredicate. it is not required to satisfy Compare \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <algorithm>\n#include <vector>\n \nint main()\n{\n    std::vector<int> haystack {1, 3, 4, 5, 9};\n    std::vector<int> needles {1, 2, 3};\n \n    for (auto needle : needles) {\n        std::cout << \"Searching for \" << needle << '\\n';\n        if (std::binary_search(haystack.begin(), haystack.end(), needle)) {\n            std::cout << \"Found \" << needle << '\\n';\n        } else {\n            std::cout << \"no dice!\\n\";\n        }\n    }\n}",
            "output": "Searching for 1\nFound 1\nSearching for 2\nno dice!\nSearching for 3\nFound 3"
        }
    },
    "equal_range": {
        "description": {
            "texte": "Returns a range containing all elements equivalent to value in the range [first, last).The range [first, last) must be at least partially ordered with respect to value, i.e. it must satisfy all of the following requirements:A fully-sorted range meets these criteria.The returned range is defined by two iterators, one pointing to the first element that is not less than value and another pointing to the first element greater than value. The first iterator may be alternatively obtained with std::lower_bound(), the second - with std::upper_bound().The first version uses operator< to compare the elements, the second version uses the given comparison function comp."
        },
        "parametres": "   first, last   -   the range of elements to examine \n   value   -   value to compare the elements to \n   comp   -   binary predicate which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the predicate function should be equivalent to the following:\n bool pred(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type T can be implicitly converted to both Type1 and Type2, and an object of type ForwardIt can be dereferenced and then implicitly converted to both Type1 and Type2. \u200b\n\n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -Compare must meet the requirements of BinaryPredicate. it is not required to satisfy Compare \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <vector>\n#include <iostream>\n \nstruct S\n{\n    int number;\n    char name;\n    // note: name is ignored by this comparison operator\n    bool operator< ( const S& s ) const { return number < s.number; }\n};\n \nint main()\n{\n    // note: not ordered, only partitioned w.r.t. S defined below\n    std::vector<S> vec = { {1,'A'}, {2,'B'}, {2,'C'}, {2,'D'}, {4,'G'}, {3,'F'} };\n \n    S value = {2, '?'};\n \n    auto p = std::equal_range(vec.begin(), vec.end(), value);\n \n    for ( auto i = p.first; i != p.second; ++i )\n        std::cout << i->name << ' ';\n \n \n    // heterogeneous comparison:\n    struct Comp\n    {\n        bool operator() ( const S& s, int i ) const { return s.number < i; }\n        bool operator() ( int i, const S& s ) const { return i < s.number; }\n    };\n \n    auto p2 = std::equal_range(vec.begin(),vec.end(), 2, Comp{});\n \n    for ( auto i = p2.first; i != p2.second; ++i )\n        std::cout << i->name << ' ';\n}",
            "output": "B C D B C D"
        }
    },
    "merge": {
        "description": {
            "texte": "Merges two sorted ranges [first1, last1) and [first2, last2) into one sorted range beginning at d_first.For equivalent elements in the original two ranges, the elements from the first range (preserving their original order) precede the elements from the second range (preserving their original order).The behavior is undefined if the destination range overlaps either of the input ranges (the input ranges may overlap each other)."
        },
        "parametres": "   first1, last1   -   the first range of elements to merge \n   first2, last2   -   the second range of elements to merge \n   d_first   -   the beginning of the destination range \n   policy   -   the execution policy to use. See execution policy for details. \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that objects of types InputIt1 and InputIt2 can be dereferenced and then implicitly converted to both Type1 and Type2. \u200b\n\n   Type requirements \n   -InputIt1, InputIt2 must meet the requirements of LegacyInputIterator. \n   -ForwardIt1, ForwardIt2, ForwardIt3 must meet the requirements of LegacyForwardIterator. \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n#include <algorithm>\n#include <vector>\n#include <random>\n#include <functional>\n \nint main()\n{\n    // fill the vectors with random numbers\n    std::random_device rd;\n    std::mt19937 mt(rd());\n    std::uniform_int_distribution<> dis(0, 9);\n \n    std::vector<int> v1(10), v2(10);\n    std::generate(v1.begin(), v1.end(), std::bind(dis, std::ref(mt)));\n    std::generate(v2.begin(), v2.end(), std::bind(dis, std::ref(mt)));\n \n    // sort\n    std::sort(v1.begin(), v1.end());\n    std::sort(v2.begin(), v2.end());\n \n    // output v1\n    std::cout << \"v1 : \";\n    std::copy(v1.begin(), v1.end(), std::ostream_iterator<int>(std::cout, \" \"));\n    std::cout << '\\n';\n \n    // output v2\n    std::cout << \"v2 : \";\n    std::copy(v2.begin(), v2.end(), std::ostream_iterator<int>(std::cout, \" \"));\n    std::cout << '\\n';\n \n    // merge\n    std::vector<int> dst;\n    std::merge(v1.begin(), v1.end(), v2.begin(), v2.end(), std::back_inserter(dst));\n \n    // output\n    std::cout << \"dst: \";\n    std::copy(dst.begin(), dst.end(), std::ostream_iterator<int>(std::cout, \" \"));\n    std::cout << '\\n';\n}",
            "output": "v1 : 0 1 3 4 4 5 5 8 8 9 \nv2 : 0 2 2 3 6 6 8 8 8 9 \ndst: 0 0 1 2 2 3 3 4 4 5 5 6 6 8 8 8 8 8 9 9"
        }
    },
    "inplace_merge": {
        "description": {
            "texte": "Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last). For equivalent elements in the original two ranges, the elements from the first range (preserving their original order) precede the elements from the second range (preserving their original order)."
        },
        "parametres": "   first   -   the beginning of the first sorted range \n   middle   -   the end of the first sorted range and the beginning of the second \n   last   -   the end of the second sorted range \n   policy   -   the execution policy to use. See execution policy for details. \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type BidirIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -BidirIt must meet the requirements of ValueSwappable and LegacyBidirectionalIterator. \n   -The type of dereferenced BidirIt must meet the requirements of MoveAssignable and MoveConstructible. \n\n",
        "exemple": {
            "input": "#include <vector>\n#include <iostream>\n#include <algorithm>\n \ntemplate<class Iter>\nvoid merge_sort(Iter first, Iter last)\n{\n    if (last - first > 1) {\n        Iter middle = first + (last - first) / 2;\n        merge_sort(first, middle);\n        merge_sort(middle, last);\n        std::inplace_merge(first, middle, last);\n    }\n}\n \nint main()\n{\n    std::vector<int> v{8, 2, -2, 0, 11, 11, 1, 7, 3};\n    merge_sort(v.begin(), v.end());\n    for(auto n : v) {\n        std::cout << n << ' ';\n    }\n    std::cout << '\\n';\n}",
            "output": "-2 0 1 2 3 7 8 11 11"
        }
    },
    "set_difference": {
        "description": {
            "texte": "Copies the elements from the sorted range [first1, last1) which are not found in the sorted range [first2, last2) to the range beginning at d_first.The resulting range is also sorted. Equivalent elements are treated individually, that is, if some element is found m times in [first1, last1) and n times in [first2, last2), it will be copied to d_first exactly std::max(m-n, 0) times. The resulting range cannot overlap with either of the input ranges."
        },
        "parametres": "   first1, last1   -   the range of elements to examine \n   first2, last2   -   the range of elements to search for \n   policy   -   the execution policy to use. See execution policy for details. \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that objects of types InputIt1 and InputIt2 can be dereferenced and then implicitly converted to both Type1 and Type2. \u200b\n\n   Type requirements \n   -InputIt1, InputIt2 must meet the requirements of LegacyInputIterator. \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n   -ForwardIt1, ForwardIt2, ForwardIt3 must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n \nint main() {\n    std::vector<int> v1 {1, 2, 5, 5, 5, 9};\n    std::vector<int> v2 {2, 5, 7};\n    std::vector<int> diff;\n \n    std::set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), \n                        std::inserter(diff, diff.begin()));\n \n    for (auto i : v1) std::cout << i << ' ';\n    std::cout << \"minus \";\n    for (auto i : v2) std::cout << i << ' ';\n    std::cout << \"is: \";\n \n    for (auto i : diff) std::cout << i << ' ';\n    std::cout << '\\n';\n}",
            "output": "1 2 5 5 5 9 minus 2 5 7 is: 1 5 5 9"
        }
    },
    "set_intersection": {
        "description": {
            "texte": "Constructs a sorted range beginning at d_first consisting of elements that are found in both sorted ranges [first1, last1) and [first2, last2). If some element is found m times in [first1, last1) and n times in [first2, last2), the first std::min(m, n) elements will be copied from the first range to the destination range. The order of equivalent elements is preserved. The resulting range cannot overlap with either of the input ranges."
        },
        "parametres": "   first1, last1   -   the first range of elements to examine \n   first2, last2   -   the second range of elements to examine \n   policy   -   the execution policy to use. See execution policy for details. \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that objects of types InputIt1 and InputIt2 can be dereferenced and then implicitly converted to both Type1 and Type2. \u200b\n\n   Type requirements \n   -InputIt1, InputIt2 must meet the requirements of LegacyInputIterator. \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n   -ForwardIt1, ForwardIt2, ForwardIt3 must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\nint main()\n{\n    std::vector<int> v1{1,2,3,4,5,6,7,8};\n    std::vector<int> v2{        5,  7,  9,10};\n    std::sort(v1.begin(), v1.end());\n    std::sort(v2.begin(), v2.end());\n \n    std::vector<int> v_intersection;\n \n    std::set_intersection(v1.begin(), v1.end(),\n                          v2.begin(), v2.end(),\n                          std::back_inserter(v_intersection));\n    for(int n : v_intersection)\n        std::cout << n << ' ';\n}",
            "output": "5 7"
        }
    },
    "set_symmetric_difference": {
        "description": {
            "texte": "Computes symmetric difference of two sorted ranges: the elements that are found in either of the ranges, but not in both of them are copied to the range beginning at d_first. The resulting range is also sorted.If some element is found m times in [first1, last1) and n times in [first2, last2), it will be copied to d_first exactly std::abs(m-n) times. If m>n, then the last m-n of those elements are copied from [first1,last1), otherwise the last n-m elements are copied from [first2,last2). The resulting range cannot overlap with either of the input ranges."
        },
        "parametres": "   first1, last1   -   the first sorted range of elements \n   first2, last2   -   the second sorted range of elements \n   policy   -   the execution policy to use. See execution policy for details. \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that objects of types InputIt1 and InputIt2 can be dereferenced and then implicitly converted to both Type1 and Type2. \u200b\n\n   Type requirements \n   -InputIt1, InputIt2 must meet the requirements of LegacyInputIterator. \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n   -ForwardIt1, ForwardIt2, ForwardIt3 must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\nint main()\n{\n    std::vector<int> v1{1,2,3,4,5,6,7,8     };\n    std::vector<int> v2{        5,  7,  9,10};\n    std::sort(v1.begin(), v1.end());\n    std::sort(v2.begin(), v2.end());\n \n    std::vector<int> v_symDifference;\n \n    std::set_symmetric_difference(\n        v1.begin(), v1.end(),\n        v2.begin(), v2.end(),\n        std::back_inserter(v_symDifference));\n \n    for(int n : v_symDifference)\n        std::cout << n << ' ';\n}",
            "output": "1 2 3 4 6 8 9 10"
        }
    },
    "set_union": {
        "description": {
            "texte": "Constructs a sorted union beginning at d_first consisting of the set of elements present in one or both sorted ranges [first1, last1) and [first2, last2).If some element is found m times in [first1, last1) and n times in [first2, last2), then all m elements will be copied from [first1, last1) to d_first, preserving order, and then exactly std::max(n-m, 0) elements will be copied from [first2, last2) to d_first, also preserving order.The resulting range cannot overlap with either of the input ranges."
        },
        "parametres": "   first1, last1   -   the first input sorted range \n   first2, last2   -   the second input sorted range \n   policy   -   the execution policy to use. See execution policy for details. \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that objects of types InputIt1 and InputIt2 can be dereferenced and then implicitly converted to both Type1 and Type2. \u200b\n\n   Type requirements \n   -InputIt1, InputIt2 must meet the requirements of LegacyInputIterator. \n   -ForwardIt1, ForwardIt2, ForwardIt3 must meet the requirements of LegacyForwardIterator. \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n\n",
        "exemple": {
            "input": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n \nint main()\n{\n    {\n        std::vector<int> v1 = {1, 2, 3, 4, 5}; \n        std::vector<int> v2 = {      3, 4, 5, 6, 7}; \n        std::vector<int> dest1;\n \n        std::set_union(v1.begin(), v1.end(),\n                       v2.begin(), v2.end(),                  \n                       std::back_inserter(dest1));\n \n        for (const auto &i : dest1) {\n            std::cout << i << ' ';\n        }   \n        std::cout << '\\n';\n    }\n    {\n        std::vector<int> v1 = {1, 2, 3, 4, 5, 5, 5}; \n        std::vector<int> v2 = {      3, 4, 5, 6, 7}; \n        std::vector<int> dest1;\n \n        std::set_union(v1.begin(), v1.end(),\n                       v2.begin(), v2.end(),                  \n                       std::back_inserter(dest1));\n \n        for (const auto &i : dest1) {\n            std::cout << i << ' ';\n        }   \n        std::cout << '\\n';\n    }\n}",
            "output": "1 2 3 4 5 6 7 \n1 2 3 4 5 5 5 6 7"
        }
    },
    "includes": {
        "description": {
            "texte": "Returns true if the sorted range [first2, last2) is a subsequence of the sorted range [first1, last1). (A subsequence need not be contiguous.)."
        },
        "parametres": "   first1, last1   -   the sorted range of elements to examine \n   first2, last2   -   the sorted range of elements to search for \n   policy   -   the execution policy to use. See execution policy for details. \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than (i.e. is ordered before) the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type InputIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -InputIt1, InputIt2 must meet the requirements of LegacyInputIterator. \n   -ForwardIt1, ForwardIt2 must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n \nint main()\n{\n  std::vector<char> v1 {'a', 'b', 'c', 'f', 'h', 'x'};\n  std::vector<char> v2 {'a', 'b', 'c'};\n  std::vector<char> v3 {'a', 'c'};\n  std::vector<char> v4 {'g'};\n  std::vector<char> v5 {'a', 'c', 'g'};\n \n  for (auto i : v1) std::cout << i << ' ';\n  std::cout << \"\\nincludes:\\n\" << std::boolalpha;\n \n  for (auto i : v2) std::cout << i << ' ';\n  std::cout << \": \" << std::includes(v1.begin(), v1.end(), v2.begin(), v2.end()) << '\\n';\n  for (auto i : v3) std::cout << i << ' ';\n  std::cout << \": \" << std::includes(v1.begin(), v1.end(), v3.begin(), v3.end()) << '\\n';\n  for (auto i : v4) std::cout << i << ' ';\n  std::cout << \": \" << std::includes(v1.begin(), v1.end(), v4.begin(), v4.end()) << '\\n';\n  for (auto i : v5) std::cout << i << ' ';\n  std::cout << \": \" << std::includes(v1.begin(), v1.end(), v5.begin(), v5.end()) << '\\n';\n \n  auto cmp_nocase = [](char a, char b) {\n    return std::tolower(a) < std::tolower(b);\n  };\n \n  std::vector<char> v6 {'A', 'B', 'C'};\n  for (auto i : v6) std::cout << i << ' ';\n  std::cout << \": (case-insensitive) \"\n            << std::includes(v1.begin(), v1.end(), v6.begin(), v6.end(), cmp_nocase)\n            << '\\n';\n}",
            "output": "a b c f h x\nincludes:\na b c : true\na c : true\ng : false\na c g : false\nA B C : (case-insensitive) true"
        }
    },
    "is_heap": {
        "description": {
            "texte": "Checks if the elements in range [first, last) are a max heap."
        },
        "parametres": "   first, last   -   the range of elements to examine \n   policy   -   the execution policy to use. See execution policy for details. \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type RandomIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -RandomIt must meet the requirements of LegacyRandomAccessIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <algorithm>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v { 3, 1, 4, 1, 5, 9 };\n \n    std::cout << \"initially, v: \";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\\n';\n \n    if (!std::is_heap(v.begin(), v.end())) {\n        std::cout << \"making heap...\\n\";\n        std::make_heap(v.begin(), v.end());\n    }\n \n    std::cout << \"after make_heap, v: \";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\\n';\n}",
            "output": "initially, v: 3 1 4 1 5 9 \nmaking heap...\nafter make_heap, v: 9 5 4 1 1 3"
        }
    },
    "is_heap_until": {
        "description": {
            "texte": "Examines the range [first, last) and finds the largest range beginning at first which is a max heap."
        },
        "parametres": "   first, last   -   the range of elements to examine \n   policy   -   the execution policy to use. See execution policy for details. \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type RandomIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -RandomIt must meet the requirements of LegacyRandomAccessIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <algorithm>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v { 3, 1, 4, 1, 5, 9 };\n \n    std::make_heap(v.begin(), v.end());\n \n    // probably mess up the heap\n    v.push_back(2);\n    v.push_back(6);\n \n    auto heap_end = std::is_heap_until(v.begin(), v.end());\n \n    std::cout << \"all of v: \";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\\n';\n \n    std::cout << \"only heap: \";\n    for (auto i = v.begin(); i != heap_end; ++i) std::cout << *i << ' ';\n    std::cout << '\\n';\n}",
            "output": "all of v:  9 5 4 1 1 3 2 6 \nonly heap: 9 5 4 1 1 3 2"
        }
    },
    "make_heap": {
        "description": {
            "texte": "Constructs a max heap in the range [first, last). The first version of the function uses operator< to compare the elements, the second uses the given comparison function comp."
        },
        "parametres": "   first, last   -   the range of elements to make the heap from \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type RandomIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -RandomIt must meet the requirements of LegacyRandomAccessIterator. \n   -The type of dereferenced RandomIt must meet the requirements of MoveAssignable and MoveConstructible. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <algorithm>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v { 3, 1, 4, 1, 5, 9 };\n \n    std::cout << \"initially, v: \";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\\n';\n \n    std::make_heap(v.begin(), v.end());\n \n    std::cout << \"after make_heap, v: \";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\\n';\n \n    std::pop_heap(v.begin(), v.end());\n    auto largest = v.back();\n    v.pop_back();\n    std::cout << \"largest element: \" << largest << '\\n';\n \n    std::cout << \"after removing the largest element, v: \";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\\n';\n}",
            "output": "initially, v: 3 1 4 1 5 9 \nafter make_heap, v: 9 5 4 1 1 3 \nlargest element: 9\nafter removing the largest element, v: 5 3 4 1 1"
        }
    },
    "sort_heap": {
        "description": {
            "texte": "Converts the max heap [first, last) into a sorted range in ascending order. The resulting range no longer has the heap property.The first version of the function uses operator< to compare the elements, the second uses the given comparison function comp."
        },
        "parametres": "   first, last   -   the range of elements to sort \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type RandomIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -RandomIt must meet the requirements of ValueSwappable and LegacyRandomAccessIterator. \n   -The type of dereferenced RandomIt must meet the requirements of MoveAssignable and MoveConstructible. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <vector>\n#include <iostream>\n \nint main()\n{\n    std::vector<int> v = {3, 1, 4, 1, 5, 9}; \n \n    std::make_heap(v.begin(), v.end());\n \n    std::cout << \"heap:\\t\";\n    for (const auto &i : v) {\n        std::cout << i << ' ';\n    }   \n \n    std::sort_heap(v.begin(), v.end());\n \n    std::cout << \"\\nsorted:\\t\";\n    for (const auto &i : v) {                                                   \n        std::cout << i << ' ';\n    }   \n    std::cout << '\\n';\n}",
            "output": "heap:   9 4 5 1 1 3 \nsorted: 1 1 3 4 5 9"
        }
    },
    "push_heap": {
        "description": {
            "texte": "Inserts the element at the position last-1 into the max heap defined by the range [first, last-1). The first version of the function uses operator< to compare the elements, the second uses the given comparison function comp."
        },
        "parametres": "   first, last   -   the range of elements defining the heap to modify \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type RandomIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -RandomIt must meet the requirements of LegacyRandomAccessIterator. \n   -The type of dereferenced RandomIt must meet the requirements of MoveAssignable and MoveConstructible. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <algorithm>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v { 3, 1, 4, 1, 5, 9 };\n \n    std::make_heap(v.begin(), v.end());\n \n    std::cout << \"v: \";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\\n';\n \n    v.push_back(6);\n \n    std::cout << \"before push_heap: \";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\\n';\n \n    std::push_heap(v.begin(), v.end());\n \n    std::cout << \"after push_heap: \";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\\n';\n}",
            "output": "v: 9 5 4 1 1 3 \nbefore push_heap: 9 5 4 1 1 3 6 \nafter push_heap:  9 5 6 1 1 3 4"
        }
    },
    "pop_heap": {
        "description": {
            "texte": "Swaps the value in the position first and the value in the position last-1 and makes the subrange [first, last-1) into a max heap. This has the effect of removing the first (largest) element from the heap defined by the range [first, last).The first version of the function uses operator< to compare the elements, the second uses the given comparison function comp."
        },
        "parametres": "   first, last   -   the range of elements defining the valid nonempty heap to modify \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type RandomIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -RandomIt must meet the requirements of ValueSwappable and LegacyRandomAccessIterator. \n   -The type of dereferenced RandomIt must meet the requirements of MoveAssignable and MoveConstructible. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <algorithm>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v { 3, 1, 4, 1, 5, 9 };\n \n    std::make_heap(v.begin(), v.end());\n \n    std::cout << \"v: \";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\\n';\n \n    std::pop_heap(v.begin(), v.end()); // moves the largest to the end\n \n    std::cout << \"after pop_heap: \";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\\n';\n \n    int largest = v.back();\n    v.pop_back();  // actually removes the largest element\n    std::cout << \"largest element: \" << largest << '\\n';\n \n    std::cout << \"heap without largest: \";\n    for (auto i : v) std::cout << i << ' ';\n    std::cout << '\\n';\n}",
            "output": "v: 9 5 4 1 1 3 \nafter pop_heap: 5 3 4 1 1 9 \nlargest element: 9\nheap without largest: 5 3 4 1 1"
        }
    },
    "max": {
        "description": {
            "texte": "Returns the greater of the given values.The (1,3) versions use operator< to compare the values, the (2,4) versions use the given comparison function comp."
        },
        "parametres": "   a, b   -   the values to compare \n   ilist   -   initializer list with the values to compare \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if a is less than b.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type T can be implicitly converted to both of them. \u200b\n\n   Type requirements \n   -T must meet the requirements of LessThanComparable in order to use overloads (1,3). \n   -T must meet the requirements of CopyConstructible in order to use overloads (3,4). \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <string>\n \nint main()\n{\n    std::cout << \"larger of 1 and 9999: \" << std::max(1, 9999) << '\\n'\n              << \"larger of 'a', and 'b': \" << std::max('a', 'b') << '\\n'\n              << \"longest of \\\"foo\\\", \\\"bar\\\", and \\\"hello\\\": \" <<\n                  std::max( { \"foo\", \"bar\", \"hello\" },\n                            [](const std::string& s1, const std::string& s2) {\n                                 return s1.size() < s2.size();\n                             }) << '\\n';\n}",
            "output": "larger of 1 and 9999: 9999\nlarger of 'a', and 'b': b\nlongest of \"foo\", \"bar\", and \"hello\": hello"
        }
    },
    "max_element": {
        "description": {
            "texte": "Finds the greatest element in the range [first, last)."
        },
        "parametres": "   first, last   -   forward iterators defining the range to examine \n   policy   -   the execution policy to use. See execution policy for details. \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type ForwardIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cmath>\n \nstatic bool abs_compare(int a, int b)\n{\n    return (std::abs(a) < std::abs(b));\n}\n \nint main()\n{\n    std::vector<int> v{ 3, 1, -14, 1, 5, 9 }; \n    std::vector<int>::iterator result;\n \n    result = std::max_element(v.begin(), v.end());\n    std::cout << \"max element at: \" << std::distance(v.begin(), result) << '\\n';\n \n    result = std::max_element(v.begin(), v.end(), abs_compare);\n    std::cout << \"max element (absolute) at: \" << std::distance(v.begin(), result);\n}",
            "output": "max element at: 5\nmax element (absolute) at: 2"
        }
    },
    "min": {
        "description": {
            "texte": "Returns the smaller of the given values.The (1,3) versions use operator< to compare the values, the (2,4) versions use the given comparison function comp."
        },
        "parametres": "   a, b   -   the values to compare \n   ilist   -   initializer list with the values to compare \n   cmp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if a is less than b.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type T can be implicitly converted to both of them. \u200b\n\n   Type requirements \n   -T must meet the requirements of LessThanComparable in order to use overloads (1,3). \n   -T must meet the requirements of CopyConstructible in order to use overloads (3,4). \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <string>\n \nint main()\n{\n    std::cout << \"smaller of 1 and 9999: \" << std::min(1, 9999) << '\\n'\n              << \"smaller of 'a', and 'b': \" << std::min('a', 'b') << '\\n'\n              << \"shortest of \\\"foo\\\", \\\"bar\\\", and \\\"hello\\\": \" <<\n                  std::min( { \"foo\", \"bar\", \"hello\" },\n                            [](const std::string& s1, const std::string& s2) {\n                                 return s1.size() < s2.size();\n                             }) << '\\n';\n}",
            "output": "smaller of 1 and 9999: 1\nsmaller of 'a', and 'b': a\nshortest of \"foo\", \"bar\", and \"hello\": foo"
        }
    },
    "min_element": {
        "description": {
            "texte": "Finds the smallest element in the range [first, last)."
        },
        "parametres": "   first, last   -   forward iterators defining the range to examine \n   policy   -   the execution policy to use. See execution policy for details. \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if a is less than b.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type ForwardIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <vector>\n \nint main()\n{\n    std::vector<int> v{3, 1, 4, 1, 5, 9};\n \n    std::vector<int>::iterator result = std::min_element(std::begin(v), std::end(v));\n    std::cout << \"min element at: \" << std::distance(std::begin(v), result);\n}",
            "output": "min element at: 1"
        }
    },
    "minmax": {
        "description": {
            "texte": "Returns the lowest and the greatest of the given values.The (1,3) versions use operator< to compare the values, whereas the (2,4) versions use the given comparison function comp."
        },
        "parametres": "   a, b   -   the values to compare \n   ilist   -   initializer list with the values to compare \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type T can be implicitly converted to both of them. \u200b\n\n   Type requirements \n   -T must meet the requirements of LessThanComparable in order to use overloads (1,3). \n   -T must meet the requirements of CopyConstructible in order to use overloads (3,4). \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\n \nint main()\n{\n    std::vector<int> v {3, 1, 4, 1, 5, 9, 2, 6}; \n    std::srand(std::time(0));\n    std::pair<int, int> bounds = std::minmax(std::rand() % v.size(),\n                                             std::rand() % v.size());\n \n    std::cout << \"v[\" << bounds.first << \",\" << bounds.second << \"]: \";\n    for (int i = bounds.first; i < bounds.second; ++i) {\n        std::cout << v[i] << ' ';\n    }\n    std::cout << '\\n';\n}",
            "output": "v[2,7]: 4 1 5 9 2"
        }
    },
    "minmax_element": {
        "description": {
            "texte": "Finds the smallest and greatest element in the range [first, last)."
        },
        "parametres": "   first, last   -   forward iterators defining the range to examine \n   policy   -   the execution policy to use. See execution policy for details. \n   cmp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if if *a is less than *b.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type ForwardIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <vector>\n \nint main() {\n    const auto v = { 3, 9, 1, 4, 2, 5, 9 };\n    const auto [min, max] = std::minmax_element(begin(v), end(v));\n \n    std::cout << \"min = \" << *min << \", max = \" << *max << '\\n';\n}",
            "output": "min = 1, max = 9"
        }
    },
    "clamp": {
        "description": {
            "texte": "The behavior is undefined if the value of lo is greater than hi."
        },
        "parametres": "   v   -   the value to clamp \n   lo,hi   -   the boundaries to clamp v to \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type T can be implicitly converted to both of them. \u200b\n\n   Type requirements \n   -T must meet the requirements of LessThanComparable in order to use overloads (1). \n\n",
        "exemple": {
            "input": "#include <cstdint>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <random>\n \nint main()\n{\n    std::mt19937 g(std::random_device{}());\n    std::uniform_int_distribution<> d(-300, 300);\n    std::cout << \" raw   clamped to int8_t   clamped to uint8_t\\n\";\n    for(int n = 0; n < 5; ++n) {\n        int v = d(g);\n        std::cout << std::setw(4) << v\n                  << std::setw(20) << std::clamp(v, INT8_MIN, INT8_MAX)\n                  << std::setw(21) << std::clamp(v, 0, UINT8_MAX) << '\\n';\n    }\n}",
            "output": ".raw   clamped to int8_t   clamped to uint8_t\n 168                 127                  168\n 128                 127                  128\n-137                -128                    0\n  40                  40                   40\n -66                 -66                    0"
        }
    },
    "compare_3way": {
        "description": {
            "texte": "Compares two values using three-way comparison and produces a result of the strongest applicable comparison category type.In detail:"
        },
        "parametres": "   a, b   -   the values to compare \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <compare>\n#include <algorithm>\n \n//does not support <=>\nstruct Rational_1 {\n    int num;\n    int den; // > 0\n};\n \ninline constexpr bool operator<(Rational_1 lhs, Rational_1 rhs)\n{\n    return lhs.num * rhs.den < rhs.num * lhs.den;\n}\n \ninline constexpr bool operator==(Rational_1 lhs, Rational_1 rhs)\n{\n    return lhs.num * rhs.den == rhs.num * lhs.den;\n}\n \n//supports <=>\nstruct Rational_2 {\n    int num;\n    int den; // > 0\n};\n \ninline constexpr std::weak_ordering operator<=>(Rational_2 lhs, Rational_2 rhs)\n{\n    return lhs.num * rhs.den <=> rhs.num * lhs.den;\n}\n \nvoid print(std::weak_ordering value)\n{\n    if (value == 0)\n        std::cout << \"equal\";\n    else if (value < 0)\n        std::cout << \"less\";\n    else\n        std::cout << \"greater\";\n    std::cout << \"\\n\";\n}\n \nint main()\n{\n    Rational_1 a{1,2};\n    Rational_1 b{3,4};\n//  print(a <=> b);                //doesn't work\n    print(std::compare_3way(a,b)); //works, defaults to < and ==\n \n    Rational_2 c{6,5};\n    Rational_2 d{8,7};\n    print(c <=> d);                //works\n    print(std::compare_3way(c,d)); //works\n}",
            "output": "less\ngreater\ngreater"
        }
    },
    "is_permutation": {
        "description": {
            "texte": "Returns true if there exists a permutation of the elements in the range [first1, last1) that makes that range equal to the range [first2,last2), where last2 denotes first2 + (last1 - first1) if it was not given."
        },
        "parametres": "   first1, last1   -   the range of elements to compare \n   first2, last2   -   the second range to compare \n   p   -   binary predicate which returns \u200btrue if the elements should be treated as equal.  The signature of the predicate function should be equivalent to the following:\n bool pred(const Type &a, const Type &b);\nType should be the value type of both ForwardIt1 and ForwardIt2. The signature does not need to have const &, but the function must not modify the objects passed to it. \u200b\n\n   Type requirements \n   -ForwardIt1, ForwardIt2 must meet the requirements of LegacyForwardIterator. \n   -ForwardIt1, ForwardIt2 must have the same value type. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <vector>\n#include <iostream>\nint main()\n{\n    std::vector<int> v1{1,2,3,4,5};\n    std::vector<int> v2{3,5,4,1,2};\n    std::cout << \"3,5,4,1,2 is a permutation of 1,2,3,4,5? \"\n              << std::boolalpha\n              << std::is_permutation(v1.begin(), v1.end(), v2.begin()) << '\\n';\n \n    std::vector<int> v3{3,5,4,1,1};\n    std::cout << \"3,5,4,1,1 is a permutation of 1,2,3,4,5? \"\n              << std::boolalpha\n              << std::is_permutation(v1.begin(), v1.end(), v3.begin()) << '\\n';\n}",
            "output": "3,5,4,1,2 is a permutation of 1,2,3,4,5? true\n3,5,4,1,1 is a permutation of 1,2,3,4,5? false"
        }
    },
    "next_permutation": {
        "description": {
            "texte": "Transforms the range [first, last) into the next permutation from the set of all permutations that are lexicographically ordered with respect to operator< or comp. Returns true if such permutation exists, otherwise transforms the range into the first permutation (as if by std::sort(first, last)) and returns false."
        },
        "parametres": "   first, last   -   the range of elements to permute \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type BidirIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -BidirIt must meet the requirements of ValueSwappable and LegacyBidirectionalIterator. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <string>\n#include <iostream>\n \nint main()\n{\n    std::string s = \"aba\";\n    std::sort(s.begin(), s.end());\n    do {\n        std::cout << s << '\\n';\n    } while(std::next_permutation(s.begin(), s.end()));\n}",
            "output": "aab\naba\nbaa"
        }
    },
    "prev_permutation": {
        "description": {
            "texte": "Transforms the range [first, last) into the previous permutation from the set of all permutations that are lexicographically ordered with respect to operator< or comp. Returns true if such permutation exists, otherwise transforms the range into the last permutation (as if by std::sort(first, last); std::reverse(first, last);) and returns false."
        },
        "parametres": "   first, last   -   the range of elements to permute \n   comp   -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns \u200btrue if the first argument is less than the second.  The signature of the comparison function should be equivalent to the following:\n bool cmp(const Type1 &a, const Type2 &b);\nWhile the signature does not need to have const &, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 & is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type BidirIt can be dereferenced and then implicitly converted to both of them. \u200b\n\n   Type requirements \n   -BidirIt must meet the requirements of ValueSwappable and LegacyBidirectionalIterator. \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <string>\n#include <iostream>\n#include <functional>\nint main()\n{\n    std::string s=\"abc\";\n    std::sort(s.begin(), s.end(), std::greater<char>());\n    do {\n        std::cout << s << ' ';\n    } while(std::prev_permutation(s.begin(), s.end()));\n    std::cout << '\\n';\n}",
            "output": "cba cab bca bac acb abc"
        }
    },
    "iota": {
        "description": {
            "texte": "Fills the range [first, last) with sequentially increasing values, starting with value and repetitively evaluating ++value.Equivalent operation:",
            "code": "*(d_first)   = value;\n*(d_first+1) = ++value;\n*(d_first+2) = ++value;\n*(d_first+3) = ++value;\n..."
        },
        "parametres": "   first, last   -   the range of elements to fill with sequentially increasing values starting with value \n   value   -   initial value to store, the expression ++value must be well-formed \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <random>\n#include <vector>\n \nint main()\n{\n    std::list<int> l(10);\n    std::iota(l.begin(), l.end(), -4);\n \n    std::vector<std::list<int>::iterator> v(l.size());\n    std::iota(v.begin(), v.end(), l.begin());\n \n    std::shuffle(v.begin(), v.end(), std::mt19937{std::random_device{}()});\n \n    std::cout << \"Contents of the list: \";\n    for(auto n: l) std::cout << n << ' ';\n    std::cout << '\\n';\n \n    std::cout << \"Contents of the list, shuffled: \";\n    for(auto i: v) std::cout << *i << ' ';\n    std::cout << '\\n';\n}",
            "output": "Contents of the list: -4 -3 -2 -1 0 1 2 3 4 5\nContents of the list, shuffled: 0 -1 3 4 -4 1 -2 -3 2 5"
        }
    },
    "inner_product": {
        "description": {
            "texte": "Computes inner product (i.e. sum of products) or performs ordered map/reduce operation on the range [first1, last1) and the range beginning at first2."
        },
        "parametres": "   first1, last1   -   the first range of elements \n   first2   -   the beginning of the second range of elements \n   init   -   initial value of the sum of the products \n   op1   -   binary operation function object that will be applied. This \"sum\" function takes a value returned by op2 and the current value of the accumulator and produces a new value to be stored in the accumulator.  The signature of the function should be equivalent to the following:\n Ret fun(const Type1 &a, const Type2 &b);\nThe signature does not need to have const &. The types Type1 and Type2 must be such that objects of types T and Type3 can be implicitly converted to Type1 and Type2 respectively. The type Ret must be such that an object of type T can be assigned a value of type Ret. \u200b\n\n   op2   -   binary operation function object that will be applied. This \"product\" function takes one value from each range and produces a new value.  The signature of the function should be equivalent to the following:\n Ret fun(const Type1 &a, const Type2 &b);\nThe signature does not need to have const &. The types Type1 and Type2 must be such that objects of types InputIt1 and InputIt2 can be dereferenced and then implicitly converted to Type1 and Type2 respectively. The type Ret must be such that an object of type Type3 can be assigned a value of type Ret. \u200b\n\n   Type requirements \n   -InputIt1, InputIt2 must meet the requirements of LegacyInputIterator. \n   -ForwardIt1, ForwardIt2 must meet the requirements of LegacyForwardIterator. \n   -T must meet the requirements of CopyAssignable and CopyConstructible. \n\n",
        "exemple": {
            "input": "#include <numeric>\n#include <iostream>\n#include <vector>\n#include <functional>\nint main()\n{\n    std::vector<int> a{0, 1, 2, 3, 4};\n    std::vector<int> b{5, 4, 2, 3, 1};\n \n    int r1 = std::inner_product(a.begin(), a.end(), b.begin(), 0);\n    std::cout << \"Inner product of a and b: \" << r1 << '\\n';\n \n    int r2 = std::inner_product(a.begin(), a.end(), b.begin(), 0,\n                                std::plus<>(), std::equal_to<>());\n    std::cout << \"Number of pairwise matches between a and b: \" <<  r2 << '\\n';\n}",
            "output": "Inner product of a and b: 21\nNumber of pairwise matches between a and b: 2"
        }
    },
    "adjacent_difference": {
        "description": {
            "texte": "Computes the differences between the second and the first of each adjacent pair of elements of the range [first, last) and writes them to the range beginning at d_first + 1. An unmodified copy of *first is written to *d_first. Equivalent operation:",
            "code": "*(d_first)   = *first;\n*(d_first+1) = *(first+1) - *(first);\n*(d_first+2) = *(first+2) - *(first+1);\n*(d_first+3) = *(first+3) - *(first+2);\n..."
        },
        "parametres": "   first, last   -   the range of elements \n   d_first   -   the beginning of the destination range \n   policy   -   the execution policy to use. See execution policy for details. \n   op   -   binary operation function object that will be applied.  The signature of the function should be equivalent to the following:\n Ret fun(const Type1 &a, const Type2 &b);\nThe signature does not need to have const &. The types Type1 and Type2 must be such that an object of type iterator_traits<InputIt>::value_type can be implicitly converted to both of them. The type Ret must be such that an object of type OutputIt can be dereferenced and assigned a value of type Ret. \u200b\n\n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. InputIt's value type must be MoveAssignable and constructible from the type of *first \n   -OutputIt must meet the requirements of LegacyOutputIterator. both acc (the accumulated value) and the result of val - acc or op(val, acc) (until C++20)val - std::move(acc) or op(val, std::move(acc)) (since C++20) must be writable to OutputIt \n   -ForwardIt1, ForwardIt2 must meet the requirements of LegacyForwardIterator. The results of *first, *first - *first (for (2)) and op(*first, *first) (for (4)) must be writable to ForwardIt2. \n\n",
        "exemple": {
            "input": "#include <numeric>\n#include <vector>\n#include <array>\n#include <iostream>\n#include <functional>\n#include <iterator>\n \nint main()\n{\n    // Default implementation - the difference b/w two adjacent items\n \n    std::vector v {2, 4, 6, 8, 10, 12, 14, 16, 18, 20};\n    std::adjacent_difference(v.begin(), v.end(), v.begin());\n \n    for (auto n : v)\n        std::cout << n << ' ';\n \n    std::cout << '\\n';\n \n    // Fibonacci \n \n    std::array<int, 10> a {1};\n \n    adjacent_difference(begin(a), std::prev(end(a)), std::next(begin(a)), std::plus<> {});\n \n    copy(begin(a), end(a), std::ostream_iterator<int> {std::cout, \" \"});\n}",
            "output": "2 2 2 2 2 2 2 2 2 2\n1 1 2 3 5 8 13 21 34 55"
        }
    },
    "accumulate": {
        "description": {
            "texte": "Computes the sum of the given value init and the elements in the range [first, last). The first version uses operator+ to sum up the elements, the second version uses the given binary function op, both applying std::move to their operands on the left hand side (since C++20)."
        },
        "parametres": "   first, last   -   the range of elements to sum \n   init   -   initial value of the sum \n   op   -   binary operation function object that will be applied. The binary operator takes the current accumulation value a (initialized to init) and the value of the current element b.  The signature of the function should be equivalent to the following:\n Ret fun(const Type1 &a, const Type2 &b);\nThe signature does not need to have const &. The type Type1 must be such that an object of type T can be implicitly converted to Type1. The type Type2 must be such that an object of type InputIt can be dereferenced and then implicitly converted to Type2. The type Ret must be such that an object of type T can be assigned a value of type Ret. \u200b\n\n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -T must meet the requirements of CopyAssignable and CopyConstructible. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <string>\n#include <functional>\n \nint main()\n{\n    std::vector<int> v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n \n    int sum = std::accumulate(v.begin(), v.end(), 0);\n \n    int product = std::accumulate(v.begin(), v.end(), 1, std::multiplies<int>());\n \n    auto dash_fold = [](std::string a, int b) {\n                         return std::move(a) + '-' + std::to_string(b);\n                     };\n \n    std::string s = std::accumulate(std::next(v.begin()), v.end(),\n                                    std::to_string(v[0]), // start with first element\n                                    dash_fold);\n \n    // Right fold using reverse iterators\n    std::string rs = std::accumulate(std::next(v.rbegin()), v.rend(),\n                                     std::to_string(v.back()), // start with last element\n                                     dash_fold);\n \n    std::cout << \"sum: \" << sum << '\\n'\n              << \"product: \" << product << '\\n'\n              << \"dash-separated string: \" << s << '\\n'\n              << \"dash-separated string (right-folded): \" << rs << '\\n';\n}",
            "output": "sum: 55\nproduct: 3628800\ndash-separated string: 1-2-3-4-5-6-7-8-9-10\ndash-separated string (right-folded): 10-9-8-7-6-5-4-3-2-1"
        }
    },
    "reduce": {
        "description": {
            "texte": "The behavior is non-deterministic if binary_op is not associative or not commutative.The behavior is undefined if binary_op modifies any element or invalidates any iterator in [first; last], including the end iterator."
        },
        "parametres": "   first, last   -   the range of elements to apply the algorithm to \n   init   -   the initial value of the generalized sum \n   policy   -   the execution policy to use. See execution policy for details. \n   binary_op   -   binary FunctionObject that will be applied in unspecified order to the result of dereferencing the input iterators, the results of other binary_op and init. \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n   -T must meet the requirements of MoveConstructible. and binary_op(init, *first), binary_op(*first, init), binary_op(init, init), and binary_op(*first, *first) must be convertible to T. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n#include <vector>\n#include <numeric>\n#include <execution>\n \nint main()\n{\n    std::vector<double> v(10'000'007, 0.5);\n \n    {\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double result = std::accumulate(v.begin(), v.end(), 0.0);\n        auto t2 = std::chrono::high_resolution_clock::now();\n        std::chrono::duration<double, std::milli> ms = t2 - t1;\n        std::cout << std::fixed << \"std::accumulate result \" << result\n                  << \" took \" << ms.count() << \" ms\\n\";\n    }\n \n    {\n        auto t1 = std::chrono::high_resolution_clock::now();\n        double result = std::reduce(std::execution::par, v.begin(), v.end());\n        auto t2 = std::chrono::high_resolution_clock::now();\n        std::chrono::duration<double, std::milli> ms = t2 - t1;\n        std::cout << \"std::reduce result \"\n                  << result << \" took \" << ms.count() << \" ms\\n\";\n    }\n}",
            "output": "std::accumulate result 5000003.50000 took 12.7365 ms\nstd::reduce result 5000003.50000 took 5.06423 ms"
        }
    },
    "transform_reduce": {
        "description": {
            "texte": "The behavior is non-deterministic if binary_op/binary_op2 is not associative or not commutative.The behavior is undefined if unary_op, binary_op, binary_op1, or binary_op2 modifies any element or invalidates any iterator in the input ranges, including their end iterators."
        },
        "parametres": "   first, last   -   the range of elements to apply the algorithm to \n   init   -   the initial value of the generalized sum \n   policy   -   the execution policy to use. See execution policy for details. \n   unary_op   -   unary FunctionObject that will be applied to each element of the input range. The return type must be acceptable as input to binary_op \n   binary_op   -   binary FunctionObject that will be applied in unspecified order to the results of unary_op, the results of other binary_op and init. \n   Type requirements \n   -T must meet the requirements of MoveConstructible in order to use overloads (3,6). and the result of the expressions binary_op(init, unary_op(*first)), binary_op(unary_op(*first), init), binary_op(init, init), and binary_op(unary_op(*first), unary_op(*first)) must be convertible to T \n   -T must meet the requirements of MoveConstructible in order to use overloads (2,5). and the result of the expressions binary_op1(init, binary_op2(*first1, *first2)), binary_op1(binary_op2(*first1, *first2), init), binary_op1(init, init), and binary_op1(binary_op2(*first1, *first2), binary_op2(*first1, *first2)) must be convertible to T \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <vector>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <execution>\n \nint main()\n{\n    std::vector<double> xvalues(10007, 1.0), yvalues(10007, 1.0);\n \n    double result = std::transform_reduce(\n        std::execution::par,\n        xvalues.begin(), xvalues.end(),\n        yvalues.begin(), 0.0\n    );\n    std::cout << result << '\\n';\n}",
            "output": "10007"
        }
    },
    "partial_sum": {
        "description": {
            "texte": "Computes the partial sums of the elements in the subranges of the range [first, last) and writes them to the range beginning at d_first. The first version uses operator+ to sum up the elements, the second version uses the given binary function op, both applying std::move to their operands on the left hand side (since C++20).Equivalent operation:",
            "code": "*(d_first)   = *first;\n*(d_first+1) = *first + *(first+1);\n*(d_first+2) = *first + *(first+1) + *(first+2);\n*(d_first+3) = *first + *(first+1) + *(first+2) + *(first+3);\n..."
        },
        "parametres": "   first, last   -   the range of elements to sum \n   d_first   -   the beginning of the destination range; may be equal to first \n   op   -   binary operation function object that will be applied.  The signature of the function should be equivalent to the following:\n Ret fun(const Type1 &a, const Type2 &b);\nThe signature does not need to have const &. The type Type1 must be such that an object of type iterator_traits<InputIt>::value_type can be implicitly converted to Type1. The type Type2 must be such that an object of type InputIt can be dereferenced and then implicitly converted to Type2. The type Ret must be such that an object of type iterator_traits<InputIt>::value_type can be assigned a value of type Ret. \u200b\n\n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n\n",
        "exemple": {
            "input": "#include <numeric>\n#include <vector>\n#include <iostream>\n#include <iterator>\n#include <functional>\n \nint main()\n{\n    std::vector<int> v = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2}; // or std::vector<int>v(10, 2);\n \n    std::cout << \"The first 10 even numbers are: \";\n    std::partial_sum(v.begin(), v.end(), \n                     std::ostream_iterator<int>(std::cout, \" \"));\n    std::cout << '\\n';\n \n    std::partial_sum(v.begin(), v.end(), v.begin(), std::multiplies<int>());\n    std::cout << \"The first 10 powers of 2 are: \";\n    for (auto n : v) {\n        std::cout << n << \" \";\n    }\n    std::cout << '\\n';\n}",
            "output": "The first 10 even numbers are: 2 4 6 8 10 12 14 16 18 20 \nThe first 10 powers of 2 are: 2 4 8 16 32 64 128 256 512 1024"
        }
    },
    "inclusive_scan": {
        "description": {
            "texte": "Computes an inclusive prefix sum operation using binary_op (or std::plus<>() for overloads (1-2)) for the range [first, last), using init as the initial value (if provided), and writes the results to the range beginning at d_first. \"inclusive\" means that the i-th input element is included in the i-th sum.Formally, assigns through each iterator i in [d_first, d_first + (last - first)) the value of:where generalized noncommutative sum GNSUM(op, a1, ..., aN) is defined as follows:In other words, the summation operations may be performed in arbitrary order, and the behavior is nondeterministic if binary_op is not associative.Overloads (2,4,6) are executed according to policy. This overload only participates in overload resolution if std::is_execution_policy_v<std::decay_t<ExecutionPolicy>> is true.binary_op shall not invalidate iterators (including the end iterators) or subranges, nor modify elements in the ranges [first, last) or [d_first, d_first + (last - first)). Otherwise, the behavior is undefined."
        },
        "parametres": "   first, last   -   the range of elements to sum \n   d_first   -   the beginning of the destination range; may be equal to first \n   policy   -   the execution policy to use. See execution policy for details. \n   init   -   the initial value (optional) \n   binary_op   -   binary FunctionObject that will be applied in to the result of dereferencing the input iterators, the results of other binary_op, and init (if provided). \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n   -ForwardIt1 must meet the requirements of LegacyForwardIterator. and, if init is not provided, ForwardIt1's value_type must be MoveConstructible and binary_op(*first, *first) must be convertible to ForwardIt1's value type \n   -ForwardIt2 must meet the requirements of LegacyForwardIterator. \n   -T (if init is provided) must meet the requirements of MoveConstructible. All of binary_op(init, *first), binary_op(init, init), and binary_op(*first, *first) must be convertible to T \n\n",
        "exemple": {
            "input": "#include <functional>\n#include <iostream>\n#include <iterator>\n#include <numeric>\n#include <vector>\n \nint main()\n{\n  std::vector data {3, 1, 4, 1, 5, 9, 2, 6};\n \n  std::cout << \"exclusive sum: \";\n  std::exclusive_scan(data.begin(), data.end(),\n                      std::ostream_iterator<int>(std::cout, \" \"),\n                      0);\n  std::cout << \"\\ninclusive sum: \";\n  std::inclusive_scan(data.begin(), data.end(),\n                      std::ostream_iterator<int>(std::cout, \" \"));\n \n  std::cout << \"\\n\\nexclusive product: \";  \n  std::exclusive_scan(data.begin(), data.end(),\n                      std::ostream_iterator<int>(std::cout, \" \"),\n                      1, std::multiplies<>{});                      \n  std::cout << \"\\ninclusive product: \";\n  std::inclusive_scan(data.begin(), data.end(),\n                      std::ostream_iterator<int>(std::cout, \" \"),\n                      std::multiplies<>{});                      \n}",
            "output": "exclusive sum: 0 3 4 8 9 14 23 25 \ninclusive sum: 3 4 8 9 14 23 25 31 \n \nexclusive product: 1 3 3 12 12 60 540 1080 \ninclusive product: 3 3 12 12 60 540 1080 6480"
        }
    },
    "exclusive_scan": {
        "description": {
            "texte": "Computes an exclusive prefix sum operation using binary_op (or std::plus<>() for overloads (1-2)) for the range [first, last), using init as the initial value, and writes the results to the range beginning at d_first. \"exclusive\" means that the i-th input element is not included in the i-th sum.Formally, assigns through each iterator i in [d_first, d_first + (last - first)) the value of the generalized noncommutative sum of init, *j... for every j in [first, first + (i - d_first)) over binary_op,where generalized noncommutative sum GNSUM(op, a1, ..., aN) is defined as follows:In other words, the summation operations may be performed in arbitrary order, and the behavior is nondeterministic if binary_op is not associative.Overloads (2,4) are executed according to policy. This overload only participates in overload resolution if std::is_execution_policy_v<std::decay_t<ExecutionPolicy>> is true.binary_op shall not invalidate iterators (including the end iterators) or subranges, nor modify elements in the ranges [first, last) or [d_first, d_first + (last - first)). Otherwise, the behavior is undefined."
        },
        "parametres": "   first, last   -   the range of elements to sum \n   d_first   -   the beginning of the destination range; may be equal to first \n   policy   -   the execution policy to use. See execution policy for details. \n   init   -   the initial value \n   binary_op   -   binary FunctionObject that will be applied in to the result of dereferencing the input iterators, the results of other binary_op, and init. \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n   -ForwardIt1, ForwardIt2 must meet the requirements of LegacyForwardIterator. \n   -T must meet the requirements of MoveConstructible. and binary_op(init, *first), binary_op(init, init), and binary_op(*first, *first) must be convertible to T \n\n",
        "exemple": {
            "input": "#include <functional>\n#include <iostream>\n#include <iterator>\n#include <numeric>\n#include <vector>\n \nint main()\n{\n  std::vector data {3, 1, 4, 1, 5, 9, 2, 6};\n \n  std::cout << \"exclusive sum: \";\n  std::exclusive_scan(data.begin(), data.end(),\n                      std::ostream_iterator<int>(std::cout, \" \"),\n                      0);\n  std::cout << \"\\ninclusive sum: \";\n  std::inclusive_scan(data.begin(), data.end(),\n                      std::ostream_iterator<int>(std::cout, \" \"));\n \n  std::cout << \"\\n\\nexclusive product: \";  \n  std::exclusive_scan(data.begin(), data.end(),\n                      std::ostream_iterator<int>(std::cout, \" \"),\n                      1, std::multiplies<>{});                      \n  std::cout << \"\\ninclusive product: \";\n  std::inclusive_scan(data.begin(), data.end(),\n                      std::ostream_iterator<int>(std::cout, \" \"),\n                      std::multiplies<>{});                      \n}",
            "output": "exclusive sum: 0 3 4 8 9 14 23 25 \ninclusive sum: 3 4 8 9 14 23 25 31 \n \nexclusive product: 1 3 3 12 12 60 540 1080 \ninclusive product: 3 3 12 12 60 540 1080 6480"
        }
    },
    "transform_inclusive_scan": {
        "description": {
            "texte": "Transforms each element in the range [first, last) with unary_op, then computes an inclusive prefix sum operation using binary_op over the resulting range, optionally with init as the initial value, and writes the results to the range beginning at d_first. \"inclusive\" means that the i-th input element is included in the i-th sum.Formally, assigns through each iterator i in [d_first, d_first + (last - first)) the value of.where generalized noncommutative sum GNSUM(op, a1, ..., aN) is defined as follows:In other words, the summation operations may be performed in arbitrary order, and the behavior is nondeterministic if binary_op is not associative.Overloads (2, 4) are executed according to policy, and do not participate in overload resolution unless std::is_execution_policy_v<std::decay_t<ExecutionPolicy>> is true.unary_op and binary_op shall not invalidate iterators (including the end iterators) or subranges, nor modify elements in the ranges [first, last) or [d_first, d_first + (last - first)). Otherwise, the behavior is undefined."
        },
        "parametres": "   first, last   -   the range of elements to sum \n   d_first   -   the beginning of the destination range; may be equal to first \n   policy   -   the execution policy to use. See execution policy for details. \n   init   -   the initial value \n   unary_op   -   unary FunctionObject that will be applied to each element of the input range. The return type must be acceptable as input to binary_op. \n   binary_op   -   binary FunctionObject that will be applied in to the result of unary_op, the results of other binary_op, and init if provided. \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n   -ForwardIt1 must meet the requirements of LegacyForwardIterator. and, if init is not provided, ForwardIt1's value_type must be MoveConstructible and binary_op(unary_op(*first), unary_op(*first)) must be convertible to ForwardIt1's value type \n   -ForwardIt2 must meet the requirements of LegacyForwardIterator. \n   -T (if init is provided) must meet the requirements of MoveConstructible. All of binary_op(init, unary_op(*first)), binary_op(init, init), and binary_op(unary_op(*first), unary_op(*first)) must be convertible to T \n\n",
        "exemple": {
            "input": "#include <functional>\n#include <iostream>\n#include <iterator>\n#include <numeric>\n#include <vector>\n \nint times_10(int x)\n{\n  return x * 10;\n}\n \nint main()\n{\n  std::vector data {3, 1, 4, 1, 5, 9, 2, 6};\n \n  std::cout << \"10 times exclusive sum: \";\n  std::transform_exclusive_scan(data.begin(), data.end(),\n                                std::ostream_iterator<int>(std::cout, \" \"),\n                                0, std::plus<int>{}, times_10);\n  std::cout << \"\\n10 times inclusive sum: \";\n  std::transform_inclusive_scan(data.begin(), data.end(),\n                                std::ostream_iterator<int>(std::cout, \" \"),\n                                std::plus<int>{}, times_10);\n}",
            "output": "10 times exclusive sum: 0 30 40 80 90 140 230 250 \n10 times inclusive sum: 30 40 80 90 140 230 250 310"
        }
    },
    "transform_exclusive_scan": {
        "description": {
            "texte": "Transforms each element in the range [first, last) with unary_op, then computes an exclusive prefix sum operation using binary_op over the resulting range, with init as the initial value, and writes the results to the range beginning at d_first. \"exclusive\" means that the i-th input element is not included in the i-th sum.Formally, assigns through each iterator i in [d_first, d_first + (last - first)) the value of the generalized noncommutative sum of init, unary_op(*j)... for every j in [first, first + (i - d_first)) over binary_op,where generalized noncommutative sum GNSUM(op, a1, ..., aN) is defined as follows:In other words, the summation operations may be performed in arbitrary order, and the behavior is nondeterministic if binary_op is not associative.Overload (2) is executed according to policy, and does not participate in overload resolution unless std::is_execution_policy_v<std::decay_t<ExecutionPolicy>> is true.unary_op and binary_op shall not invalidate iterators (including the end iterators) or subranges, nor modify elements in the ranges [first, last) or [d_first, d_first + (last - first)). Otherwise, the behavior is undefined."
        },
        "parametres": "   first, last   -   the range of elements to sum \n   d_first   -   the beginning of the destination range, may be equal to first \n   policy   -   the execution policy to use. See execution policy for details. \n   init   -   the initial value \n   unary_op   -   unary FunctionObject that will be applied to each element of the input range. The return type must be acceptable as input to binary_op. \n   binary_op   -   binary FunctionObject that will be applied in to the result of unary_op, the results of other binary_op, and init. \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n   -ForwardIt1, ForwardIt2 must meet the requirements of LegacyForwardIterator. \n   -T must meet the requirements of MoveConstructible. All of binary_op(init, unary_op(*first)), binary_op(init, init), and binary_op(unary_op(*first), unary_op(*first)) must be convertible to T. \n\n",
        "exemple": {
            "input": "#include <functional>\n#include <iostream>\n#include <iterator>\n#include <numeric>\n#include <vector>\n \nint times_10(int x)\n{\n  return x * 10;\n}\n \nint main()\n{\n  std::vector data {3, 1, 4, 1, 5, 9, 2, 6};\n \n  std::cout << \"10 times exclusive sum: \";\n  std::transform_exclusive_scan(data.begin(), data.end(),\n                                std::ostream_iterator<int>(std::cout, \" \"),\n                                0, std::plus<int>{}, times_10);\n  std::cout << \"\\n10 times inclusive sum: \";\n  std::transform_inclusive_scan(data.begin(), data.end(),\n                                std::ostream_iterator<int>(std::cout, \" \"),\n                                std::plus<int>{}, times_10);\n}",
            "output": "10 times exclusive sum: 0 30 40 80 90 140 230 250 \n10 times inclusive sum: 30 40 80 90 140 230 250 310"
        }
    },
    "qsort": {
        "description": {
            "texte": "Sorts the given array pointed to by ptr in ascending order. The array contains count elements of size bytes. Function pointed to by comp is used for object comparison.If comp indicates two elements as equivalent, their order is unspecified."
        },
        "parametres": "   ptr   -   pointer to the array to sort \n   count   -   number of elements in the array \n   size   -   size of each element in the array in bytes \n   comp   -   comparison function which returns \u200ba negative integer value if the first argument is less than the second,  a positive integer value if the first argument is greater than the second and zero if the arguments are equal. The signature of the comparison function should be equivalent to the following:\n int cmp(const void *a, const void *b);\nThe function must not modify the objects passed to it and must return consistent results when called for the same objects, regardless of their positions in the array.\n\u200b\n\n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstdlib>\n#include <climits>\n \nint main()\n{\n    int a[] = {-2, 99, 0, -743, 2, INT_MIN, 4};\n    constexpr std::size_t size = sizeof a / sizeof *a;\n \n    std::qsort(a, size, sizeof *a, [](const void* a, const void* b)\n    {\n        int arg1 = *static_cast<const int*>(a);\n        int arg2 = *static_cast<const int*>(b);\n \n        if(arg1 < arg2) return -1;\n        if(arg1 > arg2) return 1;\n        return 0;\n \n    //  return (arg1 > arg2) - (arg1 < arg2); // possible shortcut\n    //  return arg1 - arg2; // erroneous shortcut (fails if INT_MIN is present)\n    });\n \n    for(int ai : a)\n        std::cout << ai << ' ';\n}",
            "output": "-2147483648 -743 -2 0 2 4 99"
        }
    },
    "bsearch": {
        "description": {
            "texte": "Finds an element equal to element pointed to by key in an array pointed to by ptr. The array contains count elements of size bytes each and must be partitioned with respect to the object pointed to by key, that is, all the elements that compare less than must appear before all the elements that compare equal to, and those must appear before all the elements that compare greater than the key object. A fully sorted array satisfies these requirements. The elements are compared using function pointed to by comp.The behavior is undefined if the array is not already partitioned in ascending order with respect to key, according to the same criterion that comp uses.If the array contains several elements that comp would indicate as equal to the element searched for, then it is unspecified which element the function will return as the result."
        },
        "parametres": "   key   -   pointer to the element to search for \n   ptr   -   pointer to the array to examine \n   count   -   number of element in the array \n   size   -   size of each element in the array in bytes \n   comp   -   comparison function which returns \u200ba negative integer value if the first argument is less than the second,  a positive integer value if the first argument is greater than the second and zero if the arguments are equal. key is passed as the first argument, an element from the array as the second. The signature of the comparison function should be equivalent to the following:\n int cmp(const void *a, const void *b);\nThe function must not modify the objects passed to it and must return consistent results when called for the same objects, regardless of their positions in the array.\n\u200b\n\n\n",
        "exemple": {
            "input": "#include <cstdlib>\n#include <iostream>\n \nint compare(const void *ap, const void *bp)\n{\n    const int *a = (int *) ap;\n    const int *b = (int *) bp;\n    if(*a < *b)\n        return -1;\n    else if(*a > *b)\n        return 1;\n    else\n        return 0;\n}\n \nint main(int argc, char **argv)\n{\n    const int ARR_SIZE = 8;\n    int arr[ARR_SIZE] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n \n    int key1 = 4;\n    int *p1 = (int *) std::bsearch(&key1, arr, ARR_SIZE, sizeof(arr[0]), compare);\n    if(p1)\n        std::cout << \"value \" << key1 << \" found at position \" << (p1 - arr) << '\\n';\n     else\n        std::cout << \"value \" << key1 << \" not found\\n\";\n \n    int key2 = 9;\n    int *p2 = (int *) std::bsearch(&key2, arr, ARR_SIZE, sizeof(arr[0]), compare);\n    if(p2)\n        std::cout << \"value \" << key2 << \" found at position \" << (p2 - arr) << '\\n';\n     else\n        std::cout << \"value \" << key2 << \" not found\\n\";\n}",
            "output": "value 4 found at position 3\nvalue 9 not found"
        }
    },
    "destroy_at": {
        "description": {
            "texte": "Calls the destructor of the object pointed to by p, as if by p->~T()."
        },
        "parametres": "   p   -   a pointer to the object to be destroyed \n\n",
        "exemple": {
            "input": "#include <memory>\n#include <new>\n#include <iostream>\n \nstruct Tracer {\n    int value;\n    ~Tracer() { std::cout << value << \" destructed\\n\"; }\n};\n \nint main()\n{\n    alignas(Tracer) unsigned char buffer[sizeof(Tracer) * 8];\n \n    for (int i = 0; i < 8; ++i)\n        new(buffer + sizeof(Tracer) * i) Tracer{i}; //manually construct objects\n \n    auto ptr = std::launder(reinterpret_cast<Tracer*>(buffer));\n \n    for (int i = 0; i < 8; ++i)\n        std::destroy_at(ptr + i);\n \n}",
            "output": "0 destructed\n1 destructed\n2 destructed\n3 destructed\n4 destructed\n5 destructed\n6 destructed\n7 destructed"
        }
    },
    "gcd": {
        "description": {
            "texte": "Computes the greatest common divisor of the integers m and n."
        },
        "parametres": "   m, n   -   integer values \n\n"
    },
    "lcm": {
        "description": {
            "texte": "Computes the least common multiple of the integers m and n."
        },
        "parametres": "   m, n   -   integer values \n\n"
    },
    "midpoint": {
        "description": {
            "texte": "Computes the midpoint of the integers, floating-points, or pointers a and b."
        },
        "parametres": "   a, b   -   intergers, floating-points, or pointer values \n   Type requirements \n   -T must be an arithmetic type other than bool for overload (1) \n   -T must be a complete object type for overload (2) \n\n"
    },
    "lerp": {
        "description": {
            "texte": "a+t*(b\u2212a).When isfinite(a) && isfinite(b), the following properties are guaranteed:Let CMP(x,y) be 1 if x > y, -1 if x < y, and 0 otherwise. For any t1 and t2, the product of CMP(lerp(a, b, t2), lerp(a, b, t1)), CMP(t2, t1), and CMP(b, a) is non-negative. (That is, lerp is monotonic.)."
        },
        "parametres": "   a, b, t   -   values of floating-point or integral types \n\n"
    },
    "bit_cast": {
        "description": {
            "texte": "Obtain a value of type To by reinterpreting the object representation of from. Every bit in the value representation of the returned To object is equal to the corresponding bit in the object representation of from. The values of padding bits in the returned To object are unspecified.If there is no value of type To corresponding to the value representation produced, the behavior is undefined. If there are multiple such values, which value is produced is unspecified.This overload only participates in overload resolution if sizeof(To) == sizeof(From) and both To and From are TriviallyCopyable types.This function template is constexpr if and only if each of To, From and the types of all subobjects of To and From:"
        },
        "exemple": {
            "input": "#include <cstdint>\n#include <bit>\n#include <iostream>\n \nconstexpr double f64v = 19880124.0;\nconstexpr auto u64v = std::bit_cast<std::uint64_t>(f64v);\n \nconstexpr std::uint64_t u64v2 = 0x3fe9000000000000ull;\nconstexpr auto f64v2 = std::bit_cast<double>(u64v2);\n \nint main()\n{\n    std::cout\n        << std::fixed <<f64v << \"f64.to_bits() == 0x\"\n        << std::hex << u64v << \"u64\\n\";\n \n    std::cout\n        << \"f64::from_bits(0x\" << std::hex << u64v2 << \"u64) == \"\n        << std::fixed << f64v2 << \"f64\\n\";\n}",
            "output": "19880124.000000f64.to_bits() == 0x4172f58bc0000000u64\nf64::from_bits(0x3fe9000000000000u64) == 0.781250f64"
        }
    },
    "ispow2": {
        "description": {
            "texte": "Checks if x is an integral power of two.This overload only participates in overload resolution if T is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type)."
        }
    },
    "ceil2": {
        "description": {
            "texte": "Calculates the smallest integral power of two that is not smaller than x. If that value is not representable in T, the result is unspecified.This overload only participates in overload resolution if T is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type)."
        }
    },
    "floor2": {
        "description": {
            "texte": "If x is not zero, calculates the largest integral power of two that is not greater than x. If x is zero, returns zero.This overload only participates in overload resolution if T is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type)."
        }
    },
    "log2p1": {
        "description": {
            "texte": "If x is not zero, calculates the number of bits needed to store the value x, that is, \\(1 + \\lfloor log_2(x) \\rfloor\\)1 + floor(log2(x)). If x is zero, returns zero.This overload only participates in overload resolution if T is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type)."
        }
    },
    "sqrt, std::sqrtf, std::sqrtl": {
        "description": {
            "texte": "If no errors occur, square root of arg (\u221aarg), is returned.If a domain error occurs, an implementation-defined value is returned (NaN where supported).If a range error occurs due to underflow, the correct result (after rounding) is returned."
        },
        "parametres": "   arg   -   Value of a floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cfenv>\n#include <cstring>\n \n#pragma STDC FENV_ACCESS ON\n \nint main()\n{\n    // normal use\n    std::cout << \"sqrt(100) = \" << std::sqrt(100) << '\\n'\n              << \"sqrt(2) = \" << std::sqrt(2) << '\\n'\n              << \"golden ratio = \" << (1+std::sqrt(5))/2 << '\\n';\n    // special values\n    std::cout << \"sqrt(-0) = \" << std::sqrt(-0.0) << '\\n';\n    // error handling\n    errno = 0;\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"sqrt(-1.0) = \" << std::sqrt(-1) << '\\n';\n    if(errno == EDOM)\n        std::cout << \"    errno = EDOM \" << std::strerror(errno) << '\\n';\n    if(std::fetestexcept(FE_INVALID))\n        std::cout << \"    FE_INVALID raised\\n\";\n}",
            "output": "sqrt(100) = 10\nsqrt(2) = 1.41421\ngolden ratio = 1.61803\nsqrt(-0) = -0\nsqrt(-1.0) = -nan\n    errno = EDOM Numerical argument out of domain\n    FE_INVALID raised"
        }
    },
    "sin, std::sinf, std::sinl": {
        "description": {
            "texte": "If no errors occur, the sine of arg (sin(arg)) in the range [-1 ; +1], is returned.If a domain error occurs, an implementation-defined value is returned (NaN where supported).If a range error occurs due to underflow, the correct result (after rounding) is returned."
        },
        "parametres": "   arg   -   value representing angle in radians, of a floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\nconst double pi = std::acos(-1);\nint main()\n{\n    // typical usage\n    std::cout << \"sin(pi/6) = \" << std::sin(pi/6) << '\\n'\n              << \"sin(pi/2) = \" << std::sin(pi/2) << '\\n'\n              << \"sin(-3*pi/4) = \" << std::sin(-3*pi/4) << '\\n';\n    // special values\n    std::cout << \"sin(+0) = \" << std::sin(0.0) << '\\n'\n              << \"sin(-0) = \" << std::sin(-0.0) << '\\n';\n    // error handling \n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"sin(INFINITY) = \" << std::sin(INFINITY) << '\\n';\n    if (std::fetestexcept(FE_INVALID))\n        std::cout << \"    FE_INVALID raised\\n\";\n}",
            "output": "sin(pi/6) = 0.5\nsin(pi/2) = 1\nsin(-3*pi/4) = -0.707107\nsin(+0) = 0\nsin(-0) = -0\nsin(INFINITY) = -nan\n    FE_INVALID raised"
        }
    },
    "beta, std::betaf, std::betal": {
        "description": {
            "texte": "Errors may be reported as specified in math_errhandling."
        },
        "parametres": "   x, y   -   values of a floating-point or integral type \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <string>\n#include <iostream>\n#include <iomanip>\ndouble binom(int n, int k) { return 1/((n+1)*std::beta(n-k+1,k+1)); }\nint main()\n{\n    std::cout << \"Pascal's triangle:\\n\";\n    for(int n = 1; n < 10; ++n) {\n        std::cout << std::string(20-n*2, ' ');\n        for(int k = 1; k < n; ++k)\n            std::cout << std::setw(3) << binom(n,k) << ' ';\n        std::cout << '\\n';\n    }\n}",
            "output": "Pascal's triangle:\n \n                  2 \n                3   3 \n              4   6   4 \n            5  10  10   5 \n          6  15  20  15   6 \n        7  21  35  35  21   7 \n      8  28  56  70  56  28   8 \n    9  36  84 126 126  84  36   9"
        }
    },
    "hermite, std::hermitef, std::hermitel": {
        "description": {
            "texte": "Errors may be reported as specified in math_errhandling."
        },
        "parametres": "   n   -   the degree of the polynomial \n   x   -   the argument, a value of a floating-point or integral type \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\ndouble H3(double x) { return 8*std::pow(x,3) - 12*x; }\ndouble H4(double x) { return 16*std::pow(x,4)-48*x*x+12; }\nint main()\n{\n    // spot-checks\n    std::cout << std::hermite(3, 10) << '=' << H3(10) << '\\n'\n              << std::hermite(4, 10) << '=' << H4(10) << '\\n';\n}",
            "output": "7880=7880\n155212=155212"
        }
    },
    "cyl_bessel_i, std::cyl_bessel_if, std::cyl_bessel_il": {
        "description": {
            "texte": "Errors may be reported as specified in math_errhandling."
        },
        "parametres": "   \u03bd   -   the order of the function \n   x   -   the argument of the function) \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\nint main()\n{\n    // spot check for \u03bd == 0\n    double x = 1.2345;\n    std::cout << \"I_0(\" << x << \") = \" << std::cyl_bessel_i(0, x) << '\\n';\n \n    // series expansion for I_0\n    double fct = 1;\n    double sum = 0;\n    for(int k = 0; k < 5; fct*=++k) {\n        sum += std::pow((x/2),2*k) / std::pow(fct,2);\n        std::cout << \"sum = \" << sum << '\\n';\n    }        \n}",
            "output": "I_0(1.2345) = 1.41886\nsum = 1\nsum = 1.381\nsum = 1.41729\nsum = 1.41882\nsum = 1.41886"
        }
    },
    "srand": {
        "description": {
            "texte": "Seeds the pseudo-random number generator used by std::rand() with the value seed.If rand() is used before any calls to srand(), rand() behaves as if it was seeded with srand(1).Each time rand() is seeded with the same seed, it must produce the same sequence of values.srand() is not guaranteed to be thread-safe."
        },
        "parametres": "   seed   -   the seed value \n\n",
        "exemple": {
            "input": "#include <cstdlib>\n#include <iostream>\n#include <ctime>\n \nint main() \n{\n    std::srand(std::time(0)); //use current time as seed for random generator\n    int random_variable = std::rand();\n    std::cout << \"Random value on [0 \" << RAND_MAX << \"]: \" \n              << random_variable << '\\n';\n}",
            "output": "Random value on [0 2147483647]: 1373858591"
        }
    },
    "rand": {
        "description": {
            "texte": "Returns a pseudo-random integral value between \u200b0\u200b and RAND_MAX (0 and RAND_MAX included).std::srand() seeds the pseudo-random number generator used by rand(). If rand() is used before any calls to srand(), rand() behaves as if it was seeded with srand(1).Each time rand() is seeded with srand(), it must produce the same sequence of values on successive calls. Other functions in the standard library may call rand, it is implementation-defined which functions do so.It is implementation-defined whether rand() is thread-safe."
        },
        "exemple": {
            "input": "#include <cstdlib>\n#include <iostream>\n#include <ctime>\n \nint main() \n{\n    std::srand(std::time(nullptr)); // use current time as seed for random generator\n    int random_variable = std::rand();\n    std::cout << \"Random value on [0 \" << RAND_MAX << \"]: \" \n              << random_variable << '\\n';\n \n    // roll a 6-sided die 20 times\n    for (int n=0; n != 20; ++n) {\n        int x = 7;\n        while(x > 6) \n            x = 1 + std::rand()/((RAND_MAX + 1u)/6);  // Note: 1+rand()%6 is biased\n        std::cout << x << ' ';\n    }\n}",
            "output": "Random value on [0 2147483647]: 726295113\n6 3 6 2 6 5 6 3 1 1 1 6 6 6 4 1 3 6 4 2"
        }
    },
    "basic_filebuf": {
        "description": {
            "texte": "std::basic_filebuf is a std::basic_streambuf whose associated character sequence is a file. Both the input sequence and the output sequence are associated with the same file, and a joint file position is maintained for both operations.The functions underflow() and overflow()/sync() perform the actual I/O between the file and the get and put areas of the buffer. When CharT is not char, most implementations store multibyte characters in the file and a std::codecvt facet is used to perform wide/multibyte character conversion.Two specializations for common character types are also defined:"
        }
    },
    "basic_stringbuf": {
        "description": {
            "texte": "std::basic_stringbuf is a std::basic_streambuf whose associated character sequence is a memory-resident sequence of arbitrary characters, which can be initialized from or made available as an instance of std::basic_string.Typical implementations of std::basic_stringbuf hold an object of type std::basic_string or equivalent resizeable sequence container directly as a data member and use it as both the controlled character sequence (the array where the six pointers of std::basic_streambuf are pointing to) and as the associated character sequence (the source of characters for all input operations and the target for the output).In addition, a typical implementation holds a data member of type std::ios_base::openmode to indicate the status of the stream (input-only, output-only, input/output, at-end, etc).Two specializations for common character types are also defined:"
        }
    },
    "strstreambuf": {
        "description": {
            "texte": "std::strstreambuf is a std::basic_streambuf whose associated character sequence is a character array, which may be constant (e.g. a string literal), modifyable but not dynamic (e.g. a stack-allocated array), or dynamic, in which case the std::strstreambuf may be allowed to reallocate the array as necessary to accomodate output (e.g. by calling delete[] and new[] or user-provided functions).Typical implementation of a std::strstreambuf holds four private data members:"
        }
    },
    "basic_syncbuf": {
        "description": {
            "texte": "std::basic_syncbuf is a wrapper for a std::basic_streambuf (provided at construction time as a pointer). It accumulates output in its own internal buffer, and atomically transmits its entire contents to the wrapped buffer on destruction and when explicitly requested, so that they appear as a contiguous sequence of characters. It guarantees that there are no data races and no interleaving of characters sent to the wrapped buffer as long as all other outputs made to the same buffer are made through, possibly different, instances of std::basic_syncbuf.Typical implementation of std::basic_syncbuf holds a pointer to the wrapped std::basic_streambuf, a boolean flag indicating whether the buffer will transmit its contents to the wrapped buffer on sync (flush), a boolean flag indicating a pending flush when the policy is to not emit on sync, an internal buffer that uses Allocator (such as std::string), and a pointer to a mutex used to synchronize emit between multiple threads accessing the same wrapped stream buffer (these mutexes may be in a hash map with pointers to basic_streambuf objects used as keys).Like other streambuf classes, std::basic_syncbuf is normally only accessed through the corresponding stream, std::osyncstream, not directly.Two specializations for common character types are also defined:"
        }
    },
    "basic_osyncstream": {
        "description": {
            "texte": "The class template std::basic_osyncstream is a convenience wrapper for std::basic_syncbuf. It provides a mechanism to synchronize threads writing to the same stream.It can be used with a named variable:as well as with a temporary:It provides the guarantee that all output made to the same final destination buffer (std::cout in the examples above) will be free of data races and will not be interleaved or garbled in any way, as long as every write to the that final destination buffer is made through (possibly different) instances of std::basic_osyncstream.Typical implementation of std::basic_osyncstream holds only one member: the wrapped std::basic_syncbuf.Two specializations for common character types are also defined:",
            "code": "std::osyncstream(std::cout) << \"Hello, \" << \"World!\" << '\\n';"
        }
    },
    "streamoff": {
        "description": {
            "texte": "The type std::streamoff is a signed integral type of sufficient size to represent the maximum possible file size supported by the operating system. Typically, this is a typedef to long long.It is used to represent offsets from stream positions (values of type std::fpos). A std::streamoff value of -1 is also used to represent error conditions by some of the I/O library functions."
        }
    },
    "streamsize": {
        "description": {
            "texte": "The type std::streamsize is a signed integral type used to represent the number of characters transferred in an I/O operation or the size of an I/O buffer. It is used as a signed counterpart of std::size_t, similar to the POSIX type ssize_t.Except in the constructors of std::strstreambuf, negative values of std::streamsize are never used."
        }
    },
    "fpos": {
        "description": {
            "texte": "Specializations of the class template std::fpos identify absolute positions in a stream or in a file. Each object of type fpos holds the byte position in the stream (typically as a private member of type std::streamoff) and the current shift state, a value of type State (typically std::mbstate_t).The following specializations of std::fpos are provided:All specializations of fpos meet the DefaultConstructible, CopyConstructible, CopyAssignable, Destructible, and EqualityComparable requirements.If State is trivially copy constructible, fpos has a trivial copy constructor. If State is trivially copy assignable, fpos has a trivial copy assignment operator. If State is trivially destructible, fpos has a trivial destructor."
        }
    },
    "iostream_category": {
        "description": {
            "texte": "Obtains a reference to the static error category object for iostream errors. The object is required to override the virtual function error_category::name() to return a pointer to the string \"iostream\". It is used to identify error codes provided in the exceptions of type std::ios_base::failure."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n \nint main()\n{\n    std::ifstream f(\"doesn't exist\");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e) {\n        std::cout << \"Caught an ios_base::failure.\\n\"\n                  << \"Error code: \" << e.code().value() \n                  << \" (\" << e.code().message() << \")\\n\"\n                  << \"Error category: \" << e.code().category().name() << '\\n';\n \n    }\n}",
            "output": "Caught an ios_base::failure.\nError code: 1 (unspecified iostream_category error)\nError category: iostream"
        }
    },
    "io_errc": {
        "description": {
            "texte": "The scoped enumeration std::io_errc defines the error codes reported by I/O streams in std::ios_base::failure exception objects. Only one error code (std::io_errc::stream) is required, although the implementation may define additional error codes. Because the appropriate specialization of std::is_error_code_enum is provided, values of type std::io_errc are implicitly convertible to std::error_code."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f(\"doesn't exist\");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e) {\n        std::cout << \"Caught an ios_base::failure.\\n\";\n        if(e.code() == std::io_errc::stream)\n            std::cout << \"The error code is std::io_errc::stream\\n\";\n    }\n}",
            "output": "Caught an ios_base::failure.\nThe error code is std::io_errc::stream"
        }
    },
    "cin, std::wcin": {
        "description": {
            "texte": "The global objects std::cin and std::wcin control input from a stream buffer of implementation-defined type (derived from std::streambuf), associated with the standard C input stream stdin.These objects are guaranteed to be initialized during or before the first time an object of type std::ios_base::Init is constructed and are available for use in the constructors and destructors of static objects with ordered initialization (as long as <iostream> is included before the object is defined).Unless sync_with_stdio(false) has been issued, it is safe to concurrently access these objects from multiple threads for both formatted and unformatted input.Once std::cin is constructed, std::cin.tie() returns &std::cout, and likewise, std::wcin.tie() returns &std::wcout. This means that any formatted input operation on std::cin forces a call to std::cout.flush() if any characters are pending for output."
        },
        "exemple": {
            "input": "#include <iostream>\nstruct Foo {\n    int n;\n    Foo() {\n       std::cout << \"Enter n: \"; // no flush needed\n       std::cin >> n;\n    }\n};\nFoo f; // static object\nint main()\n{\n    std::cout << \"f.n is \" << f.n << '\\n';\n}",
            "output": "Enter n: 10\nf.n is 10"
        }
    },
    "cout, std::wcout": {
        "description": {
            "texte": "The global objects std::cout and std::wcout control output to a stream buffer of implementation-defined type (derived from std::streambuf), associated with the standard C output stream stdout.These objects are guaranteed to be initialized during or before the first time an object of type std::ios_base::Init is constructed and are available for use in the constructors and destructors of static objects with ordered initialization (as long as <iostream> is included before the object is defined).Unless sync_with_stdio(false) has been issued, it is safe to concurrently access these objects from multiple threads for both formatted and unformatted output.Once initialized, std::cout is tie()'d to std::cin and std::wcout is tie()'d to std::wcin, meaning that any input operation on std::cin executes std::cout.flush() (via std::basic_istream::sentry's constructor).Once initialized, std::cout is also tie()'d to std::cerr and std::wcout is tie()'d to std::wcerr, meaning that any output operation on std::cerr executes std::cout.flush() (via std::basic_ostream::sentry's constructor) (since C++11)."
        },
        "exemple": {
            "input": "#include <iostream>\nstruct Foo {\n    int n;\n    Foo() {\n       std::cout << \"static constructor\\n\";\n    }\n    ~Foo() {\n       std::cout << \"static destructor\\n\";\n    }\n};\nFoo f; // static object\nint main()\n{\n    std::cout << \"main function\\n\";\n}",
            "output": "static constructor\nmain function\nstatic destructor"
        }
    },
    "cerr, std::wcerr": {
        "description": {
            "texte": "The global objects std::cerr and std::wcerr control output to a stream buffer of implementation-defined type (derived from std::streambuf and std::wstreambuf, respectively), associated with the standard C error output stream stderr.These objects are guaranteed to be initialized during or before the first time an object of type std::ios_base::Init is constructed and are available for use in the constructors and destructors of static objects with ordered initialization (as long as <iostream> is included before the object is defined).Unless sync_with_stdio(false) has been issued, it is safe to concurrently access these objects from multiple threads for both formatted and unformatted output.Once initialized, (std::cerr.flags() & unitbuf) != 0 (same for wcerr) meaning that any output sent to these stream objects is immediately flushed to the OS (via std::basic_ostream::sentry's destructor).In addition, std::cerr.tie() returns &std::cout (same for wcerr and wcout), meaning that any output operation on std::cerr first executes std::cout.flush() (via std::basic_ostream::sentry's constructor) (since C++11)."
        },
        "exemple": {
            "input": "#include <thread>\n#include <iostream>\n#include <chrono>\nvoid f()\n{\n    std::cout << \"Output from thread...\";\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n    std::cout << \"...thread calls flush()\" << std::endl;\n}\n \nint main()\n{\n    std::thread t1(f);\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    std::clog << \"This output from main is not tie()'d to cout\\n\";\n    std::cerr << \"This output is tie()'d to cout\\n\";\n    t1.join();\n}",
            "output": "This output from main is not tie()'d to cout\nOutput from thread...This output is tie()'d to cout\n...thread calls flush()"
        }
    },
    "clog, std::wclog": {
        "description": {
            "texte": "The global objects std::clog and std::wclog control output to a stream buffer of implementation-defined type (derived from std::streambuf), associated with the standard C output stream stderr, but, unlike std::cerr/std::wcerr, these streams are not automatically flushed and not automatically tie()'d with cout.These objects are guaranteed to be initialized during or before the first time an object of type std::ios_base::Init is constructed and are available for use in the constructors and destructors of static objects with ordered initialization (as long as <iostream> is included before the object is defined).Unless sync_with_stdio(false) has been issued, it is safe to concurrently access these objects from multiple threads for both formatted and unformatted output."
        },
        "exemple": {
            "input": "#include <iostream>\n \nstruct Foo {\n    int n;\n    Foo() {\n       std::clog << \"static constructor\\n\";\n    }\n    ~Foo() {\n       std::clog << \"static destructor\\n\";\n    }\n};\n \nFoo f; // static object\n \nint main()\n{\n    std::clog << \"main function\\n\";\n}",
            "output": "static constructor\nmain function\nstatic destructor"
        }
    },
    "boolalpha, std::noboolalpha": {
        "description": {
            "texte": "std::boolalpha is an I/O manipulator, so it may be called with an expression such as out << std::boolalpha for any out of type std::basic_ostream or with an expression such as in >> std::boolalpha for any in of type std::basic_istream."
        },
        "parametres": "   str   -   reference to I/O stream \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <locale>\n#include <iostream>\nint main()\n{\n    // boolalpha output\n    std::cout << std::boolalpha \n              << \"boolalpha true: \" << true << '\\n'\n              << \"boolalpha false: \" << false << '\\n';\n    std::cout << std::noboolalpha \n              << \"noboolalpha true: \" << true << '\\n'\n              << \"noboolalpha false: \" << false << '\\n';\n    // boolalpha parse\n    bool b1, b2;\n    std::istringstream is(\"true false\");\n    is >> std::boolalpha >> b1 >> b2;\n    std::cout << '\\\"' << is.str() << \"\\\" parsed as \" << b1 << ' ' << b2 << '\\n';\n}",
            "output": "boolalpha true: true\nboolalpha false: false\nnoboolalpha true: 1\nnoboolalpha false: 0\n\"true false\" parsed as 1 0"
        }
    },
    "dec, std::hex, std::oct": {
        "description": {
            "texte": "Modifies the default numeric base for integer I/O.1) sets the basefield of the stream str to dec as if by calling str.setf(std::ios_base::dec, std::ios_base::basefield).2) sets the basefield of the stream str to hex as if by calling str.setf(std::ios_base::hex, std::ios_base::basefield).3) sets the basefield of the stream str to oct as if by calling str.setf(std::ios_base::oct, std::ios_base::basefield).This is an I/O manipulator. It may be called with an expression such as out << std::hex for any out of type std::basic_ostream or with an expression such as in >> std::hex for any in of type std::basic_istream."
        },
        "parametres": "   str   -   reference to I/O stream \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\nint main()\n{\n    std::cout << \"The number 42 in octal:   \" << std::oct << 42 << '\\n'\n              << \"The number 42 in decimal: \" << std::dec << 42 << '\\n'\n              << \"The number 42 in hex:     \" << std::hex << 42 << '\\n';\n    int n;\n    std::istringstream(\"2A\") >> std::hex >> n;\n    std::cout << std::dec << \"Parsing \\\"2A\\\" as hex gives \" << n << '\\n';\n    // the output base is sticky until changed\n    std::cout << std::hex << \"42 as hex gives \" << 42\n        << \" and 21 as hex gives \" << 21 << '\\n';\n}",
            "output": "The number 42 in octal:   52\nThe number 42 in decimal: 42\nThe number 42 in hex:     2a\nParsing \"2A\" as hex gives 42\n42 as hex gives 2a and 21 as hex gives 15"
        }
    },
    "fopen": {
        "description": {
            "texte": "Opens a file indicated by filename and returns a file stream associated with that file. mode is used to determine the file access mode."
        },
        "parametres": "   filename   -   file name to associate the file stream to \n   mode   -   null-terminated character string determining file access mode    File access mode string   Meaning   Explanation   Action if file  already exists   Action if file  does not exist \n   \"r\"   read   Open a file for reading   read from start   failure to open \n   \"w\"   write   Create a file for writing   destroy contents   create new \n   \"a\"   append   Append to a file   write to end   create new \n   \"r+\"   read extended   Open a file for read/write   read from start   error \n   \"w+\"   write extended   Create a file for read/write   destroy contents   create new \n   \"a+\"   append extended   Open a file for read/write   write to end   create new \n   File access mode flag \"b\" can optionally be specified to open a file in binary mode. This flag has no effect on POSIX systems, but on Windows, for example, it disables special handling of '\\n' and '\\x1A'.  On the append file access modes, data is written to the end of the file regardless of the current position of the file position indicator. \n   File access mode flag \"x\" can optionally be appended to \"w\" or \"w+\" specifiers. This flag forces the function to fail if the file exists, instead of overwriting it. (C++17) \n   The behavior is undefined if the mode is not one of the strings listed above. Some implementations define additional supported modes (e.g. Windows). \n\n \n\n",
        "exemple": {
            "input": "#include <cstdio>\n#include <cstdlib>\n \nint main()\n{\n    FILE* fp = std::fopen(\"test.txt\", \"r\");\n    if(!fp) {\n        std::perror(\"File opening failed\");\n        return EXIT_FAILURE;\n    }\n \n    int c; // note: int, not char, required to handle EOF\n    while ((c = std::fgetc(fp)) != EOF) { // standard C I/O file reading loop\n       std::putchar(c);\n    }\n \n    if (std::ferror(fp))\n        std::puts(\"I/O error when reading\");\n    else if (std::feof(fp))\n        std::puts(\"End of file reached successfully\");\n \n    std::fclose(fp);\n}"
        }
    },
    "fgetc, std::getc": {
        "description": {
            "texte": "Reads the next character from the given input stream."
        },
        "parametres": "   stream   -   to read the character from \n\n",
        "exemple": {
            "input": "#include <cstdio>\n#include <cstdlib>\n \nint main()\n{\n    FILE* fp = std::fopen(\"test.txt\", \"r\");\n    if(!fp) {\n        std::perror(\"File opening failed\");\n        return EXIT_FAILURE;\n    }\n \n    int c; // note: int, not char, required to handle EOF\n    while ((c = std::fgetc(fp)) != EOF) { // standard C I/O file reading loop\n       std::putchar(c);\n    }\n \n    if (std::ferror(fp))\n        std::puts(\"I/O error when reading\");\n    else if (std::feof(fp))\n        std::puts(\"End of file reached successfully\");\n \n    std::fclose(fp);\n}"
        }
    },
    "locale": {
        "description": {
            "texte": "An object of class std::locale is an immutable indexed set of immutable facets. Each stream object of the C++ input/output library is associated with an std::locale object and uses its facets for parsing and formatting of all data. In addition, a locale object is associated with each std::basic_regex object. Locale objects can also be used as predicates that perform string collation with the standard containers and algorithms and can be accessed directly to obtain or modify the facets they hold.Each locale constructed in a C++ program holds at least the following standard facets, but a program may define additional specializations or completely new facets and add them to any existing locale object.Internally, a locale object is implemented as-if it is a reference-counted pointer to an array (indexed by std::locale::id) of reference-counted pointers to facets: copying a locale only copies one pointer and increments several reference counts. To maintain the standard C++ library thread safety guarantees (operations on different objects are always thread-safe), both the locale reference count and each facet reference count are updated in thread-safe manner, similar to std::shared_ptr."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n \nint main()\n{\n    std::wcout << \"User-preferred locale setting is \" << std::locale(\"\").name().c_str() << '\\n';\n    // on startup, the global locale is the \"C\" locale\n    std::wcout << 1000.01 << '\\n';\n    // replace the C++ global locale as well as the C locale with the user-preferred locale\n    std::locale::global(std::locale(\"\"));\n    // use the new global locale for future wide character output\n    std::wcout.imbue(std::locale());\n    // output the same number again\n    std::wcout << 1000.01 << '\\n';\n}",
            "output": "User-preferred locale setting is en_US.UTF8\n1000.01\n1,000.01"
        }
    },
    "use_facet": {
        "description": {
            "texte": "Obtains a reference to a facet implemented by loc."
        },
        "parametres": "   loc   -   the locale object to query \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n \nint main()\n{\n    std::locale loc = std::locale(\"\"); // user's preferred locale\n    std::cout << \"Your currency string is \"\n              << std::use_facet<std::moneypunct<char, true>>(loc).curr_symbol() << '\\n';\n}",
            "output": "Your currency string is USD"
        }
    },
    "has_facet": {
        "description": {
            "texte": "Checks if the locale loc implements the facet Facet."
        },
        "parametres": "   loc   -   the locale object to query \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n \n// minimal custom facet\nstruct myfacet : public std::locale::facet {\n    static std::locale::id id;\n};\n \nstd::locale::id myfacet::id;\n \nint main()\n{\n    // loc is a \"C\" locale with myfacet added\n    std::locale loc(std::locale::classic(), new myfacet);\n    std::cout << std::boolalpha\n              << \"Can loc classify chars? \"\n              << std::has_facet<std::ctype<char>>(loc) << '\\n'\n              << \"Can loc classify char32_t? \"\n              << std::has_facet<std::ctype<char32_t>>(loc) << '\\n'\n              << \"Does loc implement myfacet? \"\n              << std::has_facet<myfacet>(loc) << '\\n';\n}",
            "output": "Can loc classify chars? true\nCan loc classify char32_t? false\nDoes loc implement myfacet? true"
        }
    },
    "isspace(std::locale)": {
        "description": {
            "texte": "Checks if the given character is classified as a whitespace character by the given locale's ctype facet."
        },
        "parametres": "   ch   -   character \n   loc   -   locale \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n \nvoid try_with(wchar_t c, const char* loc)\n{\n    std::wcout << \"isspace('\" << c << \"', locale(\\\"\" << loc << \"\\\")) returned \"\n               << std::boolalpha << std::isspace(c, std::locale(loc)) << '\\n';\n}\n \nint main()\n{\n    const wchar_t EM_SPACE = L'\\u2003'; // Unicode character 'EM SPACE'\n    try_with(EM_SPACE, \"C\");\n    try_with(EM_SPACE, \"en_US.UTF8\");\n}",
            "output": "isspace(' ', locale(\"C\")) returned false\nisspace(' ', locale(\"en_US.UTF8\")) returned true"
        }
    },
    "isblank(std::locale)": {
        "description": {
            "texte": " Checks if the given character is classified as a blank character by the given locale's ctype facet."
        },
        "parametres": "   ch   -   character \n   loc   -   locale \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n \nvoid try_with(wchar_t c, const char* loc)\n{\n    std::wcout << \"isblank('\" << c << \"', locale(\\\"\" << loc << \"\\\")) returned \" << std::boolalpha\n               << std::isblank(c, std::locale(loc)) << '\\n';\n}\nint main()\n{\n    const wchar_t IDEO_SPACE = L'\\u3000'; // Unicode character 'IDEOGRAPHIC SPACE'\n    try_with(IDEO_SPACE, \"C\");\n    try_with(IDEO_SPACE, \"en_US.UTF-8\");\n}",
            "output": "isblank(' ', locale(\"C\")) returned false\nisblank(' ', locale(\"en_US.UTF-8\")) returned true"
        }
    },
    "iscntrl(std::locale)": {
        "description": {
            "texte": "Checks if the given character is classified as a control character by the given locale's std::ctype facet."
        },
        "parametres": "   ch   -   character \n   loc   -   locale \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nint main()\n{\n    const wchar_t CCH = L'\\u0094'; // Destructive Backspace in Unicode\n \n    std::locale loc1(\"C\");\n    std::cout << \"iscntrl(CCH, C locale) returned \"\n              << std::boolalpha << std::iscntrl(CCH, loc1) << '\\n';\n \n    std::locale loc2(\"en_US.UTF8\");\n    std::cout << \"iscntrl(CCH, Unicode locale) returned \"\n              << std::boolalpha << std::iscntrl(CCH, loc2) << '\\n';\n}",
            "output": "iscntrl(CCH, C locale) returned false\niscntrl(CCH, Unicode locale) returned true"
        }
    },
    "isupper(std::locale)": {
        "description": {
            "texte": "Checks if the given character is classified as an uppercase alphabetic character by the given locale's std::ctype facet."
        },
        "parametres": "   ch   -   character \n   loc   -   locale \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nint main()\n{\n    const wchar_t c = L'\\u00de'; // capital letter thorn\n \n    std::locale loc1(\"C\");\n    std::cout << \"isupper('\u00de', C locale) returned \"\n               << std::boolalpha << std::isupper(c, loc1) << '\\n';\n \n    std::locale loc2(\"en_US.UTF8\");\n    std::cout << \"isupper('\u00de', Unicode locale) returned \"\n              << std::boolalpha << std::isupper(c, loc2) << '\\n';\n}",
            "output": "isupper('\u00de', C locale) returned false\nisupper('\u00de', Unicode locale) returned true"
        }
    },
    "islower(std::locale)": {
        "description": {
            "texte": "Checks if the given character is classified as a lowercase alphabetic character by the given locale's std::ctype facet."
        },
        "parametres": "   ch   -   character \n   loc   -   locale \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nint main()\n{\n    const wchar_t c = L'\\u03c0'; // greek small letter pi\n \n    std::locale loc1(\"C\");\n    std::cout << \"islower('\u03c0\u200b', C locale) returned \"\n               << std::boolalpha << std::islower(c, loc1) << '\\n';\n \n    std::locale loc2(\"en_US.UTF8\");\n    std::cout << \"islower('\u03c0\u200b', Unicode locale) returned \"\n              << std::boolalpha << std::islower(c, loc2) << '\\n';\n}",
            "output": "islower('\u03c0\u200b', C locale) returned false\nislower('\u03c0\u200b', Unicode locale) returned true"
        }
    },
    "isalpha(std::locale)": {
        "description": {
            "texte": "Checks if the given character is classified as an alphabetic character by the given locale's std::ctype facet."
        },
        "parametres": "   ch   -   character \n   loc   -   locale \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nint main()\n{\n    const wchar_t c = L'\\u042f'; // cyrillic capital letter ya\n \n    std::locale loc1(\"C\");\n    std::cout << \"isalpha('\u042f\u200b', C locale) returned \"\n               << std::boolalpha << std::isalpha(c, loc1) << '\\n';\n \n    std::locale loc2(\"en_US.UTF8\");\n    std::cout << \"isalpha('\u042f', Unicode locale) returned \"\n              << std::boolalpha << std::isalpha(c, loc2) << '\\n';\n}",
            "output": "isalpha('\u042f\u200b', C locale) returned false\nisalpha('\u042f', Unicode locale) returned true"
        }
    },
    "isdigit(std::locale)": {
        "description": {
            "texte": "Checks if the given character is classified as a digit by the given locale's std::ctype facet."
        },
        "parametres": "   ch   -   character \n   loc   -   locale \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n#include <string>\n#include <set>\n \nstruct jdigit_ctype : std::ctype<wchar_t>\n{\n    std::set<wchar_t> jdigits{L'\u4e00',L'\u4e8c',L'\u4e09',L'\u56db',L'\u4e94',L'\u516d',L'\u4e03',L'\u516b',L'\u4e5d',L'\u5341'};\n    bool do_is(mask m, char_type c) const {\n        if ((m & digit) && jdigits.count(c))\n            return true; // Japanese digits will be classified as digits\n        return ctype::do_is(m, c); // leave the rest to the parent class\n    }\n};\n \nint main()\n{\n \n    std::wstring text = L\"123\u4e00\u4e8c\u4e09\uff11\uff12\uff13\";\n    std::locale loc(std::locale(\"\"), new jdigit_ctype);\n \n    std::locale::global(std::locale(\"\"));\n    std::wcout.imbue(std::locale());\n \n    for(wchar_t c : text)\n        if(std::isdigit(c, loc))\n            std::wcout << c << \" is a digit\\n\";\n        else\n            std::wcout << c << \" is NOT a digit\\n\";\n}",
            "output": "1 is a digit\n2 is a digit\n3 is a digit\n\u4e00 is a digit\n\u4e8c is a digit\n\u4e09 is a digit\n\uff11 is NOT a digit\n\uff12 is NOT a digit\n\uff13 is NOT a digit"
        }
    },
    "ispunct(std::locale)": {
        "description": {
            "texte": "Checks if the given character is classified as an punctuation character by the given locale's std::ctype facet."
        },
        "parametres": "   ch   -   character \n   loc   -   locale \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nint main()\n{\n    const wchar_t c = L'\\u214b'; // upside-down ampersand\n \n    std::locale loc1(\"C\");\n    std::cout << \"ispunct('\u214b', C locale) returned \"\n               << std::boolalpha << std::ispunct(c, loc1) << '\\n';\n \n    std::locale loc2(\"en_US.UTF-8\");\n    std::cout << \"ispunct('\u214b', Unicode locale) returned \"\n              << std::boolalpha << std::ispunct(c, loc2) << '\\n';\n}",
            "output": "isalpha('\u214b', C locale) returned false\nisalpha('\u214b', Unicode locale) returned true"
        }
    },
    "isxdigit(std::locale)": {
        "description": {
            "texte": "Checks if the given character is classified as a hexadecimal digit by the given locale's std::ctype facet."
        },
        "parametres": "   ch   -   character \n   loc   -   locale \n\n"
    },
    "isalnum(std::locale)": {
        "description": {
            "texte": "Checks if the given character classified as an alphanumeric character by the given locale's std::ctype facet."
        },
        "parametres": "   ch   -   character \n   loc   -   locale \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nint main()\n{\n    const wchar_t c = L'\\u2135'; // mathematical symbol aleph\n \n    std::locale loc1(\"C\");\n    std::cout << \"isalnum('\u2135', C locale) returned \"\n               << std::boolalpha << std::isalnum(c, loc1) << '\\n';\n \n    std::locale loc2(\"en_US.UTF-8\");\n    std::cout << \"isalnum('\u2135', Unicode locale) returned \"\n              << std::boolalpha << std::isalnum(c, loc2) << '\\n';\n}",
            "output": "isalnum('\u2135\u200b', C locale) returned false\nisalnum('\u2135', Unicode locale) returned true"
        }
    },
    "isprint(std::locale)": {
        "description": {
            "texte": "Checks if the given character classified as a printable character (including space) by the given locale's std::ctype facet."
        },
        "parametres": "   ch   -   character \n   loc   -   locale \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nint main()\n{\n    const wchar_t c = L'\\u2122'; // trademark sign\n \n    std::locale loc1(\"C\");\n    std::cout << \"isprint('\u2122', C locale) returned \"\n               << std::boolalpha << std::isprint(c, loc1) << '\\n';\n \n    std::locale loc2(\"en_US.UTF-8\");\n    std::cout << \"isprint('\u2122', Unicode locale) returned \"\n              << std::boolalpha << std::isprint(c, loc2) << '\\n';\n}",
            "output": "isprint('\u2122', C locale) returned false\nisprint('\u2122', Unicode locale) returned true"
        }
    },
    "isgraph(std::locale)": {
        "description": {
            "texte": "Checks if the given character classified as a graphic character (i.e. printable, excluding space) by the given locale's std::ctype facet."
        },
        "parametres": "   ch   -   character \n   loc   -   locale \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nint main()\n{\n    const wchar_t c = L'\\u2a0c'; // quadruple integral\n \n    std::locale loc1(\"C\");\n    std::cout << \"isgraph('\u2a0c', C locale) returned \"\n               << std::boolalpha << std::isgraph(c, loc1) << '\\n';\n \n    std::locale loc2(\"en_US.UTF-8\");\n    std::cout << \"isgraph('\u2a0c', Unicode locale) returned \"\n              << std::boolalpha << std::isgraph(c, loc2) << '\\n';\n}",
            "output": "isgraph('\u2a0c', C locale) returned false\nisgraph('\u2a0c', Unicode locale) returned true"
        }
    },
    "toupper(std::locale)": {
        "description": {
            "texte": "Converts the character ch to uppercase if possible, using the conversion rules specified by the given locale's std::ctype facet."
        },
        "parametres": "   ch   -   character \n   loc   -   locale \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwctype>\n#include <locale>\n \nint main()\n{\n    wchar_t c = L'\\u017f'; // Latin small letter Long S ('\u017f')\n \n    std::cout << std::hex << std::showbase;\n \n    std::cout << \"in the default locale, toupper(\" << (std::wint_t)c << \") = \"\n              << std::toupper(c, std::locale()) << '\\n';\n \n    std::cout << \"in Unicode locale, toupper(\" << (std::wint_t)c << \") = \"\n              << std::toupper(c, std::locale(\"en_US.utf8\")) << '\\n';\n}",
            "output": "in the default locale, toupper(0x17f) = 0x17f\nin Unicode locale, toupper(0x17f) = 0x53"
        }
    },
    "tolower(std::locale)": {
        "description": {
            "texte": "Converts the character ch to lowercase if possible, using the conversion rules specified by the given locale's std::ctype facet."
        },
        "parametres": "   ch   -   character \n   loc   -   locale \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwctype>\n#include <locale>\n \nint main()\n{\n    wchar_t c = L'\\u0190'; // Latin capital open E ('\u0190')\n \n    std::cout << std::hex << std::showbase;\n \n    std::cout << \"in the default locale, tolower(\" << (std::wint_t)c << \") = \"\n              << std::tolower(c, std::locale()) << '\\n';\n \n    std::cout << \"in Unicode locale, tolower(\" << (std::wint_t)c << \") = \"\n              << std::tolower(c, std::locale(\"en_US.utf8\")) << '\\n';\n}",
            "output": "in the default locale, tolower(0x190) = 0x190\nin Unicode locale, tolower(0x190) = 0x25b"
        }
    },
    "wbuffer_convert": {
        "description": {
            "texte": "std::wbuffer_convert is a wrapper over stream buffer of type std::basic_streambuf<char> which gives it the appearance of std::basic_streambuf<Elem>. All I/O performed through std::wbuffer_convert undergoes character conversion as defined by the facet Codecvt. std::wbuffer_convert assumes ownership of the conversion facet, and cannot use a facet managed by a locale. The standard facets suitable for use with std::wbuffer_convert are std::codecvt_utf8 for UTF-8/UCS2 and UTF-8/UCS4 conversions and std::codecvt_utf8_utf16 for UTF-8/UTF-16 conversions.This class template makes the implicit character conversion functionality of std::basic_filebuf available for any std::basic_streambuf."
        }
    },
    "ctype_base": {
        "description": {
            "texte": "The class std::ctype_base lists the character classification categories which are inherited by the std::ctype facets."
        }
    },
    "codecvt_base": {
        "description": {
            "texte": "The class std::codecvt_base provides the conversion status constants which are inherited and used by the std::codecvt facets."
        }
    },
    "messages_base": {
        "description": {
            "texte": "The class std::messages_base provides a type definition which is inherited and used by the std::messages facets."
        }
    },
    "time_base": {
        "description": {
            "texte": "The class std::time_base provides the date order constants which are inherited by the std::time_get facets."
        }
    },
    "money_base": {
        "description": {
            "texte": "The class std::money_base provides constants which are inherited and used by the std::moneypunct, std::money_get and std::money_put facets."
        }
    },
    "ctype": {
        "description": {
            "texte": "This specialization of std::ctype encapsulates character classification features for type char. Unlike general-purpose std::ctype, which uses virtual functions, this specialization uses table lookup to classify characters (which is generally faster).The base class std::ctype<char> implements character classification equivalent to the minimal \"C\" locale. The classification rules can be extended or modified if constructed with a non-default classification table argument, if constructed as std::ctype_byname<char> or as a user-defined derived facet. All std::istream formatted input functions are required to use std::ctype<char> for character classing during input parsing."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <locale>\n#include <sstream>\n \n// This ctype facet classifies commas and endlines as whitespace\nstruct csv_whitespace : std::ctype<char> {\n    static const mask* make_table()\n    {\n        // make a copy of the \"C\" locale table\n        static std::vector<mask> v(classic_table(), classic_table() + table_size);\n        v[','] |=  space;  // comma will be classified as whitespace\n        v[' '] &= ~space;      // space will not be classified as whitespace\n        return &v[0];\n    }\n    csv_whitespace(std::size_t refs = 0) : ctype(make_table(), false, refs) {}\n};\n \nint main()\n{\n    std::string in = \"Column 1,Column 2,Column 3\\n123,456,789\";\n    std::string token;\n \n    std::cout << \"default locale:\\n\";\n    std::istringstream s1(in);\n    while(s1 >> token)\n            std::cout << \"  \" << token << '\\n';\n \n    std::cout << \"locale with modified ctype:\\n\";\n    std::istringstream s2(in);\n    s2.imbue(std::locale(s2.getloc(), new csv_whitespace));\n    while(s2 >> token)\n            std::cout << \"  \" << token<< '\\n';\n}",
            "output": "default locale:\n  Column\n  1,Column\n  2,Column\n  3\n  123,456,789\nlocale with modified ctype:\n  Column 1\n  Column 2\n  Column 3\n  123\n  456\n  789"
        }
    },
    "codecvt": {
        "description": {
            "texte": "Class std::codecvt encapsulates conversion of character strings, including wide and multibyte, from one encoding to another. All file I/O operations performed through std::basic_fstream<CharT> use the std::codecvt<CharT, char, std::mbstate_t> facet of the locale imbued in the stream.The following standalone (locale-independent) specializations are provided by the standard library:In addition, every locale object constructed in a C++ program implements its own (locale-specific) versions of these four specializations."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <locale>\n#include <iomanip>\n#include <codecvt>\n \n// utility wrapper to adapt locale-bound facets for wstring/wbuffer convert\ntemplate<class Facet>\nstruct deletable_facet : Facet\n{\n    template<class ...Args>\n    deletable_facet(Args&& ...args) : Facet(std::forward<Args>(args)...) {}\n    ~deletable_facet() {}\n};\n \nint main()\n{\n    // UTF-8 narrow multibyte encoding\n    std::string data = u8\"z\\u00df\\u6c34\\U0001f34c\";\n                       // or u8\"z\u00df\u6c34\ud83c\udf4c\"\n                       // or \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9f\\x8d\\x8c\";\n \n    std::ofstream(\"text.txt\") << data;\n \n    // using system-supplied locale's codecvt facet\n    std::wifstream fin(\"text.txt\");\n    // reading from wifstream will use codecvt<wchar_t, char, mbstate_t>\n    // this locale's codecvt converts UTF-8 to UCS4 (on systems such as Linux)\n    fin.imbue(std::locale(\"en_US.UTF-8\"));\n    std::cout << \"The UTF-8 file contains the following UCS4 code points: \\n\";\n    for (wchar_t c; fin >> c; )\n        std::cout << \"U+\" << std::hex << std::setw(4) << std::setfill('0') << c << '\\n';\n \n    // using standard (locale-independent) codecvt facet\n    std::wstring_convert<\n        deletable_facet<std::codecvt<char16_t, char, std::mbstate_t>>, char16_t> conv16;\n    std::u16string str16 = conv16.from_bytes(data);\n \n    std::cout << \"The UTF-8 file contains the following UTF-16 code points: \\n\";\n    for (char16_t c : str16)\n        std::cout << \"U+\" << std::hex << std::setw(4) << std::setfill('0') << c << '\\n';\n}",
            "output": "The UTF-8 file contains the following UCS4 code points:\nU+007a\nU+00df\nU+6c34\nU+1f34c\nThe UTF-8 file contains the following UTF-16 code points:\nU+007a\nU+00df\nU+6c34\nU+d83c\nU+df4c"
        }
    },
    "collate": {
        "description": {
            "texte": "Class std::collate encapsulates locale-specific collation (comparison) and hashing of strings. This facet is used by std::basic_regex and can be applied, by means of std::locale::operator(), directly to all standard algorithms that expect a string comparison predicate.Two standalone (locale-independent) specializations are provided by the standard library:In addition, every locale object constructed in a C++ program implements its own (locale-specific) versions of these specializations."
        },
        "exemple": {
            "input": "#include <locale>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n \nint main()\n{\n    std::wcout.imbue(std::locale(\"\"));\n    std::vector<std::wstring> v = {L\"ar\", L\"zebra\", L\"\\u00f6grupp\", L\"Zebra\", L\"\\u00e4ngel\",\n                                   L\"\\u00e5r\", L\"f\\u00f6rnamn\"};\n \n    std::wcout << \"Default locale collation order: \";\n    std::sort(v.begin(), v.end());\n    for (auto s : v) std::wcout << s << ' '; std::wcout << '\\n';\n \n    std::wcout << \"English locale collation order: \";\n    std::sort(v.begin(), v.end(), std::locale(\"en_US.UTF-8\"));\n    for (auto s : v) std::wcout << s << ' '; std::wcout << '\\n';\n \n    std::wcout << \"Swedish locale collation order: \";\n    std::sort(v.begin(), v.end(), std::locale(\"sv_SE.UTF-8\"));\n    for (auto s : v) std::wcout << s << ' '; std::wcout << '\\n';\n}",
            "output": "Default locale collation order: Zebra ar f\u00f6rnamn zebra \u00e4ngel \u00e5r \u00f6grupp\nEnglish locale collation order: \u00e4ngel ar \u00e5r f\u00f6rnamn \u00f6grupp zebra Zebra\nSwedish locale collation order: ar f\u00f6rnamn zebra Zebra \u00e5r \u00e4ngel \u00f6grupp"
        }
    },
    "messages": {
        "description": {
            "texte": "Class template std::messages is a standard locale facet that encapsulates retrieval of strings from message catalogs, such as the ones provided by GNU gettext or by POSIX catgets.The source of the messages is implementation-defined.Two standalone (locale-independent) specializations are provided by the standard library:In addition, every locale object constructed in a C++ program implements its own (locale-specific) versions of these specializations."
        }
    },
    "time_get": {
        "description": {
            "texte": "Class template std::time_get encapsulates date and time parsing rules. The I/O manipulator std::get_time uses the std::time_get facet of the I/O stream's locale to convert text input to a std::tm object."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <locale>\n#include <ctime>\n#include <iomanip>\nint main()\n{\n    std::wstring input = L\"2011-Februar-18 23:12:34\";\n    std::tm t;\n    std::wistringstream ss(input);\n    ss.imbue(std::locale(\"de_DE\"));\n    ss >> std::get_time(&t, L\"%Y-%b-%d %H:%M:%S\"); // uses std::time_get<wchar_t>\n    std::cout << std::asctime(&t);\n}",
            "output": "Sun Feb 18 23:12:34 2011"
        }
    },
    "time_put": {
        "description": {
            "texte": "Class template std::time_put encapsulates date and time formatting rules. The I/O manipulator std::put_time uses the std::time_put facet of the I/O stream's locale to generate text representation of an std::tm object."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <ctime>\n#include <iomanip>\n#include <codecvt>\n \nint main()\n{\n    std::time_t t = std::time(NULL);\n    std::wbuffer_convert<std::codecvt_utf8<wchar_t>> conv(std::cout.rdbuf());\n    std::wostream out(&conv);\n    out.imbue(std::locale(\"ja_JP.utf8\"));\n    // this I/O manipulator std::put_time uses std::time_put<wchar_t>\n    out << std::put_time(std::localtime(&t), L\"%A %c\") << '\\n';\n}",
            "output": "\u6c34\u66dc\u65e5 2011\u5e7411\u670809\u65e5 12\u664232\u520605\u79d2"
        }
    },
    "num_get": {
        "description": {
            "texte": "Class std::num_get encapsulates the rules for parsing string representations of numeric values. Specifically, types bool, unsigned short, unsigned int, long, unsigned long, long long, unsigned long long, float, double, long double, and void* are supported. The standard formatting input operators (such as cin >> n;) use the std::num_get facet of the I/O stream's locale to parse the text representations of the numbers."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n#include <string>\n#include <sstream>\n#include <iterator>\n \nint main()\n{\n    std::string de_double = \"1.234.567,89\";\n    std::string us_double = \"1,234,567.89\";\n \n    // parse using streams\n    std::istringstream de_in(de_double);\n    de_in.imbue(std::locale(\"de_DE\"));\n    double f1;\n    de_in >> f1;\n \n    std::istringstream us_in(de_double);\n    us_in.imbue(std::locale(\"en_US.UTF-8\"));\n    double f2;\n    us_in >> f2;\n \n    std::cout << \"Parsing \" << de_double << \" as double gives \" << std::fixed\n              << f1 << \" in de_DE locale and \" << f2 << \" in en_US\\n\";\n \n    // use the facet directly\n    std::istringstream s3(us_double);\n    s3.imbue(std::locale(\"en_US.UTF-8\"));\n    auto& f = std::use_facet<std::num_get<char>>(s3.getloc());\n    std::istreambuf_iterator<char> beg(s3), end;\n    double f3;\n    std::ios::iostate err;\n    f.get(beg, end, s3, err, f3);\n    std::cout << \"parsing \" << us_double\n              << \" as double using raw en_US facet gives \" << f3 << '\\n';\n}",
            "output": "Parsing 1.234.567,89 as double gives 1234567.890000 in de_DE locale and 1.234000 in en_US\nparsing 1,234,567.89 as double using raw en_US facet gives 1234567.890000"
        }
    },
    "num_put": {
        "description": {
            "texte": "Class std::num_put encapsulates the rules for formatting numeric values as strings. Specifically, the types bool, long, unsigned long, long long, unsigned long long, double, long double, void*, and of all types implicitly convertible to these (such as int or float) are supported. The standard formatting output operators (such as cout << n;) use the std::num_put facet of the I/O stream's locale to generate text representation of numbers."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n#include <string>\n#include <iterator>\n \nint main()\n{\n    double n = 1234567.89;\n    std::cout.imbue(std::locale(\"de_DE\"));\n    std::cout << \"Direct conversion to string:\\n\"\n              << std::to_string(n) << '\\n'\n              << \"Output using a german locale:\\n\"\n              << std::fixed << n << '\\n'\n              << \"Output using an american locale:\\n\";\n    // use the facet directly\n    std::cout.imbue(std::locale(\"en_US.UTF-8\"));\n    auto& f = std::use_facet<std::num_put<char>>(std::cout.getloc());\n    f.put(std::ostreambuf_iterator<char>(std::cout), std::cout, ' ', n);\n    std::cout << '\\n';\n}",
            "output": "Direct conversion to string:\n1234567.890000\nOutput using a german locale:\n1.234.567,890000\nOutput using an american locale:\n1,234,567.890000"
        }
    },
    "numpunct": {
        "description": {
            "texte": "The facet std::numpunct encapsulates numeric punctuation preferences. Stream I/O operations use std::numpunct through std::num_get and std::num_put for parsing numeric input and formatting numeric output.The numbers that are supported by std::numpunct have the format described below. Here digit represents the radix set specified by the fmtflags argument value, thousands-sep and decimal-point are the results of thousands_sep() and decimal_point() functions respectively. The format of integer values is as follows:The number of digits between the thousand-seps (maximum size of digits) is specified by the result of grouping().The format of floating-point values is as follows:Two standalone (locale-independent) specializations are provided by the standard library:In addition, every locale object constructed in a C++ program implements its own (locale-specific) versions of these specializations."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n \nstruct french_bool : std::numpunct<char> {\n    string_type do_truename() const { return \"oui\"; }\n    string_type do_falsename() const { return \"non\"; }\n};\n \nint main()\n{\n    std::cout << \"default locale: \"\n              << std::boolalpha << true << \", \" << false << '\\n';\n    std::cout.imbue(std::locale(std::cout.getloc(), new french_bool));\n    std::cout << \"locale with modified numpunct: \"\n              << std::boolalpha << true << \", \" << false << '\\n';\n}",
            "output": "default locale: true, false\nlocale with modified numpunct: oui, non"
        }
    },
    "money_get": {
        "description": {
            "texte": "Class template std::money_get encapsulates the rules for parsing monetary values from character streams. The standard I/O manipulator std::get_money uses the std::money_get facet of the I/O stream's locale."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n#include <locale>\n#include <iomanip>\n#include <iterator>\nint main()\n{\n    std::string str = \"$1.11 $2.22 $3.33\";\n    std::cout << std::fixed << std::setprecision(2);\n \n    std::cout << '\"' << str << \"\\\" parsed with the I/O manipulator: \";\n    std::istringstream s1(str);\n    s1.imbue(std::locale(\"en_US.UTF-8\"));\n    long double val;\n    while(s1 >> std::get_money(val))\n        std::cout << val/100 << ' ';\n    std::cout << '\\n';\n \n    str = \"USD  1,234.56\";\n    std::cout << '\"' << str << \"\\\" parsed with the facet directly: \";\n    std::istringstream s2(str);\n    s2.imbue(std::locale(\"en_US.UTF-8\"));\n    auto& f = std::use_facet<std::money_get<char>>(s2.getloc());\n    std::ios_base::iostate err;\n    std::istreambuf_iterator<char> beg(s2), end;\n    f.get(beg, end, true, s2, err, val);\n    std::cout << val/100 << '\\n';\n}",
            "output": "\"$1.11 $2.22 $3.33\" parsed with the I/O manipulator: 1.11 2.22 3.33\n\"USD  1,234.56\" parsed with the facet directly: 1234.56"
        }
    },
    "money_put": {
        "description": {
            "texte": "Class std::money_put encapsulates the rules for formatting monetary values as strings. The standard I/O manipulator std::put_money uses the std::money_put facet of the I/O stream's locale."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n#include <iomanip>\n#include <iterator>\nint main()\n{\n    // using the IO manipulator\n    std::cout.imbue(std::locale(\"en_US.UTF-8\"));\n    std::cout << \"american locale: \"\n               << std::showbase << std::put_money(12345678.9)<< '\\n';\n \n    // using the facet directly\n    std::cout.imbue(std::locale(\"de_DE.UTF-8\"));\n    std::cout << \"german locale: \" ;\n    auto& f = std::use_facet<std::money_put<char>>(std::cout.getloc());\n    f.put({std::cout}, false, std::cout, std::cout.fill(), 12345678.9 );\n    std::cout << '\\n';\n}",
            "output": "american locale: $123,456.79\ngerman locale: 123.456,79 \u20ac"
        }
    },
    "moneypunct": {
        "description": {
            "texte": "The facet std::moneypunct encapsulates monetary value format preferences. Stream I/O manipulators std::get_money and std::put_money use std::moneypunct through std::money_get and std::money_put for parsing monetary value input and formatting monetary value output.Four standalone (locale-independent) specializations are provided by the standard library:In addition, every locale object constructed in a C++ program implements its own (locale-specific) versions of these specializations."
        }
    },
    "ctype_byname": {
        "description": {
            "texte": "std::ctype_byname is a std::ctype facet which encapsulates character classification rules of the locale specified at its construction.Two specializations are provided by the standard library."
        },
        "parametres": "   name   -   the name of the locale \n   refs   -   the number of references that link to the facet \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n \nint main()\n{\n    wchar_t c = L'\\u00de'; // capital letter thorn\n \n    std::locale loc(\"C\");\n \n    std::cout << \"isupper('\u00de', C locale) returned \"\n               << std::boolalpha << std::isupper(c, loc) << '\\n';\n \n    loc = std::locale(loc, new std::ctype_byname<wchar_t>(\"en_US.utf8\"));\n \n    std::cout << \"isupper('\u00de', C locale with Unicode ctype) returned \"\n              << std::boolalpha << std::isupper(c, loc) << '\\n';\n}",
            "output": "isupper('\u00de', C locale) returned false\nisupper('\u00de', C locale with Unicode ctype) returned true"
        }
    },
    "codecvt_byname": {
        "description": {
            "texte": "std::codecvt_byname is a std::codecvt facet which encapsulates multibyte/wide character conversion rules of a locale specified at its construction.Four specializations are provided by the standard library."
        },
        "parametres": "   name   -   the name of the locale \n   refs   -   the number of references that link to the facet \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <locale>\n \nint main()\n{\n    // GB18030 narrow multibyte encoding\n    std::ofstream(\"text.txt\") << \"\\x7a\"              // letter 'z', U+007a\n                                 \"\\x81\\x30\\x89\\x38\"  // letter '\u00df', U+00df\n                                 \"\\xcb\\xae\"          // CJK ideogram '\u6c34' (water), U+6c34\n                                 \"\\x94\\x32\\xbc\\x35\"; // musical sign '\ud834\udd0b' (segno), U+1d10b\n    std::wifstream fin(\"text.txt\");\n    fin.imbue(std::locale(fin.getloc(),\n              new std::codecvt_byname<wchar_t, char, std::mbstate_t>(\"zh_CN.gb18030\")));\n    for (wchar_t c; fin.get(c); )\n        std::cout << std::hex << std::showbase << c << '\\n';\n}",
            "output": "0x7a\n0xdf\n0x6c34\n0x1d10b"
        }
    },
    "messages_byname": {
        "description": {
            "texte": "std::messages_byname is a std::messages facet which encapsulates retrieval of strings from message catalogs of the locale specified at its construction.Two specializations are provided by the standard library."
        },
        "parametres": "   name   -   the name of the locale \n   refs   -   the number of references that link to the facet \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n \nvoid try_with(const std::locale& loc)\n{\n    const std::messages<char>& facet = std::use_facet<std::messages<char> >(loc)\n;\n    std::messages<char>::catalog cat = facet.open(\"sed\", std::cout.getloc());\n    if(cat < 0 )\n        std::cout << \"Could not open \\\"sed\\\" message catalog\\n\";\n    else\n        std::cout << \"\\\"No match\\\" \"\n                  << facet.get(cat, 0, 0, \"No match\") << '\\n'\n                  << \"\\\"Memory exhausted\\\" \" \n                  << facet.get(cat, 0, 0, \"Memory exhausted\") << '\\n';\n    facet.close(cat);\n}\nint main()\n{\n    std::locale loc(\"en_US.utf8\");\n    std::cout.imbue(loc);\n \n    try_with(std::locale(loc, new std::messages_byname<char>(\"de_DE.utf8\")));\n    try_with(std::locale(loc, new std::messages_byname<char>(\"fr_FR.utf8\")));\n    try_with(std::locale(loc, new std::messages_byname<char>(\"ja_JP.utf8\")));\n}",
            "output": "\"No match\" Keine \u00dcbereinstimmung\n\"Memory exhausted\" Speicher ersch\u00f6pft\n\"No match\" Pas de concordance\n\"Memory exhausted\" M\u00e9moire \u00e9puis\u00e9e\n\"No match\" \u7167\u5408\u3057\u307e\u305b\u3093\n\"Memory exhausted\" \u30e1\u30e2\u30ea\u30fc\u304c\u8db3\u308a\u307e\u305b\u3093"
        }
    },
    "collate_byname": {
        "description": {
            "texte": "std::collate_byname is a std::collate facet which encapsulates locale-specific collation (comparison) and hashing of strings. Just like std::collate, it can be imbued in std::regex and applied, by means of std::locale::operator(), directly to all standard algorithms that expect a string comparison predicate.Two specializations are provided by the standard library."
        },
        "parametres": "   name   -   the name of the locale \n   refs   -   the number of references that link to the facet \n\n"
    },
    "time_get_byname": {
        "description": {
            "texte": "std::time_get_byname is a std::time_get facet which encapsulates time and date parsing rules of the locale specified at its construction.Two specializations are provided by the standard library."
        },
        "parametres": "   name   -   the name of the locale \n   refs   -   the number of references that link to the facet \n\n"
    },
    "time_put_byname": {
        "description": {
            "texte": "std::time_put_byname is a std::time_put facet which encapsulates time and date formatting rules of the locale specified at its construction.Two specializations are provided by the standard library."
        },
        "parametres": "   name   -   the name of the locale \n   refs   -   the number of references that link to the facet \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <ctime>\n#include <iomanip>\n#include <codecvt>\n \nint main()\n{\n    std::time_t t = std::time(NULL);\n    std::wbuffer_convert<std::codecvt_utf8<wchar_t>> conv(std::cout.rdbuf());\n    std::wostream out(&conv);\n \n    out.imbue(std::locale(out.getloc(),\n                          new std::time_put_byname<wchar_t>(\"ja_JP\")));\n    out << std::put_time(std::localtime(&t), L\"%A %c\") << '\\n';\n \n    out.imbue(std::locale(out.getloc(),\n                         new std::time_put_byname<wchar_t>(\"ru_RU.utf8\")));\n    out << std::put_time(std::localtime(&t), L\"%A %c\") << '\\n'; \n \n    out.imbue(std::locale(out.getloc(),\n                         new std::time_put_byname<wchar_t>(\"sv_SE.utf8\")));\n    out << std::put_time(std::localtime(&t), L\"%A %c\") << '\\n'; \n}",
            "output": "\u6728\u66dc\u65e5 2012\u5e7408\u670809\u65e5 21\u664241\u520602\u79d2\n\u0427\u0435\u0442\u0432\u0435\u0440\u0433 \u0427\u0442. 09 \u0430\u0432\u0433. 2012 21:41:02\ntorsdag tor  9 aug 2012 21:41:02"
        }
    },
    "numpunct_byname": {
        "description": {
            "texte": "std::numpunct_byname is a std::numpunct facet which encapsulates numeric punctuation preferences of a locale specified at its construction.Two specializations are provided by the standard library."
        },
        "parametres": "   name   -   the name of the locale \n   refs   -   the number of references that link to the facet \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nint main()\n{\n    const double number = 1000.25;\n    std::wcout << L\"default locale: \" << number << L'\\n';\n    std::wcout.imbue(std::locale(std::wcout.getloc(),\n                                 new std::numpunct_byname<wchar_t>(\"ru_RU.UTF8\")));\n    std::wcout << L\"default locale with russian numpunct: \" << number << L'\\n';\n}",
            "output": "default locale: 1000.25\ndefault locale with russian numpunct: 1 000,25"
        }
    },
    "moneypunct_byname": {
        "description": {
            "texte": "std::moneypunct_byname is a std::moneypunct facet which encapsulates monetary formatting preferences of a locale specified at its construction.Two specializations are provided by the standard library."
        },
        "parametres": "   name   -   the name of the locale \n   refs   -   the number of references that link to the facet \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <locale>\nint main()\n{\n    long double mon = 1234567;\n    std::locale::global(std::locale(\"en_US.utf8\"));\n    std::wcout.imbue(std::locale());\n    std::wcout << L\"american locale : \" << std::showbase\n               << std::put_money(mon) << '\\n';\n    std::wcout.imbue(std::locale(std::wcout.getloc(),\n                                 new std::moneypunct_byname<wchar_t>(\"ru_RU.utf8\")));\n    std::wcout << L\"american locale with russian moneypunct: \"\n               << std::put_money(mon) << '\\n';\n}",
            "output": "american locale : $12,345.67\namerican locale with russian moneypunct: 12 345.67 \u0440\u0443\u0431"
        }
    },
    "codecvt_utf8": {
        "description": {
            "texte": "std::codecvt_utf8 is a std::codecvt facet which encapsulates conversion between a UTF-8 encoded byte string and UCS2 or UTF-32 character string (depending on the type of Elem). This codecvt facet can be used to read and write UTF-8 files, both text and binary."
        },
        "parametres": "   refs   -   the number of references that link to the facet \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <locale>\n#include <codecvt>\n \nint main()\n{\n    // UTF-8 data. The character U+1d10b, musical sign segno, does not fit in UCS2\n    std::string utf8 = u8\"z\\u6c34\\U0001d10b\";\n \n    // the UTF-8 / UTF-16 standard conversion facet\n    std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t> utf16conv;\n    std::u16string utf16 = utf16conv.from_bytes(utf8);\n    std::cout << \"UTF16 conversion produced \" << utf16.size() << \" code units:\\n\";\n    for (char16_t c : utf16)\n        std::cout << std::hex << std::showbase << c << '\\n';\n \n    // the UTF-8 / UCS2 standard conversion facet\n    std::wstring_convert<std::codecvt_utf8<char16_t>, char16_t> ucs2conv;\n    try {\n        std::u16string ucs2 = ucs2conv.from_bytes(utf8);\n    } catch(const std::range_error& e) {\n        std::u16string ucs2 = ucs2conv.from_bytes(utf8.substr(0, ucs2conv.converted()));\n        std::cout << \"UCS2 failed after producing \" << std::dec << ucs2.size()<<\" characters:\\n\";\n        for (char16_t c : ucs2)\n            std::cout << std::hex << std::showbase << c << '\\n';\n    }\n}",
            "output": "UTF16 conversion produced 4 code units:\n0x7a\n0x6c34\n0xd834\n0xdd0b\nUCS2 failed after producing 2 characters:\n0x7a\n0x6c34"
        }
    },
    "codecvt_utf16": {
        "description": {
            "texte": "std::codecvt_utf16 is a std::codecvt facet which encapsulates conversion between a UTF-16 encoded byte string and UCS2 or UTF-32 character string (depending on the type of Elem). This codecvt facet can be used to read and write UTF-16 files in binary mode."
        },
        "parametres": "   refs   -   the number of references that link to the facet \n\n",
        "exemple": {
            "input": "#include <fstream>\n#include <iostream>\n#include <string>\n#include <locale>\n#include <codecvt>\n \nvoid prepare_file()\n{\n    // UTF-16le data (if host system is little-endian)\n    char16_t utf16le[4] ={0x007a,          // latin small letter 'z' U+007a\n                          0x6c34,          // CJK ideograph \"water\"  U+6c34\n                          0xd834, 0xdd0b}; // musical sign segno U+1d10b\n    // store in a file\n    std::ofstream fout(\"text.txt\");\n    fout.write( reinterpret_cast<char*>(utf16le), sizeof utf16le);\n}\n \nint main()\n{\n    prepare_file();\n    // open as a byte stream\n    std::wifstream fin(\"text.txt\", std::ios::binary);\n    // apply facet\n    fin.imbue(std::locale(fin.getloc(),\n       new std::codecvt_utf16<wchar_t, 0x10ffff, std::little_endian>));\n \n    for (wchar_t c; fin.get(c); )\n            std::cout << std::showbase << std::hex << c << '\\n';\n}",
            "output": "0x7a\n0x6c34\n0x1d10b"
        }
    },
    "codecvt_utf8_utf16": {
        "description": {
            "texte": "std::codecvt_utf8_utf16 is a std::codecvt facet which encapsulates conversion between a UTF-8 encoded byte string and UTF-16 encoded character string. If Elem is a 32-bit type, one UTF-16 code unit will be stored in each 32-bit character of the output sequence.This is an N:M conversion facet, and cannot be used with std::basic_filebuf (which only permits 1:N conversions, such as UTF-32/UTF-8, between the internal and the external encodings). This facet can be used with std::wstring_convert."
        },
        "parametres": "   refs   -   the number of references that link to the facet \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <codecvt>\n#include <cassert>\n#include <locale>\n \nint main()\n{\n    std::string u8 = u8\"z\\u00df\\u6c34\\U0001f34c\";\n    std::u16string u16 = u\"z\\u00df\\u6c34\\U0001f34c\";\n \n    // UTF-8 to UTF-16/char16_t\n    std::u16string u16_conv = std::wstring_convert<\n        std::codecvt_utf8_utf16<char16_t>, char16_t>{}.from_bytes(u8);\n    assert(u16 == u16_conv);\n    std::cout << \"UTF-8 to UTF-16 conversion produced \"\n              << u16_conv.size() << \" code units:\\n\";\n    for (char16_t c : u16_conv)\n        std::cout << std::hex << std::showbase << c << ' ';\n \n    // UTF-16/char16_t to UTF-8\n    std::string u8_conv = std::wstring_convert<\n        std::codecvt_utf8_utf16<char16_t>, char16_t>{}.to_bytes(u16);\n    assert(u8 == u8_conv);\n    std::cout << \"\\nUTF-16 to UTF-8 conversion produced \"\n              << std::dec << u8_conv.size() << \" bytes:\\n\" << std::hex;\n    for (char c : u8_conv)\n        std::cout << +(unsigned char)c << ' ';\n}",
            "output": "UTF-8 to UTF-16 conversion produced 5 code units:\n0x7a 0xdf 0x6c34 0xd83c 0xdf4c \nUTF-16 to UTF-8 conversion produced 10 bytes:\n0x7a 0xc3 0x9f 0xe6 0xb0 0xb4 0xf0 0x9f 0x8d 0x8c"
        }
    },
    "codecvt_mode": {
        "description": {
            "texte": "The facets std::codecvt_utf8, std::codecvt_utf16, and std::codecvt_utf8_utf16 accept an optional value of type std::codecvt_mode as a template argument, which specifies optional features of the unicode string conversion."
        },
        "exemple": {
            "input": "#include <fstream>\n#include <iostream>\n#include <string>\n#include <locale>\n#include <codecvt>\n \nint main()\n{\n    // UTF-8 data with BOM\n    std::ofstream(\"text.txt\") << u8\"\\ufeffz\\u6c34\\U0001d10b\";\n    // read the UTF8 file, skipping the BOM\n    std::wifstream fin(\"text.txt\");\n    fin.imbue(std::locale(fin.getloc(),\n                          new std::codecvt_utf8<wchar_t, 0x10ffff, std::consume_header>));\n    for (wchar_t c; fin.get(c); )\n        std::cout << std::hex << std::showbase << c << '\\n';\n}",
            "output": "0x7a\n0x6c34\n0x1d10b"
        }
    },
    "setlocale": {
        "description": {
            "texte": "The setlocale function installs the specified system locale or its portion as the new C locale. The modifications remain in effect and influences the execution of all locale-sensitive C library functions until the next call to setlocale. If locale is a null pointer, setlocale queries the current C locale without modifying it."
        },
        "parametres": "   category   -   locale category identifier, one of the LC_xxx macros. May be 0. \n   locale   -   system-specific locale identifier. Can be \"\" for the user-preferred locale or \"C\" for the minimal locale \n\n",
        "exemple": {
            "input": "#include <cstdio>\n#include <clocale>\n#include <ctime>\n#include <cwchar>\n \nint main()\n{\n    // the C locale will be UTF-8 enabled English;\n    // decimal dot will be German\n    // date and time formatting will be Japanese\n    std::setlocale(LC_ALL, \"en_US.UTF-8\");\n    std::setlocale(LC_NUMERIC, \"de_DE.UTF-8\");\n    std::setlocale(LC_TIME, \"ja_JP.UTF-8\");\n \n    wchar_t str[100];\n    std::time_t t = std::time(NULL);\n    std::wcsftime(str, 100, L\"%A %c\", std::localtime(&t));\n    std::wprintf(L\"Number: %.2f\\nDate: %Ls\\n\", 3.14, str);\n}",
            "output": "Number: 3,14\nDate: \u6708\u66dc\u65e5 2011\u5e7412\u670819\u65e5 18\u664204\u520640\u79d2"
        }
    },
    "localeconv": {
        "description": {
            "texte": "The localeconv function obtains a pointer to a static object of type std::lconv, which represents numeric and monetary formatting rules of the current C locale."
        },
        "exemple": {
            "input": "#include <clocale>\n#include <iostream>\n \nint main()\n{\n    std::setlocale(LC_ALL, \"ja_JP.UTF-8\");\n    std::lconv* lc = std::localeconv();\n    std::cout << \"Japanese currency symbol: \" << lc->currency_symbol\n              << '(' << lc->int_curr_symbol << \")\\n\";\n}",
            "output": "Japanese currency symbol: \uffe5(JPY )"
        }
    },
    "lconv": {
        "description": {
            "texte": "The class std::lconv contains numeric and monetary formatting rules as defined by a C locale. Objects of this struct may be obtained with std::localeconv. The members of std::lconv are values of type char and of type char*. Each char* member except decimal_point may be pointing at a null character (that is, at an empty C-string). The members of type char are all non-negative numbers, any of which may be CHAR_MAX if the corresponding value is not available in the current C locale."
        },
        "exemple": {
            "input": "#include <clocale>\n#include <iostream>\n \nint main()\n{\n    std::setlocale(LC_ALL, \"ja_JP.UTF-8\");\n    std::lconv* lc = std::localeconv();\n    std::cout << \"Japanese currency symbol: \" << lc->currency_symbol\n              << '(' << lc->int_curr_symbol << \")\\n\";\n}",
            "output": "Japanese currency symbol: \uffe5(JPY )"
        }
    },
    "LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME": {
        "description": {
            "texte": "Each of the above macro constants expand to integer constant expressions with distinct values that are suitable for use as the first argument of std::setlocale.Additional macro constants, with names that begin with LC_ followed by at least one uppercase letter, may be defined in <clocale>. For example, the POSIX specification requires LC_MESSAGES (which controls std::perror and std::strerror), ISO/IEC 30112:2014 (2014 draft) additionally defines LC_IDENTIFICATION, LC_XLITERATE, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_PAPER, LC_MEASUREMENT, and LC_KEYBOARD, which are supported by the GNU C library (except for LC_XLITERATE)."
        },
        "exemple": {
            "input": "#include <cstdio>\n#include <clocale>\n#include <ctime>\n#include <cwchar>\n \nint main()\n{\n    std::setlocale(LC_ALL, \"en_US.UTF-8\"); // the C locale will be the UTF-8 enabled English\n    std::setlocale(LC_NUMERIC, \"de_DE.UTF-8\");   // decimal dot will be German\n    std::setlocale(LC_TIME, \"ja_JP.UTF-8\");      // date/time formatting will be Japanese\n    wchar_t str[100];\n    std::time_t t = std::time(nullptr);\n    std::wcsftime(str, 100, L\"%A %c\", std::localtime(&t));\n    std::wprintf(L\"Number: %.2f\\nDate: %Ls\\n\", 3.14, str);\n}",
            "output": "Number: 3,14\nDate: \u6708\u66dc\u65e5 2011\u5e7412\u670819\u65e5 18\u664204\u520640\u79d2"
        }
    },
    "tm": {
        "description": {
            "texte": "Structure holding a calendar date and time broken down into its components."
        }
    },
    "basic_regex": {
        "description": {
            "texte": "The class template basic_regex provides a general framework for holding regular expressions.Several specializations for common character types are provided:"
        }
    },
    "sub_match": {
        "description": {
            "texte": "The class template sub_match is used by the regular expression engine to denote sequences of characters matched by marked sub-expressions. A match is a [begin, end) pair within the target range matched by the regular expression, but with additional observer functions to enhance code clarity.Only the default constructor is publicly accessible. Instances of sub_match are normally constructed and populated as a part of a std::match_results container during the processing of one of the regex algorithms.The member functions return defined default values unless the matched member is true.sub_match inherits from std::pair<BidirIt, BidirIt>, although it cannot be treated as a std::pair object because member functions such as swap and assignment will not work as expected."
        }
    },
    "match_results": {
        "description": {
            "texte": "The class template std::match_results holds a collection of character sequences that represent the result of a regular expression match.This is a specialized allocator-aware container. It can only be default created, obtained from std::regex_iterator, or modified by std::regex_search or std::regex_match. Because std::match_results holds std::sub_matches, each of which is a pair of iterators into the original character sequence that was matched, it's undefined behavior to examine std::match_results if the original character sequence was destroyed or iterators to it were invalidated for other reasons.The first sub_match (index 0) contained in a match_result always represents the full match within a target sequence made by a regex, and subsequent sub_matches represent sub-expression matches corresponding in sequence to the left parenthesis delimiting the sub-expression in the regex.std::match_results meets the requirements of a AllocatorAwareContainer and of a SequenceContainer, except that only copy assignment, move assignment, and operations defined for a constant containers are supported, and that the semantics of comparison functions are different from those required for a container."
        }
    },
    "regex_match": {
        "description": {
            "texte": "Determines if the regular expression e matches the entire target character sequence, which may be specified as std::string, a C-string, or an iterator pair.Note that regex_match will only successfully match a regular expression to an entire character sequence, whereas std::regex_search will successfully match subsequences."
        },
        "parametres": "   first, last   -   the target character range to apply the regex to, given as iterators \n   m   -   the match results \n   str   -   the target string, given as a null-terminated C-style string \n   s   -   the target string, given as a std::basic_string \n   e   -   the regular expression \n   flags   -   flags used to determine how the match will be performed \n   Type requirements \n   -BidirIt must meet the requirements of LegacyBidirectionalIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <regex>\n \nint main()\n{\n    // Simple regular expression matching\n    const std::string fnames[] = {\"foo.txt\", \"bar.txt\", \"baz.dat\", \"zoidberg\"};\n    const std::regex txt_regex(\"[a-z]+\\\\.txt\");\n \n    for (const auto &fname : fnames) {\n        std::cout << fname << \": \" << std::regex_match(fname, txt_regex) << '\\n';\n    }   \n \n    // Extraction of a sub-match\n    const std::regex base_regex(\"([a-z]+)\\\\.txt\");\n    std::smatch base_match;\n \n    for (const auto &fname : fnames) {\n        if (std::regex_match(fname, base_match, base_regex)) {\n            // The first sub_match is the whole string; the next\n            // sub_match is the first parenthesized expression.\n            if (base_match.size() == 2) {\n                std::ssub_match base_sub_match = base_match[1];\n                std::string base = base_sub_match.str();\n                std::cout << fname << \" has a base of \" << base << '\\n';\n            }\n        }\n    }\n \n    // Extraction of several sub-matches\n    const std::regex pieces_regex(\"([a-z]+)\\\\.([a-z]+)\");\n    std::smatch pieces_match;\n \n    for (const auto &fname : fnames) {\n        if (std::regex_match(fname, pieces_match, pieces_regex)) {\n            std::cout << fname << '\\n';\n            for (size_t i = 0; i < pieces_match.size(); ++i) {\n                std::ssub_match sub_match = pieces_match[i];\n                std::string piece = sub_match.str();\n                std::cout << \"  submatch \" << i << \": \" << piece << '\\n';\n            }   \n        }   \n    }   \n}",
            "output": "foo.txt: 1\nbar.txt: 1\nbaz.dat: 0\nzoidberg: 0\nfoo.txt has a base of foo\nbar.txt has a base of bar\nfoo.txt\n  submatch 0: foo.txt\n  submatch 1: foo\n  submatch 2: txt\nbar.txt\n  submatch 0: bar.txt\n  submatch 1: bar\n  submatch 2: txt\nbaz.dat\n  submatch 0: baz.dat\n  submatch 1: baz\n  submatch 2: dat"
        }
    },
    "regex_search": {
        "description": {
            "texte": "Determines if there is a match between the regular expression e and some subsequence in the target character sequence.regex_search will successfully match any subsequence of the given sequence, whereas std::regex_match will only return true if the regular expression matches the entire sequence."
        },
        "parametres": "   first, last   -   a range identifying the target character sequence \n   str   -   a pointer to a null-terminated target character sequence \n   s   -   a string identifying target character sequence \n   e   -   the std::regex that should be applied to the target character sequence \n   m   -   the match results \n   flags   -   std::regex_constants::match_flag_type governing search behavior \n   Type requirements \n   -BidirIt must meet the requirements of LegacyBidirectionalIterator. \n   -Alloc must meet the requirements of Allocator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <regex>\n \nint main()\n{\n    std::string lines[] = {\"Roses are #ff0000\",\n                           \"violets are #0000ff\",\n                           \"all of my base are belong to you\"};\n \n    std::regex color_regex(\"#([a-f0-9]{2})\"\n                            \"([a-f0-9]{2})\"\n                            \"([a-f0-9]{2})\");\n \n    // simple match\n    for (const auto &line : lines) {\n        std::cout << line << \": \" << std::boolalpha\n                  << std::regex_search(line, color_regex) << '\\n';\n    }   \n    std::cout << '\\n';\n \n    // show contents of marked subexpressions within each match\n    std::smatch color_match;\n    for (const auto& line : lines) {\n        if(std::regex_search(line, color_match, color_regex)) {\n            std::cout << \"matches for '\" << line << \"'\\n\";\n            std::cout << \"Prefix: '\" << color_match.prefix() << \"'\\n\";\n            for (size_t i = 0; i < color_match.size(); ++i) \n                std::cout << i << \": \" << color_match[i] << '\\n';\n            std::cout << \"Suffix: '\" << color_match.suffix() << \"\\'\\n\\n\";\n        }\n    }\n \n    // repeated search (see also std::regex_iterator)\n    std::string log(R\"(\n        Speed:        366\n        Mass:        35\n        Speed:        378\n        Mass:        32\n        Speed:        400\n        Mass:        30)\");\n    std::regex r(R\"(Speed:\\t\\d*)\");\n    std::smatch sm;\n    while(regex_search(log, sm, r))\n    {\n        std::cout << sm.str() << '\\n';\n        log = sm.suffix();\n    }\n \n    // C-style string demo\n    std::cmatch cm;\n    if(std::regex_search(\"this is a test\", cm, std::regex(\"test\"))) \n        std::cout << \"\\nFound \" << cm[0] << \" at position \" << cm.prefix().length();\n}",
            "output": "Roses are #ff0000: true\nviolets are #0000ff: true\nall of my base are belong to you: false\n \nmatches for 'Roses are #ff0000'\nPrefix: 'Roses are '\n0: #ff0000\n1: ff\n2: 00\n3: 00\nSuffix: ''\n \nmatches for 'violets are #0000ff'\nPrefix: 'violets are '\n0: #0000ff\n1: 00\n2: 00\n3: ff\nSuffix: ''\n \nSpeed:        366\nSpeed:        378\nSpeed:        400\n \nFound test at position 10"
        }
    },
    "regex_replace": {
        "description": {
            "texte": "regex_replace uses a regular expression to perform substitution on a sequence of characters:"
        },
        "parametres": "   first, last   -   the input character sequence, represented as a pair of iterators \n   s   -   the input character sequence, represented as std::basic_string or character array \n   re   -   the std::basic_regex that will be matched against the input sequence \n   flags   -   the match flags of type std::regex_constants::match_flag_type \n   fmt   -   the regex replacement format string, exact syntax depends on the value of flags \n   out   -   output iterator to store the result of the replacement \n   Type requirements \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n   -BidirIt must meet the requirements of LegacyBidirectionalIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n#include <regex>\n#include <string>\n \nint main()\n{\n   std::string text = \"Quick brown fox\";\n   std::regex vowel_re(\"a|e|i|o|u\");\n \n   // write the results to an output iterator\n   std::regex_replace(std::ostreambuf_iterator<char>(std::cout),\n                      text.begin(), text.end(), vowel_re, \"*\");\n \n   // construct a string holding the results\n   std::cout << '\\n' << std::regex_replace(text, vowel_re, \"[$&]\") << '\\n';\n}",
            "output": "Q**ck br*wn f*x\nQ[u][i]ck br[o]wn f[o]x"
        }
    },
    "regex_iterator": {
        "description": {
            "texte": "std::regex_iterator is a read-only iterator that accesses the individual matches of a regular expression within the underlying character sequence. It meets the requirements of a LegacyForwardIterator, except that for dereferenceable values a and b with a == b, *a and *b will not be bound to the same object.On construction, and on every increment, it calls std::regex_search and remembers the result (that is, saves a copy of the value std::match_results<BidirIt>). The first object may be read when the iterator is constructed or when the first dereferencing is done. Otherwise, dereferencing only returns a copy of the most recently obtained regex match.The default-constructed std::regex_iterator is the end-of-sequence iterator. When a valid std::regex_iterator is incremented after reaching the last match (std::regex_search returns false), it becomes equal to the end-of-sequence iterator. Dereferencing or incrementing it further invokes undefined behavior.A typical implementation of std::regex_iterator holds the begin and the end iterators for the underlying sequence (two instances of BidirIt), a pointer to the regular expression (const regex_type*), the match flags (std::regex_constants::match_flag_type), and the current match (std::match_results<BidirIt>)."
        },
        "exemple": {
            "input": "#include <regex>\n#include <iterator>\n#include <iostream>\n#include <string>\n \nint main()\n{\n    const std::string s = \"Quick brown fox.\";\n \n    std::regex words_regex(\"[^\\\\s]+\");\n    auto words_begin = \n        std::sregex_iterator(s.begin(), s.end(), words_regex);\n    auto words_end = std::sregex_iterator();\n \n    std::cout << \"Found \" \n              << std::distance(words_begin, words_end) \n              << \" words:\\n\";\n \n    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {\n        std::smatch match = *i;                                                 \n        std::string match_str = match.str(); \n        std::cout << match_str << '\\n';\n    }   \n}",
            "output": "Found 3 words:\nQuick\nbrown\nfox."
        }
    },
    "regex_token_iterator": {
        "description": {
            "texte": "std::regex_token_iterator is a read-only LegacyForwardIterator that accesses the individual sub-matches of every match of a regular expression within the underlying character sequence. It can also be used to access the parts of the sequence that were not matched by the given regular expression (e.g. as a tokenizer).On construction, it constructs an std::regex_iterator and on every increment it steps through the requested sub-matches from the current match_results, incrementing the underlying regex_iterator when incrementing away from the last submatch.The default-constructed std::regex_token_iterator is the end-of-sequence iterator. When a valid std::regex_token_iterator is incremented after reaching the last submatch of the last match, it becomes equal to the end-of-sequence iterator. Dereferencing or incrementing it further invokes undefined behavior.Just before becoming the end-of-sequence iterator, a std::regex_token_iterator may become a suffix iterator, if the index -1 (non-matched fragment) appears in the list of the requested submatch indexes. Such iterator, if dereferenced, returns a match_results corresponding to the sequence of characters between the last match and the end of sequence.A typical implementation of std::regex_token_iterator holds the underlying std::regex_iterator, a container (e.g. std::vector<int>) of the requested submatch indexes, the internal counter equal to the index of the submatch, a pointer to std::sub_match, pointing at the current submatch of the current match, and a std::match_results object containing the last non-matched character sequence (used in tokenizer mode)."
        },
        "exemple": {
            "input": "#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <regex>\n \nint main()\n{\n   std::string text = \"Quick brown fox.\";\n   // tokenization (non-matched fragments)\n   // Note that regex is matched only two times: when the third value is obtained\n   // the iterator is a suffix iterator.\n   std::regex ws_re(\"\\\\s+\"); // whitespace\n   std::copy( std::sregex_token_iterator(text.begin(), text.end(), ws_re, -1),\n              std::sregex_token_iterator(),\n              std::ostream_iterator<std::string>(std::cout, \"\\n\"));\n \n   // iterating the first submatches\n   std::string html = \"<p><a href=\\\"http://google.com\\\">google</a> \"\n                      \"< a HREF =\\\"http://cppreference.com\\\">cppreference</a>\\n</p>\";\n   std::regex url_re(\"<\\\\s*A\\\\s+[^>]*href\\\\s*=\\\\s*\\\"([^\\\"]*)\\\"\", std::regex::icase);\n   std::copy( std::sregex_token_iterator(html.begin(), html.end(), url_re, 1),\n              std::sregex_token_iterator(),\n              std::ostream_iterator<std::string>(std::cout, \"\\n\"));\n}",
            "output": "Quick\nbrown\nfox.\nhttp://google.com\nhttp://cppreference.com"
        }
    },
    "regex_error": {
        "description": {
            "texte": "Defines the type of exception object thrown to report errors in the regular expressions library."
        },
        "exemple": {
            "input": "#include <regex>\n#include <iostream>\n \nint main()\n{\n    try {\n        std::regex re(\"[a-b][a\");\n    } \n \n    catch (const std::regex_error& e) {\n        std::cout << \"regex_error caught: \" << e.what() << '\\n';\n        if (e.code() == std::regex_constants::error_brack) {\n            std::cout << \"The code was error_brack\\n\";\n        }\n    }\n}",
            "output": "regex_error caught: The expression contained mismatched [ and ].\nThe code was error_brack"
        }
    },
    "regex_traits": {
        "description": {
            "texte": "The type trait template regex_traits supplies std::basic_regex with the set of types and functions necessary to operate on the type CharT.Since many of regex operations are locale-sensitive (when std::regex_constants::collate flag is set), the regex_traits class typically holds an instance of a std::locale as a private member."
        }
    },
    "regex_constants::syntax_option_type": {
        "description": {
            "texte": "The syntax_option_type is a BitmaskType that contains options that govern how regular expressions behave.The possible values for this type (icase, optimize, etc.) are duplicated inside std::basic_regex."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <regex>\n \nint main()\n{\n    std::string str = \"zzxayyzz\";\n    std::regex re1(\".*(a|xayy)\"); // ECMA\n    std::regex re2(\".*(a|xayy)\", std::regex::extended); // POSIX\n \n    std::cout << \"Searching for .*(a|xayy) in zzxayyzz:\\n\";\n    std::smatch m;\n    std::regex_search(str, m, re1);\n    std::cout << \" ECMA (depth first search) match: \" << m[0] << '\\n';\n    std::regex_search(str, m, re2);\n    std::cout << \" POSIX (leftmost longest)  match: \" << m[0] << '\\n';\n}",
            "output": "Searching for .*(a|xayy) in zzxayyzz:\n ECMA (depth first search) match: zzxa\n POSIX (leftmost longest)  match: zzxayy"
        }
    },
    "regex_constants::match_flag_type": {
        "description": {
            "texte": "match_flag_type is a BitmaskType that specifies additional regular expression matching options."
        }
    },
    "regex_constants::error_type": {
        "description": {
            "texte": "The error_type is a type that describes errors that may occur during regular expression parsing."
        }
    },
    "atomic": {
        "description": {
            "texte": "Each instantiation and full specialization of the std::atomic template defines an atomic type. If one thread writes to an atomic object while another thread reads from it, the behavior is well-defined (see memory model for details on data races).In addition, accesses to atomic objects may establish inter-thread synchronization and order non-atomic memory accesses as specified by std::memory_order.std::atomic is neither copyable nor movable."
        }
    },
    "atomic_ref": {
        "description": {
            "texte": "The std::atomic_ref class template applies atomic operations to the object it references. For the lifetime of the atomic_ref object, the object it references is considered an atomic object. If one thread writes to an atomic object while another thread reads from it, the behavior is well-defined (see memory model for details on data races). In addition, accesses to atomic objects may establish inter-thread synchronization and order non-atomic memory accesses as specified by std::memory_order.The lifetime of an object must exceed the lifetime of all atomic_refs that references the object. While any atomic_ref instances referencing an object exists, the object must be exclusively accessed through these atomic_ref instances. No subobject of an object referenced by an atomic_ref object may be concurrently referenced by any other atomic_ref object.Atomic operations applied to an object through an atomic_ref are atomic with respect to atomic operations applied through any other atomic_ref referencing the same object.std::atomic_ref is CopyConstructible.Like language references, constness is shallow for atomic_ref - it is possible to modify the referenced value through a const atomic_ref object."
        }
    },
    "atomic_store, std::atomic_store_explicit": {
        "description": {
            "texte": "none."
        },
        "parametres": "   obj   -   pointer to the atomic object to modify \n   desr   -   the value to store in the atomic object \n   order   -   the memory synchronization ordering for this operation: only std::memory_order_relaxed, std::memory_order_release and std::memory_order_seq_cst are permitted. \n\n"
    },
    "atomic_load, std::atomic_load_explicit": {
        "description": {
            "texte": "The value that is held by the atomic object pointed to by obj."
        },
        "parametres": "   obj   -   pointer to the atomic object to modify \n   order   -   the memory synchronization ordering for this operation: only std::memory_order_relaxed, std::memory_order_consume, std::memory_order_acquire and std::memory_order_seq_cst are permitted. \n\n"
    },
    "atomic_exchange, std::atomic_exchange_explicit": {
        "description": {
            "texte": "The value held previously by the atomic object pointed to by obj."
        },
        "parametres": "   obj   -   pointer to the atomic object to modify \n   desr   -   the value to store in the atomic object \n   order   -   the memory synchronization ordering for this operation: all values are permitted. \n\n",
        "exemple": {
            "input": "#include <thread>\n#include <vector>\n#include <iostream>\n#include <atomic>\n \nstd::atomic<bool> lock(false); // holds true when locked\n                               // holds false when unlocked\n \nvoid f(int n)\n{\n    for (int cnt = 0; cnt < 100; ++cnt) {\n        while(std::atomic_exchange_explicit(&lock, true, std::memory_order_acquire))\n             ; // spin until acquired\n        std::cout << \"Output from thread \" << n << '\\n';\n        std::atomic_store_explicit(&lock, false, std::memory_order_release);\n    }\n}\nint main()\n{\n    std::vector<std::thread> v;\n    for (int n = 0; n < 10; ++n) {\n        v.emplace_back(f, n);\n    }\n    for (auto& t : v) {\n        t.join();\n    }\n}",
            "output": "Output from thread 2\nOutput from thread 6\nOutput from thread 7\n...<exactly 1000 lines>..."
        }
    },
    "atomic_compare_exchange_weak, std::atomic_compare_exchange_strong, std::atomic_compare_exchange_weak_explicit, std::atomic_compare_exchange_strong_explicit": {
        "description": {
            "texte": "Atomically compares the object representation (until C++20)value representation (since C++20) of the object pointed to by obj with that of the object pointed to by expected, and if those are bitwise-equal, replaces the former with desired (performs read-modify-write operation). Otherwise, loads the actual value pointed to by obj into *expected (performs load operation). Copying is performed as if by std::memcpy.The memory models for the read-modify-write and load operations are succ and fail respectively. The (1-2) versions use std::memory_order_seq_cst by default.These functions are defined in terms of member functions of std::atomic:"
        },
        "parametres": "   obj   -   pointer to the atomic object to test and modify \n   expected   -   pointer to the value expected to be found in the atomic object \n   desired   -   the value to store in the atomic object if it is as expected \n   succ   -   the memory synchronization ordering for the read-modify-write operation if the comparison succeeds. All values are permitted. \n   fail   -   the memory synchronization ordering for the load operation if the comparison fails. Cannot be std::memory_order_release or std::memory_order_acq_rel and cannot specify stronger ordering than succ (until C++17) \n\n",
        "exemple": {
            "input": "#include <atomic>\n \ntemplate<class T>\nstruct node\n{\n    T data;\n    node* next;\n    node(const T& data) : data(data), next(nullptr) {}\n};\n \ntemplate<class T>\nclass stack\n{\n    std::atomic<node<T>*> head;\n public:\n    void push(const T& data)\n    {\n        node<T>* new_node = new node<T>(data);\n \n        // put the current value of head into new_node->next\n        new_node->next = head.load(std::memory_order_relaxed);\n \n        // now make new_node the new head, but if the head\n        // is no longer what's stored in new_node->next\n        // (some other thread must have inserted a node just now)\n        // then put that new head into new_node->next and try again\n        while(!std::atomic_compare_exchange_weak_explicit(\n                                &head,\n                                &new_node->next,\n                                new_node,\n                                std::memory_order_release,\n                                std::memory_order_relaxed))\n                ; // the body of the loop is empty\n// note: the above loop is not thread-safe in at least\n// GCC prior to 4.8.3 (bug 60272), clang prior to 2014-05-05 (bug 18899)\n// MSVC prior to 2014-03-17 (bug 819819). See member function version for workaround\n    }\n};\n \nint main()\n{\n    stack<int> s;\n    s.push(1);\n    s.push(2);\n    s.push(3);\n}"
        }
    },
    "atomic_fetch_add, std::atomic_fetch_add_explicit": {
        "description": {
            "texte": "Performs atomic addition. Atomically adds arg to the value pointed to by obj and returns the value obj held previously. The operation is performed as if the following was executed:"
        },
        "parametres": "   obj   -   pointer to the atomic object to modify \n   arg   -   the value to add to the value stored in the atomic object \n   order   -   the memory synchronization ordering for this operation: all values are permitted. \n\n",
        "exemple": {
            "input": "#include <string>\n#include <thread>\n#include <vector>\n#include <iostream>\n#include <atomic>\n#include <chrono>\n \n// meaning of cnt:\n// 5: there are no active readers or writers.\n// 1...4: there are 4...1 readers active, The writer is blocked\n// 0: temporary value between fetch_sub and fetch_add in reader lock\n// -1: there is a writer active. The readers are blocked.\nconst int N = 5; // four concurrent readers are allowed\nstd::atomic<int> cnt(N);\n \nstd::vector<int> data;\n \nvoid reader(int id)\n{\n    for(;;)\n    {\n        // lock\n        while(std::atomic_fetch_sub(&cnt, 1) <= 0)\n            std::atomic_fetch_add(&cnt, 1);\n        // read\n        if(!data.empty())\n            std::cout << (  \"reader \" + std::to_string(id)\n                          + \" sees \" + std::to_string(*data.rbegin()) + '\\n');\n        if(data.size() == 25)\n            break;\n        // unlock\n        std::atomic_fetch_add(&cnt, 1);\n        // pause\n        std::this_thread::sleep_for(std::chrono::milliseconds(1));\n    }\n}\n \nvoid writer()\n{\n    for(int n = 0; n < 25; ++n)\n    {\n        // lock\n        while(std::atomic_fetch_sub(&cnt, N+1) != N)\n            std::atomic_fetch_add(&cnt, N+1);\n        // write\n        data.push_back(n);\n        std::cout << \"writer pushed back \" << n << '\\n';\n        // unlock\n        std::atomic_fetch_add(&cnt, N+1);\n        // pause\n        std::this_thread::sleep_for(std::chrono::milliseconds(1));\n    }\n}\n \nint main()\n{\n    std::vector<std::thread> v;\n    for (int n = 0; n < N; ++n) {\n        v.emplace_back(reader, n);\n    }\n    v.emplace_back(writer);\n    for (auto& t : v) {\n        t.join();\n    }\n}",
            "output": "writer pushed back 0\nreader 2 sees 0\nreader 3 sees 0\nreader 1 sees 0\n<...>\nreader 2 sees 24\nreader 4 sees 24\nreader 1 sees 24"
        }
    },
    "atomic_fetch_sub, std::atomic_fetch_sub_explicit": {
        "description": {
            "texte": "Performs atomic subtraction. Atomically subtracts arg from the value pointed to by obj and returns the value obj held previously. The operation is performed as if the following was executed:"
        },
        "parametres": "   obj   -   pointer to the atomic object to modify \n   arg   -   the value to subtract from the value stored in the atomic object \n   order   -   the memory sycnhronization ordering for this operation: all values are permitted. \n\n",
        "exemple": {
            "input": "#include <string>\n#include <thread>\n#include <vector>\n#include <iostream>\n#include <atomic>\n#include <numeric>\n \nconst int N = 50;\nstd::atomic<int> cnt;\nstd::vector<int> data(N);\n \nvoid reader(int id) \n{\n    for (;;) {\n        int idx = atomic_fetch_sub_explicit(&cnt, 1, std::memory_order_relaxed);\n        if (idx >= 0) {\n            std::cout << \"reader \" << std::to_string(id) << \" processed item \"\n                      << std::to_string(data[idx]) << '\\n';\n        } else {\n            std::cout << \"reader \" << std::to_string(id) << \" done\\n\";\n            break;\n        }\n    }\n}\n \nint main()\n{\n    std::iota(data.begin(), data.end(), 1);\n    cnt = data.size() - 1;\n \n    std::vector<std::thread> v;\n    for (int n = 0; n < 5; ++n) {\n        v.emplace_back(reader, n);\n    }\n    for (auto& t : v) {\n        t.join();\n    }\n}",
            "output": "reader 2 processed item 50\nreader 1 processed item 44\nreader 4 processed item 46\n<....>\nreader 0 done\nreader 4 done\nreader 3 done"
        }
    },
    "atomic_fetch_and, std::atomic_fetch_and_explicit": {
        "description": {
            "texte": "Atomically replaces the value pointed by obj with the result of bitwise AND between the old value of obj and arg. Returns the value obj held previously.The operation is performed as if the following is executed:If std::atomic<T> has no fetch_and member (this member is only provided for integral types), the program is ill-formed."
        },
        "parametres": "   obj   -   pointer to the atomic object to modify. bool is not an Integral type for the purposes of the atomic operations. \n   arg   -   the value to bitwise AND to the value stored in the atomic object \n   order   -   the memory synchronization ordering for this operation: all values are permitted. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <atomic>\n#include <thread>\n#include <chrono>\n#include <functional>\n \n// Binary semaphore for demonstrative purposes only\n// This is a simple yet meaningful example: atomic operations\n// are unnecessary without threads. \nclass Semaphore {\n    std::atomic_char m_signaled;\n  public:\n    Semaphore(bool initial = false)\n    {\n        m_signaled = initial;\n    }\n    // Block until semaphore is signaled\n    void take() \n    {\n        while (!std::atomic_fetch_and(&m_signaled, false)) {\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n \n    void put() \n    {\n        std::atomic_fetch_or(&m_signaled, true);\n    }\n};\n \nclass ThreadedCounter {\n    static const int N = 100;\n    static const int REPORT_INTERVAL = 10;\n    int m_count;\n    bool m_done;\n    Semaphore m_count_sem;\n    Semaphore m_print_sem;\n \n    void count_up() \n    {\n        for (m_count = 1; m_count <= N; m_count++) {\n            if (m_count % REPORT_INTERVAL == 0) {\n                if (m_count == N) m_done = true;\n                m_print_sem.put(); // signal printing to occur\n                m_count_sem.take(); // wait until printing is complete proceeding\n            }\n        }\n        std::cout << \"count_up() done\\n\";\n        m_done = true;\n        m_print_sem.put();\n    }\n \n    void print_count() \n    {\n        do {\n            m_print_sem.take();\n            std::cout << m_count << '\\n';\n            m_count_sem.put();\n        } while (!m_done);\n        std::cout << \"print_count() done\\n\";\n    }\n \n  public:\n    ThreadedCounter() : m_done(false) {}\n    void run() \n    {\n        auto print_thread = std::thread(&ThreadedCounter::print_count, this);\n        auto count_thread = std::thread(&ThreadedCounter::count_up, this);\n        print_thread.join();\n        count_thread.join();\n    }\n};\n \nint main() \n{\n    ThreadedCounter m_counter;\n    m_counter.run();\n}",
            "output": "10\n20\n30\n40\n50\n60\n70\n80\n90\n100\nprint_count() done\ncount_up() done"
        }
    },
    "atomic_fetch_or, std::atomic_fetch_or_explicit": {
        "description": {
            "texte": "Atomically replaces the value pointed by obj with the result of bitwise OR between the old value of obj and arg. Returns the value obj held previously.The operation is performed as if the following is executed:If std::atomic<T> has no fetch_xor member (this member is only provided for integral types), the program is ill-formed."
        },
        "parametres": "   obj   -   pointer to the atomic object to modify \n   arg   -   the value to bitwise OR to the value stored in the atomic object \n   order   -   the memory synchronization ordering for this operation: all values are permitted. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <atomic>\n#include <thread>\n#include <chrono>\n#include <functional>\n \n// Binary semaphore for demonstrative purposes only\n// This is a simple yet meaningful example: atomic operations\n// are unnecessary without threads. \nclass Semaphore {\n    std::atomic_char m_signaled;\n  public:\n    Semaphore(bool initial = false)\n    {\n        m_signaled = initial;\n    }\n    // Block until semaphore is signaled\n    void take() \n    {\n        while (!std::atomic_fetch_and(&m_signaled, false)) {\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n \n    void put() \n    {\n        std::atomic_fetch_or(&m_signaled, true);\n    }\n};\n \nclass ThreadedCounter {\n    static const int N = 100;\n    static const int REPORT_INTERVAL = 10;\n    int m_count;\n    bool m_done;\n    Semaphore m_count_sem;\n    Semaphore m_print_sem;\n \n    void count_up() \n    {\n        for (m_count = 1; m_count <= N; m_count++) {\n            if (m_count % REPORT_INTERVAL == 0) {\n                if (m_count == N) m_done = true;\n                m_print_sem.put(); // signal printing to occur\n                m_count_sem.take(); // wait until printing is complete proceeding\n            }\n        }\n        std::cout << \"count_up() done\\n\";\n        m_done = true;\n        m_print_sem.put();\n    }\n \n    void print_count() \n    {\n        do {\n            m_print_sem.take();\n            std::cout << m_count << '\\n';\n            m_count_sem.put();\n        } while (!m_done);\n        std::cout << \"print_count() done\\n\";\n    }\n \n  public:\n    ThreadedCounter() : m_done(false) {}\n    void run() \n    {\n        auto print_thread = std::thread(&ThreadedCounter::print_count, this);\n        auto count_thread = std::thread(&ThreadedCounter::count_up, this);\n        print_thread.join();\n        count_thread.join();\n    }\n};\n \nint main() \n{\n    ThreadedCounter m_counter;\n    m_counter.run();\n}",
            "output": "10\n20\n30\n40\n50\n60\n70\n80\n90\n100\nprint_count() done\ncount_up() done"
        }
    },
    "atomic_fetch_xor, std::atomic_fetch_xor_explicit": {
        "description": {
            "texte": " Atomically replaces the value pointed by obj with the result of bitwise XOR between the old value of obj and arg. Returns the value obj held previously.The operation is performed as if the following is executed:If std::atomic<T> has no fetch_xor member (this member is only provided for integral types), the program is ill-formed."
        },
        "parametres": "   obj   -   pointer to the atomic object to modify \n   arg   -   the value to bitwise XOR to the value stored in the atomic object \n   order   -   the memory synchronization ordering for this operation: all values are permitted. \n\n"
    },
    "\nstd::atomic_is_lock_free, ATOMIC_xxx_LOCK_FREE": {
        "description": {
            "texte": "true if *obj is a lock-free atomic, false otherwise."
        },
        "parametres": "   obj   -   pointer to the atomic object to examine \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <utility>\n#include <atomic>\n \nstruct A { int a[100]; };\nstruct B { int x, y; };\nint main()\n{\n    std::atomic<A> a;\n    std::atomic<B> b;\n    std::cout << std::boolalpha\n              << \"std::atomic<A> is lock free? \"\n              << std::atomic_is_lock_free(&a) << '\\n'\n              << \"std::atomic<B> is lock free? \"\n              << std::atomic_is_lock_free(&b) << '\\n';\n}",
            "output": "std::atomic<A> is lock free? false\nstd::atomic<B> is lock free? true"
        }
    },
    "atomic_flag": {
        "description": {
            "texte": "std::atomic_flag is an atomic boolean type. Unlike all specializations of std::atomic, it is guaranteed to be lock-free. Unlike std::atomic<bool>, std::atomic_flag does not provide load or store operations."
        },
        "exemple": {
            "input": "#include <thread>\n#include <vector>\n#include <iostream>\n#include <atomic>\n \nstd::atomic_flag lock = ATOMIC_FLAG_INIT;\n \nvoid f(int n)\n{\n    for (int cnt = 0; cnt < 100; ++cnt) {\n        while (lock.test_and_set(std::memory_order_acquire))  // acquire lock\n             ; // spin\n        std::cout << \"Output from thread \" << n << '\\n';\n        lock.clear(std::memory_order_release);               // release lock\n    }\n}\n \nint main()\n{\n    std::vector<std::thread> v;\n    for (int n = 0; n < 10; ++n) {\n        v.emplace_back(f, n);\n    }\n    for (auto& t : v) {\n        t.join();\n    }\n}",
            "output": "Output from thread 2\nOutput from thread 6\nOutput from thread 7\n...<exactly 1000 lines>..."
        }
    },
    "atomic_flag_test_and_set, std::atomic_flag_test_and_set_explicit": {
        "description": {
            "texte": "Atomically changes the state of a std::atomic_flag pointed to by p to set (true) and returns the value it held before."
        },
        "parametres": "   p   -   pointer to std::atomic_flag to access \n   order   -   the memory synchronization order for this operation \n\n",
        "exemple": {
            "input": "#include <thread>\n#include <vector>\n#include <iostream>\n#include <atomic>\n \nstd::atomic_flag lock = ATOMIC_FLAG_INIT;\n \nvoid f(int n)\n{\n    for (int cnt = 0; cnt < 100; ++cnt) {\n        while(std::atomic_flag_test_and_set_explicit(&lock, std::memory_order_acquire))\n             ; // spin until the lock is acquired\n        std::cout << \"Output from thread \" << n << '\\n';\n        std::atomic_flag_clear_explicit(&lock, std::memory_order_release);\n    }\n}\n \nint main()\n{\n    std::vector<std::thread> v;\n    for (int n = 0; n < 10; ++n) {\n        v.emplace_back(f, n);\n    }\n    for (auto& t : v) {\n        t.join();\n    }\n}",
            "output": "Output from thread 2\nOutput from thread 6\nOutput from thread 7\n...<exactly 1000 lines>..."
        }
    },
    "atomic_flag_clear, std::atomic_flag_clear_explicit": {
        "description": {
            "texte": "Atomically changes the state of a std::atomic_flag pointed to by p to clear (false)."
        },
        "parametres": "   p   -   pointer to std::atomic_flag to access \n   order   -   the memory synchronization ordering for this operation: only std::memory_order_relaxed, std::memory_order_release, or std::memory_order_seq_cst are permitted. \n\n"
    },
    "atomic_init": {
        "description": {
            "texte": "Initializes the default-constructed atomic object obj with the value desired. The function is not atomic: concurrent access from another thread, even through an atomic operation, is a data race.If obj was not default-constructed, the behavior is undefined.If this function is called twice on the same obj, the behavior is undefined."
        },
        "parametres": "   obj   -   pointer to an atomic object to initialize \n   desired   -   the value to initialize atomic object with \n\n"
    },
    "ATOMIC_VAR_INIT": {
        "description": {
            "texte": "Expands to an expression which can be used to initialize an std::atomic object that can be initialized from value. If the atomic object has static storage duration, this initialization is constant initialization."
        },
        "exemple": {
            "input": "#include <atomic>\n#include <iostream>\n \nint main()\n{\n    std::atomic<int> a = ATOMIC_VAR_INIT(1);\n    // std::atomic<int> a(1);   // C++-only alternative\n    std::cout << \"Initialized std::atomic<int> as: \" << a << '\\n';\n}",
            "output": "Initialized std::atomic<int> as: 1"
        }
    },
    "ATOMIC_FLAG_INIT": {
        "description": {
            "texte": "Defines the expression which can be used to initialize std::atomic_flag to clear (false) state with the statement std::atomic_flag v = ATOMIC_FLAG_INIT;. It is unspecified if it can be used with other initialization contexts.If the flag has static storage duration, this initialization is static.This is the only way to initialize std::atomic_flag to a definite value: the value held after any other initialization is unspecified."
        },
        "exemple": {
            "input": "#include <atomic>\n \nstd::atomic_flag static_flag = ATOMIC_FLAG_INIT; // static initialization,\n// guaranteed to be available during dynamic initialization of static objects.\n \nint main()\n{\n    std::atomic_flag automatic_flag = ATOMIC_FLAG_INIT; // guaranteed to work\n//    std::atomic_flag another_flag(ATOMIC_FLAG_INIT); // unspecified\n}"
        }
    },
    "memory_order": {
        "description": {
            "texte": "std::memory_order specifies how memory accesses, including regular, non-atomic memory accesses, are to be ordered around an atomic operation. Absent any constraints on a multi-core system, when multiple threads simultaneously read and write to several variables, one thread can observe the values change in an order different from the order another thread wrote them. Indeed, the apparent order of changes can even differ among multiple reader threads. Some similar effects can occur even on uniprocessor systems due to compiler transformations allowed by the memory model.The default behavior of all atomic operations in the library provides for sequentially consistent ordering (see discussion below). That default can hurt performance, but the library's atomic operations can be given an additional std::memory_order argument to specify the exact constraints, beyond atomicity, that the compiler and processor must enforce for that operation."
        },
        "exemple": {
            "input": "#include <vector>\n#include <iostream>\n#include <thread>\n#include <atomic>\n \nstd::atomic<int> cnt = {0};\n \nvoid f()\n{\n    for (int n = 0; n < 1000; ++n) {\n        cnt.fetch_add(1, std::memory_order_relaxed);\n    }\n}\n \nint main()\n{\n    std::vector<std::thread> v;\n    for (int n = 0; n < 10; ++n) {\n        v.emplace_back(f);\n    }\n    for (auto& t : v) {\n        t.join();\n    }\n    std::cout << \"Final counter value is \" << cnt << '\\n';\n}",
            "output": "Final counter value is 10000"
        }
    },
    "kill_dependency": {
        "description": {
            "texte": "Informs the compiler that the dependency tree started by an std::memory_order_consume atomic load operation does not extend past the return value of std::kill_dependency; that is, the argument does not carry a dependency into the return value.This may be used to avoid unnecessary std::memory_order_acquire fences when the dependency chain leaves function scope (and the function does not have the [[carries_dependency]] attribute)."
        },
        "parametres": "   y   -   the expression whose return value is to be removed from a dependency tree \n\n"
    },
    "atomic_thread_fence": {
        "description": {
            "texte": "Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by order, without an associated atomic operation.A release fence F in thread A synchronizes-with atomic acquire operation Y in thread B, if.In this case, all non-atomic and relaxed atomic stores that are sequenced-before F in thread A will happen-before all non-atomic and relaxed atomic loads from the same locations made in thread B after Y.An atomic release operation X in thread A synchronizes-with an acquire fence F in thread B, if.In this case, all non-atomic and relaxed atomic stores that are sequenced-before X in thread A will happen-before all non-atomic and relaxed atomic loads from the same locations made in thread B after F.A release fence FA in thread A synchronizes-with an acquire fence FB in thread B, if.In this case, all non-atomic and relaxed atomic stores that are sequenced-before FA in thread A will happen-before all non-atomic and relaxed atomic loads from the same locations made in thread B after FB."
        },
        "parametres": "   order   -   the memory ordering executed by this fence \n\n",
        "exemple": {
            "input": "const int num_mailboxes = 32;\nstd::atomic<int> mailbox_receiver[num_mailboxes];\nstd::string mailbox_data[num_mailboxes];\n \n// The writer threads update non-atomic shared data \n// and then update mailbox_receiver[i] as follows\nmailbox_data[i] = ...;\nstd::atomic_store_explicit(&mailbox_receiver[i], receiver_id, std::memory_order_release);\n \n// Reader thread needs to check all mailbox[i], but only needs to sync with one\nfor (int i = 0; i < num_mailboxes; ++i) {\n    if (std::atomic_load_explicit(&mailbox_receiver[i], std::memory_order_relaxed) == my_id) {\n        std::atomic_thread_fence(std::memory_order_acquire); // synchronize with just one writer\n        do_work( mailbox_data[i] ); // guaranteed to observe everything done in the writer thread before\n                    // the atomic_store_explicit()\n    }\n }"
        }
    },
    "atomic_signal_fence": {
        "description": {
            "texte": "Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by order, between a thread and a signal handler executed on the same thread. This is equivalent to std::atomic_thread_fence, except no CPU instructions for memory ordering are issued. Only reordering of the instructions by the compiler is suppressed as order instructs. For example, a fence with release semantics prevents reads or writes from being moved past subsequent writes and a fence with acquire semantics prevents reads or writes from being moved ahead of preceding reads."
        },
        "parametres": "   order   -   the memory ordering executed by this fence \n\n"
    },
    "hardware_destructive_interference_size, std::hardware_constructive_interference_size": {
        "description": {
            "texte": "These constants provide a portable way to access the L1 data cache line size."
        }
    },
    "this_thread::get_id": {
        "description": {
            "texte": "Returns the id of the current thread."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <thread>\n#include <chrono>\n#include <mutex>\n \nstd::mutex g_display_mutex;\n \nvoid foo()\n{\n    std::thread::id this_id = std::this_thread::get_id();\n \n    g_display_mutex.lock();\n    std::cout << \"thread \" << this_id << \" sleeping...\\n\";\n    g_display_mutex.unlock();\n \n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nint main()\n{\n    std::thread t1(foo);\n    std::thread t2(foo);\n \n    t1.join();\n    t2.join();\n}",
            "output": "thread 0x2384b312 sleeping...\nthread 0x228a10fc sleeping..."
        }
    },
    "this_thread::yield": {
        "description": {
            "texte": "Provides a hint to the implementation to reschedule the execution of threads, allowing other threads to run."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n#include <thread>\n \n// \"busy sleep\" while suggesting that other threads run \n// for a small amount of time\nvoid little_sleep(std::chrono::microseconds us)\n{\n    auto start = std::chrono::high_resolution_clock::now();\n    auto end = start + us;\n    do {\n        std::this_thread::yield();\n    } while (std::chrono::high_resolution_clock::now() < end);\n}\n \nint main()\n{\n    auto start = std::chrono::high_resolution_clock::now();\n \n    little_sleep(std::chrono::microseconds(100));\n \n    auto elapsed = std::chrono::high_resolution_clock::now() - start;\n    std::cout << \"waited for \"\n              << std::chrono::duration_cast<std::chrono::microseconds>(elapsed).count()\n              << \" microseconds\\n\";\n}",
            "output": "waited for 128 microseconds"
        }
    },
    "this_thread::sleep_for": {
        "description": {
            "texte": "Blocks the execution of the current thread for at least the specified sleep_duration.This function may block for longer than sleep_duration due to scheduling or resource contention delays.The standard recommends that a steady clock is used to measure the duration. If an implementation uses a system clock instead, the wait time may also be sensitive to clock adjustments."
        },
        "parametres": "   sleep_duration   -   time duration to sleep \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n#include <thread>\n \nint main()\n{\n    using namespace std::chrono_literals;\n    std::cout << \"Hello waiter\\n\" << std::flush;\n    auto start = std::chrono::high_resolution_clock::now();\n    std::this_thread::sleep_for(2s);\n    auto end = std::chrono::high_resolution_clock::now();\n    std::chrono::duration<double, std::milli> elapsed = end-start;\n    std::cout << \"Waited \" << elapsed.count() << \" ms\\n\";\n}",
            "output": "Hello waiter\nWaited 2000.12 ms"
        }
    },
    "this_thread::sleep_until": {
        "description": {
            "texte": "Blocks the execution of the current thread until specified sleep_time has been reached.The clock tied to sleep_time is used, which means that adjustments of the clock are taken into account. Thus, the duration of the block might, but might not, be less or more than sleep_time - Clock::now() at the time of the call, depending on the direction of the adjustment. The function also may block for longer than until after sleep_time has been reached due to scheduling or resource contention delays."
        },
        "parametres": "   sleep_time   -   time to block until \n\n"
    },
    "mutex": {
        "description": {
            "texte": "The mutex class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads.mutex offers exclusive, non-recursive ownership semantics:The behavior of a program is undefined if a mutex is destroyed while still owned by any threads, or a thread terminates while owning a mutex. The mutex class satisfies all requirements of Mutex and StandardLayoutType.std::mutex is neither copyable nor movable."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <map>\n#include <string>\n#include <chrono>\n#include <thread>\n#include <mutex>\n \nstd::map<std::string, std::string> g_pages;\nstd::mutex g_pages_mutex;\n \nvoid save_page(const std::string &url)\n{\n    // simulate a long page fetch\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n    std::string result = \"fake content\";\n \n    std::lock_guard<std::mutex> guard(g_pages_mutex);\n    g_pages[url] = result;\n}\n \nint main() \n{\n    std::thread t1(save_page, \"http://foo\");\n    std::thread t2(save_page, \"http://bar\");\n    t1.join();\n    t2.join();\n \n    // safe to access g_pages without lock now, as the threads are joined\n    for (const auto &pair : g_pages) {\n        std::cout << pair.first << \" => \" << pair.second << '\\n';\n    }\n}",
            "output": "http://bar => fake content\nhttp://foo => fake content"
        }
    },
    "recursive_mutex": {
        "description": {
            "texte": "The recursive_mutex class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads.recursive_mutex offers exclusive, recursive ownership semantics:The behavior of a program is undefined if a recursive_mutex is destroyed while still owned by some thread. The recursive_mutex class satisfies all requirements of Mutex and StandardLayoutType."
        }
    },
    "shared_mutex": {
        "description": {
            "texte": "The shared_mutex class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads. In contrast to other mutex types which facilitate exclusive access, a shared_mutex has two levels of access:Shared mutexes are usually used in situations when multiple readers can access the same resource at the same time without causing data races, but only one writer can do so.The shared_mutex class satisfies all requirements of SharedMutex and StandardLayoutType."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <mutex>  // For std::unique_lock\n#include <shared_mutex>\n#include <thread>\n \nclass ThreadSafeCounter {\n public:\n  ThreadSafeCounter() = default;\n \n  // Multiple threads/readers can read the counter's value at the same time.\n  unsigned int get() const {\n    std::shared_lock lock(mutex_);\n    return value_;\n  }\n \n  // Only one thread/writer can increment/write the counter's value.\n  void increment() {\n    std::unique_lock lock(mutex_);\n    value_++;\n  }\n \n  // Only one thread/writer can reset/write the counter's value.\n  void reset() {\n    std::unique_lock lock(mutex_);\n    value_ = 0;\n  }\n \n private:\n  mutable std::shared_mutex mutex_;\n  unsigned int value_ = 0;\n};\n \nint main() {\n  ThreadSafeCounter counter;\n \n  auto increment_and_print = [&counter]() {\n    for (int i = 0; i < 3; i++) {\n      counter.increment();\n      std::cout << std::this_thread::get_id() << ' ' << counter.get() << '\\n';\n \n      // Note: Writing to std::cout actually needs to be synchronized as well\n      // by another std::mutex. This has been omitted to keep the example small.\n    }\n  };\n \n  std::thread thread1(increment_and_print);\n  std::thread thread2(increment_and_print);\n \n  thread1.join();\n  thread2.join();\n}\n \n// Explanation: The output below was generated on a single-core machine. When\n// thread1 starts, it enters the loop for the first time and calls increment()\n// followed by get(). However, before it can print the returned value to\n// std::cout, the scheduler puts thread1 to sleep and wakes up thread2, which\n// obviously has time enough to run all three loop iterations at once. Back to\n// thread1, still in the first loop iteration, it finally prints its local copy\n// of the counter's value, which is 1, to std::cout and then runs the remaining\n// two loop iterations. On a multi-core machine, none of the threads is put to\n// sleep and the output is more likely to be in ascending order.",
            "output": "123084176803584 2\n123084176803584 3\n123084176803584 4\n123084185655040 1\n123084185655040 5\n123084185655040 6"
        }
    },
    "timed_mutex": {
        "description": {
            "texte": "The timed_mutex class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads.In a manner similar to mutex, timed_mutex offers exclusive, non-recursive ownership semantics. In addition, timed_mutex provides the ability to attempt to claim ownership of a timed_mutex with a timeout via the try_lock_for() and try_lock_until() methods.The timed_mutex class satisfies all requirements of TimedMutex and StandardLayoutType."
        }
    },
    "recursive_timed_mutex": {
        "description": {
            "texte": "The recursive_timed_mutex class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads.In a manner similar to std::recursive_mutex, recursive_timed_mutex provides exclusive, recursive ownership semantics. In addition, recursive_timed_mutex provides the ability to attempt to claim ownership of a recursive_timed_mutex with a timeout via the try_lock_for and try_lock_until methods.The recursive_timed_mutex class satisfies all requirements of TimedMutex and StandardLayoutType."
        }
    },
    "shared_timed_mutex": {
        "description": {
            "texte": "The shared_timed_mutex class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads. In contrast to other mutex types which facilitate exclusive access, a shared_timed_mutex has two levels of access:Shared mutexes are usually used in situations when multiple readers can access the same resource at the same time without causing data races, but only one writer can do so.In a manner similar to timed_mutex, shared_timed_mutex provides the ability to attempt to claim ownership of a shared_timed_mutex with a timeout via the try_lock_for(), try_lock_until(), try_lock_shared_for(), try_lock_shared_until() methods.The shared_timed_mutex class satisfies all requirements of SharedTimedMutex and StandardLayoutType."
        },
        "exemple": {
            "input": "#include <mutex>\n#include <shared_mutex>\n \nclass R\n{\n    mutable std::shared_timed_mutex mut;\n    /* data */\npublic:\n    R& operator=(const R& other)\n    {\n        // requires exclusive ownership to write to *this\n        std::unique_lock<std::shared_timed_mutex> lhs(mut, std::defer_lock);\n        // requires shared ownership to read from other\n        std::shared_lock<std::shared_timed_mutex> rhs(other.mut, std::defer_lock);\n        std::lock(lhs, rhs);\n        /* assign data */\n        return *this;\n    }\n};\n \nint main() {\n    R r;\n}"
        }
    },
    "lock_guard": {
        "description": {
            "texte": "The class lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a mutex for the duration of a scoped block.When a lock_guard object is created, it attempts to take ownership of the mutex it is given. When control leaves the scope in which the lock_guard object was created, the lock_guard is destructed and the mutex is released.The lock_guard class is non-copyable."
        },
        "exemple": {
            "input": "#include <thread>\n#include <mutex>\n#include <iostream>\n \nint g_i = 0;\nstd::mutex g_i_mutex;  // protects g_i\n \nvoid safe_increment()\n{\n    std::lock_guard<std::mutex> lock(g_i_mutex);\n    ++g_i;\n \n    std::cout << std::this_thread::get_id() << \": \" << g_i << '\\n';\n \n    // g_i_mutex is automatically released when lock\n    // goes out of scope\n}\n \nint main()\n{\n    std::cout << \"main: \" << g_i << '\\n';\n \n    std::thread t1(safe_increment);\n    std::thread t2(safe_increment);\n \n    t1.join();\n    t2.join();\n \n    std::cout << \"main: \" << g_i << '\\n';\n}",
            "output": "main: 0\n140641306900224: 1\n140641298507520: 2\nmain: 2"
        }
    },
    "scoped_lock": {
        "description": {
            "texte": "The class scoped_lock is a mutex wrapper that provides a convenient RAII-style mechanism for owning one or more mutexes for the duration of a scoped block.When a scoped_lock object is created, it attempts to take ownership of the mutexes it is given. When control leaves the scope in which the scoped_lock object was created, the scoped_lock is destructed and the mutexes are released, in reverse order. If several mutexes are given, deadlock avoidance algorithm is used as if by std::lock.The scoped_lock class is non-copyable."
        },
        "exemple": {
            "input": "#include <mutex>\n#include <thread>\n#include <iostream>\n#include <vector>\n#include <functional>\n#include <chrono>\n#include <string>\n \nstruct Employee {\n    Employee(std::string id) : id(id) {}\n    std::string id;\n    std::vector<std::string> lunch_partners;\n    std::mutex m;\n    std::string output() const\n    {\n        std::string ret = \"Employee \" + id + \" has lunch partners: \";\n        for( const auto& partner : lunch_partners )\n            ret += partner + \" \";\n        return ret;\n    }\n};\n \nvoid send_mail(Employee &, Employee &)\n{\n    // simulate a time-consuming messaging operation\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nvoid assign_lunch_partner(Employee &e1, Employee &e2)\n{\n    static std::mutex io_mutex;\n    {\n        std::lock_guard<std::mutex> lk(io_mutex);\n        std::cout << e1.id << \" and \" << e2.id << \" are waiting for locks\" << std::endl;\n    }\n \n    {\n        // use std::scoped_lock to acquire two locks without worrying about \n        // other calls to assign_lunch_partner deadlocking us\n        // and it also provides a convenient RAII-style mechanism\n \n        std::scoped_lock lock(e1.m, e2.m);\n \n        // Equivalent code 1 (using std::lock and std::lock_guard)\n        // std::lock(e1.m, e2.m);\n        // std::lock_guard<std::mutex> lk1(e1.m, std::adopt_lock);\n        // std::lock_guard<std::mutex> lk2(e2.m, std::adopt_lock);\n \n        // Equivalent code 2 (if unique_locks are needed, e.g. for condition variables)\n        // std::unique_lock<std::mutex> lk1(e1.m, std::defer_lock);\n        // std::unique_lock<std::mutex> lk2(e2.m, std::defer_lock);\n        // std::lock(lk1, lk2);\n        {\n            std::lock_guard<std::mutex> lk(io_mutex);\n            std::cout << e1.id << \" and \" << e2.id << \" got locks\" << std::endl;\n        }\n        e1.lunch_partners.push_back(e2.id);\n        e2.lunch_partners.push_back(e1.id);\n    }\n \n    send_mail(e1, e2);\n    send_mail(e2, e1);\n}\n \nint main()\n{\n    Employee alice(\"alice\"), bob(\"bob\"), christina(\"christina\"), dave(\"dave\");\n \n    // assign in parallel threads because mailing users about lunch assignments\n    // takes a long time\n    std::vector<std::thread> threads;\n    threads.emplace_back(assign_lunch_partner, std::ref(alice), std::ref(bob));\n    threads.emplace_back(assign_lunch_partner, std::ref(christina), std::ref(bob));\n    threads.emplace_back(assign_lunch_partner, std::ref(christina), std::ref(alice));\n    threads.emplace_back(assign_lunch_partner, std::ref(dave), std::ref(bob));\n \n    for (auto &thread : threads) thread.join();\n    std::cout << alice.output() << '\\n'  << bob.output() << '\\n'\n              << christina.output() << '\\n' << dave.output() << '\\n';\n}",
            "output": "alice and bob are waiting for locks\nalice and bob got locks\nchristina and bob are waiting for locks\nchristina and alice are waiting for locks\ndave and bob are waiting for locks\ndave and bob got locks\nchristina and alice got locks\nchristina and bob got locks\nEmployee alice has lunch partners: bob christina \nEmployee bob has lunch partners: alice dave christina \nEmployee christina has lunch partners: alice bob \nEmployee dave has lunch partners: bob"
        }
    },
    "unique_lock": {
        "description": {
            "texte": "The class unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking, time-constrained attempts at locking, recursive locking, transfer of lock ownership, and use with condition variables.The class unique_lock is movable, but not copyable -- it meets the requirements of MoveConstructible and MoveAssignable but not of CopyConstructible or CopyAssignable.The class unique_lock meets the BasicLockable requirements. If Mutex meets the Lockable requirements, unique_lock also meets the Lockable requirements (ex.: can be used in std::lock); if Mutex meets the TimedLockable requirements, unique_lock also meets the TimedLockable requirements."
        },
        "exemple": {
            "input": "#include <mutex>\n#include <thread>\n#include <chrono>\n \nstruct Box {\n    explicit Box(int num) : num_things{num} {}\n \n    int num_things;\n    std::mutex m;\n};\n \nvoid transfer(Box &from, Box &to, int num)\n{\n    // don't actually take the locks yet\n    std::unique_lock<std::mutex> lock1(from.m, std::defer_lock);\n    std::unique_lock<std::mutex> lock2(to.m, std::defer_lock);\n \n    // lock both unique_locks without deadlock\n    std::lock(lock1, lock2);\n \n    from.num_things -= num;\n    to.num_things += num;\n \n    // 'from.m' and 'to.m' mutexes unlocked in 'unique_lock' dtors\n}\n \nint main()\n{\n    Box acc1(100);\n    Box acc2(50);\n \n    std::thread t1(transfer, std::ref(acc1), std::ref(acc2), 10);\n    std::thread t2(transfer, std::ref(acc2), std::ref(acc1), 5);\n \n    t1.join();\n    t2.join();\n}"
        }
    },
    "shared_lock": {
        "description": {
            "texte": "The class shared_lock is a general-purpose shared mutex ownership wrapper allowing deferred locking, timed locking and transfer of lock ownership. Locking a shared_lock locks the associated shared mutex in shared mode (to lock it in exclusive mode, std::unique_lock can be used).The shared_lock class is movable, but not copyable -- it meets the requirements of MoveConstructible and MoveAssignable but not of CopyConstructible or CopyAssignable.In order to wait in a shared mutex in shared ownership mode, std::condition_variable_any can be used (std::condition_variable requires std::unique_lock and so can only wait in unique ownership mode)."
        }
    },
    "defer_lock_t, std::try_to_lock_t, std::adopt_lock_t": {
        "description": {
            "texte": "std::defer_lock_t, std::try_to_lock_t and std::adopt_lock_t are empty struct tag types used to specify locking strategy for std::lock_guard, std::scoped_lock, std::unique_lock, and std::shared_lock."
        },
        "exemple": {
            "input": "#include <mutex>\n#include <thread>\n \nstruct bank_account {\n    explicit bank_account(int balance) : balance(balance) {}\n    int balance;\n    std::mutex m;\n};\n \nvoid transfer(bank_account &from, bank_account &to, int amount)\n{\n    // lock both mutexes without deadlock\n    std::lock(from.m, to.m);\n    // make sure both already-locked mutexes are unlocked at the end of scope\n    std::lock_guard<std::mutex> lock1(from.m, std::adopt_lock);\n    std::lock_guard<std::mutex> lock2(to.m, std::adopt_lock);\n \n// equivalent approach:\n//    std::unique_lock<std::mutex> lock1(from.m, std::defer_lock);\n//    std::unique_lock<std::mutex> lock2(to.m, std::defer_lock);\n//    std::lock(lock1, lock2);\n \n    from.balance -= amount;\n    to.balance += amount;\n}\n \nint main()\n{\n    bank_account my_account(100);\n    bank_account your_account(50);\n \n    std::thread t1(transfer, std::ref(my_account), std::ref(your_account), 10);\n    std::thread t2(transfer, std::ref(your_account), std::ref(my_account), 5);\n \n    t1.join();\n    t2.join();\n}"
        }
    },
    "lock": {
        "description": {
            "texte": "Locks the given Lockable objects lock1, lock2, ..., lockn using a deadlock avoidance algorithm to avoid deadlock.The objects are locked by an unspecified series of calls to lock, try_lock, and unlock. If a call to lock or unlock results in an exception, unlock is called for any locked objects before rethrowing."
        },
        "parametres": "   lock1, lock2, ... , lockn   -   the Lockable objects to lock \n\n",
        "exemple": {
            "input": "#include <mutex>\n#include <thread>\n#include <iostream>\n#include <vector>\n#include <functional>\n#include <chrono>\n#include <string>\n \nstruct Employee {\n    Employee(std::string id) : id(id) {}\n    std::string id;\n    std::vector<std::string> lunch_partners;\n    std::mutex m;\n    std::string output() const\n    {\n        std::string ret = \"Employee \" + id + \" has lunch partners: \";\n        for( const auto& partner : lunch_partners )\n            ret += partner + \" \";\n        return ret;\n    }\n};\n \nvoid send_mail(Employee &, Employee &)\n{\n    // simulate a time-consuming messaging operation\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nvoid assign_lunch_partner(Employee &e1, Employee &e2)\n{\n    static std::mutex io_mutex;\n    {\n        std::lock_guard<std::mutex> lk(io_mutex);\n        std::cout << e1.id << \" and \" << e2.id << \" are waiting for locks\" << std::endl;\n    }\n \n    // use std::lock to acquire two locks without worrying about \n    // other calls to assign_lunch_partner deadlocking us\n    {\n        std::lock(e1.m, e2.m);\n        std::lock_guard<std::mutex> lk1(e1.m, std::adopt_lock);\n        std::lock_guard<std::mutex> lk2(e2.m, std::adopt_lock);\n// Equivalent code (if unique_locks are needed, e.g. for condition variables)\n//        std::unique_lock<std::mutex> lk1(e1.m, std::defer_lock);\n//        std::unique_lock<std::mutex> lk2(e2.m, std::defer_lock);\n//        std::lock(lk1, lk2);\n// Superior solution available in C++17\n//        std::scoped_lock lk(e1.m, e2.m);\n        {\n            std::lock_guard<std::mutex> lk(io_mutex);\n            std::cout << e1.id << \" and \" << e2.id << \" got locks\" << std::endl;\n        }\n        e1.lunch_partners.push_back(e2.id);\n        e2.lunch_partners.push_back(e1.id);\n    }\n    send_mail(e1, e2);\n    send_mail(e2, e1);\n}\n \nint main()\n{\n    Employee alice(\"alice\"), bob(\"bob\"), christina(\"christina\"), dave(\"dave\");\n \n    // assign in parallel threads because mailing users about lunch assignments\n    // takes a long time\n    std::vector<std::thread> threads;\n    threads.emplace_back(assign_lunch_partner, std::ref(alice), std::ref(bob));\n    threads.emplace_back(assign_lunch_partner, std::ref(christina), std::ref(bob));\n    threads.emplace_back(assign_lunch_partner, std::ref(christina), std::ref(alice));\n    threads.emplace_back(assign_lunch_partner, std::ref(dave), std::ref(bob));\n \n    for (auto &thread : threads) thread.join();\n    std::cout << alice.output() << '\\n'  << bob.output() << '\\n'\n              << christina.output() << '\\n' << dave.output() << '\\n';\n}",
            "output": "alice and bob are waiting for locks\nalice and bob got locks\nchristina and bob are waiting for locks\nchristina and bob got locks\nchristina and alice are waiting for locks\nchristina and alice got locks\ndave and bob are waiting for locks\ndave and bob got locks\nEmployee alice has lunch partners: bob christina \nEmployee bob has lunch partners: alice christina dave \nEmployee christina has lunch partners: bob alice \nEmployee dave has lunch partners: bob"
        }
    },
    "try_lock": {
        "description": {
            "texte": "Tries to lock each of the given Lockable objects lock1, lock2, ..., lockn by calling try_lock in order beginning with the first.If a call to try_lock fails, no further call to try_lock is performed, unlock is called for any locked objects and a 0-based index of the object that failed to lock is returned.If a call to try_lock results in an exception, unlock is called for any locked objects before rethrowing."
        },
        "parametres": "   lock1, lock2, ... , lockn   -   the Lockable objects to lock \n\n",
        "exemple": {
            "input": "#include <mutex>\n#include <vector>\n#include <thread>\n#include <iostream>\n#include <functional>\n#include <chrono>\n \nint main()\n{\n    int foo_count = 0;\n    std::mutex foo_count_mutex;\n    int bar_count = 0;\n    std::mutex bar_count_mutex;\n    int overall_count = 0;\n    bool done = false;\n    std::mutex done_mutex;\n \n    auto increment = [](int &counter, std::mutex &m,  const char *desc) {\n        for (int i = 0; i < 10; ++i) {\n            std::unique_lock<std::mutex> lock(m);\n            ++counter;\n            std::cout << desc << \": \" << counter << '\\n';\n            lock.unlock();\n            std::this_thread::sleep_for(std::chrono::seconds(1));\n        }\n    };\n \n    std::thread increment_foo(increment, std::ref(foo_count), \n        std::ref(foo_count_mutex), \"foo\");\n    std::thread increment_bar(increment, std::ref(bar_count), \n        std::ref(bar_count_mutex), \"bar\");\n \n    std::thread update_overall([&]() {\n        done_mutex.lock();\n        while (!done) {\n            done_mutex.unlock();\n            int result = std::try_lock(foo_count_mutex, bar_count_mutex);\n            if (result == -1) {\n                overall_count += foo_count + bar_count;\n                foo_count = 0;\n                bar_count = 0;\n                std::cout << \"overall: \" << overall_count << '\\n';\n                foo_count_mutex.unlock();\n                bar_count_mutex.unlock();\n            }\n            std::this_thread::sleep_for(std::chrono::seconds(2));\n            done_mutex.lock();\n        }\n        done_mutex.unlock();\n    });\n \n    increment_foo.join();\n    increment_bar.join();\n    done_mutex.lock();\n    done = true;\n    done_mutex.unlock();\n    update_overall.join();\n \n    std::cout << \"Done processing\\n\"\n              << \"foo: \" << foo_count << '\\n'\n              << \"bar: \" << bar_count << '\\n'\n              << \"overall: \" << overall_count << '\\n';\n}",
            "output": "bar: 1\nfoo: 1\nfoo: 2\nbar: 2\nfoo: 3\noverall: 5\nbar: 1\nfoo: 1\nbar: 2\nfoo: 2\nbar: 3\noverall: 10\nbar: 1\nfoo: 1\nbar: 2\nfoo: 2\noverall: 14\nbar: 1\nfoo: 1\nbar: 2\noverall: 17\nfoo: 1\nbar: 1\nfoo: 2\noverall: 20\nDone processing\nfoo: 0\nbar: 0\noverall: 20"
        }
    },
    "defer_lock, std::try_to_lock, std::adopt_lock": {
        "description": {
            "texte": "std::defer_lock, std::try_to_lock and std::adopt_lock are instances of empty struct tag types std::defer_lock_t, std::try_to_lock_t and std::adopt_lock_t respectively.They are used to specify locking strategies for std::lock_guard, std::unique_lock and std::shared_lock."
        },
        "exemple": {
            "input": "#include <mutex>\n#include <thread>\n \nstruct bank_account {\n    explicit bank_account(int balance) : balance(balance) {}\n    int balance;\n    std::mutex m;\n};\n \nvoid transfer(bank_account &from, bank_account &to, int amount)\n{\n    // lock both mutexes without deadlock\n    std::lock(from.m, to.m);\n    // make sure both already-locked mutexes are unlocked at the end of scope\n    std::lock_guard<std::mutex> lock1(from.m, std::adopt_lock);\n    std::lock_guard<std::mutex> lock2(to.m, std::adopt_lock);\n \n// equivalent approach:\n//    std::unique_lock<std::mutex> lock1(from.m, std::defer_lock);\n//    std::unique_lock<std::mutex> lock2(to.m, std::defer_lock);\n//    std::lock(lock1, lock2);\n \n    from.balance -= amount;\n    to.balance += amount;\n}\n \nint main()\n{\n    bank_account my_account(100);\n    bank_account your_account(50);\n \n    std::thread t1(transfer, std::ref(my_account), std::ref(your_account), 10);\n    std::thread t2(transfer, std::ref(your_account), std::ref(my_account), 5);\n \n    t1.join();\n    t2.join();\n}"
        }
    },
    "once_flag": {
        "description": {
            "texte": "The class std::once_flag is a helper structure for std::call_once.An object of type std::once_flag that is passed to multiple calls to std::call_once allows those calls to coordinate with each other such that only one of the calls will actually run to completion.std::once_flag is neither copyable nor movable."
        }
    },
    "call_once": {
        "description": {
            "texte": "Executes the Callable object f exactly once, even if called concurrently, from several threads.In detail:All active calls on the same flag form a single total order consisting of zero or more exceptional calls, followed by one returning call. The end of each active call synchronizes-with the next active call in that order.The return from the returning call synchronizes-with the returns from all passive calls on the same flag: this means that all concurrent calls to call_once are guaranteed to observe any side-effects made by the active call, with no additional synchronization."
        },
        "parametres": "   flag   -   an object, for which exactly one function gets executed \n   f   -   Callable object to invoke \n   args...   -   arguments to pass to the function \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <thread>\n#include <mutex>\n \nstd::once_flag flag1, flag2;\n \nvoid simple_do_once()\n{\n    std::call_once(flag1, [](){ std::cout << \"Simple example: called once\\n\"; });\n}\n \nvoid may_throw_function(bool do_throw)\n{\n  if (do_throw) {\n    std::cout << \"throw: call_once will retry\\n\"; // this may appear more than once\n    throw std::exception();\n  }\n  std::cout << \"Didn't throw, call_once will not attempt again\\n\"; // guaranteed once\n}\n \nvoid do_once(bool do_throw)\n{\n  try {\n    std::call_once(flag2, may_throw_function, do_throw);\n  }\n  catch (...) {\n  }\n}\n \nint main()\n{\n    std::thread st1(simple_do_once);\n    std::thread st2(simple_do_once);\n    std::thread st3(simple_do_once);\n    std::thread st4(simple_do_once);\n    st1.join();\n    st2.join();\n    st3.join();\n    st4.join();\n \n    std::thread t1(do_once, true);\n    std::thread t2(do_once, true);\n    std::thread t3(do_once, false);\n    std::thread t4(do_once, true);\n    t1.join();\n    t2.join();\n    t3.join();\n    t4.join();\n}",
            "output": "Simple example: called once\nthrow: call_once will retry\nthrow: call_once will retry\nDidn't throw, call_once will not attempt again"
        }
    },
    "condition_variable": {
        "description": {
            "texte": "The condition_variable class is a synchronization primitive that can be used to block a thread, or multiple threads at the same time, until another thread both modifies a shared variable (the condition), and notifies the condition_variable.The thread that intends to modify the variable has to.Even if the shared variable is atomic, it must be modified under the mutex in order to correctly publish the modification to the waiting thread.Any thread that intends to wait on std::condition_variable has to.std::condition_variable works only with std::unique_lock<std::mutex>; this restriction allows for maximal efficiency on some platforms. std::condition_variable_any provides a condition variable that works with any BasicLockable object, such as std::shared_lock.Condition variables permit concurrent invocation of the wait, wait_for, wait_until, notify_one and notify_all member functions.The class std::condition_variable is a StandardLayoutType. It is not CopyConstructible, MoveConstructible, CopyAssignable, or MoveAssignable."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n \nstd::mutex m;\nstd::condition_variable cv;\nstd::string data;\nbool ready = false;\nbool processed = false;\n \nvoid worker_thread()\n{\n    // Wait until main() sends data\n    std::unique_lock<std::mutex> lk(m);\n    cv.wait(lk, []{return ready;});\n \n    // after the wait, we own the lock.\n    std::cout << \"Worker thread is processing data\\n\";\n    data += \" after processing\";\n \n    // Send data back to main()\n    processed = true;\n    std::cout << \"Worker thread signals data processing completed\\n\";\n \n    // Manual unlocking is done before notifying, to avoid waking up\n    // the waiting thread only to block again (see notify_one for details)\n    lk.unlock();\n    cv.notify_one();\n}\n \nint main()\n{\n    std::thread worker(worker_thread);\n \n    data = \"Example data\";\n    // send data to the worker thread\n    {\n        std::lock_guard<std::mutex> lk(m);\n        ready = true;\n        std::cout << \"main() signals data ready for processing\\n\";\n    }\n    cv.notify_one();\n \n    // wait for the worker\n    {\n        std::unique_lock<std::mutex> lk(m);\n        cv.wait(lk, []{return processed;});\n    }\n    std::cout << \"Back in main(), data = \" << data << '\\n';\n \n    worker.join();\n}",
            "output": "main() signals data ready for processing\nWorker thread is processing data\nWorker thread signals data processing completed\nBack in main(), data = Example data after processing"
        }
    },
    "condition_variable_any": {
        "description": {
            "texte": "The condition_variable_any class is a generalization of std::condition_variable. Whereas std::condition_variable works only on std::unique_lock<std::mutex>, condition_variable_any can operate on any lock that meets the BasicLockable requirements.See std::condition_variable for the description of the semantics of condition variables.The class std::condition_variable_any is a StandardLayoutType. It is not CopyConstructible, MoveConstructible, CopyAssignable, or MoveAssignable.If the lock is std::unique_lock, std::condition_variable may provide better performance."
        }
    },
    "notify_all_at_thread_exit": {
        "description": {
            "texte": "notify_all_at_thread_exit provides a mechanism to notify other threads that a given thread has completely finished, including destroying all thread_local objects. It operates as follows:lk.unlock(); cond.notify_all();The implied lk.unlock is sequenced after (as defined in std::memory_order) the destruction of all objects with thread local storage duration associated with the current thread.An equivalent effect may be achieved with the facilities provided by std::promise or std::packaged_task."
        },
        "parametres": "   cond   -   the condition variable to notify at thread exit \n   lk   -   the lock associated with the condition variable cond \n\n",
        "exemple": {
            "input": "#include <mutex>\n#include <thread>\n#include <condition_variable>\n \n#include <cassert>\n#include <string>\n \nstd::mutex m;\nstd::condition_variable cv;\n \nbool ready = false;\nstd::string result; // some arbitrary type\n \nvoid thread_func()\n{\n    thread_local std::string thread_local_data = \"42\";\n \n    std::unique_lock<std::mutex> lk(m);\n \n    // assign a value to result using thread_local data\n    result = thread_local_data;\n    ready = true;\n \n    std::notify_all_at_thread_exit(cv, std::move(lk));\n \n}   // 1. destroy thread_locals;\n    // 2. unlock mutex;\n    // 3. notify cv.\n \nint main()\n{\n    std::thread t(thread_func);\n    t.detach();\n \n    // do other work\n    // ...\n \n    // wait for the detached thread\n    std::unique_lock<std::mutex> lk(m);\n    cv.wait(lk, []{ return ready; });\n \n    // result is ready and thread_local destructors have finished, no UB\n    assert(result == \"42\");\n}"
        }
    },
    "cv_status": {
        "description": {
            "texte": "The scoped enumeration std::cv_status describes whether a timed wait returned because of timeout or not.std::cv_status is used by the wait_for and wait_until methods of std::condition_variable and std::condition_variable_any."
        }
    },
    "promise": {
        "description": {
            "texte": "The class template std::promise provides a facility to store a value or an exception that is later acquired asynchronously via a std::future object created by the std::promise object. Note that the std::promise object is meant to be used only once.Each promise is associated with a shared state, which contains some state information and a result which may be not yet evaluated, evaluated to a value (possibly void) or evaluated to an exception. A promise may do three things with the shared state:The promise is the \"push\" end of the promise-future communication channel: the operation that stores a value in the shared state synchronizes-with (as defined in std::memory_order) the successful return from any function that is waiting on the shared state (such as std::future::get). Concurrent access to the same shared state may conflict otherwise: for example multiple callers of std::shared_future::get must either all be read-only or provide external synchronization."
        },
        "exemple": {
            "input": "#include <vector>\n#include <thread>\n#include <future>\n#include <numeric>\n#include <iostream>\n#include <chrono>\n \nvoid accumulate(std::vector<int>::iterator first,\n                std::vector<int>::iterator last,\n                std::promise<int> accumulate_promise)\n{\n    int sum = std::accumulate(first, last, 0);\n    accumulate_promise.set_value(sum);  // Notify future\n}\n \nvoid do_work(std::promise<void> barrier)\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    barrier.set_value();\n}\n \nint main()\n{\n    // Demonstrate using promise<int> to transmit a result between threads.\n    std::vector<int> numbers = { 1, 2, 3, 4, 5, 6 };\n    std::promise<int> accumulate_promise;\n    std::future<int> accumulate_future = accumulate_promise.get_future();\n    std::thread work_thread(accumulate, numbers.begin(), numbers.end(),\n                            std::move(accumulate_promise));\n    accumulate_future.wait();  // wait for result\n    std::cout << \"result=\" << accumulate_future.get() << '\\n';\n    work_thread.join();  // wait for thread completion\n \n    // Demonstrate using promise<void> to signal state between threads.\n    std::promise<void> barrier;\n    std::future<void> barrier_future = barrier.get_future();\n    std::thread new_work_thread(do_work, std::move(barrier));\n    barrier_future.wait();\n    new_work_thread.join();\n}",
            "output": "result=21"
        }
    },
    "shared_future": {
        "description": {
            "texte": "The class template std::shared_future provides a mechanism to access the result of asynchronous operations, similar to std::future, except that multiple threads are allowed to wait for the same shared state. Unlike std::future, which is only moveable (so only one instance can refer to any particular asynchronous result), std::shared_future is copyable and multiple shared future objects may refer to the same shared state.Access to the same shared state from multiple threads is safe if each thread does it through its own copy of a shared_future object."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <future>\n#include <chrono>\n \nint main()\n{   \n    std::promise<void> ready_promise, t1_ready_promise, t2_ready_promise;\n    std::shared_future<void> ready_future(ready_promise.get_future());\n \n    std::chrono::time_point<std::chrono::high_resolution_clock> start;\n \n    auto fun1 = [&, ready_future]() -> std::chrono::duration<double, std::milli> \n    {\n        t1_ready_promise.set_value();\n        ready_future.wait(); // waits for the signal from main()\n        return std::chrono::high_resolution_clock::now() - start;\n    };\n \n \n    auto fun2 = [&, ready_future]() -> std::chrono::duration<double, std::milli> \n    {\n        t2_ready_promise.set_value();\n        ready_future.wait(); // waits for the signal from main()\n        return std::chrono::high_resolution_clock::now() - start;\n    };\n \n    auto fut1 = t1_ready_promise.get_future();\n    auto fut2 = t2_ready_promise.get_future();\n \n    auto result1 = std::async(std::launch::async, fun1);\n    auto result2 = std::async(std::launch::async, fun2);\n \n    // wait for the threads to become ready\n    fut1.wait();\n    fut2.wait();\n \n    // the threads are ready, start the clock\n    start = std::chrono::high_resolution_clock::now();\n \n    // signal the threads to go\n    ready_promise.set_value();\n \n    std::cout << \"Thread 1 received the signal \"\n              << result1.get().count() << \" ms after start\\n\"\n              << \"Thread 2 received the signal \"\n              << result2.get().count() << \" ms after start\\n\";\n}",
            "output": "Thread 1 received the signal 0.072 ms after start\nThread 2 received the signal 0.041 ms after start"
        }
    },
    "packaged_task": {
        "description": {
            "texte": "The class template std::packaged_task wraps any Callable target (function, lambda expression, bind expression, or another function object) so that it can be invoked asynchronously. Its return value or exception thrown is stored in a shared state which can be accessed through std::future objects."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <thread>\n#include <future>\n#include <functional>\n \n// unique function to avoid disambiguating the std::pow overload set\nint f(int x, int y) { return std::pow(x,y); }\n \nvoid task_lambda()\n{\n    std::packaged_task<int(int,int)> task([](int a, int b) {\n        return std::pow(a, b); \n    });\n    std::future<int> result = task.get_future();\n \n    task(2, 9);\n \n    std::cout << \"task_lambda:\\t\" << result.get() << '\\n';\n}\n \nvoid task_bind()\n{\n    std::packaged_task<int()> task(std::bind(f, 2, 11));\n    std::future<int> result = task.get_future();\n \n    task();\n \n    std::cout << \"task_bind:\\t\" << result.get() << '\\n';\n}\n \nvoid task_thread()\n{\n    std::packaged_task<int(int,int)> task(f);\n    std::future<int> result = task.get_future();\n \n    std::thread task_td(std::move(task), 2, 10);\n    task_td.join();\n \n    std::cout << \"task_thread:\\t\" << result.get() << '\\n';\n}\n \nint main()\n{\n    task_lambda();\n    task_bind();\n    task_thread();\n}",
            "output": "task_lambda: 512\ntask_bind:   2048\ntask_thread: 1024"
        }
    },
    "async": {
        "description": {
            "texte": "The template function async runs the function f asynchronously (potentially in a separate thread which may be part of a thread pool) and returns a std::future that will eventually hold the result of that function call.In any case, the call to std::async synchronizes-with (as defined in std::memory_order) the call to f, and the completion of f is sequenced-before making the shared state ready. If the async policy is chosen, the associated thread completion synchronizes-with the successful return from the first function that is waiting on the shared state, or with the return of the last function that releases the shared state, whichever comes first."
        },
        "parametres": "   f   -   Callable object to call \n   args...   -   parameters to pass to f \n   policy   -   bitmask value, where individual bits control the allowed methods of execution    Bit   Explanation \n   std::launch::async   enable asynchronous evaluation \n   std::launch::deferred   enable lazy evaluation \n  \n   Type requirements \n   -Function, Args must meet the requirements of MoveConstructible. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <future>\n#include <string>\n#include <mutex>\n \nstd::mutex m;\nstruct X {\n    void foo(int i, const std::string& str) {\n        std::lock_guard<std::mutex> lk(m);\n        std::cout << str << ' ' << i << '\\n';\n    }\n    void bar(const std::string& str) {\n        std::lock_guard<std::mutex> lk(m);\n        std::cout << str << '\\n';\n    }\n    int operator()(int i) {\n        std::lock_guard<std::mutex> lk(m);\n        std::cout << i << '\\n';\n        return i + 10;\n    }\n};\n \ntemplate <typename RandomIt>\nint parallel_sum(RandomIt beg, RandomIt end)\n{\n    auto len = end - beg;\n    if (len < 1000)\n        return std::accumulate(beg, end, 0);\n \n    RandomIt mid = beg + len/2;\n    auto handle = std::async(std::launch::async,\n                             parallel_sum<RandomIt>, mid, end);\n    int sum = parallel_sum(beg, mid);\n    return sum + handle.get();\n}\n \nint main()\n{\n    std::vector<int> v(10000, 1);\n    std::cout << \"The sum is \" << parallel_sum(v.begin(), v.end()) << '\\n';\n \n    X x;\n    // Calls (&x)->foo(42, \"Hello\") with default policy:\n    // may print \"Hello 42\" concurrently or defer execution\n    auto a1 = std::async(&X::foo, &x, 42, \"Hello\");\n    // Calls x.bar(\"world!\") with deferred policy\n    // prints \"world!\" when a2.get() or a2.wait() is called\n    auto a2 = std::async(std::launch::deferred, &X::bar, x, \"world!\");\n    // Calls X()(43); with async policy\n    // prints \"43\" concurrently\n    auto a3 = std::async(std::launch::async, X(), 43);\n    a2.wait();                     // prints \"world!\"\n    std::cout << a3.get() << '\\n'; // prints \"53\"\n} // if a1 is not done at this point, destructor of a1 prints \"Hello 42\" here",
            "output": "The sum is 10000\n43\nworld!\n53\nHello 42"
        }
    },
    "launch": {
        "description": {
            "texte": "Specifies the launch policy for a task executed by the std::async function. std::launch is an enumeration used as BitmaskType.The following constants denoting individual bits are defined by the standard library:In addition, implementations are allowed to:"
        }
    },
    "future_status": {
        "description": {
            "texte": "Specifies state of a future as returned by wait_for and wait_until functions of std::future and std::shared_future."
        }
    },
    "future_error": {
        "description": {
            "texte": "The class std::future_error defines an exception object that is thrown on failure by the functions in the thread library that deal with asynchronous execution and shared states (std::future, std::promise, etc). Similar to std::system_error, this exception carries an error code compatible with std::error_code."
        },
        "exemple": {
            "input": "#include <future>\n#include <iostream>\n \nint main()\n{\n    std::future<int> empty;\n    try {\n        int n = empty.get(); // The behavior is undefined, but\n                             // some implementations throw std::future_error\n    } catch (const std::future_error& e) {\n        std::cout << \"Caught a future_error with code \\\"\" << e.code()\n                  << \"\\\"\\nMessage: \\\"\" << e.what() << \"\\\"\\n\";\n    }\n}",
            "output": "Caught a future_error with code \"future:3\"\nMessage: \"No associated state\""
        }
    },
    "future_category": {
        "description": {
            "texte": "Obtains a reference to the static error category object for the errors related to futures and promises. The object is required to override the virtual function error_category::name() to return a pointer to the string \"future\". It is used to identify error codes provided in the exceptions of type std::future_error."
        }
    },
    "future_errc": {
        "description": {
            "texte": "The scoped enumeration std::future_errc defines the error codes reported by std::future and related classes in std::future_error exception objects. Only four error codes are required, although the implementation may define additional error codes. Because the appropriate specialization of std::is_error_code_enum is provided, values of type std::future_errc are implicitly convertible to std::error_code."
        }
    },
    "filesystem::path": {
        "description": {
            "texte": "Objects of type path represent paths on a filesystem. Only syntactic aspects of paths are handled: the pathname may represent a non-existing path or even one that is not allowed to exist on the current file system or OS.The path name has the following syntax:A path can be normalized by following this algorithm:The path can be traversed element-wise via iterators returned by the begin() and end() functions, which views the path in generic format and iterates over root name, root directory, and the subsequent file name elements (directory separators are skipped except the one that identifies the root directory). If the very last element in the path is a directory separator, the last iterator will dereference to an empty element.Calling any non-const member function of a path invalidates all iterators referring to elements of that object.If the OS uses a native syntax that is different from the portable generic syntax described above, library functions that are defined to accept \"detected format\" accept path names in both formats: a detected format argument is taken to be in the generic format if and only if it matches the generic format but is not acceptable to the operating system as a native path. On those OS where native format differs between pathnames of directories and pathnames of files, a generic pathname is treated as a directory path if it ends on a directory separator and a regular file otherwise.In any case, the path class behaves as if it stores a pathname in the native format and automatically converts to generic format as needed (each member function specifies which format it interprets the path as).On POSIX systems, the generic format is the native format and there is no need to distinguish or convert between them.Paths are implicitly convertible to and from std::basic_strings, which makes it possible to use them with over files APIs, e.g. as an argument to std::ifstream::open."
        }
    },
    "filesystem::filesystem_error": {
        "description": {
            "texte": "The class std::filesystem::filesystem_error defines an exception object that is thrown on failure by the throwing overloads of the functions in the filesystem library."
        }
    },
    "filesystem::directory_entry": {
        "description": {
            "texte": "Represents a directory entry. The object stores a path as a member and may also store additional file attributes (hard link count, status, symlink status file size, and last write time) during directory iteration."
        }
    },
    "filesystem::directory_iterator": {
        "description": {
            "texte": "directory_iterator is a LegacyInputIterator that iterates over the directory_entry elements of a directory (but does not visit the subdirectories). The iteration order is unspecified, except that each directory entry is visited only once. The special pathnames dot and dot-dot are skipped.If the directory_iterator reports an error or is advanced past the last directory entry, it becomes equal to the default-constructed iterator, also known as the end iterator. Two end iterators are always equal, dereferencing or incrementing the end iterator is undefined behavior.If a file or a directory is deleted or added to the directory tree after the directory iterator has been created, it is unspecified whether the change would be observed through the iterator."
        },
        "exemple": {
            "input": "#include <fstream>\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::create_directories(\"sandbox/a/b\");\n    std::ofstream(\"sandbox/file1.txt\");\n    std::ofstream(\"sandbox/file2.txt\");\n    for(auto& p: fs::directory_iterator(\"sandbox\"))\n        std::cout << p.path() << '\\n';\n    fs::remove_all(\"sandbox\");\n}",
            "output": "\"sandbox/a\"\n\"sandbox/file1.txt\"\n\"sandbox/file2.txt\""
        }
    },
    "filesystem::recursive_directory_iterator": {
        "description": {
            "texte": "recursive_directory_iterator is an LegacyInputIterator that iterates over the directory_entry elements of a directory, and, recursively, over the entries of all subdirectories. The iteration order is unspecified, except that each directory entry is visited only once.By default, symlinks are not followed, but this can be enabled by specifying the directory option follow_directory_symlink at construction time.The special pathnames dot and dot-dot are skipped.If the recursive_directory_iterator reports an error or is advanced past the last directory entry of the top-level directory, it becomes equal to the default-constructed iterator, also known as the end iterator. Two end iterators are always equal, dereferencing or incrementing the end iterator is undefined behavior.If a file or a directory is deleted or added to the directory tree after the recursive directory iterator has been created, it is unspecified whether the change would be observed through the iterator.If the directory structure contains cycles, the end iterator may be unreachable."
        },
        "exemple": {
            "input": "#include <fstream>\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::create_directories(\"sandbox/a/b\");\n    std::ofstream(\"sandbox/file1.txt\");\n    fs::create_symlink(\"a\", \"sandbox/syma\");\n    for(auto& p: fs::recursive_directory_iterator(\"sandbox\"))\n        std::cout << p.path() << '\\n';\n    fs::remove_all(\"sandbox\");\n}",
            "output": "\"sandbox/a\"\n\"sandbox/a/b\"\n\"sandbox/file1.txt\"\n\"sandbox/syma\""
        }
    },
    "filesystem::file_status": {
        "description": {
            "texte": "Stores information about the type and permissions of a file."
        }
    },
    "filesystem::space_info": {
        "description": {
            "texte": "Represents the filesystem information as determined by space.The members have the following meaning:"
        },
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::space_info devi = fs::space(\"/dev/null\");\n    fs::space_info tmpi = fs::space(\"/tmp\");\n \n    std::cout << \".        Capacity       Free      Available\\n\"\n              << \"/dev:   \" << devi.capacity << \"   \"\n              << devi.free << \"   \" << devi.available  << '\\n'\n              << \"/tmp: \" << tmpi.capacity << \" \"\n              << tmpi.free << \" \" << tmpi.available  << '\\n';\n}",
            "output": ".         Capacity       Free      Available\n/dev:   4175114240   4175110144   4175110144\n/tmp: 420651237376 411962273792 390570749952"
        }
    },
    "filesystem::file_type": {
        "description": {
            "texte": "file_type defines constants that indicate a type of a file or directory a path refers to. The value of the enumerators are distinct."
        }
    },
    "filesystem::perms": {
        "description": {
            "texte": "This type represents file access permissions. perms satisfies the requirements of BitmaskType (which means the bitwise operators operator&, operator|, operator^, operator~, operator&=, operator|=, and operator^= are defined for this type).Access permissions model POSIX permission bits, and any individual file permissions (as reported by status) are a combination of some of the following bits:"
        },
        "exemple": {
            "input": "#include <fstream>\n#include <bitset>\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nvoid demo_perms(fs::perms p)\n{\n    std::cout << ((p & fs::perms::owner_read) != fs::perms::none ? \"r\" : \"-\")\n              << ((p & fs::perms::owner_write) != fs::perms::none ? \"w\" : \"-\")\n              << ((p & fs::perms::owner_exec) != fs::perms::none ? \"x\" : \"-\")\n              << ((p & fs::perms::group_read) != fs::perms::none ? \"r\" : \"-\")\n              << ((p & fs::perms::group_write) != fs::perms::none ? \"w\" : \"-\")\n              << ((p & fs::perms::group_exec) != fs::perms::none ? \"x\" : \"-\")\n              << ((p & fs::perms::others_read) != fs::perms::none ? \"r\" : \"-\")\n              << ((p & fs::perms::others_write) != fs::perms::none ? \"w\" : \"-\")\n              << ((p & fs::perms::others_exec) != fs::perms::none ? \"x\" : \"-\")\n              << '\\n';\n}\nint main()\n{\n    std::ofstream(\"test.txt\"); // create file\n \n    std::cout << \"Created file with permissions: \";\n    demo_perms(fs::status(\"test.txt\").permissions());\n \n    fs::permissions(\"test.txt\",\n                    fs::perms::owner_all | fs::perms::group_all,\n                    fs::perm_options::add);\n \n    std::cout << \"After adding o+rwx and g+rwx:  \";\n    demo_perms(fs::status(\"test.txt\").permissions());\n \n    fs::remove(\"test.txt\");\n}",
            "output": "Created file with permissions: rw-r--r--\nAfter adding o+rwx and g+wrx:  rwxrwxr--"
        }
    },
    "filesystem::perm_options": {
        "description": {
            "texte": "This type represents available options that control the behavior of the function permissions().perm_options satisfies the requirements of BitmaskType (which means the bitwise operators operator&, operator|, operator^, operator~, operator&=, operator|=, and operator^= are defined for this type)."
        },
        "exemple": {
            "input": "#include <fstream>\n#include <bitset>\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nvoid demo_perms(fs::perms p)\n{\n    std::cout << ((p & fs::perms::owner_read) != fs::perms::none ? \"r\" : \"-\")\n              << ((p & fs::perms::owner_write) != fs::perms::none ? \"w\" : \"-\")\n              << ((p & fs::perms::owner_exec) != fs::perms::none ? \"x\" : \"-\")\n              << ((p & fs::perms::group_read) != fs::perms::none ? \"r\" : \"-\")\n              << ((p & fs::perms::group_write) != fs::perms::none ? \"w\" : \"-\")\n              << ((p & fs::perms::group_exec) != fs::perms::none ? \"x\" : \"-\")\n              << ((p & fs::perms::others_read) != fs::perms::none ? \"r\" : \"-\")\n              << ((p & fs::perms::others_write) != fs::perms::none ? \"w\" : \"-\")\n              << ((p & fs::perms::others_exec) != fs::perms::none ? \"x\" : \"-\")\n              << '\\n';\n}\nint main()\n{\n    std::ofstream(\"test.txt\"); // create file\n \n    std::cout << \"Created file with permissions: \";\n    demo_perms(fs::status(\"test.txt\").permissions());\n \n    fs::permissions(\"test.txt\",\n                    fs::perms::owner_all | fs::perms::group_all,\n                    fs::perm_options::add);\n \n    std::cout << \"After adding o+rwx and g+rwx:  \";\n    demo_perms(fs::status(\"test.txt\").permissions());\n \n    fs::remove(\"test.txt\");\n}",
            "output": "Created file with permissions: rw-r--r--\nAfter adding o+rwx and g+wrx:  rwxrwxr--"
        }
    },
    "filesystem::copy_options": {
        "description": {
            "texte": "This type represents available options that control the behavior of the copy() and copy_file() function.copy_options satisfies the requirements of BitmaskType (which means the bitwise operators operator&, operator|, operator^, operator~, operator&=, operator|=, and operator^= are defined for this type). none represents the empty bitmask; every other enumerator represents a distinct bitmask element."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::create_directories(\"sandbox/dir/subdir\");\n    std::ofstream(\"sandbox/file1.txt\").put('a');\n    fs::copy(\"sandbox/file1.txt\", \"sandbox/file2.txt\"); // copy file\n    fs::copy(\"sandbox/dir\", \"sandbox/dir2\"); // copy directory (non-recursive)\n    // sandbox holds 2 files and 2 directories, one of which has a subdirectory\n    // sandbox/file1.txt\n    // sandbox/file2.txt\n    // sandbox/dir2\n    // sandbox/dir\n    //    sandbox/dir/subdir\n    fs::copy(\"sandbox\", \"sandbox/copy\", fs::copy_options::recursive);\n    // sandbox/copy holds copies of the above files and subdirectories\n    fs::remove_all(\"sandbox\");\n}"
        }
    },
    "filesystem::directory_options": {
        "description": {
            "texte": "This type represents available options that control the behavior of the directory_iterator and recursive_directory_iterator.directory_options satisfies the requirements of BitmaskType (which means the bitwise operators operator&, operator|, operator^, operator~, operator&=, operator|=, and operator^= are defined for this type). none represents the empty bitmask; every other enumerator represents a distinct bitmask element."
        }
    },
    "filesystem::file_time_type": {
        "description": {
            "texte": "Represents file time."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n#include <iomanip>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nusing namespace std::chrono_literals;\nint main()\n{\n    fs::path p = fs::current_path() / \"example.bin\";\n    std::ofstream(p.c_str()).put('a'); // create file\n    auto ftime = fs::last_write_time(p);\n \n    // assuming system_clock for this demo\n    // note: not true on MSVC or GCC 9; C++20 will allow portable output\n    std::time_t cftime = decltype(ftime)::clock::to_time_t(ftime);\n    std::cout << \"File write time is \" << std::asctime(std::localtime(&cftime)) << '\\n';\n \n    fs::last_write_time(p, ftime + 1h); // move file write time 1 hour to the future\n    ftime = fs::last_write_time(p); // read back from the filesystem\n \n    cftime = decltype(ftime)::clock::to_time_t(ftime);\n    std::cout << \"File write time is \" << std::asctime(std::localtime(&cftime)) << '\\n';\n    fs::remove(p);\n}",
            "output": "File write time is Tue Mar 31 19:47:04 2015\n \nFile write time is Tue Mar 31 20:47:04 2015"
        }
    },
    "filesystem::absolute": {
        "description": {
            "texte": "Returns a path referencing the same file system location as p, for which is_absolute() is true. The non-throwing overload returns default-constructed path if an error occurs."
        },
        "parametres": "   p   -   path to convert to absolute form \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path p = \"C:cl.exe\";\n    std::cout << \"Current path is \" << fs::current_path() << '\\n'\n              << \"Absolute path for \" << p << \" is \" << fs::absolute(p) << '\\n';\n// actual location: \"C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\bin\\cl.exe\"\n}",
            "output": "Current path is \"D:/local/ConsoleApplication1\"\nAbsolute path for \"C:cl.exe\" is \"C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\bin\\cl.exe\""
        }
    },
    "filesystem::canonical, std::filesystem::weakly_canonical": {
        "description": {
            "texte": "The overload that does not take a std::error_code& parameter throws filesystem_error on underlying OS API errors, constructed with p as the first path argument and the OS error code as the error code argument. The overload taking a std::error_code& parameter sets it to the OS API error code if an OS API call fails, and executes ec.clear() if no errors occur. Any overload not marked noexcept may throw std::bad_alloc if memory allocation fails."
        },
        "parametres": "   p   -   a path which may be absolute or relative; for canonical it must be an existing path \n   ec   -   error code to store error status to \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path p = fs::path(\"..\") / \"..\" / \"AppData\";\n    std::cout << \"Current path is \" << fs::current_path() << '\\n'\n              << \"Canonical path for \" << p << \" is \" << fs::canonical(p) << '\\n';\n}",
            "output": "Current path is \"C:\\Users\\abcdef\\AppData\\Local\\Temp\"\nCanonical path for \"..\\..\\AppData\" is \"C:\\Users\\abcdef\\AppData\""
        }
    },
    "filesystem::relative, std::filesystem::proximate": {
        "description": {
            "texte": "The overload that does not take a std::error_code& parameter throws filesystem_error on underlying OS API errors, constructed with p as the first path argument, base as the second path argument, and the OS error code as the error code argument. The overload taking a std::error_code& parameter sets it to the OS API error code if an OS API call fails, and executes ec.clear() if no errors occur. Any overload not marked noexcept may throw std::bad_alloc if memory allocation fails."
        },
        "parametres": "   p   -   an existing path \n   base   -   base path, against which p will be made relative/proximate \n   ec   -   error code to store error status to \n\n"
    },
    "filesystem::copy": {
        "description": {
            "texte": "Copies files and directories, with a variety of options.The behavior is as follows:"
        },
        "parametres": "   from   -   path to the source file, directory, or symlink \n   to   -   path to the target file, directory, or symlink \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::create_directories(\"sandbox/dir/subdir\");\n    std::ofstream(\"sandbox/file1.txt\").put('a');\n    fs::copy(\"sandbox/file1.txt\", \"sandbox/file2.txt\"); // copy file\n    fs::copy(\"sandbox/dir\", \"sandbox/dir2\"); // copy directory (non-recursive)\n    // sandbox holds 2 files and 2 directories, one of which has a subdirectory\n    // sandbox/file1.txt\n    // sandbox/file2.txt\n    // sandbox/dir2\n    // sandbox/dir\n    //    sandbox/dir/subdir\n    fs::copy(\"sandbox\", \"sandbox/copy\", fs::copy_options::recursive);\n    // sandbox/copy holds copies of the above files and subdirectories\n    fs::remove_all(\"sandbox\");\n}"
        }
    },
    "filesystem::copy_symlink": {
        "description": {
            "texte": "Copies a symlink to another location."
        },
        "parametres": "   from   -   path to a symbolic link to copy \n   to   -   destination path of the new symlink \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n"
    },
    "filesystem::create_directory, std::filesystem::create_directories": {
        "description": {
            "texte": "true if a directory was created for the directory p resolves to, false otherwise."
        },
        "parametres": "   p   -   the path to the new directory to create \n   existing_p   -   the path to a directory to copy the attributes from \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::create_directories(\"sandbox/1/2/a\");\n    fs::create_directory(\"sandbox/1/2/b\");\n    fs::permissions(\"sandbox/1/2/b\", fs::perms::remove_perms | fs::perms::others_all);\n    fs::create_directory(\"sandbox/1/2/c\", \"sandbox/1/2/b\");\n    std::system(\"ls -l sandbox/1/2\");\n    fs::remove_all(\"sandbox\");\n}",
            "output": "drwxr-xr-x 2 user group 4096 Apr 15 09:33 a\ndrwxr-x--- 2 user group 4096 Apr 15 09:33 b\ndrwxr-x--- 2 user group 4096 Apr 15 09:33 c"
        }
    },
    "filesystem::create_hard_link": {
        "description": {
            "texte": "Creates a hard link link with its target set to target as if by POSIX link(): the pathname target must exist.Once created, link and target are two logical names that refer to the same file (they are equivalent). Even if the original name target is deleted, the file continues to exist and is accessible as link."
        },
        "parametres": "   target   -   path of the file or directory to link to \n   link   -   path of the new hard link \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::create_directories(\"sandbox/subdir\");\n    std::ofstream(\"sandbox/a\").put('a'); // create regular file\n    fs::create_hard_link(\"sandbox/a\", \"sandbox/b\");\n    fs::remove(\"sandbox/a\");\n    // read from the original file via surviving hard link\n    char c = std::ifstream(\"sandbox/b\").get();\n    std::cout << c << '\\n';\n    fs::remove_all(\"sandbox\");\n}",
            "output": "a"
        }
    },
    "filesystem::create_symlink, std::filesystem::create_directory_symlink": {
        "description": {
            "texte": "Creates a symbolic link link with its target set to target as if by POSIX symlink(): the pathname target may be invalid or non-existing.Some operating systems require symlink creation to identify that the link is to a directory. Portable code should use (2) to create directory symlinks rather than (1), even though there is no distinction on POSIX systems."
        },
        "parametres": "   target   -   path to point the symlink to, does not have to exist \n   link   -   path of the new symbolic link \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::create_directories(\"sandbox/subdir\");\n    fs::create_symlink(\"target\", \"sandbox/sym1\");\n    fs::create_directory_symlink(\"subdir\", \"sandbox/sym2\");\n \n    for(auto it = fs::directory_iterator(\"sandbox\"); it != fs::directory_iterator(); ++it)\n        if(is_symlink(it->symlink_status()))\n            std::cout << *it << \"->\" << read_symlink(*it) << '\\n';\n \n    fs::remove_all(\"sandbox\");\n}",
            "output": "\"sandbox/sym1\"->\"target\"\n\"sandbox/sym2\"->\"subdir\""
        }
    },
    "filesystem::current_path": {
        "description": {
            "texte": "Returns or changes the current path."
        },
        "parametres": "   p   -   path to change the current working directory to \n   ec   -   out-parameter for error reporting in the non-throwing overloads \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    std::cout << \"Current path is \" << fs::current_path() << '\\n';\n}",
            "output": "Current path is \"D:/local/ConsoleApplication1\""
        }
    },
    "filesystem::exists": {
        "description": {
            "texte": "Checks if the given file status or path corresponds to an existing file or directory."
        },
        "parametres": "   s   -   file status to check \n   p   -   path to examine \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <cstdint>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nvoid demo_exists(const fs::path& p, fs::file_status s = fs::file_status{})\n{\n    std::cout << p;\n    if(fs::status_known(s) ? fs::exists(s) : fs::exists(p))\n        std::cout << \" exists\\n\";\n    else\n        std::cout << \" does not exist\\n\";\n}\nint main()\n{\n    fs::create_directory(\"sandbox\");\n    std::ofstream(\"sandbox/file\"); // create regular file\n    fs::create_symlink(\"non-existing\", \"sandbox/symlink\");\n \n    demo_exists(\"sandbox\");\n    for(auto it = fs::directory_iterator(\"sandbox\"); it != fs::directory_iterator(); ++it)\n        demo_exists(*it, it->status()); // use cached status from directory entry\n    fs::remove_all(\"sandbox\");\n}",
            "output": "\"sandbox\" exists\n\"sandbox/file\" exists\n\"sandbox/symlink\" does not exist"
        }
    },
    "filesystem::equivalent": {
        "description": {
            "texte": "Checks whether the paths p1 and p2 resolve to the same file system entity.If either p1 or p2 does not exist, an error is reported.The non-throwing overload returns false on errors."
        },
        "parametres": "   p1, p2   -   paths to check for equivalence \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstdint>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    // hard link equivalency\n    fs::path p1 = \".\";\n    fs::path p2 = fs::current_path();\n    if(fs::equivalent(p1, p2))\n        std::cout << p1 << \" is equivalent to \" << p2 << '\\n';\n \n    // symlink equivalency\n    fs::path p3 = \"/lib/libc.so.6\";\n    fs::path p4 = p3.parent_path() / fs::read_symlink(p3);\n    if(fs::equivalent(p3, p4))\n        std::cout << p3 << \" is equivalent to \" << p4 << '\\n';\n}",
            "output": "\".\" is equivalent to \"/var/tmp/test\"\n\"/lib/libc.so.6\" is equivalent to \"/lib/libc-2.12.so\""
        }
    },
    "filesystem::file_size": {
        "description": {
            "texte": "If p does not exist, reports an error.For a regular file p, returns the size determined as if by reading the st_size member of the structure obtained by POSIX stat (symlinks are followed).The result of attempting to determine the size of a directory (as well as any other file that is not a regular file or a symlink) is implementation-defined.The non-throwing overload returns -1 on errors."
        },
        "parametres": "   p   -   path to examine \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path p = fs::current_path() / \"example.bin\";\n    std::ofstream(p).put('a'); // create file of size 1\n    std::cout << \"File size = \" << fs::file_size(p) << '\\n';\n    fs::remove(p);\n \n    try {\n        fs::file_size(\"/dev\"); // attempt to get size of a directory\n    } catch(fs::filesystem_error& e) {\n        std::cout << e.what() << '\\n';\n    }        \n}",
            "output": "File size = 1\nfilesystem error: cannot get file size: Is a directory [/dev]"
        }
    },
    "filesystem::hard_link_count": {
        "description": {
            "texte": "Returns the number of hard links for the filesystem object identified by path p.The non-throwing overload returns static_cast<uintmax_t>(-1) on errors."
        },
        "parametres": "   p   -   path to examine \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    // On a POSIX-style filesystem, each directory has at least 2 hard links:\n    // itself and the special member pathname \".\"\n    fs::path p = fs::current_path();\n    std::cout << \"Number of hard links for current path is \"\n              << fs::hard_link_count(p) << '\\n';\n \n    // each \"..\" is a hard link to the parent directory, so the total number\n    // of hard links for any directory is 2 plus number of direct subdirectories\n    p = fs::current_path() / \"..\"; // each dot-dot is a hard link to parent\n    std::cout << \"Number of hard links for .. is \"\n              << fs::hard_link_count(p) << '\\n';\n}",
            "output": "Number of hard links for current path is 2\nNumber of hard links for .. is 3"
        }
    },
    "filesystem::last_write_time": {
        "description": {
            "texte": "The overload that does not take a std::error_code& parameter throws filesystem_error on underlying OS API errors, constructed with p as the first path argument and the OS error code as the error code argument. The overload taking a std::error_code& parameter sets it to the OS API error code if an OS API call fails, and executes ec.clear() if no errors occur. Any overload not marked noexcept may throw std::bad_alloc if memory allocation fails."
        },
        "parametres": "   p   -   path to examine or modify \n   new_time   -   new modification time \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n#include <iomanip>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nusing namespace std::chrono_literals;\nint main()\n{\n    fs::path p = fs::current_path() / \"example.bin\";\n    std::ofstream(p.c_str()).put('a'); // create file\n    auto ftime = fs::last_write_time(p);\n \n    // assuming system_clock for this demo\n    // note: not true on MSVC or GCC 9; C++20 will allow portable output\n    std::time_t cftime = decltype(ftime)::clock::to_time_t(ftime);\n    std::cout << \"File write time is \" << std::asctime(std::localtime(&cftime)) << '\\n';\n \n    fs::last_write_time(p, ftime + 1h); // move file write time 1 hour to the future\n    ftime = fs::last_write_time(p); // read back from the filesystem\n \n    cftime = decltype(ftime)::clock::to_time_t(ftime);\n    std::cout << \"File write time is \" << std::asctime(std::localtime(&cftime)) << '\\n';\n    fs::remove(p);\n}",
            "output": "File write time is Tue Mar 31 19:47:04 2015\n \nFile write time is Tue Mar 31 20:47:04 2015"
        }
    },
    "filesystem::permissions": {
        "description": {
            "texte": "Changes access permissions of the file to which p resolves, as if by POSIX fchmodat. Symlinks are followed unless perm_options::nofollow is set in opts.The second signature behaves as if called with opts set to perm_options::replace.The effects depend on prms and opts as follows:opts is required to have only one of replace, add, or remove to be set.The non-throwing overload has no special action on error."
        },
        "parametres": "   p   -   path to examine \n   prms   -   permissions to set, add, or remove \n   opts   -   options controlling the action taken by this function \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <fstream>\n#include <bitset>\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nvoid demo_perms(fs::perms p)\n{\n    std::cout << ((p & fs::perms::owner_read) != fs::perms::none ? \"r\" : \"-\")\n              << ((p & fs::perms::owner_write) != fs::perms::none ? \"w\" : \"-\")\n              << ((p & fs::perms::owner_exec) != fs::perms::none ? \"x\" : \"-\")\n              << ((p & fs::perms::group_read) != fs::perms::none ? \"r\" : \"-\")\n              << ((p & fs::perms::group_write) != fs::perms::none ? \"w\" : \"-\")\n              << ((p & fs::perms::group_exec) != fs::perms::none ? \"x\" : \"-\")\n              << ((p & fs::perms::others_read) != fs::perms::none ? \"r\" : \"-\")\n              << ((p & fs::perms::others_write) != fs::perms::none ? \"w\" : \"-\")\n              << ((p & fs::perms::others_exec) != fs::perms::none ? \"x\" : \"-\")\n              << '\\n';\n}\nint main()\n{\n    std::ofstream(\"test.txt\"); // create file\n \n    std::cout << \"Created file with permissions: \";\n    demo_perms(fs::status(\"test.txt\").permissions());\n \n    fs::permissions(\"test.txt\",\n                    fs::perms::owner_all | fs::perms::group_all,\n                    fs::perm_options::add);\n \n    std::cout << \"After adding o+rwx and g+rwx:  \";\n    demo_perms(fs::status(\"test.txt\").permissions());\n \n    fs::remove(\"test.txt\");\n}",
            "output": "Created file with permissions: rw-r--r--\nAfter adding o+rwx and g+wrx:  rwxrwxr--"
        }
    },
    "filesystem::read_symlink": {
        "description": {
            "texte": "If the path p refers to a symbolic link, returns a new path object which refers to the target of that symbolic link.It is an error if p does not refer to a symbolic link.The non-throwing overload returns an empty path on errors."
        },
        "parametres": "   p   -   path to a symlink \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\n \nnamespace fs = std::filesystem;\n \nint main()\n{\n    // on a typical Linux system, /lib/libc.so.6 is a symlink\n    fs::path p = \"/lib/libc.so.6\";\n    if(fs::exists(p) && fs::is_symlink(p))\n        std::cout << p << \" -> \" << fs::read_symlink(p) << '\\n';\n    else\n        std::cout << p << \" does not exist or is not a symlink\\n\";\n}",
            "output": "\"/lib/libc.so.6\" -> \"libc-2.12.so\""
        }
    },
    "filesystem::remove, std::filesystem::remove_all": {
        "description": {
            "texte": "The overload that does not take a std::error_code& parameter throws filesystem_error on underlying OS API errors, constructed with p as the first path argument and the OS error code as the error code argument. The overload taking a std::error_code& parameter sets it to the OS API error code if an OS API call fails, and executes ec.clear() if no errors occur. Any overload not marked noexcept may throw std::bad_alloc if memory allocation fails."
        },
        "parametres": "   p   -   path to delete \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstdint>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path dir = fs::temp_directory_path();\n    fs::create_directories(dir / \"abcdef/example\");\n    std::uintmax_t n = fs::remove_all(dir / \"abcdef\");\n    std::cout << \"Deleted \" << n << \" files or directories\\n\";\n}",
            "output": "Deleted 2 files or directories"
        }
    },
    "filesystem::rename": {
        "description": {
            "texte": "Moves or renames the filesystem object identified by old_p to new_p as if by the POSIX rename:Rename fails if."
        },
        "parametres": "   old_p   -   path to move or rename \n   new_p   -   target path for the move/rename operation \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path p = fs::current_path() / \"sandbox\";\n    fs::create_directories(p/\"from\");\n    std::ofstream(p/\"from/file1.txt\").put('a');\n    fs::create_directory(p/\"to\");\n \n//    fs::rename(p/\"from/file1.txt\", p/\"to/\"); // error: to is a directory\n    fs::rename(p/\"from/file1.txt\", p/\"to/file2.txt\"); // OK\n//    fs::rename(p/\"from\", p/\"to\"); // error: to is not empty\n    fs::rename(p/\"from\", p/\"to/subdir\"); // OK\n \n    fs::remove_all(p);\n}"
        }
    },
    "filesystem::resize_file": {
        "description": {
            "texte": "Changes the size of the regular file named by p as if by POSIX truncate: if the file size was previously larger than new_size, the remainder of the file is discarded. If the file was previously smaller than new_size, the file size is increased and the new area appears as if zero-filled."
        },
        "parametres": "   p   -   path to resize \n   new_size   -   size that the file will now have \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path p = fs::current_path() / \"example.bin\";\n    std::ofstream(p).put('a');\n    std::cout << \"File size: \" << std::setw(10) << fs::file_size(p)\n              << \" Free space: \" << fs::space(p).free << '\\n';\n    fs::resize_file(p, 1024*1024*1024); // resize to 1 G\n    std::cout << \"File size: \" << fs::file_size(p)\n              << \" Free space: \" << fs::space(p).free << '\\n';\n    fs::remove(p);\n}",
            "output": "File size:          1 Free space: 3724541952\nFile size: 1073741824 Free space: 3724476416"
        }
    },
    "filesystem::space": {
        "description": {
            "texte": "Determines the information about the filesystem on which the pathname p is located, as if by POSIX statvfs.Populates and returns an object of type space_info, set from the members of the POSIX struct statvfs as follows.The non-throwing overload sets all members to static_cast<uintmax_t>(-1) on error."
        },
        "parametres": "   p   -   path to examine \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::space_info devi = fs::space(\"/dev/null\");\n    fs::space_info tmpi = fs::space(\"/tmp\");\n \n    std::cout << \".        Capacity       Free      Available\\n\"\n              << \"/dev:   \" << devi.capacity << \"   \"\n              << devi.free << \"   \" << devi.available  << '\\n'\n              << \"/tmp: \" << tmpi.capacity << \" \"\n              << tmpi.free << \" \" << tmpi.available  << '\\n';\n}",
            "output": ".         Capacity       Free      Available\n/dev:   4175114240   4175110144   4175110144\n/tmp: 420651237376 411962273792 390570749952"
        }
    },
    "filesystem::status, std::filesystem::symlink_status": {
        "description": {
            "texte": "The file status (a file_status object)."
        },
        "parametres": "   p   -   path to examine \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n \nnamespace fs = std::filesystem;\n \nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << \" is a regular file\\n\";\n    if(fs::is_directory(s)) std::cout << \" is a directory\\n\";\n    if(fs::is_block_file(s)) std::cout << \" is a block device\\n\";\n    if(fs::is_character_file(s)) std::cout << \" is a character device\\n\";\n    if(fs::is_fifo(s)) std::cout << \" is a named IPC pipe\\n\";\n    if(fs::is_socket(s)) std::cout << \" is a named IPC socket\\n\";\n    if(fs::is_symlink(s)) std::cout << \" is a symlink\\n\";\n    if(!fs::exists(s)) std::cout << \" does not exist\\n\";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory(\"sandbox\");\n    std::ofstream(\"sandbox/file\"); // create regular file\n    fs::create_directory(\"sandbox/dir\");\n    mkfifo(\"sandbox/pipe\", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, \"sandbox/sock\");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink(\"file\", \"sandbox/symlink\");\n \n    // demo different status accessors\n    for(auto it = fs::directory_iterator(\"sandbox\"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status(\"dev/null\", fs::status(\"/dev/null\")); // direct calls to status\n    demo_status(\"dev/sda\", fs::status(\"/dev/sda\"));\n    demo_status(\"sandbox/no\", fs::status(\"/sandbox/no\"));\n \n    // cleanup\n    close(fd);\n    fs::remove_all(\"sandbox\");\n}",
            "output": "\"sandbox/file\" is a regular file\n\"sandbox/dir\" is a directory\n\"sandbox/pipe\" is a named IPC pipe\n\"sandbox/sock\" is a named IPC socket\n\"sandbox/symlink\" is a symlink\n\"dev/null\" is a character device\n\"dev/sda\" is a block device\n\"sandbox/no\" does not exist"
        }
    },
    "filesystem::temp_directory_path": {
        "description": {
            "texte": "Returns the directory location suitable for temporary files."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    std::cout << \"Temp directory is \" << fs::temp_directory_path() << '\\n';\n}",
            "output": "Temp directory is \"C:\\Windows\\TEMP\\\""
        }
    },
    "filesystem::is_block_file": {
        "description": {
            "texte": "Checks if the given file status or path corresponds to a block special file, as if determined by the POSIX S_ISBLK . Examples of block special files are block devices such as /dev/sda or /dev/loop0 on Linux."
        },
        "parametres": "   s   -   file status to check \n   p   -   path to examine \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n \nnamespace fs = std::filesystem;\n \nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << \" is a regular file\\n\";\n    if(fs::is_directory(s)) std::cout << \" is a directory\\n\";\n    if(fs::is_block_file(s)) std::cout << \" is a block device\\n\";\n    if(fs::is_character_file(s)) std::cout << \" is a character device\\n\";\n    if(fs::is_fifo(s)) std::cout << \" is a named IPC pipe\\n\";\n    if(fs::is_socket(s)) std::cout << \" is a named IPC socket\\n\";\n    if(fs::is_symlink(s)) std::cout << \" is a symlink\\n\";\n    if(!fs::exists(s)) std::cout << \" does not exist\\n\";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory(\"sandbox\");\n    std::ofstream(\"sandbox/file\"); // create regular file\n    fs::create_directory(\"sandbox/dir\");\n    mkfifo(\"sandbox/pipe\", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, \"sandbox/sock\");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink(\"file\", \"sandbox/symlink\");\n \n    // demo different status accessors\n    for(auto it = fs::directory_iterator(\"sandbox\"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status(\"dev/null\", fs::status(\"/dev/null\")); // direct calls to status\n    demo_status(\"dev/sda\", fs::status(\"/dev/sda\"));\n    demo_status(\"sandbox/no\", fs::status(\"/sandbox/no\"));\n \n    // cleanup\n    close(fd);\n    fs::remove_all(\"sandbox\");\n}",
            "output": "\"sandbox/file\" is a regular file\n\"sandbox/dir\" is a directory\n\"sandbox/pipe\" is a named IPC pipe\n\"sandbox/sock\" is a named IPC socket\n\"sandbox/symlink\" is a symlink\n\"dev/null\" is a character device\n\"dev/sda\" is a block device\n\"sandbox/no\" does not exist"
        }
    },
    "filesystem::is_character_file": {
        "description": {
            "texte": "Checks if the given file status or path corresponds to a character special file, as if determined by POSIX S_ISCHR. Examples of character special files are character devices such as /dev/null, /dev/tty, /dev/audio, or /dev/nvram on Linux."
        },
        "parametres": "   s   -   file status to check \n   p   -   path to examine \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n \nnamespace fs = std::filesystem;\n \nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << \" is a regular file\\n\";\n    if(fs::is_directory(s)) std::cout << \" is a directory\\n\";\n    if(fs::is_block_file(s)) std::cout << \" is a block device\\n\";\n    if(fs::is_character_file(s)) std::cout << \" is a character device\\n\";\n    if(fs::is_fifo(s)) std::cout << \" is a named IPC pipe\\n\";\n    if(fs::is_socket(s)) std::cout << \" is a named IPC socket\\n\";\n    if(fs::is_symlink(s)) std::cout << \" is a symlink\\n\";\n    if(!fs::exists(s)) std::cout << \" does not exist\\n\";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory(\"sandbox\");\n    std::ofstream(\"sandbox/file\"); // create regular file\n    fs::create_directory(\"sandbox/dir\");\n    mkfifo(\"sandbox/pipe\", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, \"sandbox/sock\");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink(\"file\", \"sandbox/symlink\");\n \n    // demo different status accessors\n    for(auto it = fs::directory_iterator(\"sandbox\"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status(\"dev/null\", fs::status(\"/dev/null\")); // direct calls to status\n    demo_status(\"dev/sda\", fs::status(\"/dev/sda\"));\n    demo_status(\"sandbox/no\", fs::status(\"/sandbox/no\"));\n \n    // cleanup\n    close(fd);\n    fs::remove_all(\"sandbox\");\n}",
            "output": "\"sandbox/file\" is a regular file\n\"sandbox/dir\" is a directory\n\"sandbox/pipe\" is a named IPC pipe\n\"sandbox/sock\" is a named IPC socket\n\"sandbox/symlink\" is a symlink\n\"dev/null\" is a character device\n\"dev/sda\" is a block device\n\"sandbox/no\" does not exist"
        }
    },
    "filesystem::is_directory": {
        "description": {
            "texte": "Checks if the given file status or path corresponds to a directory."
        },
        "parametres": "   s   -   file status to check \n   p   -   path to query \n   ec   -   error code to modify in case of errors \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n \nnamespace fs = std::filesystem;\n \nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << \" is a regular file\\n\";\n    if(fs::is_directory(s)) std::cout << \" is a directory\\n\";\n    if(fs::is_block_file(s)) std::cout << \" is a block device\\n\";\n    if(fs::is_character_file(s)) std::cout << \" is a character device\\n\";\n    if(fs::is_fifo(s)) std::cout << \" is a named IPC pipe\\n\";\n    if(fs::is_socket(s)) std::cout << \" is a named IPC socket\\n\";\n    if(fs::is_symlink(s)) std::cout << \" is a symlink\\n\";\n    if(!fs::exists(s)) std::cout << \" does not exist\\n\";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory(\"sandbox\");\n    std::ofstream(\"sandbox/file\"); // create regular file\n    fs::create_directory(\"sandbox/dir\");\n    mkfifo(\"sandbox/pipe\", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, \"sandbox/sock\");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink(\"file\", \"sandbox/symlink\");\n \n    // demo different status accessors\n    for(auto it = fs::directory_iterator(\"sandbox\"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status(\"dev/null\", fs::status(\"/dev/null\")); // direct calls to status\n    demo_status(\"dev/sda\", fs::status(\"/dev/sda\"));\n    demo_status(\"sandbox/no\", fs::status(\"/sandbox/no\"));\n \n    // cleanup\n    close(fd);\n    fs::remove_all(\"sandbox\");\n}",
            "output": "\"sandbox/file\" is a regular file\n\"sandbox/dir\" is a directory\n\"sandbox/pipe\" is a named IPC pipe\n\"sandbox/sock\" is a named IPC socket\n\"sandbox/symlink\" is a symlink\n\"dev/null\" is a character device\n\"dev/sda\" is a block device\n\"sandbox/no\" does not exist"
        }
    },
    "filesystem::is_empty": {
        "description": {
            "texte": "Checks whether the given path refers to an empty file or directory."
        },
        "parametres": "   p   -   path to examine \n   ec   -   error code to modify in case of error \n\n"
    },
    "filesystem::status_known": {
        "description": {
            "texte": "Checks if the given file status is known, Equivalent to s.type() != file_type::none."
        },
        "parametres": "   s   -   file status to check \n\n"
    },
    "filesystem::is_fifo": {
        "description": {
            "texte": "Checks if the given file status or path corresponds to a FIFO or pipe file as if determined by POSIX S_ISFIFO."
        },
        "parametres": "   s   -   file status to check \n   p   -   path to query \n   ec   -   error code to modify in case of errors \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n \nnamespace fs = std::filesystem;\n \nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << \" is a regular file\\n\";\n    if(fs::is_directory(s)) std::cout << \" is a directory\\n\";\n    if(fs::is_block_file(s)) std::cout << \" is a block device\\n\";\n    if(fs::is_character_file(s)) std::cout << \" is a character device\\n\";\n    if(fs::is_fifo(s)) std::cout << \" is a named IPC pipe\\n\";\n    if(fs::is_socket(s)) std::cout << \" is a named IPC socket\\n\";\n    if(fs::is_symlink(s)) std::cout << \" is a symlink\\n\";\n    if(!fs::exists(s)) std::cout << \" does not exist\\n\";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory(\"sandbox\");\n    std::ofstream(\"sandbox/file\"); // create regular file\n    fs::create_directory(\"sandbox/dir\");\n    mkfifo(\"sandbox/pipe\", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, \"sandbox/sock\");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink(\"file\", \"sandbox/symlink\");\n \n    // demo different status accessors\n    for(auto it = fs::directory_iterator(\"sandbox\"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status(\"dev/null\", fs::status(\"/dev/null\")); // direct calls to status\n    demo_status(\"dev/sda\", fs::status(\"/dev/sda\"));\n    demo_status(\"sandbox/no\", fs::status(\"/sandbox/no\"));\n \n    // cleanup\n    close(fd);\n    fs::remove_all(\"sandbox\");\n}",
            "output": "\"sandbox/file\" is a regular file\n\"sandbox/dir\" is a directory\n\"sandbox/pipe\" is a named IPC pipe\n\"sandbox/sock\" is a named IPC socket\n\"sandbox/symlink\" is a symlink\n\"dev/null\" is a character device\n\"dev/sda\" is a block device\n\"sandbox/no\" does not exist"
        }
    },
    "filesystem::is_other": {
        "description": {
            "texte": "Checks if the given file status or path corresponds to a file of type other type. That is, the file exists, but is neither regular file, nor directory nor a symlink."
        },
        "parametres": "   s   -   file status to check \n   p   -   path to examine \n   ec   -   error code to store the error status to \n\n"
    },
    "filesystem::is_regular_file": {
        "description": {
            "texte": "Checks if the given file status or path corresponds to a regular file."
        },
        "parametres": "   s   -   file status to check \n   p   -   path to examine \n   ec   -   error code to store the error status to \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n \nnamespace fs = std::filesystem;\n \nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << \" is a regular file\\n\";\n    if(fs::is_directory(s)) std::cout << \" is a directory\\n\";\n    if(fs::is_block_file(s)) std::cout << \" is a block device\\n\";\n    if(fs::is_character_file(s)) std::cout << \" is a character device\\n\";\n    if(fs::is_fifo(s)) std::cout << \" is a named IPC pipe\\n\";\n    if(fs::is_socket(s)) std::cout << \" is a named IPC socket\\n\";\n    if(fs::is_symlink(s)) std::cout << \" is a symlink\\n\";\n    if(!fs::exists(s)) std::cout << \" does not exist\\n\";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory(\"sandbox\");\n    std::ofstream(\"sandbox/file\"); // create regular file\n    fs::create_directory(\"sandbox/dir\");\n    mkfifo(\"sandbox/pipe\", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, \"sandbox/sock\");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink(\"file\", \"sandbox/symlink\");\n \n    // demo different status accessors\n    for(auto it = fs::directory_iterator(\"sandbox\"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status(\"dev/null\", fs::status(\"/dev/null\")); // direct calls to status\n    demo_status(\"dev/sda\", fs::status(\"/dev/sda\"));\n    demo_status(\"sandbox/no\", fs::status(\"/sandbox/no\"));\n \n    // cleanup\n    close(fd);\n    fs::remove_all(\"sandbox\");\n}",
            "output": "\"sandbox/file\" is a regular file\n\"sandbox/dir\" is a directory\n\"sandbox/pipe\" is a named IPC pipe\n\"sandbox/sock\" is a named IPC socket\n\"sandbox/symlink\" is a symlink\n\"dev/null\" is a character device\n\"dev/sda\" is a block device\n\"sandbox/no\" does not exist"
        }
    },
    "filesystem::is_socket": {
        "description": {
            "texte": "Checks if the given file status or path corresponds to a named IPC socket, as if determined by the POSIX S_IFSOCK."
        },
        "parametres": "   s   -   file status to check \n   p   -   path to examine \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n \nnamespace fs = std::filesystem;\n \nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << \" is a regular file\\n\";\n    if(fs::is_directory(s)) std::cout << \" is a directory\\n\";\n    if(fs::is_block_file(s)) std::cout << \" is a block device\\n\";\n    if(fs::is_character_file(s)) std::cout << \" is a character device\\n\";\n    if(fs::is_fifo(s)) std::cout << \" is a named IPC pipe\\n\";\n    if(fs::is_socket(s)) std::cout << \" is a named IPC socket\\n\";\n    if(fs::is_symlink(s)) std::cout << \" is a symlink\\n\";\n    if(!fs::exists(s)) std::cout << \" does not exist\\n\";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory(\"sandbox\");\n    std::ofstream(\"sandbox/file\"); // create regular file\n    fs::create_directory(\"sandbox/dir\");\n    mkfifo(\"sandbox/pipe\", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, \"sandbox/sock\");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink(\"file\", \"sandbox/symlink\");\n \n    // demo different status accessors\n    for(auto it = fs::directory_iterator(\"sandbox\"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status(\"dev/null\", fs::status(\"/dev/null\")); // direct calls to status\n    demo_status(\"dev/sda\", fs::status(\"/dev/sda\"));\n    demo_status(\"sandbox/no\", fs::status(\"/sandbox/no\"));\n \n    // cleanup\n    close(fd);\n    fs::remove_all(\"sandbox\");\n}",
            "output": "\"sandbox/file\" is a regular file\n\"sandbox/dir\" is a directory\n\"sandbox/pipe\" is a named IPC pipe\n\"sandbox/sock\" is a named IPC socket\n\"sandbox/symlink\" is a symlink\n\"dev/null\" is a character device\n\"dev/sda\" is a block device\n\"sandbox/no\" does not exist"
        }
    },
    "filesystem::is_symlink": {
        "description": {
            "texte": "Checks if the given file status or path corresponds to a symbolic link, as if determined by the POSIX S_IFLNK."
        },
        "parametres": "   s   -   file status to check \n   p   -   path to examine \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n \nnamespace fs = std::filesystem;\n \nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << \" is a regular file\\n\";\n    if(fs::is_directory(s)) std::cout << \" is a directory\\n\";\n    if(fs::is_block_file(s)) std::cout << \" is a block device\\n\";\n    if(fs::is_character_file(s)) std::cout << \" is a character device\\n\";\n    if(fs::is_fifo(s)) std::cout << \" is a named IPC pipe\\n\";\n    if(fs::is_socket(s)) std::cout << \" is a named IPC socket\\n\";\n    if(fs::is_symlink(s)) std::cout << \" is a symlink\\n\";\n    if(!fs::exists(s)) std::cout << \" does not exist\\n\";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory(\"sandbox\");\n    std::ofstream(\"sandbox/file\"); // create regular file\n    fs::create_directory(\"sandbox/dir\");\n    mkfifo(\"sandbox/pipe\", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, \"sandbox/sock\");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink(\"file\", \"sandbox/symlink\");\n \n    // demo different status accessors\n    for(auto it = fs::directory_iterator(\"sandbox\"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status(\"dev/null\", fs::status(\"/dev/null\")); // direct calls to status\n    demo_status(\"dev/sda\", fs::status(\"/dev/sda\"));\n    demo_status(\"sandbox/no\", fs::status(\"/sandbox/no\"));\n \n    // cleanup\n    close(fd);\n    fs::remove_all(\"sandbox\");\n}",
            "output": "\"sandbox/file\" is a regular file\n\"sandbox/dir\" is a directory\n\"sandbox/pipe\" is a named IPC pipe\n\"sandbox/sock\" is a named IPC socket\n\"sandbox/symlink\" is a symlink\n\"dev/null\" is a character device\n\"dev/sda\" is a block device\n\"sandbox/no\" does not exist"
        }
    },
    "NULL": {
        "description": {
            "texte": "The macro NULL is an implementation-defined null pointer constant, which may be.A null pointer constant may be implicitly converted to any pointer type; such conversion results in the null pointer value of that type. If a null pointer constant has integer type, it may be converted to a prvalue of type std::nullptr_t."
        },
        "exemple": {
            "input": "#include <cstddef>\n#include <type_traits>\n#include <iostream>\nclass S;\nint main()\n{\n    int* p = NULL;\n    int* p2 = static_cast<std::nullptr_t>(NULL);\n    void(*f)(int) = NULL;\n    int S::*mp = NULL;\n    void(S::*mfp)(int) = NULL;\n \n    if (std::is_same_v<decltype(NULL), std::nullptr_t>) {\n        std::cout << \"NULL implemented with type std::nullptr_t\\n\";\n    } else {\n        std::cout << \"NULL implemented using an integral type\\n\";\n    }\n}",
            "output": "NULL implemented using an integral type"
        }
    },
    "offsetof": {
        "description": {
            "texte": "The macro offsetof expands to an integral constant expression of type std::size_t, the value of which is the offset, in bytes, from the beginning of an object of specified type to its specified member, including padding if any.If type is not a standard layout type, the behavior is undefined (until C++17)use of the offsetof macro is conditionally-supported (since C++17).If member is a static member or a member function, the behavior is undefined.The offset of the first member of a standard-layout type is always zero (empty-base optimization is mandatory).The expression offsetof(type, member) is never type-dependent and it is value-dependent if and only if type is dependent."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <cstddef>\nstruct S {\n    char c;\n    double d;\n};\nint main()\n{\n    std::cout << \"the first element is at offset \" << offsetof(S, c) << '\\n'\n              << \"the double is at offset \" << offsetof(S, d) << '\\n';\n}",
            "output": "the first element is at offset 0\nthe double is at offset 8"
        }
    },
    "ptrdiff_t": {
        "description": {
            "texte": "std::ptrdiff_t is the signed integer type of the result of subtracting two pointers."
        },
        "exemple": {
            "input": "#include <cstddef>\n#include <iostream>\nint main()\n{\n    const std::size_t N = 100;\n    int* a = new int[N];\n    int* end = a + N;\n    for (std::ptrdiff_t i = N; i > 0; --i)\n        std::cout << (*(end - i) = i) << ' ';\n    delete[] a;\n}"
        }
    },
    "max_align_t": {
        "description": {
            "texte": "std::max_align_t is a trivial standard-layout type whose alignment requirement is at least as strict (as large) as that of every scalar type."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <cstddef>\nint main()\n{\n    std::cout << alignof(std::max_align_t) << '\\n';\n}",
            "output": "16"
        }
    },
    "float_round_style": {
        "description": {
            "texte": "Enumeration constants of type std::float_round_style indicate the rounding style used by floating-point arithmetics whenever a result of an expression is stored in an object of a floating-point type. The values are:"
        }
    },
    "float_denorm_style": {
        "description": {
            "texte": "Enumeration constants of type std::float_denorm_style indicate support of subnormal values by floating-point types."
        }
    },
    "numeric_limits::max_digits10": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::max_digits10 is the number of base-10 digits that are necessary to uniquely represent all distinct values of the type T, such as necessary for serialization/deserialization to text. This constant is meaningful for all floating-point types."
        },
        "exemple": {
            "input": "#include <limits>\n#include <sstream>\n#include <iomanip>\n#include <cmath>\n#include <iostream>\n \nint main()\n{\n    float value = 10.0000086;\n \n    constexpr auto digits10 = std::numeric_limits<decltype(value)>::digits10;\n    constexpr auto max_digits10 = std::numeric_limits<decltype(value)>::max_digits10;\n    constexpr auto submax_digits10 = max_digits10 - 1;\n \n    std::cout\n        << \"float:\\n\"\n        << \"       digits10 is \" << digits10 << \" digits\" << '\\n'\n        << \"   max_digits10 is \" << max_digits10 << \" digits\" << '\\n'\n        << \"submax_digits10 is \" << submax_digits10 << \" digits\" << '\\n'\n        << '\\n';\n \n    const auto original_precision = std::cout.precision();\n    for( auto i = 0; i < 5; ++i )\n    {\n        std::cout\n            << \"   max_digits10: \" << std::setprecision(max_digits10) << value << '\\n'\n            << \"submax_digits10: \" << std::setprecision(submax_digits10) << value << '\\n'\n            << '\\n';\n \n        value = std::nextafter( value, std::numeric_limits<decltype(value)>::max() );\n    }\n    std::cout.precision( original_precision );\n \n    return 0;\n}",
            "output": "float:\n       digits10 is 6 digits\n   max_digits10 is 9 digits\nsubmax_digits10 is 8 digits\n \n   max_digits10: 10.0000086\nsubmax_digits10: 10.000009\n \n   max_digits10: 10.0000095\nsubmax_digits10: 10.00001\n \n   max_digits10: 10.0000105\nsubmax_digits10: 10.00001\n \n   max_digits10: 10.0000114\nsubmax_digits10: 10.000011\n \n   max_digits10: 10.0000124\nsubmax_digits10: 10.000012"
        }
    },
    "numeric_limits::digits10": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::digits10 is the number of base-10 digits that can be represented by the type T without change, that is, any number with this many significant decimal digits can be converted to a value of type T and back to decimal form, without change due to rounding or overflow. For base-radix types, it is the value of digits (digits-1 for floating-point types) multiplied by log10(radix) and rounded down."
        }
    },
    "FLT_ROUNDS": {
        "description": {
            "texte": "Specifies the current rounding direction of floating-point arithmetic operations."
        }
    },
    "FLT_EVAL_METHOD": {
        "description": {
            "texte": "Specifies the precision in which all floating-point arithmetic operations other than assignment and cast are done."
        }
    },
    "sig_atomic_t": {
        "description": {
            "texte": "An integer type which can be accessed as an atomic entity even in the presence of asynchronous interrupts made by signals."
        }
    },
    "operator new, operator new[]": {
        "description": {
            "texte": "Allocates requested number of bytes. These allocation functions are called by new-expressions to allocate memory in which new object would then be initialized. They may also be called using regular function call syntax."
        },
        "parametres": "   count   -   number of bytes to allocate \n   ptr   -   pointer to a memory area to initialize the object at \n   tag   -   disambiguation tag used to select non-throwing overloads \n   al   -   alignment to use. The behavior is undefined if this is not a valid alignment value \n\n",
        "exemple": {
            "input": "#include <cstdio>\n#include <cstdlib>\n#include <new>\n// replacement of a minimal set of functions:\nvoid* operator new(std::size_t sz) {\n    std::printf(\"global op new called, size = %zu\\n\", sz);\n    void *ptr = std::malloc(sz);\n    if (ptr)\n        return ptr;\n    else\n        throw std::bad_alloc{};\n}\nvoid operator delete(void* ptr) noexcept\n{\n    std::puts(\"global op delete called\");\n    std::free(ptr);\n}\nint main() {\n     int* p1 = new int;\n     delete p1;\n \n     int* p2 = new int[10]; // guaranteed to call the replacement in C++11\n     delete[] p2;\n}",
            "output": "global op new called, size = 4\nglobal op delete called\nglobal op new called, size = 40\nglobal op delete called"
        }
    },
    "operator delete, operator delete[]": {
        "description": {
            "texte": "Deallocates storage previously allocated by a matching operator new. These deallocation functions are called by delete-expressions and by new-expressions to deallocate memory after destructing (or failing to construct) objects with dynamic storage duration. They may also be called using regular function call syntax.In all cases, if ptr is a null pointer, the standard library deallocation functions do nothing. If the pointer passed to the standard library deallocation function was not obtained from the corresponding standard library allocation function, the behavior is undefined.After the standard library deallocation function returns, all pointers referring to any part of the deallocated storage become invalid."
        },
        "parametres": "   ptr   -   pointer to a memory block to deallocate or a null pointer \n   sz   -   the size that was passed to the matching allocation function \n   place   -   pointer used as the placement parameter in the matching placement new \n   tag   -   overload disambiguation tag matching the tag used by non-throwing operator new \n   al   -   alignment of the object or array element that was allocated \n   args   -   arbitrary parameters matching a placement allocation function (may include std::size_t and std::align_val_t) \n\n",
        "exemple": {
            "input": "#include <cstdio>\n#include <cstdlib>\n// replacement of a minimal set of functions:\nvoid* operator new(std::size_t sz) {\n    std::printf(\"global op new called, size = %zu\\n\",sz);\n    return std::malloc(sz);\n}\nvoid operator delete(void* ptr) noexcept\n{\n    std::puts(\"global op delete called\");\n    std::free(ptr);\n}\nint main() {\n     int* p1 = new int;\n     delete p1;\n \n     int* p2 = new int[10]; // guaranteed to call the replacement in C++11\n     delete[] p2;\n}",
            "output": "global op new called, size = 4\nglobal op delete called\nglobal op new called, size = 40\nglobal op delete called"
        }
    },
    "get_new_handler": {
        "description": {
            "texte": "Returns the currently installed new-handler, which may be a null pointer."
        }
    },
    "set_new_handler": {
        "description": {
            "texte": "Makes new_p the new global new-handler function and returns the previously installed new-handler.The new-handler function is the function called by allocation functions whenever a memory allocation attempt fails. Its intended purpose is one of three things:The default implementation throws std::bad_alloc. The user can install his own new-handler, which may offer behavior different than the default one.If new-handler returns, the allocation function repeats the previously-failed allocation attempt and calls the new-handler again if the allocation fails again. To end the loop, new-handler may call std::set_new_handler(nullptr): if, after a failed allocation attempt, allocation function finds that std::get_new_handler returns a null pointer value, it will throw std::bad_alloc.At program startup, new-handler is a null pointer."
        },
        "parametres": "   new_p   -   pointer to function of type std::new_handler, or null pointer \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <new>\n \nvoid handler()\n{\n    std::cout << \"Memory allocation failed, terminating\\n\";\n    std::set_new_handler(nullptr);\n}\n \nint main()\n{\n    std::set_new_handler(handler);\n    try {\n        while (true) {\n            new int[100000000ul];\n        }\n    } catch (const std::bad_alloc& e) {\n        std::cout << e.what() << '\\n';\n    }\n}",
            "output": "Memory allocation failed, terminating\nstd::bad_alloc"
        }
    },
    "bad_alloc": {
        "description": {
            "texte": "std::bad_alloc is the type of the object thrown as exceptions by the allocation functions to report failure to allocate storage."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <new>\n \nint main()\n{\n    try {\n        while (true) {\n            new int[100000000ul];\n        }\n    } catch (const std::bad_alloc& e) {\n        std::cout << \"Allocation failed: \" << e.what() << '\\n';\n    }\n}",
            "output": "Allocation failed: std::bad_alloc"
        }
    },
    "bad_array_new_length": {
        "description": {
            "texte": "std::bad_array_new_length is the type of the object thrown as exceptions by the new-expressions to report invalid array lengths if.1) array length is negative.2) total size of the new array would exceed implementation-defined maximum value.3) the number of initializer-clauses exceeds the number of elements to initialize.Only the first array dimension may generate this exception; dimensions other than the first are constant expressions and are checked at compile time."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <new>\n#include <climits>\n \nint main()\n{\n    int negative = -1;\n    int small = 1;\n    int large = INT_MAX;\n    try {\n        new int[negative];           // negative size\n        new int[small]{1,2,3};       // too many initializers\n        new int[large][1000000];     // too large\n    } catch(const std::bad_array_new_length &e) {\n        std::cout << e.what() << '\\n';\n    }\n}"
        }
    },
    "nothrow_t": {
        "description": {
            "texte": "std::nothrow_t is an empty class type used to disambiguate the overloads of throwing and non-throwing allocation functions."
        }
    },
    "align_val_t": {
        "description": {
            "texte": "Both new-expression and delete-expression, when used with objects whose alignment requirement is greater than __STDCPP_DEFAULT_NEW_ALIGNMENT__, pass that alignment requirement as an argument of type std::align_val_t to the selected allocation/deallocation function."
        }
    },
    "destroying_delete_t, std::destroying_delete": {
        "description": {
            "texte": "Tag type used to identify the destroying delete form of operator delete."
        }
    },
    "new_handler": {
        "description": {
            "texte": "std::new_handler is the function pointer type (pointer to function that takes no arguments and returns void), which is used by the functions std::set_new_handler and std::get_new_handler."
        }
    },
    "nothrow": {
        "description": {
            "texte": "std::nothrow is a constant of type std::nothrow_t used to disambiguate the overloads of throwing and non-throwing allocation functions."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <new>\n \nint main()\n{\n    try {\n        while (true) {\n            new int[100000000ul];   // throwing overload\n        }\n    } catch (const std::bad_alloc& e) {\n        std::cout << e.what() << '\\n';\n    }\n \n    while (true) {\n        int* p = new(std::nothrow) int[100000000ul]; // non-throwing overload\n        if (p == nullptr) {\n            std::cout << \"Allocation returned nullptr\\n\";\n            break;\n        }\n    }\n}",
            "output": "std::bad_alloc\nAllocation returned nullptr"
        }
    },
    "bad_typeid": {
        "description": {
            "texte": "An exception of this type is thrown when a typeid operator is applied to a dereferenced null pointer value of a polymorphic type."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <typeinfo>\n \nstruct S { // The type has to be polymorphic\n    virtual void f();\n}; \n \nint main()\n{\n    S* p = nullptr;\n    try {\n        std::cout << typeid(*p).name() << '\\n';\n    } catch(const std::bad_typeid& e) {\n        std::cout << e.what() << '\\n';\n    }\n}",
            "output": "Attempted a typeid of NULL pointer!"
        }
    },
    "bad_cast": {
        "description": {
            "texte": "An exception of this type is thrown when a dynamic_cast to a reference type fails the run-time check (e.g. because the types are not related by inheritance), and also from std::use_facet if the requested facet does not exist in the locale."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <typeinfo>\n \nstruct Foo { virtual ~Foo() {} };\nstruct Bar { virtual ~Bar() {} };\n \nint main()\n{\n    Bar b;\n    try {\n        Foo& f = dynamic_cast<Foo&>(b);\n    } catch(const std::bad_cast& e)\n    {\n        std::cout << e.what() << '\\n';\n    }\n}",
            "output": "Bad dynamic cast"
        }
    },
    "begin(std::initializer_list)\n": {
        "description": {
            "texte": "The overload of std::begin for initializer_list returns a pointer to the first element of il."
        },
        "parametres": "   il   -   an initializer_list \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <initializer_list>\n \nint main() \n{\n    std::initializer_list<int> il = {3, 1, 4, 1};\n    for(auto it = std::begin(il); it != std::end(il); ++it) {\n        std::cout << *it << '\\n';\n    }\n}",
            "output": "3\n1\n4\n1"
        }
    },
    "end(std::initializer_list)\n": {
        "description": {
            "texte": "The overload of std::end for initializer_list returns a pointer to one past the last element of il."
        },
        "parametres": "   il   -   an initializer_list \n\n",
        "exemple": {
            "input": "#include <iostream>\n \nint main() \n{\n    // range-based for uses std::begin and std::end to iterate\n    // over a given range; in this case, it's an initializer list\n    for (int i : {3, 1, 4, 1}) {\n        std::cout << i << '\\n';\n    }\n}",
            "output": "3\n1\n4\n1"
        }
    },
    "Feature testing (C++20)\n": {
        "description": {
            "texte": "The standard defines a set of preprocessor macros corresponding to C++ language and library features introduced in C++11 or later. They are intended as a simple and portable way to detect the presence of said features."
        },
        "exemple": {
            "input": "#ifdef __has_include                           // Check if __has_include is present\n#  if __has_include(<optional>)                // Check for a standard library\n#    include <optional>\n#  elif __has_include(<experimental/optional>) // Check for an experimental version\n#    include <experimental/optional>\n#  elif __has_include(<boost/optional.hpp>)    // Try with an external library\n#    include <boost/optional.hpp>\n#  else                                        // Not found at all\n#     error \"Missing <optional>\"\n#  endif\n#endif\n \n#ifdef __has_cpp_attribute                      // Check if __has_cpp_attribute is present\n#  if __has_cpp_attribute(deprecated)           // Check for an attribute\n#    define DEPRECATED(msg) [[deprecated(msg)]]\n#  endif\n#endif\n#ifndef DEPRECATED\n#    define DEPRECATED(msg)\n#endif\n \nDEPRECATED(\"foo() has been deprecated\") void foo();\n \n#if __cpp_constexpr >= 201304                   // Check for a specific version of a feature\n#  define CONSTEXPR constexpr\n#else\n#  define CONSTEXPR inline\n#endif\n \nCONSTEXPR int bar(unsigned i)\n{\n#if __cpp_binary_literals                    // Check for the presence of a feature\n    unsigned mask1 = 0b11000000;\n    unsigned mask2 = 0b00000111;\n#else\n    unsigned mask1 = 0xC0;\n    unsigned mask2 = 0x07;\n#endif\n    if ( i & mask1 )\n        return 1;\n    if ( i & mask2 )\n        return 2;\n    return 0;\n}\n \nint main()\n{\n}"
        }
    },
    "SIGTERM, SIGSEGV, SIGINT, SIGILL, SIGABRT, SIGFPE": {
        "description": {
            "texte": "Each of the above macro constants expands to an integer constant expression with distinct values, which represent different signals sent to the program."
        }
    },
    "SIG_DFL, SIG_IGN": {
        "description": {
            "texte": "The SIG_DFL and SIG_IGN macros expand into integral expressions that are not equal to an address of any function. The macros define signal handling strategies for std::signal() function."
        }
    },
    "SIG_ERR": {
        "description": {
            "texte": "A value of type void (*)(int). When returned by std::signal, indicates that an error has occurred."
        }
    },
    "signal": {
        "description": {
            "texte": "Sets the handler for signal sig. The signal handler can be set so that default handling will occur, signal is ignored, or a user-defined function is called.When signal handler is set to a function and a signal occurs, it is implementation defined whether std::signal(sig, SIG_DFL) will be executed immediately before the start of signal handler. Also, the implementation can prevent some implementation-defined set of signals from occurring while the signal handler runs.For some of the signals, the implementation may call std::signal(sig, SIG_IGN) at the startup of the program. For the rest, the implementation must call std::signal(sig, SIG_DFL).(Note: POSIX introduced sigaction to standardize these implementation-defined behaviors)."
        },
        "parametres": "   sig   -   the signal to set the signal handler to. It can be an implementation-defined value or one of the following values:     SIGABRTSIGFPESIGILLSIGINTSIGSEGVSIGTERM   defines signal types  (macro constant) \n  \n   handler   -   the signal handler. This must be one of the following: \n\nSIG_DFL macro. The signal handler is set to default signal handler. \n\nSIG_IGN macro. The signal is ignored. \npointer to a function. The signature of the function must be equivalent to the following: \n    extern \"C\" void fun(int sig);\n        \n\n",
        "exemple": {
            "input": "#include <csignal>\n#include <iostream>\n \nnamespace\n{\n  volatile std::sig_atomic_t gSignalStatus;\n}\n \nvoid signal_handler(int signal)\n{\n  gSignalStatus = signal;\n}\n \nint main()\n{\n  // Install a signal handler\n  std::signal(SIGINT, signal_handler);\n \n  std::cout << \"SignalValue: \" << gSignalStatus << '\\n';\n  std::cout << \"Sending signal \" << SIGINT << '\\n';\n  std::raise(SIGINT);\n  std::cout << \"SignalValue: \" << gSignalStatus << '\\n';\n}",
            "output": "SignalValue: 0\nSending signal 2\nSignalValue: 2"
        }
    },
    "jmp_buf": {
        "description": {
            "texte": "The std::jmp_buf type is an array type suitable for storing information to restore a calling environment. The stored information is sufficient to restore execution at the correct block of the program and invocation of that block. The state of floating-point status flags, or open files, or any other data is not stored in an object of type jmp_buf."
        }
    },
    "longjmp": {
        "description": {
            "texte": "Loads the execution context env saved by a previous call to setjmp. This function does not return. Control is transferred to the call site of the macro setjmp that set up env. That setjmp then returns the value, passed as the status.If the function that called setjmp has exited, the behavior is undefined (in other words, only long jumps up the call stack are allowed).No destructors for automatic objects are called. If replacing of std::longjmp with throw and setjmp with catch would execute a non-trivial destructor for any automatic object, the behavior of such std::longjmp is undefined."
        },
        "parametres": "   env   -   variable referring to the execution state of the program saved by setjmp \n   status   -   the value to return from setjmp. If it is equal to \u200b0\u200b, 1 is used instead \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <csetjmp>\n \nstd::jmp_buf jump_buffer;\n \n[[noreturn]] void a(int count) \n{\n    std::cout << \"a(\" << count << \") called\\n\";\n    std::longjmp(jump_buffer, count+1);  // setjmp() will return count+1\n}\n \nint main()\n{\n    volatile int count = 0; // local variables must be volatile for setjmp\n    if (setjmp(jump_buffer) != 9) {\n        a(count++);  // This will cause setjmp() to exit\n    }\n}",
            "output": "a(0) called\na(1) called\na(2) called\na(3) called\na(4) called\na(5) called\na(6) called\na(7) called\na(8) called"
        }
    },
    "va_list": {
        "description": {
            "texte": "va_list is a complete object type suitable for holding the information needed by the macros va_start, va_copy, va_arg, and va_end.If a va_list instance is created, passed to another function, and used via va_arg in that function, then any subsequent use in the calling function should be preceded by a call to va_end.It is legal to pass a pointer to a va_list object to another function and then use that object after the function returns."
        }
    },
    "va_copy": {
        "description": {
            "texte": "The va_copy macro copies src to dest.va_end should be called on dest before the function returns or any subsequent re-initialization of dest (via calls to va_start or va_copy)."
        },
        "parametres": "   dest   -   an instance of the va_list type to initialize \n   src   -   the source va_list that will be used to initialize dest \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstdarg>\n#include <cmath>\n \ndouble sample_stddev(int count, ...) \n{\n    double sum = 0;\n    va_list args1;\n    va_start(args1, count);\n    va_list args2;\n    va_copy(args2, args1);\n    for (int i = 0; i < count; ++i) {\n        double num = va_arg(args1, double);\n        sum += num;\n    }\n    va_end(args1);\n    double mean = sum / count;\n \n    double sum_sq_diff = 0;\n    for (int i = 0; i < count; ++i) {\n        double num = va_arg(args2, double);\n        sum_sq_diff += (num-mean) * (num-mean);\n    }\n    va_end(args2);\n    return std::sqrt(sum_sq_diff / count);\n}\n \nint main() \n{\n    std::cout << sample_stddev(4, 25.0, 27.3, 26.9, 25.7) << '\\n';\n}",
            "output": "0.920258"
        }
    },
    "is_error_code_enum": {
        "description": {
            "texte": "If T is an error code enumeration, this template provides the member constant value equal true. For any other type, value is false.This template may be specialized for a user-defined type to indicate that the type is eligible for std::error_code and std::error_condition automatic conversions.The following classes of the standard library are an error code enum:"
        }
    },
    "is_error_condition_enum": {
        "description": {
            "texte": "If T is an error condition enum, this template provides the member constant value equal true. For any other type, value is false.This template may be specialized for a user-defined type to indicate that the type is eligible for std::error_condition automatic conversions.The following class of the standard library is an error condition enum: std::errc."
        }
    },
    "operator==,!=,<(std::error_code)": {
        "description": {
            "texte": "Compares two error code objects."
        },
        "parametres": "   lhs, rhs   -   error codes to compare \n\n"
    },
    "operator<<(std::error_code)": {
        "description": {
            "texte": "Performs stream output operation on error code ec.Equivalent to os << ec.category().name() << ':' << ec.value()."
        },
        "parametres": "   os   -   output stream to insert data to \n   ec   -   error code \n\n"
    },
    "make_error_code(std::errc)\n": {
        "description": {
            "texte": "Creates error code value for errc enum e.Equivalent to std::error_code(static_cast<int>(e), std::generic_category())."
        },
        "parametres": "   e   -   error code enum to create error code for \n\n"
    },
    "operator==,!=,<(std::error_condition)": {
        "description": {
            "texte": "Compares two error conditions."
        },
        "parametres": "   lhs, rhs   -   error conditions to compare \n\n"
    },
    "make_error_condition(std::errc)\n": {
        "description": {
            "texte": "Creates an error condition for an errc value e. Sets the error code to int(e) and error category to std::generic_category."
        },
        "parametres": "   e   -   standard error code \n\n",
        "exemple": {
            "input": "#include <system_error>\n#include <string>\n#include <iostream>\n \nint main()\n{\n    auto err = std::make_error_condition(std::errc::invalid_argument);\n    std::cout << err.message() << '\\n';\n}",
            "output": "Invalid argument"
        }
    },
    "make_pair": {
        "description": {
            "texte": "Creates a std::pair object, deducing the target type from the types of arguments."
        },
        "parametres": "   t, u   -   the values to construct the pair from \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <utility>\n#include <functional>\n \nint main()\n{\n    int n = 1;\n    int a[5] = {1, 2, 3, 4, 5};\n \n    // build a pair from two ints\n    auto p1 = std::make_pair(n, a[1]);\n    std::cout << \"The value of p1 is \"\n              << \"(\" << p1.first << \", \" << p1.second << \")\\n\";\n \n    // build a pair from a reference to int and an array (decayed to pointer)\n    auto p2 = std::make_pair(std::ref(n), a);\n    n = 7;\n    std::cout << \"The value of p2 is \"\n              << \"(\" << p2.first << \", \" << *(p2.second + 2) << \")\\n\";\n}",
            "output": "The value of p1 is (1, 2)\nThe value of p2 is (7, 3)"
        }
    },
    "operator==,!=,,>=(std::pair)": {
        "description": {
            "texte": "1) true if both lhs.first == rhs.first and lhs.second == rhs.second, otherwise false.2) !(lhs == rhs).3) If lhs.first<rhs.first, returns true. Otherwise, if rhs.first<lhs.first, returns false. Otherwise, if lhs.second<rhs.second, returns true. Otherwise, returns false.4) !(rhs < lhs).5) rhs < lhs.6) !(lhs < rhs)."
        },
        "parametres": "   lhs, rhs   -   pairs to compare \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <string>\n \nint main()\n{\n    std::vector<std::pair<int, std::string>> v = { {2, \"baz\"},\n                                                   {2, \"bar\"},\n                                                   {1, \"foo\"} };\n    std::sort(v.begin(), v.end());\n \n    for(auto p: v) {\n        std::cout << \"(\" << p.first << \",\" << p.second << \")\\n\";\n    }\n}",
            "output": "(1,foo)\n(2,bar)\n(2,baz)"
        }
    },
    "swap(std::pair)\n": {
        "description": {
            "texte": "Swaps the contents of x and y. Equivalent to x.swap(y)."
        },
        "parametres": "   x, y   -   pairs whose contents to swap \n\n"
    },
    "get(std::pair)\n": {
        "description": {
            "texte": "Extracts an element from the pair using tuple-like interface.The index-based overloads (1-4) fail to compile if the index I is neither 0 nor 1.The type-based overloads (5-12) fail to compile if the types T and U are the same."
        },
        "parametres": "   p   -   pair whose contents to extract \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <utility>\n \nint main()\n{\n    auto p = std::make_pair(1, 3.14);\n    std::cout << '(' << std::get<0>(p) << \", \" << std::get<1>(p) << \")\\n\";\n    std::cout << '(' << std::get<int>(p) << \", \" << std::get<double>(p) << \")\\n\";\n}",
            "output": "(1, 3.14)\n(1, 3.14)"
        }
    },
    "pointer_traits": {
        "description": {
            "texte": "The pointer_traits class template provides the standardized way to access certain properties of pointer-like types (fancy pointers, such as boost::interprocess::offset_ptr). The standard template std::allocator_traits relies on pointer_traits to determine the defaults for various typedefs required by Allocator.1) The non-specialized pointer_traits declares the following types:2) A specialization is provided for pointer types, T*, which declares the following types.3) A specialization for user-defined fancy pointer types may define an additional static member function."
        },
        "exemple": {
            "input": "#include <memory>\n#include <iostream>\n \ntemplate <class Ptr>\nstruct BlockList\n{\n   // Predefine a memory block \n   struct block;\n \n   // Define a pointer to a memory block from the kind of pointer Ptr s\n   // If Ptr is any kind of T*, block_ptr_t is block*\n   // If Ptr is smart_ptr<T>, block_ptr_t is smart_ptr<block>\n   using block_ptr_t = typename std::pointer_traits<Ptr>::template rebind<block>;\n \n   struct block\n   {\n      std::size_t size;\n      block_ptr_t next_block;\n   }; \n \n   block_ptr_t free_blocks;\n}; \n \nint main()\n{\n    BlockList<int*> bl1;\n    // The type of bl1.free_blocks is block*\n \n    BlockList<std::shared_ptr<char>> bl2;\n    // The type of bl2.free_blocks is std::shared_ptr<block>\n    std::cout << bl2.free_blocks.use_count() << '\\n';\n}",
            "output": "\u200b0\u200b"
        }
    },
    "pointer_safety": {
        "description": {
            "texte": "The scoped enumeration type pointer_safety lists the pointer safety modes supported by C++"
        }
    },
    "allocator_traits": {
        "description": {
            "texte": "The allocator_traits class template provides the standardized way to access various properties of Allocators. The standard containers and other standard library components access allocators through this template, which makes it possible to use any class type as an allocator, as long as the user-provided specialization of allocator_traits implements all required functionality.The default, non-specialized, allocator_traits contains the following members:"
        }
    },
    "allocator_arg_t": {
        "description": {
            "texte": "std::allocator_arg_t is an empty class type used to disambiguate the overloads of constructors and member functions of allocator-aware objects, including std::tuple, std::function, std::packaged_task,  (until C++17)and std::promise."
        }
    },
    "allocator_arg": {
        "description": {
            "texte": "std::allocator_arg is a constant of type std::allocator_arg_t used to disambiguate, at call site, the overloads of the constructors and member functions of allocator-aware objects, such as std::tuple, std::function, std::packaged_task,  (until C++17)and std::promise."
        }
    },
    "uses_allocator": {
        "description": {
            "texte": "Provides a specialization of the std::uses_allocator type trait for std::packaged_task."
        }
    },
    "raw_storage_iterator": {
        "description": {
            "texte": "The output iterator std::raw_storage_iterator makes it possible for standard algorithms to store results in uninitialized memory. Whenever the algorithm writes an object of type T to the dereferenced iterator, the object is copy-constructed into the location in the uninitialized storage pointed to by the iterator. The template parameter OutputIt is any type that meets the requirements of LegacyOutputIterator and has operator* defined to return an object, for which operator& returns an object of type T*. Usually, the type T* is used as OutputIt."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <memory>\n#include <algorithm>\n \nint main()\n{\n    const std::string s[] = {\"This\", \"is\", \"a\", \"test\", \".\"};\n    std::string* p = std::allocator<std::string>().allocate(5);\n \n    std::copy(std::begin(s), std::end(s),\n              std::raw_storage_iterator<std::string*, std::string>(p));\n \n    for(std::string* i = p; i!=p+5; ++i) {\n        std::cout << *i << '\\n';\n        i->~basic_string<char>();\n    }\n    std::allocator<std::string>().deallocate(p, 5);\n}",
            "output": "This\nis\na\ntest\n."
        }
    },
    "unique_ptr": {
        "description": {
            "texte": "std::unique_ptr is a smart pointer that owns and manages another object through a pointer and disposes of that object when the unique_ptr goes out of scope.The object is disposed of using the associated deleter when either of the following happens:The object is disposed of using a potentially user-supplied deleter by calling get_deleter()(ptr). The default deleter uses the delete operator, which destroys the object and deallocates the memory.A unique_ptr may alternatively own no object, in which case it is called empty.There are two versions of std::unique_ptr:The class satisfies the requirements of MoveConstructible and MoveAssignable, but not the requirements of either CopyConstructible or CopyAssignable."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <memory>\n#include <cstdio>\n#include <fstream>\n#include <cassert>\n#include <functional>\n \nstruct B {\n  virtual void bar() { std::cout << \"B::bar\\n\"; }\n  virtual ~B() = default;\n};\nstruct D : B\n{\n    D() { std::cout << \"D::D\\n\";  }\n    ~D() { std::cout << \"D::~D\\n\";  }\n    void bar() override { std::cout << \"D::bar\\n\";  }\n};\n \n// a function consuming a unique_ptr can take it by value or by rvalue reference\nstd::unique_ptr<D> pass_through(std::unique_ptr<D> p)\n{\n    p->bar();\n    return p;\n}\n \nvoid close_file(std::FILE* fp) { std::fclose(fp); }\n \nint main()\n{\n  std::cout << \"unique ownership semantics demo\\n\";\n  {\n      auto p = std::make_unique<D>(); // p is a unique_ptr that owns a D\n      auto q = pass_through(std::move(p)); \n      assert(!p); // now p owns nothing and holds a null pointer\n      q->bar();   // and q owns the D object\n  } // ~D called here\n \n  std::cout << \"Runtime polymorphism demo\\n\";\n  {\n    std::unique_ptr<B> p = std::make_unique<D>(); // p is a unique_ptr that owns a D\n                                                  // as a pointer to base\n    p->bar(); // virtual dispatch\n \n    std::vector<std::unique_ptr<B>> v;  // unique_ptr can be stored in a container\n    v.push_back(std::make_unique<D>());\n    v.push_back(std::move(p));\n    v.emplace_back(new D);\n    for(auto& p: v) p->bar(); // virtual dispatch\n  } // ~D called 3 times\n \n  std::cout << \"Custom deleter demo\\n\";\n  std::ofstream(\"demo.txt\") << 'x'; // prepare the file to read\n  {\n      std::unique_ptr<std::FILE, decltype(&close_file)> fp(std::fopen(\"demo.txt\", \"r\"),\n                                                           &close_file);\n      if(fp) // fopen could have failed; in which case fp holds a null pointer\n        std::cout << (char)std::fgetc(fp.get()) << '\\n';\n  } // fclose() called here, but only if FILE* is not a null pointer\n    // (that is, if fopen succeeded)\n \n  std::cout << \"Custom lambda-expression deleter demo\\n\";\n  {\n    std::unique_ptr<D, std::function<void(D*)>> p(new D, [](D* ptr)\n        {\n            std::cout << \"destroying from a custom deleter...\\n\";\n            delete ptr;\n        });  // p owns D\n    p->bar();\n  } // the lambda above is called and D is destroyed\n \n  std::cout << \"Array form of unique_ptr demo\\n\";\n  {\n      std::unique_ptr<D[]> p{new D[3]};\n  } // calls ~D 3 times\n}",
            "output": "unique ownership semantics demo\nD::D\nD::bar\nD::bar\nD::~D\nRuntime polymorphism demo\nD::D\nD::bar\nD::D\nD::D\nD::bar\nD::bar\nD::bar\nD::~D\nD::~D\nD::~D\nCustom deleter demo\nx\nCustom lambda-expression deleter demo\nD::D\nD::bar\ndestroying from a custom deleter...\nD::~D\nArray form of unique_ptr demo\nD::D\nD::D\nD::D\nD::~D\nD::~D\nD::~D"
        }
    },
    "weak_ptr": {
        "description": {
            "texte": "std::weak_ptr is a smart pointer that holds a non-owning (\"weak\") reference to an object that is managed by std::shared_ptr. It must be converted to std::shared_ptr in order to access the referenced object.std::weak_ptr models temporary ownership: when an object needs to be accessed only if it exists, and it may be deleted at any time by someone else, std::weak_ptr is used to track the object, and it is converted to std::shared_ptr to assume temporary ownership. If the original std::shared_ptr is destroyed at this time, the object's lifetime is extended until the temporary std::shared_ptr is destroyed as well.Another use for std::weak_ptr is to break reference cycles formed by objects managed by std::shared_ptr. If such cycle is orphaned (i,e. there are no outside shared pointers into the cycle), the shared_ptr reference counts cannot reach zero and the memory is leaked. To prevent this, one of the pointers in the cycle can be made weak."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nstd::weak_ptr<int> gw;\n \nvoid observe()\n{\n    std::cout << \"use_count == \" << gw.use_count() << \": \";\n    if (auto spt = gw.lock()) { // Has to be copied into a shared_ptr before usage\n        std::cout << *spt << \"\\n\";\n    }\n    else {\n        std::cout << \"gw is expired\\n\";\n    }\n}\n \nint main()\n{\n    {\n        auto sp = std::make_shared<int>(42);\n        gw = sp;\n \n        observe();\n    }\n \n    observe();\n}",
            "output": "use_count == 1: 42\nuse_count == 0: gw is expired"
        }
    },
    "auto_ptr": {
        "description": {
            "texte": "auto_ptr is a smart pointer that manages an object obtained via new expression and deletes that object when auto_ptr itself is destroyed. It may be used to provide exception safety for dynamically-allocated objects, for passing ownership of dynamically-allocated objects into functions and for returning dynamically-allocated objects from functions.Copying an auto_ptr copies the pointer and transfers ownership to the destination: both copy construction and copy assignment of auto_ptr modify their right hand arguments, and the \"copy\" is not equal to the original. Because of these unusual copy semantics, auto_ptr may not be placed in standard containers. std::unique_ptr is preferred for this and other uses. (since C++11).An additional class template auto_ptr_ref is referred to throughout the documentation. It is an implementation-defined type that holds a reference to auto_ptr. The implementation is allowed to provide the template with a different name or implement the functions returning it or accepting it as parameter in other ways."
        }
    },
    "atomic(std::shared_ptr)\n": {
        "description": {
            "texte": "The partial template specialization of std::atomic for std::shared_ptr<T> allows users to manipulate shared_ptr objects atomically.If multiple threads of execution access the same std::shared_ptr object without synchronization and any of those accesses uses a non-const member function of shared_ptr then a data race will occur unless all such access is performed through an instance of std::atomic<std::shared_ptr>> (or, deprecated as of C++20, through the standalone functions for atomic access to std::shared_ptr).Associated use_count increments are guaranteed to be part of the atomic operation. Associated use_count decrements are sequenced after the atomic operation, but are not required to be part of it, except for the use_count change when overriding expected in a failed CAS. Any associated deletion and deallocation are sequenced after the atomic update step and are not part of the atomic operation.Note that the control block of a shared_ptr is thread-safe: different non-atomic std::shared_ptr objects can be accessed using mutable operations, such as operator= or reset, simultaneously by multiple threads, even when these instances are copies, and share the same control block internally.The type T may be an incomplete type."
        }
    },
    "atomic(std::weak_ptr)\n": {
        "description": {
            "texte": "The partial template specialization of std::atomic for std::weak_ptr<T> allows users to manipulate weak_ptr objects atomically.If multiple threads of execution access the same std::weak_ptr object without synchronization and any of those accesses uses a non-const member function of weak_ptr then a data race will occur unless all such access is performed through an instance of std::atomic<std::weak_ptr>>.Associated use_count increments are guaranteed to be part of the atomic operation. Associated use_count decrements are sequenced after the atomic operation, but are not required to be part of it, except for the use_count change when overriding expected in a failed CAS. Any associated deletion and deallocation are sequenced after the atomic update step and are not part of the atomic operation.Note that the control block used by std::weak_ptr and std::shared_ptr is thread-safe: different non-atomic std::weak_ptr objects can be accessed using mutable operations, such as operator= or reset, simultaneously by multiple threads, even when these instances are copies or otherwise share the same control block internally.The type T may be an incomplete type."
        }
    },
    "owner_less": {
        "description": {
            "texte": "std::owner_less<> is a specialization of std::owner_less with parameter types deduced."
        },
        "parametres": "   lhs, rhs   -   shared-ownership pointers to compare \n\n"
    },
    "enable_shared_from_this": {
        "description": {
            "texte": "std::enable_shared_from_this allows an object t that is currently managed by a std::shared_ptr named pt to safely generate additional std::shared_ptr instances pt1, pt2, ... that all share ownership of t with pt.Publicly inheriting from std::enable_shared_from_this<T> provides the type T with a member function shared_from_this. If an object t of type T is managed by a std::shared_ptr<T> named pt, then calling T::shared_from_this will return a new std::shared_ptr<T> that shares ownership of t with pt."
        },
        "exemple": {
            "input": "#include <memory>\n#include <iostream>\n \nstruct Good: std::enable_shared_from_this<Good> // note: public inheritance\n{\n    std::shared_ptr<Good> getptr() {\n        return shared_from_this();\n    }\n};\n \nstruct Bad\n{\n    std::shared_ptr<Bad> getptr() {\n        return std::shared_ptr<Bad>(this);\n    }\n    ~Bad() { std::cout << \"Bad::~Bad() called\\n\"; }\n};\n \nint main()\n{\n    // Good: the two shared_ptr's share the same object\n    std::shared_ptr<Good> gp1 = std::make_shared<Good>();\n    std::shared_ptr<Good> gp2 = gp1->getptr();\n    std::cout << \"gp2.use_count() = \" << gp2.use_count() << '\\n';\n \n    // Bad: shared_from_this is called without having std::shared_ptr owning the caller \n    try {\n        Good not_so_good;\n        std::shared_ptr<Good> gp1 = not_so_good.getptr();\n    } catch(std::bad_weak_ptr& e) {\n        // undefined behavior (until C++17) and std::bad_weak_ptr thrown (since C++17)\n        std::cout << e.what() << '\\n';    \n    }\n \n    // Bad, each shared_ptr thinks it's the only owner of the object\n    std::shared_ptr<Bad> bp1 = std::make_shared<Bad>();\n    std::shared_ptr<Bad> bp2 = bp1->getptr();\n    std::cout << \"bp2.use_count() = \" << bp2.use_count() << '\\n';\n} // UB: double-delete of Bad",
            "output": "gp2.use_count() = 2\nbad_weak_ptr\nbp2.use_count() = 1\nBad::~Bad() called\nBad::~Bad() called\n*** glibc detected *** ./test: double free or corruption"
        }
    },
    "bad_weak_ptr": {
        "description": {
            "texte": "std::bad_weak_ptr is the type of the object thrown as exceptions by the constructors of std::shared_ptr that take std::weak_ptr as the argument, when the std::weak_ptr refers to an already deleted object."
        },
        "exemple": {
            "input": "#include <memory>\n#include <iostream>\nint main()\n{\n    std::shared_ptr<int> p1(new int(42));\n    std::weak_ptr<int> wp(p1);\n    p1.reset();\n    try {\n        std::shared_ptr<int> p2(wp);\n    } catch(const std::bad_weak_ptr& e) {\n        std::cout << e.what() << '\\n';\n    }\n}",
            "output": "std::bad_weak_ptr"
        }
    },
    "default_delete": {
        "description": {
            "texte": "std::default_delete is the default destruction policy used by std::unique_ptr when no deleter is specified.1) The non-specialized default_delete uses delete to deallocate memory for a single object.2) A partial specialization for array types that uses delete[] is also provided."
        },
        "parametres": "   d   -   a deleter to copy from \n\n",
        "exemple": {
            "input": "#include <memory>\n#include <vector>\n#include <algorithm>\n \nint main()\n{\n//    {\n//        std::shared_ptr<int> shared_bad(new int[10]);\n//    } // the destructor calls delete, undefined behavior\n \n    {\n        std::shared_ptr<int> shared_good(new int[10], std::default_delete<int[]>\n());\n    } // the destructor calls delete[], ok\n \n    {\n        std::unique_ptr<int> ptr(new int(5));\n    } // unique_ptr<int> uses default_delete<int>\n \n    {\n        std::unique_ptr<int[]> ptr(new int[10]);\n    } // unique_ptr<int[]> uses default_delete<int[]>\n \n   // default_delete can be used anywhere a delete functor is needed\n   std::vector<int*> v;\n   for(int n = 0; n < 100; ++n)\n      v.push_back(new int(n));\n   std::for_each(v.begin(), v.end(), std::default_delete<int>());\n}"
        }
    },
    "hash \n": {
        "description": {
            "texte": "The template specialization of std::hash for the std::variant template allows users to obtain hashes of variant objects.The specialization std::hash<std::variant<Types...>> is enabled (see std::hash) if every specialization in std::hash<std::remove_const_t<Types>>... is enabled, and is disabled otherwise.The member functions of this specialization are not guaranteed to be noexcept."
        }
    },
    "hash(std::shared_ptr)\n": {
        "description": {
            "texte": "The template specialization of std::hash for std::shared_ptr<T> allows users to obtain hashes of objects of type std::shared_ptr<T>.For a given std::shared_ptr<T> p, this specialization ensures that."
        }
    },
    "to_address": {
        "description": {
            "texte": "Obtain the address represented by p without forming a reference to the pointee."
        },
        "parametres": "   p   -   fancy or raw pointer \n\n",
        "exemple": {
            "input": "#include <memory>\n \ntemplate<class A>\nauto allocator_new(A& a)\n{\n    auto p = a.allocate(1);\n    try {\n        std::allocator_traits<A>::construct(a, std::to_address(p));\n    } catch (...) {\n        a.deallocate(p, 1);\n        throw;\n    }\n    return p;\n}\n \ntemplate<class A>\nvoid allocator_delete(A& a, typename std::allocator_traits<A>::pointer p)\n{\n    std::allocator_traits<A>::destroy(a, std::to_address(p));\n    a.deallocate(p, 1);\n}\n \nint main()\n{\n    std::allocator<int> a;\n    auto p = allocator_new(a);\n    allocator_delete(a, p);\n}"
        }
    },
    "align": {
        "description": {
            "texte": "Given a pointer ptr to a buffer of size space, returns a pointer aligned by the specified alignment for size number of bytes and decreases space argument by the number of bytes used for alignment. The first aligned address is returned.The function modifies the pointer only if it would be possible to fit the wanted number of bytes aligned by the given alignment into the buffer. If the buffer is too small, the function does nothing and returns nullptr.The behavior is undefined if alignment is not a power of two."
        },
        "parametres": "   alignment   -   the desired alignment \n   size   -   the size of the storage to be aligned \n   ptr   -   pointer to contiguous storage of at least space bytes \n   space   -   the size of the buffer in which to operate \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \ntemplate <std::size_t N>\nstruct MyAllocator\n{\n    char data[N];\n    void* p;\n    std::size_t sz;\n    MyAllocator() : p(data), sz(N) {}\n    template <typename T>\n    T* aligned_alloc(std::size_t a = alignof(T))\n    {\n        if (std::align(a, sizeof(T), p, sz))\n        {\n            T* result = reinterpret_cast<T*>(p);\n            p = (char*)p + sizeof(T);\n            sz -= sizeof(T);\n            return result;\n        }\n        return nullptr;\n    }\n};\n \nint main()\n{\n    MyAllocator<64> a;\n \n    // allocate a char\n    char* p1 = a.aligned_alloc<char>();\n    if (p1)\n        *p1 = 'a';\n    std::cout << \"allocated a char at \" << (void*)p1 << '\\n';\n \n    // allocate an int\n    int* p2 = a.aligned_alloc<int>();\n    if (p2)\n        *p2 = 1;\n    std::cout << \"allocated an int at \" << (void*)p2 << '\\n';\n \n    // allocate an int, aligned at 32-byte boundary\n    int* p3 = a.aligned_alloc<int>(32);\n    if (p3)\n        *p3 = 2;\n    std::cout << \"allocated an int at \" << (void*)p3 << \" (32 byte alignment)\\n\";\n}",
            "output": "allocated a char at 0x2ff21a08\nallocated an int at 0x2ff21a0c\nallocated an int at 0x2ff21a20 (32 byte alignment)"
        }
    },
    "assume_aligned": {
        "description": {
            "texte": "Informs the implementation that the object ptr points to is aligned to at least N. The implementation may use this information to generate more efficient code, but it might only make this assumption if the object is accessed via the return value of assume_aligned.The program is ill-formed if N is not a power of 2. The behavior is undefined if ptr does not point to an object of type T (ignoring cv-qualification at every level), or if the object's alignment is not at least N."
        }
    },
    "declare_reachable": {
        "description": {
            "texte": "Declares the object referenced by the pointer p reachable. Reachable objects will not be deleted by the garbage collector or considered to be a leak by a leak detector even if all pointers to it are destroyed. An object may be declared reachable multiple times, in which case multiple calls to std::undeclare_reachable would be needed to remove this property. For example, a XOR linked list needs to declare its nodes reachable if the implementation has garbage collection enabled."
        },
        "parametres": "   p   -   a safely-derived pointer or a null pointer \n\n"
    },
    "undeclare_reachable": {
        "description": {
            "texte": "Removes the reachable status of the object, referenced by the pointer p, if it was previously set by std::declare_reachable. If the object was declared reachable multiple times, equal number of calls to undeclare_reachable would be needed to remove this status. Once the object is not declared reachable and has no pointers referencing it, it may be reclaimed by garbage collector or reported as a leak by a leak detector."
        },
        "parametres": "   p   -   a pointer to an object previously declared reachable and not destructed since then \n\n"
    },
    "declare_no_pointers": {
        "description": {
            "texte": "Informs the garbage collector or leak detector that the specified memory region (n bytes beginning at the byte pointed to by p) contains no traceable pointers. If any part of the region is within an allocated object, the entire region must be contained in the same object."
        },
        "parametres": "   p   -   pointer to the beginning of the range \n   n   -   the number of bytes in the range \n\n"
    },
    "undeclare_no_pointers": {
        "description": {
            "texte": "Unregisters a range earlier registered with std::declare_no_pointers()."
        },
        "parametres": "   p   -   pointer to the beginning of the range previosly registered with std::declare_no_pointers \n   n   -   the number of bytes in the range, same value as previously used with std::declare_no_pointers \n\n"
    },
    "get_pointer_safety": {
        "description": {
            "texte": "Obtains the implementation-defined pointer safety model, which is a value of type std::pointer_safety."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nint main()\n{\n    std::cout << \"Pointer safety: \";\n    switch (std::get_pointer_safety()) {\n        case std::pointer_safety::strict:    std::cout << \"strict\\n\"; break;\n        case std::pointer_safety::preferred: std::cout << \"preferred\\n\"; break;\n        case std::pointer_safety::relaxed:   std::cout << \"relaxed\\n\"; break;\n    }\n}",
            "output": "Pointer safety: relaxed"
        }
    },
    "get_temporary_buffer": {
        "description": {
            "texte": "Allocates uninitialized contiguous storage, which should be sufficient to store up to count adjacent objects of type T. The request is non-binding and the implementation may allocate less or more than necessary to store count adjacent objects."
        },
        "parametres": "   count   -   the desired number of objects \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <iterator>\n \nint main()\n{\n    const std::string s[] = {\"string\", \"1\", \"test\", \"...\"};\n    const auto p = std::get_temporary_buffer<std::string>(4);\n    // requires that p.first is passed to return_temporary_buffer\n    // (beware of early exit points and exceptions)\n \n    std::copy(s, s + p.second,\n              std::raw_storage_iterator<std::string*, std::string>(p.first));\n    // requires that each string in p is individually destroyed\n    // (beware of early exit points and exceptions)\n \n    std::copy(p.first, p.first + p.second,\n              std::ostream_iterator<std::string>{std::cout, \"\\n\"});\n \n    std::for_each(p.first, p.first + p.second, [](std::string& e) {\n        e.~basic_string<char>();\n    });\n \n    std::return_temporary_buffer(p.first);\n}",
            "output": "string\n1\ntest\n..."
        }
    },
    "return_temporary_buffer": {
        "description": {
            "texte": "Deallocates storage previously allocated with std::get_temporary_buffer."
        },
        "parametres": "   p   -   the pointer previously returned by std::get_temporary_buffer and not invalidated by an earlier call to return_temporary_buffer \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <iterator>\n \nint main()\n{\n    const std::string s[] = {\"string\", \"1\", \"test\", \"...\"};\n    const auto p = std::get_temporary_buffer<std::string>(4);\n    // requires that p.first is passed to return_temporary_buffer\n    // (beware of early exit points and exceptions)\n \n    std::copy(s, s + p.second,\n              std::raw_storage_iterator<std::string*, std::string>(p.first));\n    // requires that each string in p is individually destroyed\n    // (beware of early exit points and exceptions)\n \n    std::copy(p.first, p.first + p.second,\n              std::ostream_iterator<std::string>{std::cout, \"\\n\"});\n \n    std::for_each(p.first, p.first + p.second, [](std::string& e) {\n        e.~basic_string<char>();\n    });\n \n    std::return_temporary_buffer(p.first);\n}",
            "output": "string\n1\ntest\n..."
        }
    },
    "make_unique, std::make_unique_default_init": {
        "description": {
            "texte": "Constructs an object of type T and wraps it in a std::unique_ptr."
        },
        "parametres": "   args   -   list of arguments with which an instance of T will be constructed. \n   size   -   the size of the array to construct \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nstruct Vec3\n{\n    int x, y, z;\n    Vec3() : x(0), y(0), z(0) { }\n    Vec3(int x, int y, int z) :x(x), y(y), z(z) { }\n    friend std::ostream& operator<<(std::ostream& os, Vec3& v) {\n        return os << '{' << \"x:\" << v.x << \" y:\" << v.y << \" z:\" << v.z  << '}';\n    }\n};\n \nint main()\n{\n    // Use the default constructor.\n    std::unique_ptr<Vec3> v1 = std::make_unique<Vec3>();\n    // Use the constructor that matches these arguments\n    std::unique_ptr<Vec3> v2 = std::make_unique<Vec3>(0, 1, 2);\n    // Create a unique_ptr to an array of 5 elements\n    std::unique_ptr<Vec3[]> v3 = std::make_unique<Vec3[]>(5);\n \n    std::cout << \"make_unique<Vec3>():      \" << *v1 << '\\n'\n              << \"make_unique<Vec3>(0,1,2): \" << *v2 << '\\n'\n              << \"make_unique<Vec3[]>(5):   \" << '\\n';\n    for (int i = 0; i < 5; i++) {\n        std::cout << \"     \" << v3[i] << '\\n';\n    }\n}",
            "output": "make_unique<Vec3>():      {x:0 y:0 z:0}\nmake_unique<Vec3>(0,1,2): {x:0 y:1 z:2}\nmake_unique<Vec3[]>(5):   \n     {x:0 y:0 z:0}\n     {x:0 y:0 z:0}\n     {x:0 y:0 z:0}\n     {x:0 y:0 z:0}\n     {x:0 y:0 z:0}"
        }
    },
    "operator==,!=,,>=(std::unique_ptr)\n": {
        "description": {
            "texte": "Compares the pointer values of two unique_ptrs, or a unique_ptr and nullptr."
        },
        "parametres": "   x, y   -   unique_ptrs to compare \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nint main() \n{\n    std::unique_ptr<int> p1(new int(42));\n    std::unique_ptr<int> p2(new int(42));\n \n    std::cout << \"p1 == p1: \" << (p1 == p1) << '\\n';\n \n    // p1 and p2 point to different memory locations, so p1 != p2\n    std::cout << \"p1 == p2: \" << (p1 == p2) << '\\n';\n}",
            "output": "p1 == p1: 1\np1 == p2: 0"
        }
    },
    "make_shared, std::make_shared_default_init": {
        "description": {
            "texte": "In each case, the object (or individual elements if T is an array type) (since C++20) will be destroyed by p->~X(), where p is a pointer to the object and X is its type."
        },
        "parametres": "   args   -   list of arguments with which an instance of T will be constructed. \n   N   -   array size to use \n   u   -   the initial value to initialize every element of the array \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n#include <type_traits>\n \nstruct C\n{\n  C(int i) : i(i) {} //< constructor needed (until C++20)\n  int i;\n};\n \nint main()\n{\n    auto sp = std::make_shared<C>(12);\n \n    static_assert(std::is_same_v<decltype(sp), std::shared_ptr<C>>);\n \n    std::cout << sp->i << '\\n';\n}",
            "output": "12"
        }
    },
    "allocate_shared, std::allocate_shared_default_init": {
        "description": {
            "texte": "For allocate_shared, the object (or the individual array elements for (2-5)) (since C++20) are destroyed via the expression std::allocator_traits<A2>::destroy(a, p), where p is a pointer to the object and a is a copy of the allocator passed to allocate_shared, rebound to the type of the object being destroyed."
        },
        "parametres": "   alloc   -   The Allocator to use. \n   args...   -   list of arguments with which an instance of T will be constructed. \n   N   -   array size to use \n   u   -   the initial value to initialize every element of the array \n\n"
    },
    "static_pointer_cast, std::dynamic_pointer_cast, std::const_pointer_cast, std::reinterpret_pointer_cast": {
        "description": {
            "texte": "Creates a new instance of std::shared_ptr whose stored pointer is obtained from r's stored pointer using a cast expression.If r is empty, so is the new shared_ptr (but its stored pointer is not necessarily null). Otherwise, the new shared_ptr will share ownership with the initial value of r, except that it is empty if the dynamic_cast performed by dynamic_pointer_cast returns a null pointer.Let Y be typename std::shared_ptr<T>::element_type, then the resulting std::shared_ptr's stored pointer will be obtained by evaluating, respectively:The behavior of these functions is undefined unless the corresponding cast from U* to T* is well formed:"
        },
        "parametres": "   r   -   The pointer to convert \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nstruct Base \n{ \n    int a; \n    virtual void f() const { std::cout << \"I am base!\\n\";}\n    virtual ~Base(){}\n};\n \nstruct Derived : Base\n{\n    void f() const override\n    { std::cout << \"I am derived!\\n\"; }\n    ~Derived(){}\n};\n \nint main(){\n    auto basePtr = std::make_shared<Base>();\n    std::cout << \"Base pointer says: \";\n    basePtr->f();\n \n    auto derivedPtr = std::make_shared<Derived>();\n    std::cout << \"Derived pointer says: \";\n    derivedPtr->f();\n \n    // static_pointer_cast to go up class hierarchy\n    basePtr = std::static_pointer_cast<Base>(derivedPtr);\n    std::cout << \"Base pointer to derived says: \";\n    basePtr->f();\n \n    // dynamic_pointer_cast to go down/across class hierarchy\n    auto downcastedPtr = std::dynamic_pointer_cast<Derived>(basePtr);\n    if(downcastedPtr)\n    { \n        std::cout << \"Downcasted pointer says: \";\n        downcastedPtr->f(); \n    }\n \n    // All pointers to derived share ownership\n    std::cout << \"Pointers to underlying derived: \" \n            << derivedPtr.use_count() \n            << \"\\n\"; \n}",
            "output": "Base pointer says: I am base!\nDerived pointer says: I am derived!\nBase pointer to derived says: I am derived!\nDowncasted pointer says: I am derived!\nPointers to underlying derived: 3"
        }
    },
    "get_deleter": {
        "description": {
            "texte": "Access to the p's deleter. If the shared pointer p owns a deleter of type cv-unqualified Deleter (e.g. if it was created with one of the constructors that take a deleter as a parameter), then returns a pointer to the deleter. Otherwise, returns a null pointer."
        },
        "parametres": "   p   -   a shared pointer whose deleter needs to be accessed \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nstruct Foo { int i; };\nvoid foo_deleter(Foo * p)\n{\n    std::cout << \"foo_deleter called!\\n\";\n    delete p;\n}\n \nint main()\n{\n    std::shared_ptr<int> aptr;\n \n    {\n        // create a shared_ptr that owns a Foo and a deleter\n        auto foo_p = new Foo;\n        std::shared_ptr<Foo> r(foo_p, foo_deleter);\n        aptr = std::shared_ptr<int>(r, &r->i); // aliasing ctor\n        // aptr is now pointing to an int, but managing the whole Foo\n    } // r gets destroyed (deleter not called)\n \n    // obtain pointer to the deleter:\n    if(auto del_p = std::get_deleter<void(*)(Foo*)>(aptr))\n    {\n        std::cout << \"shared_ptr<int> owns a deleter\\n\";\n        if(*del_p == foo_deleter)\n            std::cout << \"...and it equals &foo_deleter\\n\";\n    } else\n        std::cout << \"The deleter of shared_ptr<int> is null!\\n\";\n} // deleter called here",
            "output": "shared_ptr<int> owns a deleter\n...and it equals &foo_deleter\nfoo_deleter called!"
        }
    },
    "shared_ptr::operator==, !=, , >=": {
        "description": {
            "texte": "Compares two shared_ptr<T> objects or compares shared_ptr<T> with a null pointer.Note that the comparison operators for shared_ptr simply compare pointer values; the actual objects pointed to are not compared. Having operator< defined for shared_ptr allows shared_ptrs to be used as keys in associative containers, like std::map and std::set."
        },
        "parametres": "   lhs   -   the left-hand shared_ptr to compare \n   rhs   -   the right-hand shared_ptr to compare \n\n"
    },
    "shared_ptr::operator<<": {
        "description": {
            "texte": "Inserts the value of the pointer stored in ptr into the output stream os.Equivalent to os << ptr.get()."
        },
        "parametres": "   os   -   a std::basic_ostream to insert ptr into \n   ptr   -   the data to be inserted into os \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nclass Foo {};\n \nint main()\n{\n    auto sp = std::make_shared<Foo>();\n    std::cout << sp << '\\n';\n    std::cout << sp.get() << '\\n';\n}",
            "output": "0x6d9028\n0x6d9028"
        }
    },
    "swap(std::unique_ptr)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::unique_ptr. Swaps the pointers of lhs and rhs. Calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   smart pointers whose contents to swap \n\n"
    },
    "swap(std::weak_ptr)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::weak_ptr. Swaps the pointers of lhs and rhs. Calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   smart pointers whose contents to swap \n\n"
    },
    "swap(std::shared_ptr)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::shared_ptr. Swaps the pointers of lhs and rhs. Calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   smart pointers whose contents to swap \n\n"
    },
    "atomic_...\n": {
        "description": {
            "texte": "If multiple threads of execution access the same std::shared_ptr object without synchronization and any of those accesses uses a non-const member function of shared_ptr then a data race will occur unless all such access is performed through these functions, which are overloads of the corresponding atomic access functions (std::atomic_load, std::atomic_store, etc.).Note that the control block of a shared_ptr is thread-safe: different std::shared_ptr objects can be accessed using mutable operations, such as operator= or reset, simultaneously by multiple threads, even when these instances are copies, and share the same control block internally.All these functions invoke undefined behavior if p is a null pointer."
        },
        "parametres": "   p, expected   -   a pointer to a std::shared_ptr \n   r, desired   -   a std::shared_ptr \n   mo, success, failure   -   memory ordering selectors of type std::memory_order \n\n"
    },
    "pmr::polymorphic_allocator": {
        "description": {
            "texte": "The class template std::pmr::polymorphic_allocator is an Allocator whose allocation behavior depends on the memory resource it is constructed with. Thus, different instances of polymorphic_allocator can exhibit entirely different allocation behavior. This runtime polymorphism allows objects using polymorphic_allocator to behave as if they used different allocator types at run time despite the identical static allocator type.All specializations of polymorphic_allocator meet the Allocator completeness requirements."
        }
    },
    "pmr::pool_options": {
        "description": {
            "texte": "std::pmr::pool_options is a set of constructor options for pool resources including std::pmr::synchronized_pool_resource and std::pmr::unsynchronized_pool_resource."
        }
    },
    "pmr::synchronized_pool_resource": {
        "description": {
            "texte": "The class std::pmr::synchronized_pool_resource is a general-purpose memory resource class with the following properties:synchronized_pool_resource may be accessed from multiple threads without external synchronization, and may have thread-specific pools to reduce synchronization costs. If the memory resource is only accessed from one thread, unsynchronized_pool_resource is more efficient."
        }
    },
    "pmr::unsynchronized_pool_resource": {
        "description": {
            "texte": "The class std::pmr::unsynchronized_pool_resource is a general-purpose memory resource class with the following properties:unsynchronized_pool_resource is not thread-safe, and cannot be accessed from multiple threads simultaneously; use synchronized_pool_resource if access from multiple threads is required."
        }
    },
    "pmr::monotonic_buffer_resource": {
        "description": {
            "texte": "The class std::pmr::monotonic_buffer_resource is a special-purpose memory resource class that releases the allocated memory only when the resource is destroyed. It is intended for very fast memory allocations in situations where memory is used to build up a few objects and then is released all at once.monotonic_buffer_resource can be constructed with an initial buffer. If there is no initial buffer, or if the buffer is exhausted, additional buffers are obtained from an upstream memory resource supplied at construction. The size of buffers obtained follows a geometric progression.monotonic_buffer_resource is not thread-safe."
        }
    },
    "pmr::new_delete_resource": {
        "description": {
            "texte": "Returns a pointer to a memory_resource that uses the global operator new and operator delete to allocate memory."
        }
    },
    "pmr::null_memory_resource": {
        "description": {
            "texte": "Returns a pointer to a memory_resource that doesn't perform any allocation."
        }
    },
    "pmr::get_default_resource": {
        "description": {
            "texte": "Gets the default memory resource pointer.The default memory resource pointer is used by certain facilities when an explicit memory resource is not supplied. The initial default memory resource pointer is the return value of std::pmr::new_delete_resource.This function is thread-safe. Previous call to std::pmr::set_default_resource synchronizes with (see std::memory_order) the subsequent std::pmr::get_default_resource calls."
        }
    },
    "pmr::set_default_resource": {
        "description": {
            "texte": "If r is not null, sets the default memory resource pointer to r; otherwise, sets the default memory resource pointer to std::pmr::new_delete_resource().The default memory resource pointer is used by certain facilities when an explicit memory resource is not supplied. The initial default memory resource pointer is the return value of std::pmr::new_delete_resource.This function is thread-safe. Every call to std::pmr::set_default_resource synchronizes with (see std::memory_order) the subsequent std::pmr::set_default_resource and std::pmr::get_default_resource calls."
        }
    },
    "operator==,!=(std::scoped_allocator_adaptor)": {
        "description": {
            "texte": "Compares two scoped allocator adaptors. Two such allocators are equal if:"
        },
        "parametres": "   lhs, rhs   -   scoped allocator adaptors to compare \n\n"
    },
    "hash (std::bitset)\n": {
        "description": {
            "texte": "The template specialization of std::hash for std::bitset<N> allows users to obtain hashes of objects of type std::bitset<N>."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <bitset>\n#include <functional>\n \nint main()\n{\n    std::bitset<4> b1(1);\n    std::bitset<4> b2(2);\n    std::bitset<4> b3(b2);\n \n    std::hash<std::bitset<4>> hash_fn;\n \n    size_t h1 = hash_fn(b1);\n    size_t h2 = hash_fn(b2);\n    size_t h3 = hash_fn(b3);\n \n    std::cout << h1 << '\\n';\n    std::cout << h2 << '\\n';\n    std::cout << h3 << '\\n';\n}",
            "output": "67918732\n118251589\n118251589"
        }
    },
    "operator&,|,^(std::bitset)\n": {
        "description": {
            "texte": "Performs binary AND, OR, and XOR between two bitsets, lhs and rhs."
        },
        "parametres": "   lhs   -   the bitset on the left-hand side of the operator \n   rhs   -   the bitset on the right-hand side of the operator \n\n",
        "exemple": {
            "input": "#include <bitset>\n#include <iostream>\n \nint main()\n{\n    std::bitset<4> b1(\"0110\");\n    std::bitset<4> b2(\"0011\");\n    std::cout << \"b1 & b2: \" << (b1 & b2) << '\\n';\n    std::cout << \"b1 | b2: \" << (b1 | b2) << '\\n';\n    std::cout << \"b1 ^ b2: \" << (b1 ^ b2) << '\\n';\n}",
            "output": "b1 & b2: 0010\nb1 | b2: 0111\nb1 ^ b2: 0101"
        }
    },
    "operator>(std::bitset)\n": {
        "description": {
            "texte": "Inserts or extracts a bitset from a character stream.Characters are extracted until either.If no characters are extracted, is.setstate(ios_base::failbit) is called."
        },
        "parametres": "   os   -   the character stream to write to \n   is   -   the character stream to read from \n   x   -   the bitset to be read or written \n\n",
        "exemple": {
            "input": "#include <bitset>\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::string bit_string = \"001101\";\n    std::istringstream bit_stream(bit_string);\n \n    std::bitset<3> b1;\n    bit_stream >> b1; // reads \"001\", stream still holds \"101\"\n    std::cout << b1 << '\\n';\n \n    std::bitset<8> b2;\n    bit_stream >> b2; // reads \"101\", populates the 8-bit set as \"00000101\"\n    std::cout << b2 << '\\n';\n}",
            "output": "001\n00000101"
        }
    },
    "tuple_size\n": {
        "description": {
            "texte": " The partial specialization of std::tuple_size for pairs provides a compile-time way to obtain the number of elements in a pair, which is always 2, using tuple-like syntax."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <utility>\n#include <tuple>\n \ntemplate<class T>\nvoid test(T t)\n{\n    int a[std::tuple_size<T>::value]; // can be used at compile time\n    std::cout << std::tuple_size<T>::value << '\\n'; // or at run time\n}\n \nint main()\n{\n    test(std::make_tuple(1, 2, 3.14));\n    test(std::make_pair(1, 3.14));\n}",
            "output": "3\n2"
        }
    },
    "tuple_element": {
        "description": {
            "texte": "Provides compile-time indexed access to the type of the elements of the span using tuple-like interface. The program is ill-formed if I >= N or if N == std::dynamic_extent."
        }
    },
    "uses_allocator\n": {
        "description": {
            "texte": "This specialization of std::uses_allocator informs other library components that all objects of type std::function support uses-allocator construction, even though they do not have a nested allocator_type."
        }
    },
    "ignore": {
        "description": {
            "texte": "An object of unspecified type such that any value can be assigned to it with no effect. Intended for use with std::tie when unpacking a std::tuple, as a placeholder for the arguments that are not used."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <set>\n#include <tuple>\n \nint main()\n{\n    std::set<std::string> set_of_str;\n    bool inserted = false;\n    std::tie(std::ignore, inserted) = set_of_str.insert(\"Test\");\n    if (inserted) {\n        std::cout << \"Value was inserted successfully\\n\";\n    }\n}",
            "output": "Value was inserted successfully"
        }
    },
    "tie": {
        "description": {
            "texte": "Creates a tuple of lvalue references to its arguments or instances of std::ignore."
        },
        "parametres": "   args   -   zero or more lvalue arguments to construct the tuple from \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <set>\n#include <tuple>\n \nstruct S {\n    int n;\n    std::string s;\n    float d;\n    bool operator<(const S& rhs) const\n    {\n        // compares n to rhs.n,\n        // then s to rhs.s,\n        // then d to rhs.d\n        return std::tie(n, s, d) < std::tie(rhs.n, rhs.s, rhs.d);\n    }\n};\n \nint main()\n{\n    std::set<S> set_of_s; // S is LessThanComparable\n \n    S value{42, \"Test\", 3.14};\n    std::set<S>::iterator iter;\n    bool inserted;\n \n    // unpacks the return value of insert into iter and inserted\n    std::tie(iter, inserted) = set_of_s.insert(value);\n \n    if (inserted)\n        std::cout << \"Value was inserted successfully\\n\";\n}",
            "output": "Value was inserted successfully"
        }
    },
    "make_tuple": {
        "description": {
            "texte": "Creates a tuple object, deducing the target type from the types of arguments.For each Ti in Types..., the corresponding type Vi in VTypes... is std::decay<Ti>::type unless application of std::decay results in std::reference_wrapper<X> for some type X, in which case the deduced type is X&."
        },
        "parametres": "   args   -   zero or more arguments to construct the tuple from \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <tuple>\n#include <functional>\n \nstd::tuple<int, int> f() // this function returns multiple values\n{\n    int x = 5;\n    return std::make_tuple(x, 7); // return {x,7}; in C++17\n}\n \nint main()\n{\n    // heterogeneous tuple construction\n    int n = 1;\n    auto t = std::make_tuple(10, \"Test\", 3.14, std::ref(n), n);\n    n = 7;\n    std::cout << \"The value of t is \"  << \"(\"\n              << std::get<0>(t) << \", \" << std::get<1>(t) << \", \"\n              << std::get<2>(t) << \", \" << std::get<3>(t) << \", \"\n              << std::get<4>(t) << \")\\n\";\n \n    // function returning multiple values\n    int a, b;\n    std::tie(a, b) = f();\n    std::cout << a << \" \" << b << \"\\n\";\n}",
            "output": "The value of t is (10, Test, 3.14, 7, 1)\n5 7"
        }
    },
    "forward_as_tuple": {
        "description": {
            "texte": "Constructs a tuple of references to the arguments in args suitable for forwarding as an argument to a function. The tuple has rvalue reference data members when rvalues are used as arguments, and otherwise has lvalue reference data members."
        },
        "parametres": "   args   -   zero or more arguments to construct the tuple from \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <map>\n#include <tuple>\n#include <string>\n \nint main()\n{\n    std::map<int, std::string> m;\n \n    m.emplace(std::piecewise_construct,\n              std::forward_as_tuple(10),\n              std::forward_as_tuple(20, 'a'));\n    std::cout << \"m[10] = \" << m[10] << '\\n';\n \n    // The following is an error: it produces a\n    // std::tuple<int&&, char&&> holding two dangling references.\n    //\n    // auto t = std::forward_as_tuple(20, 'a');\n    // m.emplace(std::piecewise_construct, std::forward_as_tuple(10), t);\n}",
            "output": "m[10] = aaaaaaaaaaaaaaaaaaaa"
        }
    },
    "tuple_cat": {
        "description": {
            "texte": "Constructs a tuple that is a concatenation of all tuples in args."
        },
        "parametres": "   args   -   zero or more tuples to concatenate \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <tuple>\n#include <string>\n \n// helper function to print a tuple of any size\ntemplate<class Tuple, std::size_t N>\nstruct TuplePrinter {\n    static void print(const Tuple& t) \n    {\n        TuplePrinter<Tuple, N-1>::print(t);\n        std::cout << \", \" << std::get<N-1>(t);\n    }\n};\n \ntemplate<class Tuple>\nstruct TuplePrinter<Tuple, 1> {\n    static void print(const Tuple& t) \n    {\n        std::cout << std::get<0>(t);\n    }\n};\n \ntemplate<class... Args>\nvoid print(const std::tuple<Args...>& t) \n{\n    std::cout << \"(\";\n    TuplePrinter<decltype(t), sizeof...(Args)>::print(t);\n    std::cout << \")\\n\";\n}\n// end helper function\n \nint main()\n{\n    std::tuple<int, std::string, float> t1(10, \"Test\", 3.14);\n    int n = 7;\n    auto t2 = std::tuple_cat(t1, std::make_pair(\"Foo\", \"bar\"), t1, std::tie(n));\n    n = 10;\n    print(t2);\n}",
            "output": "(10, Test, 3.14, Foo, bar, 10, Test, 3.14, 10)"
        }
    },
    "get(std::tuple)\n": {
        "description": {
            "texte": "A reference to the selected element of t."
        },
        "parametres": "   t   -   tuple whose contents to extract \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <tuple>\n \nint main()\n{\n    auto t = std::make_tuple(1, \"Foo\", 3.14);\n    // index-based access\n    std::cout << \"(\" << std::get<0>(t) << \", \" << std::get<1>(t)\n              << \", \" << std::get<2>(t) << \")\\n\";\n    // type-based access\n    std::cout << \"(\" << std::get<int>(t) << \", \" << std::get<const char*>(t)\n              << \", \" << std::get<double>(t) << \")\\n\";\n    // Note: std::tie and structured binding may also be used to decompose a tuple\n}",
            "output": "(1, Foo, 3.14)\n(1, Foo, 3.14)"
        }
    },
    "operator==,!=,,>=(std::tuple)": {
        "description": {
            "texte": "1-2) Compares every element of the tuple lhs with the corresponding element of the tuple rhs.3-6) Compares lhs and rhs lexicographically, that is, compares the first elements, if they are equivalent, compares the second elements, if those are equivalent, compares the third elements, and so on.All comparison operators are short-circuited; they do not access tuple elements beyond what is necessary to determine the result of the comparison."
        },
        "parametres": "   lhs, rhs   -   tuples to compare \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <tuple>\n#include <vector>\n#include <algorithm>\nint main()\n{\n    std::vector<std::tuple<int, std::string, float>> v;\n    v.emplace_back(2, \"baz\", -0.1);\n    v.emplace_back(2, \"bar\", 3.14);\n    v.emplace_back(1, \"foo\", 100.1);\n    std::sort(v.begin(), v.end());\n \n    for(auto p: v) {\n        std::cout << \"(\" << std::get<0>(p) << \", \" << std::get<1>(p)\n                  << \", \" << std::get<2>(p) << \")\\n\";\n    }\n}",
            "output": "(1, foo, 100.1)\n(2, bar, 3.14)\n(2, baz, -0.1)"
        }
    },
    "swap(std::tuple)\n": {
        "description": {
            "texte": "Swaps the contents of lhs and rhs. Equivalent to lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   tuples whose contents to swap \n\n"
    },
    "bad_optional_access": {
        "description": {
            "texte": "Defines a type of object to be thrown by std::optional::value when accessing an optional object that does not contain a value."
        }
    },
    "nullopt_t": {
        "description": {
            "texte": "std::nullopt_t is an empty class type used to indicate optional type with uninitialized state. In particular, std::optional has a constructor with nullopt_t as a single argument, which creates an optional that does not contain a value.std::nullopt_t must be a non-aggregate LiteralType and cannot have a default constructor or an initializer-list constructor.It must have a constexpr constructor that takes some implementation-defined literal type."
        }
    },
    "nullopt": {
        "description": {
            "texte": "std::nullopt is a constant of type std::nullopt_t that is used to indicate optional type with uninitialized state."
        }
    },
    "operator==, !=, , >=(std::optional)": {
        "description": {
            "texte": "Performs comparison operations on optional objects."
        },
        "parametres": "   lhs, rhs, opt   -   an optional object to compare \n   value   -   value to compare to the contained value \n\n"
    },
    "swap(std::optional)": {
        "description": {
            "texte": "Overloads the std::swap algorithm for std::optional. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs).This function template does not participate in overload resolution unless std::is_move_constructible_v<T> and std::is_swappable_v<T> are both true."
        },
        "parametres": "   lhs, rhs   -   optional objects whose states to swap \n\n"
    },
    "make_optional": {
        "description": {
            "texte": "The constructed optional object."
        },
        "parametres": "   value   -   the value to construct optional object with \n   il, args   -   arguments to be passed to the constructor of T. \n\n"
    },
    "swap(std::any)": {
        "description": {
            "texte": "Overloads the std::swap algorithm for std::any. Swaps the content of two any objects by calling lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   objects to swap \n\n"
    },
    "any_cast": {
        "description": {
            "texte": "Performs type-safe access to the contained object.Let U be std::remove_cv_t<std::remove_reference_t<T>>."
        },
        "parametres": "   operand   -   target any object \n\n",
        "exemple": {
            "input": "#include <string>\n#include <iostream>\n#include <any>\n#include <utility>\n \nint main()\n{\n    // simple example \n \n    auto a = std::any(12);\n \n    std::cout << std::any_cast<int>(a) << '\\n'; \n \n    try {\n        std::cout << std::any_cast<std::string>(a) << '\\n';\n    }\n    catch(const std::bad_any_cast& e) {\n        std::cout << e.what() << '\\n';\n    }\n \n    // pointer example\n \n    if (int* i = std::any_cast<int>(&a)) {\n       std::cout << \"a is int: \" << *i << '\\n';\n    } else if (std::string* s = std::any_cast<std::string>(&a)) {\n       std::cout << \"a is std::string: \" << *s << '\\n';\n    } else {\n       std::cout << \"a is another type or unset\\n\";\n    }\n \n    // advanced example\n \n    a = std::string(\"hello\");\n \n    auto& ra = std::any_cast<std::string&>(a); //< reference\n    ra[1] = 'o';\n \n    std::cout << \"a: \"\n        << std::any_cast<const std::string&>(a) << '\\n'; //< const reference\n \n    auto b = std::any_cast<std::string&&>(std::move(a)); //< rvalue reference\n \n    // Note: 'b' is a move-constructed std::string,\n    // 'a' is left in valid but unspecified state\n \n    std::cout << \"a: \" << *std::any_cast<std::string>(&a) //< pointer\n        << \"b: \" << b << '\\n';\n}",
            "output": "12\nbad any_cast\na is int: 12\na: hollo\na: b: hollo"
        }
    },
    "monostate": {
        "description": {
            "texte": "Unit type intended for use as a well-behaved empty alternative in std::variant. In particular, a variant of non-default-constructible types may list std::monostate as its first alternative: this makes the variant itself default-constructible."
        },
        "exemple": {
            "input": "#include <variant>\n#include <iostream>\n \nstruct S\n{\n    S(int i) : i(i) {}\n    int i;\n};\n \nint main() {\n \n    // Without the monostate type this declaration will fail.\n    // This is because S is not default-constructible.\n \n    std::variant<std::monostate, S> var; \n \n    // var.index() is now 0 - the first element\n    // std::get<S> will throw! We need to assign a value\n \n    var = 12; \n \n    std::cout << std::get<S>(var).i << '\\n';\n}",
            "output": "12"
        }
    },
    "bad_variant_access": {
        "description": {
            "texte": "std::bad_variant_access is the type of the exception thrown in the following situations:"
        },
        "exemple": {
            "input": "#include <variant>\n#include <iostream>\n \nint main()\n{\n    std::variant<int, float> v;\n    v = 12;\n    try {\n      std::get<float>(v);\n    }\n    catch(const std::bad_variant_access& e) {\n        std::cout << e.what() << '\\n';\n    }\n}",
            "output": "bad_variant_access"
        }
    },
    "variant_size, std::variant_size_v": {
        "description": {
            "texte": "Provides access to the number of alternatives in a possibly cv-qualified variant as a compile-time constant expression.Formally,"
        }
    },
    "variant_alternative, std::variant_alternative_t": {
        "description": {
            "texte": "Provides compile-time indexed access to the types of the alternatives of the possibly cv-qualified variant, combining cv-qualifications of the variant (if any) with the cv-qualifications of the alternative.Formally,"
        }
    },
    "variant_npos": {
        "description": {
            "texte": "This is a special value equal to the largest value representable by the type std::size_t, used as the return type of index() when valueless_by_exception() is true."
        }
    },
    "visit": {
        "description": {
            "texte": "Applies the visitor vis to the variants vars.Effectively returns.std::invoke(std::forward<Visitor>(vis), std::get<is>(std::forward<Variants>(vars))...)., where is... is vars.index()...."
        },
        "parametres": "   vis   -   a Callable that accepts every possible alternative from every variant \n   vars   -   list of variants to pass to the visitor \n\n",
        "exemple": {
            "input": "#include <iomanip>\n#include <iostream>\n#include <string>\n#include <type_traits>\n#include <variant>\n#include <vector>\n \n// the variant to visit\nusing var_t = std::variant<int, long, double, std::string>;\n \n// helper type for the visitor #3\ntemplate<class T> struct always_false : std::false_type {};\n \n// helper type for the visitor #4\ntemplate<class... Ts> struct overloaded : Ts... { using Ts::operator()...; };\ntemplate<class... Ts> overloaded(Ts...) -> overloaded<Ts...>;\n \nint main() {\n    std::vector<var_t> vec = {10, 15l, 1.5, \"hello\"};\n    for(auto& v: vec) {\n \n        // 1. void visitor, only called for side-effects (here, for I/O)\n        std::visit([](auto&& arg){std::cout << arg;}, v);\n \n        // 2. value-returning visitor, demonstrates the idiom of returning another variant\n        var_t w = std::visit([](auto&& arg) -> var_t {return arg + arg;}, v);\n \n        // 3. type-matching visitor: a lambda that handles each type differently\n        std::cout << \". After doubling, variant holds \";\n        std::visit([](auto&& arg) {\n            using T = std::decay_t<decltype(arg)>;\n            if constexpr (std::is_same_v<T, int>)\n                std::cout << \"int with value \" << arg << '\\n';\n            else if constexpr (std::is_same_v<T, long>)\n                std::cout << \"long with value \" << arg << '\\n';\n            else if constexpr (std::is_same_v<T, double>)\n                std::cout << \"double with value \" << arg << '\\n';\n            else if constexpr (std::is_same_v<T, std::string>)\n                std::cout << \"std::string with value \" << std::quoted(arg) << '\\n';\n            else \n                static_assert(always_false<T>::value, \"non-exhaustive visitor!\");\n        }, w);\n    }\n \n    for (auto& v: vec) {\n        // 4. another type-matching visitor: a class with 3 overloaded operator()'s\n        std::visit(overloaded {\n            [](auto arg) { std::cout << arg << ' '; },\n            [](double arg) { std::cout << std::fixed << arg << ' '; },\n            [](const std::string& arg) { std::cout << std::quoted(arg) << ' '; },\n        }, v);\n    }\n}",
            "output": "10. After doubling, variant holds int with value 20\n15. After doubling, variant holds long with value 30\n1.5. After doubling, variant holds double with value 3\nhello. After doubling, variant holds std::string with value \"hellohello\"\n10 15 1.500000 \"hello\""
        }
    },
    "holds_alternative": {
        "description": {
            "texte": "Checks if the variant v holds the alternative T. The call is ill-formed if T does not appear exactly once in Types..."
        },
        "parametres": "   v   -   variant to examine \n\n",
        "exemple": {
            "input": "#include <variant>\n#include <string>\n#include <iostream>\nint main()\n{\n    std::variant<int, std::string> v = \"abc\";\n    std::cout << std::boolalpha\n              << \"variant holds int? \"\n              << std::holds_alternative<int>(v) << '\\n'\n              << \"variant holds string? \"\n              << std::holds_alternative<std::string>(v) << '\\n';\n}",
            "output": "variant holds int? false\nvariant holds string? true"
        }
    },
    "get (std::variant)": {
        "description": {
            "texte": "Reference to the value stored in the variant."
        },
        "parametres": "   I   -   index to look up \n   Type   -   unique type to look up \n   v   -   a variant \n\n",
        "exemple": {
            "input": "#include <variant>\n#include <string>\n \nint main()\n{\n    std::variant<int, float> v{12}, w;\n    int i = std::get<int>(v);\n    w = std::get<int>(v);\n    w = std::get<0>(v); // same effect as the previous line\n \n//  std::get<double>(v); // error: no double in [int, float]\n//  std::get<3>(v);      // error: valid index values are 0 and 1\n \n    try {\n      std::get<float>(w); // w contains int, not float: will throw\n    }\n    catch (std::bad_variant_access&) {}\n}"
        }
    },
    "get_if": {
        "description": {
            "texte": "Pointer to the value stored in the pointed-to variant or null pointer on error."
        },
        "parametres": "   I   -   index to look up \n   Type   -   unique type to look up \n   pv   -   pointer to a variant \n\n",
        "exemple": {
            "input": "#include <variant>\n#include <iostream>\n \nint main()\n{\n    std::variant<int, float> v{12};\n \n    if(auto pval = std::get_if<int>(&v))\n      std::cout << \"variant value: \" << *pval << '\\n'; \n    else \n      std::cout << \"failed to get value!\" << '\\n'; \n}",
            "output": "variant value: 12"
        }
    },
    "operator==, !=, , >=(std::variant)": {
        "description": {
            "texte": "The boolean result of the comparison as described above."
        },
        "parametres": "   v,w   -   variants to compare \n\n"
    },
    "swap(std::variant)": {
        "description": {
            "texte": "Overloads the std::swap algorithm for std::variant. Effectively calls lhs.swap(rhs).This overload only participates in overload resolution if is_move_constructible_v<T_i> and is_swappable_v<T_i> are both true for all T_i in Types..."
        },
        "parametres": "   lhs, rhs   -   variant objects whose values to swap \n\n"
    },
    "integral_constant": {
        "description": {
            "texte": "std::integral_constant wraps a static constant of specified type. It is the base class for the C++ type traits.Two typedefs for the common case where T is bool are provided:"
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nint main() \n{\n    typedef std::integral_constant<int, 2> two_t;\n    typedef std::integral_constant<int, 4> four_t;\n \n//  static_assert(std::is_same<two_t, four_t>::value,\n//                \"two_t and four_t are not equal!\"); \n//  error: static assertion failed: \"two_t and four_t are not equal!\"\n \n    static_assert(two_t::value*2 == four_t::value,\n       \"2*2 != 4\"\n    );\n \n    enum class my_e {\n       e1,\n       e2\n    };\n    typedef std::integral_constant<my_e, my_e::e1> my_e_e1;\n    typedef std::integral_constant<my_e, my_e::e2> my_e_e2;\n \n//  static_assert(my_e_e1::value == my_e::e2,\n//               \"my_e_e1::value != my_e::e2\");\n//  error: static assertion failed: \"my_e_e1::value != my_e::e2\"\n \n    static_assert(std::is_same<my_e_e2, my_e_e2>::value,\n                  \"my_e_e2 != my_e_e2\");\n}"
        }
    },
    "is_void": {
        "description": {
            "texte": "Checks whether T is a void type. Provides the member constant value that is equal to true, if T is the type void, const void, volatile void, or const volatile void. Otherwise, value is equal to false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_void<void>::value << '\\n';\n    std::cout << std::is_void<int>::value << '\\n';\n}",
            "output": "true\nfalse"
        }
    },
    "is_null_pointer": {
        "description": {
            "texte": "Checks whether T is the type std::nullptr_t.Provides the member constant value that is equal to true, if T is the type std::nullptr_t, const std::nullptr_t, volatile std::nullptr_t, or const volatile std::nullptr_t.Otherwise, value is equal to false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nint main()\n{\n    std::cout << std::boolalpha\n              << std::is_null_pointer< decltype(nullptr) >::value << ' '\n              << std::is_null_pointer< int* >::value << '\\n'\n              << std::is_pointer< decltype(nullptr) >::value << ' '\n              << std::is_pointer<int*>::value << '\\n';\n}",
            "output": "true false\nfalse true"
        }
    },
    "is_floating_point": {
        "description": {
            "texte": "Checks whether T is a floating-point type. Provides the member constant value which is equal to true, if T is the type float, double, long double, including any cv-qualified variants. Otherwise, value is equal to false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_floating_point<A>::value << '\\n';\n    std::cout << std::is_floating_point<float>::value << '\\n';\n    std::cout << std::is_floating_point<int>::value << '\\n';\n}",
            "output": "false\ntrue\nfalse"
        }
    },
    "is_array": {
        "description": {
            "texte": "Checks whether T is an array type. Provides the member constant value which is equal to true, if T is an array type. Otherwise, value is equal to false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_array<A>::value << '\\n';\n    std::cout << std::is_array<A[]>::value << '\\n';\n    std::cout << std::is_array<A[3]>::value << '\\n';\n    std::cout << std::is_array<float>::value << '\\n';\n    std::cout << std::is_array<int>::value << '\\n';\n    std::cout << std::is_array<int[]>::value << '\\n';\n    std::cout << std::is_array<int[3]>::value << '\\n';\n}",
            "output": "false\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue"
        }
    },
    "is_enum": {
        "description": {
            "texte": "Checks whether T is an enumeration type. Provides the member constant value which is equal to true, if T is an enumeration type . Otherwise, value is equal to false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nenum E {};\n \nenum class Ec : int {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_enum<A>::value << '\\n';\n    std::cout << std::is_enum<E>::value << '\\n';\n    std::cout << std::is_enum<Ec>::value << '\\n';\n    std::cout << std::is_enum<int>::value << '\\n';\n}",
            "output": "false\ntrue\ntrue\nfalse"
        }
    },
    "is_union": {
        "description": {
            "texte": "Checks whether T is a union type. Provides the member constant value, which is equal to true if T is a union type . Otherwise, value is equal to false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nstruct A {};\n \ntypedef union {\n    int a;\n    float b;\n} B;\n \nstruct C {\n    B d;\n};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_union<A>::value << '\\n';\n    std::cout << std::is_union<B>::value << '\\n';\n    std::cout << std::is_union<C>::value << '\\n';\n    std::cout << std::is_union<int>::value << '\\n';\n}",
            "output": "false\ntrue\nfalse\nfalse"
        }
    },
    "is_class": {
        "description": {
            "texte": "Checks whether T is a non-union class type. Provides the member constant value which is equal to true, if T is a class type (but not union). Otherwise, value is equal to false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nstruct A {};\n \nclass B {};\n \nenum class C {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_class<A>::value << '\\n';\n    std::cout << std::is_class<B>::value << '\\n';\n    std::cout << std::is_class<C>::value << '\\n';\n    std::cout << std::is_class<int>::value << '\\n';\n}",
            "output": "true\ntrue\nfalse\nfalse"
        }
    },
    "is_function": {
        "description": {
            "texte": "Checks whether T is a function type. Types like std::function, lambdas, classes with overloaded operator() and pointers to functions don't count as function types. Provides the member constant value which is equal to true, if T is a function type. Otherwise, value is equal to false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nstruct A {\n    int fun() const&;\n};\n \ntemplate<typename>\nstruct PM_traits {};\n \ntemplate<class T, class U>\nstruct PM_traits<U T::*> {\n    using member_type = U;\n};\n \nint f();\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_function<A>::value << '\\n';\n    std::cout << std::is_function<int(int)>::value << '\\n';\n    std::cout << std::is_function<decltype(f)>::value << '\\n';\n    std::cout << std::is_function<int>::value << '\\n';\n \n    using T = PM_traits<decltype(&A::fun)>::member_type; // T is int() const&\n    std::cout << std::is_function<T>::value << '\\n';\n}",
            "output": "false\ntrue\ntrue\nfalse\ntrue"
        }
    },
    "is_pointer": {
        "description": {
            "texte": "Checks whether T is a pointer to object or a pointer to function (but not a pointer to member/member function). Provides the member constant value which is equal to true, if T is a object/function pointer type. Otherwise, value is equal to false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_pointer<A>::value << '\\n';\n    std::cout << std::is_pointer<A *>::value << '\\n';\n    std::cout << std::is_pointer<A &>::value << '\\n';\n    std::cout << std::is_pointer<int>::value << '\\n';\n    std::cout << std::is_pointer<int *>::value << '\\n';\n    std::cout << std::is_pointer<int **>::value << '\\n';\n    std::cout << std::is_pointer<int[10]>::value << '\\n';\n    std::cout << std::is_pointer<std::nullptr_t>::value << '\\n';\n}",
            "output": "false\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\nfalse"
        }
    },
    "is_lvalue_reference": {
        "description": {
            "texte": "Checks whether T is a lvalue reference type. Provides the member constant value which is equal to true, if T is a lvalue reference type. Otherwise, value is equal to false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_lvalue_reference<A>::value << '\\n';\n    std::cout << std::is_lvalue_reference<A&>::value << '\\n';\n    std::cout << std::is_lvalue_reference<A&&>::value << '\\n';\n    std::cout << std::is_lvalue_reference<int>::value << '\\n';\n    std::cout << std::is_lvalue_reference<int&>::value << '\\n';\n    std::cout << std::is_lvalue_reference<int&&>::value << '\\n';\n}",
            "output": "false\ntrue\nfalse\nfalse\ntrue\nfalse"
        }
    },
    "is_rvalue_reference": {
        "description": {
            "texte": "Checks whether T is a rvalue reference type. Provides the member constant value which is equal to true, if T is a rvalue reference type. Otherwise, value is equal to false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_rvalue_reference<A>::value << '\\n';\n    std::cout << std::is_rvalue_reference<A&>::value << '\\n';\n    std::cout << std::is_rvalue_reference<A&&>::value << '\\n';\n    std::cout << std::is_rvalue_reference<int>::value << '\\n';\n    std::cout << std::is_rvalue_reference<int&>::value << '\\n';\n    std::cout << std::is_rvalue_reference<int&&>::value << '\\n';\n}",
            "output": "false\nfalse\ntrue\nfalse\nfalse\ntrue"
        }
    },
    "is_member_object_pointer": {
        "description": {
            "texte": "Checks whether T is a non-static member object. Provides the member constant value which is equal to true, if T is a non-static member object type. Otherwise, value is equal to false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nint main() {\n    class cls {};\n    std::cout << (std::is_member_object_pointer<int(cls::*)>::value\n                     ? \"T is member object pointer\"\n                     : \"T is not a member object pointer\") << '\\n';\n    std::cout << (std::is_member_object_pointer<int(cls::*)()>::value\n                     ? \"T is member object pointer\"\n                     : \"T is not a member object pointer\") << '\\n';\n}",
            "output": "T is member object pointer\nT is not a member object pointer"
        }
    },
    "is_member_function_pointer": {
        "description": {
            "texte": "Checks whether T is a non-static member function pointer. Provides the member constant value which is equal to true, if T is a non-static member function pointer type. Otherwise, value is equal to false."
        },
        "exemple": {
            "input": "#include <type_traits>\n \nclass A {\npublic:\n    void member() { }\n};\n \nint main()\n{\n    // fails at compile time if A::member is a data member and not a function\n    static_assert(std::is_member_function_pointer<decltype(&A::member)>::value,\n                  \"A::member is not a member function.\"); \n}"
        }
    },
    "is_fundamental": {
        "description": {
            "texte": "If T is a fundamental type (that is, arithmetic type, void, or nullptr_t), provides the member constant value equal true. For any other type, value is false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << \"A\\t\"      << std::is_fundamental<A>::value << '\\n';\n    std::cout << \"int\\t\"    << std::is_fundamental<int>::value << '\\n';\n    std::cout << \"int&\\t\"   << std::is_fundamental<int&>::value << '\\n';\n    std::cout << \"int*\\t\"   << std::is_fundamental<int*>::value << '\\n';\n    std::cout << \"float\\t\"  << std::is_fundamental<float>::value << '\\n';\n    std::cout << \"float&\\t\" << std::is_fundamental<float&>::value << '\\n';\n    std::cout << \"float*\\t\" << std::is_fundamental<float*>::value << '\\n';\n}",
            "output": "A        false\nint        true\nint&        false\nint*        false\nfloat        true\nfloat&        false\nfloat*        false"
        }
    },
    "is_arithmetic": {
        "description": {
            "texte": "If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified version thereof, provides the member constant value equal true. For any other type, value is false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << \"A:           \" <<  std::is_arithmetic<A>::value << '\\n';\n    std::cout << \"bool:        \" <<  std::is_arithmetic<bool>::value << '\\n';\n    std::cout << \"int:         \" <<  std::is_arithmetic<int>::value << '\\n';\n    std::cout << \"int const:   \" <<  std::is_arithmetic<int const>::value << '\\n';\n    std::cout << \"int &:       \" <<  std::is_arithmetic<int&>::value << '\\n';\n    std::cout << \"int *:       \" <<  std::is_arithmetic<int*>::value << '\\n';\n    std::cout << \"float:       \" <<  std::is_arithmetic<float>::value << '\\n';\n    std::cout << \"float const: \" <<  std::is_arithmetic<float const>::value << '\\n';\n    std::cout << \"float &:     \" <<  std::is_arithmetic<float&>::value << '\\n';\n    std::cout << \"float *:     \" <<  std::is_arithmetic<float*>::value << '\\n';\n    std::cout << \"char:        \" <<  std::is_arithmetic<char>::value << '\\n';\n    std::cout << \"char const:  \" <<  std::is_arithmetic<char const>::value << '\\n';\n    std::cout << \"char &:      \" <<  std::is_arithmetic<char&>::value << '\\n';\n    std::cout << \"char *:      \" <<  std::is_arithmetic<char*>::value << '\\n';\n}",
            "output": "A:           false\nbool:        true\nint:         true\nint const:   true\nint &:       false\nint *:       false\nfloat:       true\nfloat const: true\nfloat &:     false\nfloat *:     false\nchar:        true\nchar const:  true\nchar &:      false\nchar *:      false"
        }
    },
    "is_scalar": {
        "description": {
            "texte": "If T is a scalar type (that is a possibly cv-qualified arithmetic, pointer, pointer to member, enumeration, or std::nullptr_t type), provides the member constant value equal true. For any other type, value is false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nint main() {\n    class cls {};\n    std::cout << (std::is_scalar<int>::value\n                     ? \"T is a scalar\"\n                     : \"T is not a scalar\") << '\\n';\n    std::cout << (std::is_scalar<cls>::value\n                     ? \"T is a scalar\"\n                     : \"T is not a scalar\") << '\\n';\n}",
            "output": "T is a scalar\nT is not a scalar"
        }
    },
    "is_object": {
        "description": {
            "texte": "If T is an object type (that is any possibly cv-qualified type other than function, reference, or void types), provides the member constant value equal true. For any other type, value is false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nint main() {\n    class cls {};\n    std::cout << std::boolalpha;\n    std::cout << std::is_object<int>::value << '\\n';\n    std::cout << std::is_object<int&>::value << '\\n';\n    std::cout << std::is_object<cls>::value << '\\n';\n    std::cout << std::is_object<cls&>::value << '\\n';\n}",
            "output": "true\nfalse\ntrue\nfalse"
        }
    },
    "is_compound": {
        "description": {
            "texte": "If T is a compound type (that is, array, function, object pointer, function pointer, member object pointer, member function pointer, reference, class, union, or enumeration, including any cv-qualified variants), provides the member constant value equal true. For any other type, value is false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nint main() {\n    class cls {};\n    std::cout << (std::is_compound<cls>::value\n                     ? \"T is compound\"\n                     : \"T is not a compound\") << '\\n';\n    std::cout << (std::is_compound<int>::value\n                     ? \"T is compound\"\n                     : \"T is not a compound\") << '\\n';\n}",
            "output": "T is compound\nT is not a compound"
        }
    },
    "is_reference": {
        "description": {
            "texte": "If T is a reference type (lvalue reference or rvalue reference), provides the member constant value equal true. For any other type, value is false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_reference<A>::value << '\\n';\n    std::cout << std::is_reference<A&>::value << '\\n';\n    std::cout << std::is_reference<A&&>::value << '\\n';\n    std::cout << std::is_reference<int>::value << '\\n';\n    std::cout << std::is_reference<int&>::value << '\\n';\n    std::cout << std::is_reference<int&&>::value << '\\n';\n}",
            "output": "false\ntrue\ntrue\nfalse\ntrue\ntrue"
        }
    },
    "is_member_pointer": {
        "description": {
            "texte": "If T is pointer to non-static member object or a pointer to non-static member function, provides the member constant value equal true. For any other type, value is false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nint main() {\n    class cls {};\n    std::cout << (std::is_member_pointer<int(cls::*)>::value\n                     ? \"T is member pointer\"\n                     : \"T is not a member pointer\") << '\\n';\n    std::cout << (std::is_member_pointer<int>::value\n                     ? \"T is member pointer\"\n                     : \"T is not a member pointer\") << '\\n';\n}",
            "output": "T is member pointer\nT is not a member pointer"
        }
    },
    "is_const": {
        "description": {
            "texte": "If T is a const-qualified type (that is, const, or const volatile), provides the member constant value equal true. For any other type, value is false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_const<int>::value << '\\n'; // false\n    std::cout << std::is_const<const int>::value  << '\\n'; // true\n    std::cout << std::is_const<const int*>::value  << '\\n'; // false\n    std::cout << std::is_const<int* const>::value  << '\\n'; // true\n    std::cout << std::is_const<const int&>::value  << '\\n'; // false\n    std::cout << std::is_const<typename std::remove_reference<const int&>::type>::value << '\\n'; // true\n}",
            "output": "false\ntrue\nfalse\ntrue\nfalse\ntrue"
        }
    },
    "is_volatile": {
        "description": {
            "texte": "If T is a volatile-qualified type (that is, volatile, or const volatile), provides the member constant value equal true. For any other type, value is false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_volatile<int>::value << '\\n';\n    std::cout << std::is_volatile<volatile int>::value  << '\\n';\n}",
            "output": "false\ntrue"
        }
    },
    "is_trivial": {
        "description": {
            "texte": "If T is TrivialType (that is, a scalar type, a trivially copyable class with a trivial default constructor, or array of such type/class, possibly cv-qualified), provides the member constant value equal true. For any other type, value is false.The behavior is undefined if std::remove_all_extents_t<T> is an incomplete type and not (possibly cv-qualified) void."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nstruct A {\n    int m;\n};\n \nstruct B {\n    B() {}\n};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_trivial<A>::value << '\\n';\n    std::cout << std::is_trivial<B>::value << '\\n';\n}",
            "output": "true\nfalse"
        }
    },
    "is_trivially_copyable": {
        "description": {
            "texte": "If T is a TriviallyCopyable type, provides the member constant value equal true. For any other type, value is false.The only trivially copyable types are scalar types, trivially copyable classes, and arrays of such types/classes (possibly const-qualified, but not volatile-qualified).The behavior is undefined if std::remove_all_extents_t<T> is an incomplete type and not (possibly cv-qualified) void."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nstruct A {\n    int m;\n};\n \nstruct B {\n    B(B const&) {}\n};\n \nstruct C {\n    virtual void foo();\n};\n \nstruct D {\n    int m;\n \n    D(D const&) = default; // -> trivially copyable\n    D(int x): m(x+1) {}\n};\n \nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_trivially_copyable<A>::value << '\\n';\n    std::cout << std::is_trivially_copyable<B>::value << '\\n';\n    std::cout << std::is_trivially_copyable<C>::value << '\\n';\n    std::cout << std::is_trivially_copyable<D>::value << '\\n';\n}",
            "output": "true\nfalse\nfalse\ntrue"
        }
    },
    "is_standard_layout": {
        "description": {
            "texte": "If T is a standard layout type (that is, a scalar type, a standard-layout class, or an array of such type/class, possibly cv-qualified), provides the member constant value equal true. For any other type, value is false.A standard-layout class is a class that satisfies StandardLayoutType.The behavior is undefined if std::remove_all_extents_t<T> is an incomplete type and not (possibly cv-qualified) void."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nstruct A {\n    int m;\n};\n \nstruct B {\n    int m1;\nprivate:\n    int m2;\n};\n \nstruct C {\n    virtual void foo();\n};\n \nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_standard_layout<A>::value << '\\n';\n    std::cout << std::is_standard_layout<B>::value << '\\n';\n    std::cout << std::is_standard_layout<C>::value << '\\n';\n}",
            "output": "true\nfalse\nfalse"
        }
    },
    "is_pod": {
        "description": {
            "texte": "If T is a PODType (\"plain old data type\"), that is, both trivial and standard-layout, provides the member constant value equal true. For any other type, value is false.The behavior is undefined if std::remove_all_extents_t<T> is an incomplete type and not (possibly cv-qualified) void."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nstruct A {\n    int m;\n};\n \nstruct B {\n    int m1;\nprivate:\n    int m2;\n};\n \nstruct C {\n    virtual void foo();\n};\n \nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_pod<A>::value << '\\n';\n    std::cout << std::is_pod<B>::value << '\\n';\n    std::cout << std::is_pod<C>::value << '\\n';\n}",
            "output": "true\nfalse\nfalse"
        }
    },
    "is_literal_type": {
        "description": {
            "texte": "If T satisfies all requirements of LiteralType, provides the member constant value equal true. For any other type, value is false.The behavior is undefined if std::remove_all_extents_t<T> is an incomplete type and not (possibly cv-qualified) void."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nstruct A {\n    int m;\n};\n \nstruct B {\n    virtual ~B();\n};\n \nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_literal_type<A>::value << '\\n';\n    std::cout << std::is_literal_type<B>::value << '\\n';\n}",
            "output": "true\nfalse"
        }
    },
    "has_unique_object_representations": {
        "description": {
            "texte": "If T is TriviallyCopyable and if any two objects of type T with the same value have the same object representation, provides the member constant value equal true. For any other type, value is false.For the purpose of this trait, two arrays have the same value if their elements have the same values, two non-union classes have the same value if their direct subobjects have the same value, and two unions have the same value if they have the same active member and the value of that member are the same.It is implementation-defined which scalar types satisfy this trait, but unsigned (until C++20) integer types that do not use padding bits are guaranteed to have unique object representations.The behavior is undefined if T is an incomplete type other than (possibly cv-qualified) void or array of unknown bound."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nstruct foo\n{\n    char c;\n    float f;\n    short st;\n    int i;\n};\n \nstruct bar\n{\n    int a;\n    int b;\n};\n \nint main()\n{   \n     std::cout  << std::boolalpha \n                << \"Does foo have unique object representations? \"\n                << std::has_unique_object_representations_v<foo> << '\\n'\n                << \"Does bar have unique object representations? \" \n                << std::has_unique_object_representations_v<bar> << '\\n';\n}",
            "output": "Does foo have unique object representations? false\nDoes bar have unique object representations? true"
        }
    },
    "is_empty": {
        "description": {
            "texte": "If T is an empty type (that is, a non-union class type with no non-static data members other than bit-fields of size 0, no virtual functions, no virtual base classes, and no non-empty base classes), provides the member constant value equal true. For any other type, value is false.If T is a non-union class type, T shall be a complete type; otherwise, the behavior is undefined."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nstruct A {};\n \nstruct B {\n    int m;\n};\n \nstruct C {\n    static int m;\n};\n \nstruct D {\n    virtual ~D();\n};\n \nunion E {};\n \nstruct F {\n    [[no_unique_address]] E e;\n};\n \nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << \"A \" << std::is_empty<A>::value << '\\n';\n    std::cout << \"B \" << std::is_empty<B>::value << '\\n';\n    std::cout << \"C \" << std::is_empty<C>::value << '\\n';\n    std::cout << \"D \" << std::is_empty<D>::value << '\\n';\n    std::cout << \"E \" << std::is_empty<E>::value << '\\n';\n    std::cout << \"F \" << std::is_empty<F>::value << '\\n'; // the result is ABI-dependent\n \n}",
            "output": "A true\nB false\nC true\nD false\nE false\nF true"
        }
    },
    "is_polymorphic": {
        "description": {
            "texte": "If T is a polymorphic class (that is, a non-union class that declares or inherits at least one virtual function), provides the member constant value equal true. For any other type, value is false.If T is a non-union class type, T shall be a complete type; otherwise, the behavior is undefined."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nstruct A {\n    int m;\n};\n \nstruct B {\n    virtual void foo();\n};\n \nstruct C : B {};\n \nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_polymorphic<A>::value << '\\n';\n    std::cout << std::is_polymorphic<B>::value << '\\n';\n    std::cout << std::is_polymorphic<C>::value << '\\n';\n}",
            "output": "false\ntrue\ntrue"
        }
    },
    "is_abstract": {
        "description": {
            "texte": "If T is an abstract class (that is, a non-union class that declares or inherits at least one pure virtual function), provides the member constant value equal true. For any other type, value is false.If T is a non-union class type, T shall be a complete type; otherwise, the behavior is undefined."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nstruct A {\n    int m;\n};\n \nstruct B {\n    virtual void foo();\n};\n \nstruct C {\n    virtual void foo() = 0;\n};\n \nstruct D : C {};\n \nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_abstract<A>::value << '\\n';\n    std::cout << std::is_abstract<B>::value << '\\n';\n    std::cout << std::is_abstract<C>::value << '\\n';\n    std::cout << std::is_abstract<D>::value << '\\n';\n}",
            "output": "false\nfalse\ntrue\ntrue"
        }
    },
    "is_final": {
        "description": {
            "texte": "If T is a final class (that is, a class declared with the final specifier), provides the member constant value equal true. For any other type, value is false.If T is a class type, T shall be a complete type; otherwise, the behavior is undefined."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nclass A {};\nclass B final {};\n \nint main() \n{\n    std::cout\n        << std::boolalpha\n        << std::is_final<A>::value << '\\n'\n        << std::is_final<B>::value << '\\n';\n}",
            "output": "false\ntrue"
        }
    },
    "is_aggregate": {
        "description": {
            "texte": "Checks if T is an aggregate type. The member constant value is equal to true if T is an aggregate type and false otherwise.The behavior is undefined if std::remove_all_extents_t<T> is an incomplete type other than (possibly cv-qualified) void."
        },
        "exemple": {
            "input": "#include <type_traits>\n#include <new>\n#include <utility>\n \n// constructs a T at the uninitialized memory pointed to by p\n// using list-initialization for aggregates and non-list initialization otherwise\ntemplate<class T, class... Args>\nT* construct(T* p, Args&&... args) {\n    if constexpr(std::is_aggregate_v<T>) {\n        return ::new (static_cast<void*>(p)) T{std::forward<Args>(args)...};\n    }\n    else {\n        return ::new (static_cast<void*>(p)) T(std::forward<Args>(args)...);\n    }\n}\n \nstruct A { int x, y; };\nstruct B { B(int, const char*) { } };\n \nint main() {\n    std::aligned_union_t<1, A, B> storage;\n    A* a = construct(reinterpret_cast<A*>(&storage), 1, 2);\n    B* b = construct(reinterpret_cast<B*>(&storage), 1, \"hello\");\n}"
        }
    },
    "is_signed": {
        "description": {
            "texte": "If T is an arithmetic type, provides the member constant value equal true if T(-1) < T(0): this results in true for the floating-point types and the signed integer types, and in false for the unsigned integer types and the type bool.For any other type, value is false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nclass A {};\nenum B : int {};\nenum class C : int {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_signed<A>::value << '\\n';\n    std::cout << std::is_signed<float>::value << '\\n';\n    std::cout << std::is_signed<signed int>::value << '\\n';\n    std::cout << std::is_signed<unsigned int>::value << '\\n';\n    std::cout << std::is_signed<B>::value << '\\n';\n    std::cout << std::is_signed<C>::value << '\\n';\n \n    // shorter:\n    std::cout << std::is_signed<signed int>() << '\\n';\n    std::cout << std::is_signed<unsigned int>() << '\\n';\n}",
            "output": "false\ntrue\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse"
        }
    },
    "is_unsigned": {
        "description": {
            "texte": "If T is an arithmetic type, provides the member constant value equal true if T(0) < T(-1): this results in true for the unsigned integer types and the type bool and in false for the signed integer types and the floating-point types.For any other type, value is false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nclass A {};\nenum B : unsigned {};\nenum class C : unsigned {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_unsigned<A>::value << '\\n';\n    std::cout << std::is_unsigned<float>::value << '\\n';\n    std::cout << std::is_unsigned<signed int>::value << '\\n';\n    std::cout << std::is_unsigned<unsigned int>::value << '\\n';\n    std::cout << std::is_unsigned<B>::value << '\\n';\n    std::cout << std::is_unsigned<C>::value << '\\n';\n}",
            "output": "false\nfalse\nfalse\ntrue\nfalse\nfalse"
        }
    },
    "is_bounded_array": {
        "description": {
            "texte": "Checks whether T is an array type of known bound. Provides the member constant value which is equal to true, if T is an array type of known bound. Otherwise, value is equal to false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_bounded_array_v<A> << '\\n';\n    std::cout << std::is_bounded_array_v<A[]> << '\\n';\n    std::cout << std::is_bounded_array_v<A[3]> << '\\n';\n    std::cout << std::is_bounded_array_v<float> << '\\n';\n    std::cout << std::is_bounded_array_v<int> << '\\n';\n    std::cout << std::is_bounded_array_v<int[]> << '\\n';\n    std::cout << std::is_bounded_array_v<int[3]> << '\\n';\n}",
            "output": "false\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue"
        }
    },
    "is_unbounded_array": {
        "description": {
            "texte": "Checks whether T is an array type of unknown bound. Provides the member constant value which is equal to true, if T is an array type of unknown bound. Otherwise, value is equal to false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_unbounded_array_v<A> << '\\n';\n    std::cout << std::is_unbounded_array_v<A[]> << '\\n';\n    std::cout << std::is_unbounded_array_v<A[3]> << '\\n';\n    std::cout << std::is_unbounded_array_v<float> << '\\n';\n    std::cout << std::is_unbounded_array_v<int> << '\\n';\n    std::cout << std::is_unbounded_array_v<int[]> << '\\n';\n    std::cout << std::is_unbounded_array_v<int[3]> << '\\n';\n}",
            "output": "false\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse"
        }
    },
    "is_constructible, std::is_trivially_constructible, std::is_nothrow_constructible": {
        "description": {
            "texte": "1) If T is an object or reference type and the variable definition T obj(std::declval<Args>()...); is well-formed, provides the member constant value equal to true. In all other cases, value is false.For the purposes of this check, the variable definition is never interpreted as a function declaration, and the use of std::declval is not considered an odr-use. Access checks are performed as if from a context unrelated to T and any of the types in Args. Only the validity of the immediate context of the variable definition is considered.2) same as 1), but the variable definition does not call any operation that is not trivial. For the purposes of this check, the call to std::declval is considered trivial.3) same as 1), but the variable definition is noexcept.T and all types in the parameter pack Args shall each be a complete type, (possibly cv-qualified) void, or an array of unknown bound. Otherwise, the behavior is undefined.If an instantiation of a template above depends, directly or indirectly, on an incomplete type, and that instantiation could yield a different result if that type were hypothetically completed, the behavior is undefined."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nclass Foo {\n    int v1;\n    double v2;\n public:\n    Foo(int n) : v1(n), v2() {}\n    Foo(int n, double f) noexcept : v1(n), v2(f) {}\n};\n \nint main() {\n    std::cout << \"Foo is ...\\n\" << std::boolalpha\n              << \"\\tTrivially-constructible from const Foo&? \"\n              << std::is_trivially_constructible<Foo, const Foo&>::value << '\\n'\n              << \"\\tTrivially-constructible from int? \"\n              << std::is_trivially_constructible<Foo, int>::value << '\\n'\n              << \"\\tConstructible from int? \"\n              << std::is_constructible<Foo, int>::value << '\\n'\n              << \"\\tNothrow-constructible from int? \"\n              << std::is_nothrow_constructible<Foo, int>::value << '\\n'\n              << \"\\tNothrow-constructible from int and double? \"\n              << std::is_nothrow_constructible<Foo, int, double>::value << '\\n';\n}",
            "output": "Foo is ...\n        Trivially-constructible from const Foo&? true\n        Trivially-constructible from int? false\n        Constructible from int? true\n        Nothrow-constructible from int? false\n        Nothrow-constructible from int and double? true"
        }
    },
    "is_default_constructible, std::is_trivially_default_constructible, std::is_nothrow_default_constructible": {
        "description": {
            "texte": "1) If std::is_constructible<T>::value is true, provides the member constant value equal to true, otherwise value is false.2) If std::is_trivially_constructible<T>::value is true, provides the member constant value equal to true, otherwise value is false.3) If std::is_nothrow_constructible<T>::value is true, provides the member constant value equal to true, otherwise value is false.T shall be a complete type, (possibly cv-qualified) void, or an array of unknown bound. Otherwise, the behavior is undefined.If an instantiation of a template above depends, directly or indirectly, on an incomplete type, and that instantiation could yield a different result if that type were hypothetically completed, the behavior is undefined."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nstruct Ex1 {\n    std::string str; // member has a non-trivial default ctor\n};\nstruct Ex2 {\n    int n;\n    Ex2() = default; // trivial and non-throwing\n};\n \nint main() {\n    std::cout << std::boolalpha << \"Ex1 is default-constructible? \"\n              << std::is_default_constructible<Ex1>::value << '\\n'\n              << \"Ex1 is trivially default-constructible? \"\n              << std::is_trivially_default_constructible<Ex1>::value << '\\n'\n              << \"Ex2 is trivially default-constructible? \"\n              << std::is_trivially_default_constructible<Ex2>::value << '\\n'\n              << \"Ex2 is nothrow default-constructible? \"\n              << std::is_nothrow_default_constructible<Ex2>::value << '\\n';\n}",
            "output": "Ex1 is default-constructible? true\nEx1 is trivially default-constructible? false\nEx2 is trivially default-constructible? true\nEx2 is nothrow default-constructible? true"
        }
    },
    "is_copy_constructible, std::is_trivially_copy_constructible, std::is_nothrow_copy_constructible": {
        "description": {
            "texte": "1) If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to std::is_constructible<T, const T&>::value.2) Same as (1), but uses std::is_trivially_constructible<T, const T&>.3) Same as (1), but uses std::is_nothrow_constructible<T, const T&>.T shall be a complete type, (possibly cv-qualified) void, or an array of unknown bound. Otherwise, the behavior is undefined.If an instantiation of a template above depends, directly or indirectly, on an incomplete type, and that instantiation could yield a different result if that type were hypothetically completed, the behavior is undefined."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nstruct Ex1 {\n    std::string str; // member has a non-trivial copy ctor\n};\nstruct Ex2 {\n    int n;\n    Ex2(const Ex2&) = default; // trivial and non-throwing\n};\n \nint main() {\n    std::cout << std::boolalpha << \"Ex1 is copy-constructible? \"\n              << std::is_copy_constructible<Ex1>::value << '\\n'\n              << \"Ex1 is trivially copy-constructible? \"\n              << std::is_trivially_copy_constructible<Ex1>::value << '\\n'\n              << \"Ex2 is trivially copy-constructible? \"\n              << std::is_trivially_copy_constructible<Ex2>::value << '\\n'\n              << \"Ex2 is nothrow copy-constructible? \"\n              << std::is_nothrow_copy_constructible<Ex2>::value << '\\n';\n}",
            "output": "Ex1 is copy-constructible? true\nEx1 is trivially copy-constructible? false\nEx2 is trivially copy-constructible? true\nEx2 is nothrow copy-constructible? true"
        }
    },
    "is_move_constructible, std::is_trivially_move_constructible, std::is_nothrow_move_constructible": {
        "description": {
            "texte": "1) If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to std::is_constructible<T, T&&>::value.2) Same as (1), but uses std::is_trivially_constructible<T, T&&>.3) Same as (1), but uses std::is_nothrow_constructible<T, T&&>.T shall be a complete type, (possibly cv-qualified) void, or an array of unknown bound. Otherwise, the behavior is undefined.If an instantiation of a template above depends, directly or indirectly, on an incomplete type, and that instantiation could yield a different result if that type were hypothetically completed, the behavior is undefined."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nstruct Ex1 {\n    std::string str; // member has a non-trivial but non-throwing move ctor\n};\nstruct Ex2 {\n    int n;\n    Ex2(Ex2&&) = default; // trivial and non-throwing\n};\nstruct NoMove {\n    // prevents implicit declaration of default move constructor\n    // however, the class is still move-constructible because its\n    // copy constructor can bind to an rvalue argument\n    NoMove(const NoMove&) {}\n};\n \nint main() {\n    std::cout << std::boolalpha << \"Ex1 is move-constructible? \"\n              << std::is_move_constructible<Ex1>::value << '\\n'\n              << \"Ex1 is trivially move-constructible? \"\n              << std::is_trivially_move_constructible<Ex1>::value << '\\n'\n              << \"Ex1 is nothrow move-constructible? \"\n              << std::is_nothrow_move_constructible<Ex1>::value << '\\n'\n              << \"Ex2 is trivially move-constructible? \"\n              << std::is_trivially_move_constructible<Ex2>::value << '\\n'\n              << \"Ex2 is nothrow move-constructible? \"\n              << std::is_nothrow_move_constructible<Ex2>::value << '\\n';\n \n    std::cout << std::boolalpha\n              << \"NoMove is move-constructible? \"\n              << std::is_move_constructible<NoMove>::value << '\\n'\n              << \"NoMove is nothrow move-constructible? \"\n              << std::is_nothrow_move_constructible<NoMove>::value << '\\n';\n}",
            "output": "Ex1 is move-constructible? true\nEx1 is trivially move-constructible? false\nEx1 is nothrow move-constructible? true\nEx2 is trivially move-constructible? true\nEx2 is nothrow move-constructible? true\nNoMove is move-constructible? true\nNoMove is nothrow move-constructible? false"
        }
    },
    "is_assignable, std::is_trivially_assignable, std::is_nothrow_assignable": {
        "description": {
            "texte": "T and U shall each be a complete type, (possibly cv-qualified) void, or an array of unknown bound. Otherwise, the behavior is undefined.If an instantiation of a template above depends, directly or indirectly, on an incomplete type, and that instantiation could yield a different result if that type were hypothetically completed, the behavior is undefined."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <type_traits>\nstruct Ex1 { int n; };\nint main() {\n    std::cout << std::boolalpha\n              << \"int is assignable from int? \"\n              << std::is_assignable<int, int>::value << '\\n' // 1 = 1; wouldn't compile\n              << \"int& is assignable from int? \"\n              << std::is_assignable<int&, int>::value << '\\n' // int a; a = 1; works\n              << \"int is assignable from double? \"\n              << std::is_assignable<int, double>::value << '\\n'\n              << \"int& is nothrow assignable from double? \"\n              << std::is_nothrow_assignable<int&, double>::value << '\\n'\n              << \"string is assignable from double? \"\n              << std::is_assignable<std::string, double>::value << '\\n'\n              << \"Ex1& is trivially assignable from const Ex1&? \"\n              << std::is_trivially_assignable<Ex1&, const Ex1&>::value << '\\n';\n}",
            "output": "int is assignable from int? false\nint& is assignable from int? true\nint is assignable from double? false\nint& is nothrow assignable from double? true\nstring is assignable from double? true\nEx1& is trivially assignable from const Ex1&? true"
        }
    },
    "is_copy_assignable, std::is_trivially_copy_assignable, std::is_nothrow_copy_assignable": {
        "description": {
            "texte": "T shall be a complete type, (possibly cv-qualified) void, or an array of unknown bound. Otherwise, the behavior is undefined.If an instantiation of a template above depends, directly or indirectly, on an incomplete type, and that instantiation could yield a different result if that type were hypothetically completed, the behavior is undefined."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <utility>\n#include <type_traits>\nstruct Foo { int n; };\nint main() {\n    std::cout << std::boolalpha\n              << \"Foo is trivially copy-assignable? \"\n              << std::is_trivially_copy_assignable<Foo>::value << '\\n'\n              << \"int[2] is copy-assignable? \"\n              << std::is_copy_assignable<int[2]>::value << '\\n'\n              << \"int is nothrow copy-assignable? \"\n              << std::is_nothrow_copy_assignable<int>::value << '\\n';\n}",
            "output": "Foo is trivially copy-assignable? true\nint[2] is copy-assignable? false\nint is nothrow copy-assignable? true"
        }
    },
    "is_move_assignable, std::is_trivially_move_assignable, std::is_nothrow_move_assignable": {
        "description": {
            "texte": "T shall be a complete type, (possibly cv-qualified) void, or an array of unknown bound. Otherwise, the behavior is undefined.If an instantiation of a template above depends, directly or indirectly, on an incomplete type, and that instantiation could yield a different result if that type were hypothetically completed, the behavior is undefined."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <type_traits>\nstruct Foo { int n; };\nstruct NoMove {\n    // prevents implicit declaration of default move assignment operator\n    // however, the class is still move-assignable because its\n    // copy assignment operator can bind to an rvalue argument\n    NoMove& operator=(const NoMove&) { return *this; }\n};\nint main() {\n    std::cout << std::boolalpha\n              << \"std::string is nothrow move-assignable? \"\n              << std::is_nothrow_move_assignable<std::string>::value << '\\n'\n              << \"int[2] is move-assignable? \"\n              << std::is_move_assignable<int[2]>::value << '\\n'\n              << \"Foo is trivally move-assignable? \"\n              << std::is_trivially_move_assignable<Foo>::value << '\\n';\n \n    std::cout << std::boolalpha\n              << \"NoMove is move-assignable? \"\n              << std::is_move_assignable<NoMove>::value << '\\n'\n              << \"NoMove is nothrow move-assignable? \"\n              << std::is_nothrow_move_assignable<NoMove>::value << '\\n';\n}",
            "output": "std::string is nothrow move-assignable? true\nint[2] is move-assignable? false\nFoo is trivially move-assignable? true\nNoMove is move-assignable? true\nNoMove is nothrow move-assignable? false"
        }
    },
    "has_virtual_destructor": {
        "description": {
            "texte": "If T is a type with a virtual destructor, provides the member constant value equal true. For any other type, value is false.If T is a non-union class type, T shall be a complete type; otherwise, the behavior is undefined."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n#include <string>\n#include <stdexcept>\n \nint main()\n{\n    std::cout << std::boolalpha\n              << \"std::string has a virtual destructor? \"\n              << std::has_virtual_destructor<std::string>::value << '\\n'\n              << \"std::runtime_error has a virtual destructor? \"\n              << std::has_virtual_destructor<std::runtime_error>::value << '\\n';\n}",
            "output": "std::string has a virtual destructor? false\nstd::runtime_error has a virtual destructor? true"
        }
    },
    "is_swappable_with, std::is_swappable, std::is_nothrow_swappable_with, std::is_nothrow_swappable": {
        "description": {
            "texte": "T and U shall each be a complete type, (possibly cv-qualified) void, or an array of unknown bound. Otherwise, the behavior is undefined.If an instantiation of a template above depends, directly or indirectly, on an incomplete type, and that instantiation could yield a different result if that type were hypothetically completed, the behavior is undefined."
        }
    },
    "alignment_of": {
        "description": {
            "texte": "Provides the member constant value equal to the alignment requirement of the type T, as if obtained by an alignof expression. If T is an array type, returns the alignment requirements of the element type. If T is a reference type, returns the alignment requirements of the type referred to.If alignof(T) is not a valid expression, the behavior is undefined."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main() \n{\n    std::cout << std::alignment_of<A>::value << '\\n';\n    std::cout << std::alignment_of<int>() << '\\n'; // alt syntax\n    std::cout << std::alignment_of_v<double> << '\\n'; // c++17 alt syntax\n}",
            "output": "1\n4\n8"
        }
    },
    "extent": {
        "description": {
            "texte": "If T is an array type, provides the member constant value equal to the number of elements along the Nth dimension of the array, if N is in [0, std::rank<T>::value). For any other type, or if T is array of unknown bound along its first dimension and N is 0, value is 0."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nint main()\n{\n    std::cout << std::extent<int[3]>::value << '\\n'; //< default dimension is 0\n    std::cout << std::extent<int[3][4], 0>::value << '\\n';\n    std::cout << std::extent<int[3][4], 1>::value << '\\n';\n    std::cout << std::extent<int[3][4], 2>::value << '\\n';\n    std::cout << std::extent<int[]>::value << '\\n';\n \n    const auto ext = std::extent<int[9]>{};\n    std::cout << ext << '\\n'; //< implicit conversion to std::size_t\n \n    const int ints[] = {1,2,3,4};\n    std::cout << std::extent<decltype(ints)>::value << '\\n'; //< array size \n}",
            "output": "3\n3\n4\n0\n0\n9\n4"
        }
    },
    "is_same": {
        "description": {
            "texte": "If T and U name the same type (including const/volatile qualifications), provides the member constant value equal to true. Otherwise value is false.Commutativity is satisfied, i.e. for any two types T and U, is_same<T, U>::value == true if and only if is_same<U, T>::value == true."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n#include <cstdint>\n \nvoid print_separator()\n{\n    std::cout << \"-----\\n\";\n}\n \nint main()\n{\n    std::cout << std::boolalpha;\n \n    // some implementation-defined facts\n    std::cout << std::is_same<int, std::int32_t>::value << '\\n';\n    // usually true if 'int' is 32 bit\n    std::cout << std::is_same<int, std::int64_t>::value << '\\n';\n    // possibly true if ILP64 data model is used\n \n    print_separator();\n \n    // 'float' is never an integral type\n    std::cout << std::is_same<float, std::int32_t>::value << '\\n'; // false\n \n    print_separator();\n \n    // 'int' is implicitly 'signed'\n    std::cout << std::is_same<int, int>::value << \"\\n\";          // true\n    std::cout << std::is_same<int, unsigned int>::value << \"\\n\"; // false\n    std::cout << std::is_same<int, signed int>::value << \"\\n\";   // true\n \n    print_separator();\n \n    // unlike other types, 'char' is neither 'unsigned' nor 'signed'\n    std::cout << std::is_same<char, char>::value << \"\\n\";          // true\n    std::cout << std::is_same<char, unsigned char>::value << \"\\n\"; // false\n    std::cout << std::is_same<char, signed char>::value << \"\\n\";   // false\n}",
            "output": "true\nfalse\n-----\nfalse\n-----\ntrue\nfalse\ntrue\n-----\ntrue\nfalse\nfalse"
        }
    },
    "is_base_of": {
        "description": {
            "texte": "If Derived is derived from Base or if both are the same non-union class (in both cases ignoring cv-qualification), provides the member constant value equal to true. Otherwise value is false.If both Base and Derived are non-union class types, and they are not the same type (ignoring cv-qualification), Derived shall be a complete type; otherwise the behavior is undefined."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nclass B : A {};\n \nclass C {};\n \nint main() \n{\n    std::cout << std::boolalpha;\n    std::cout << \"a2b: \" << std::is_base_of<A, B>::value << '\\n';\n    std::cout << \"b2a: \" << std::is_base_of<B, A>::value << '\\n';\n    std::cout << \"c2b: \" << std::is_base_of<C, B>::value << '\\n';\n    std::cout << \"same type: \" << std::is_base_of<C, C>::value << '\\n';\n}",
            "output": "a2b: true\nb2a: false\nc2b: false\nsame type: true"
        }
    },
    "is_convertible, std::is_nothrow_convertible": {
        "description": {
            "texte": "From and To shall each be a complete type, (possibly cv-qualified) void, or an array of unknown bound. Otherwise, the behavior is undefined.If an instantiation of a template above depends, directly or indirectly, on an incomplete type, and that instantiation could yield a different result if that type were hypothetically completed, the behavior is undefined."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nclass E { public: template<class T> E(T&&) { } };\n \nint main() \n{\n    class A {};\n    class B : public A {};\n    class C {};\n    class D { public: operator C() { return c; }  C c; };\n \n \n    bool b2a = std::is_convertible<B*, A*>::value;\n    bool a2b = std::is_convertible<A*, B*>::value;\n    bool b2c = std::is_convertible<B*, C*>::value;\n    bool d2c = std::is_convertible<D, C>::value;\n \n    // A Perfect Forwarding constructor make the class 'convert' from everything\n \n    bool everything2e = std::is_convertible<A, E>::value; //< B, C, D, etc\n \n    std::cout << std::boolalpha;\n \n    std::cout << b2a << '\\n';\n    std::cout << a2b << '\\n';\n    std::cout << b2c << '\\n';\n    std::cout << d2c << '\\n';\n    std::cout << '\\n';\n    std::cout << everything2e << '\\n';\n}",
            "output": "true\nfalse\nfalse\ntrue\n \ntrue"
        }
    },
    "is_invocable, std::is_invocable_r, std::is_nothrow_invocable, std::is_nothrow_invocable_r": {
        "description": {
            "texte": "Fn, R and all types in the parameter pack ArgTypes shall each be a complete type, (possibly cv-qualified) void, or an array of unknown bound. Otherwise, the behavior is undefined.If an instantiation of a template above depends, directly or indirectly, on an incomplete type, and that instantiation could yield a different result if that type were hypothetically completed, the behavior is undefined."
        },
        "exemple": {
            "input": "#include <type_traits>\n \nauto func2(char) -> int (*)()\n{\n    return nullptr;\n}\n \nint main()\n{\n    static_assert( std::is_invocable<int()>::value );\n    static_assert( std::is_invocable_r<int, int()>::value );\n    static_assert( std::is_invocable_r<void, void(int), int>::value );\n    static_assert( std::is_invocable_r<int(*)(), decltype(func2), char>::value );\n}"
        }
    },
    "invoke": {
        "description": {
            "texte": "Invoke the Callable object f with the parameters args. As by INVOKE(std::forward<F>(f), std::forward<Args>(args)...).where INVOKE(f, t1, t2, ..., tN) is defined as follows:"
        },
        "parametres": "   f   -   Callable object to be invoked \n   args   -   arguments to pass to f \n\n",
        "exemple": {
            "input": "#include <functional>\n#include <iostream>\n \nstruct Foo {\n    Foo(int num) : num_(num) {}\n    void print_add(int i) const { std::cout << num_+i << '\\n'; }\n    int num_;\n};\n \nvoid print_num(int i)\n{\n    std::cout << i << '\\n';\n}\n \nstruct PrintNum {\n    void operator()(int i) const\n    {\n        std::cout << i << '\\n';\n    }\n};\n \nint main()\n{\n    // invoke a free function\n    std::invoke(print_num, -9);\n \n    // invoke a lambda\n    std::invoke([]() { print_num(42); });\n \n    // invoke a member function\n    const Foo foo(314159);\n    std::invoke(&Foo::print_add, foo, 1);\n \n    // invoke (access) a data member\n    std::cout << \"num_: \" << std::invoke(&Foo::num_, foo) << '\\n';\n \n    // invoke a function object\n    std::invoke(PrintNum(), 18);\n}",
            "output": "-9\n42\n314160\nnum_: 314159\n18"
        }
    },
    "remove_cv, std::remove_const, std::remove_volatile": {
        "description": {
            "texte": "Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed.1) removes the topmost const, the topmost volatile, or both, if present.2) removes the topmost const.3) removes the topmost volatile."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nint main() {\n    typedef std::remove_cv<const int>::type type1;\n    typedef std::remove_cv<volatile int>::type type2;\n    typedef std::remove_cv<const volatile int>::type type3;\n    typedef std::remove_cv<const volatile int*>::type type4;\n    typedef std::remove_cv<int * const volatile>::type type5;\n \n    std::cout << \"test1 \" << (std::is_same<int, type1>::value\n        ? \"passed\" : \"failed\") << '\\n';\n    std::cout << \"test2 \" << (std::is_same<int, type2>::value\n        ? \"passed\" : \"failed\") << '\\n';\n    std::cout << \"test3 \" << (std::is_same<int, type3>::value\n        ? \"passed\" : \"failed\") << '\\n';\n    std::cout << \"test4 \" << (std::is_same<const volatile int*, type4>::value\n        ? \"passed\" : \"failed\") << '\\n';\n    std::cout << \"test5 \" << (std::is_same<int*, type5>::value\n        ? \"passed\" : \"failed\") << '\\n';\n}",
            "output": "test1 passed\ntest2 passed\ntest3 passed\ntest4 passed\ntest5 passed"
        }
    },
    "add_cv, std::add_const, std::add_volatile": {
        "description": {
            "texte": "Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier).1) adds both const and volatile.2) adds const.3) adds volatile."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nstruct foo\n{\n    void m() { std::cout << \"Non-cv\\n\"; }\n    void m() const { std::cout << \"Const\\n\"; }\n    void m() volatile { std::cout << \"Volatile\\n\"; }\n    void m() const volatile { std::cout << \"Const-volatile\\n\"; }\n};\n \nint main()\n{\n    foo{}.m();\n    std::add_const<foo>::type{}.m();\n    std::add_volatile<foo>::type{}.m();\n    std::add_cv<foo>::type{}.m();\n}",
            "output": "Non-cv\nConst\nVolatile\nConst-volatile"
        }
    },
    "remove_reference": {
        "description": {
            "texte": "If the type T is a reference type, provides the member typedef type which is the type referred to by T. Otherwise type is T."
        },
        "exemple": {
            "input": "#include <iostream> // std::cout\n#include <type_traits> // std::is_same\n \ntemplate<class T1, class T2>\nvoid print_is_same() {\n  std::cout << std::is_same<T1, T2>() << '\\n';\n}\n \nint main() {\n  std::cout << std::boolalpha;\n \n  print_is_same<int, int>();\n  print_is_same<int, int &>();\n  print_is_same<int, int &&>();\n \n  print_is_same<int, std::remove_reference<int>::type>();\n  print_is_same<int, std::remove_reference<int &>::type>();\n  print_is_same<int, std::remove_reference<int &&>::type>();\n}",
            "output": "true\nfalse\nfalse\ntrue\ntrue\ntrue"
        }
    },
    "add_lvalue_reference, std::add_rvalue_reference": {
        "description": {
            "texte": "Creates a lvalue or rvalue reference type of T."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nint main() {\n   using nonref = int;\n   using lref = typename std::add_lvalue_reference<nonref>::type;\n   using rref = typename std::add_rvalue_reference<nonref>::type;\n \n   std::cout << std::boolalpha;\n   std::cout << std::is_lvalue_reference<nonref>::value << '\\n';\n   std::cout << std::is_lvalue_reference<lref>::value << '\\n';\n   std::cout << std::is_rvalue_reference<rref>::value << '\\n';\n}",
            "output": "false\ntrue\ntrue"
        }
    },
    "remove_pointer": {
        "description": {
            "texte": "Provides the member typedef type which is the type pointed to by T, or, if T is not a pointer, then type is the same as T."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \ntemplate<class T1, class T2>\nvoid print_is_same() \n{\n    std::cout << std::is_same<T1, T2>() << '\\n';\n}\n \nvoid print_separator() \n{\n    std::cout << \"-----\\n\";\n}\n \nint main() \n{\n    std::cout << std::boolalpha;\n \n    print_is_same<int, int>();   // true\n    print_is_same<int, int*>();  // false\n    print_is_same<int, int**>(); // false\n \n    print_separator();\n \n    print_is_same<int, std::remove_pointer<int>::type>();   // true\n    print_is_same<int, std::remove_pointer<int*>::type>();  // true\n    print_is_same<int, std::remove_pointer<int**>::type>(); // false\n \n    print_separator();\n \n    print_is_same<int, std::remove_pointer<int* const>::type>();          // true\n    print_is_same<int, std::remove_pointer<int* volatile>::type>();       // true\n    print_is_same<int, std::remove_pointer<int* const volatile>::type>(); // true\n}",
            "output": "true\nfalse\nfalse\n-----\ntrue\ntrue\nfalse\n-----\ntrue\ntrue\ntrue"
        }
    },
    "add_pointer": {
        "description": {
            "texte": "If T is a reference type, then provides the member typedef type which is a pointer to the referred type.Otherwise, if T names an object type, a function type that is not cv- or ref-qualified, or a (possibly cv-qualified) void type, provides the member typedef type which is the type T*.Otherwise (if T is a cv- or ref-qualified function type), provides the member typedef type which is the type T."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nint main()\n{\n    int i = 123;\n    int& ri = i;\n    typedef std::add_pointer<decltype(i)>::type IntPtr;\n    typedef std::add_pointer<decltype(ri)>::type IntPtr2;\n    IntPtr pi = &i;\n    std::cout << \"i = \" << i << \"\\n\";\n    std::cout << \"*pi = \" << *pi << \"\\n\";\n \n    static_assert(std::is_pointer<IntPtr>::value, \"IntPtr should be a pointer\");\n    static_assert(std::is_same<IntPtr, int*>::value, \"IntPtr should be a pointer to int\");\n    static_assert(std::is_same<IntPtr2, IntPtr>::value, \"IntPtr2 should be equal to IntPtr\");\n \n    typedef std::remove_pointer<IntPtr>::type IntAgain;\n    IntAgain j = i;\n    std::cout << \"j = \" << j << \"\\n\";\n \n    static_assert(!std::is_pointer<IntAgain>::value, \"IntAgain should not be a pointer\");\n    static_assert(std::is_same<IntAgain, int>::value, \"IntAgain should be equal to int\");\n}",
            "output": "i = 123\n*pi = 123\nj = 123"
        }
    },
    "make_signed": {
        "description": {
            "texte": "If T is an integral (except bool) or enumeration type, provides the member typedef type which is the signed integer type corresponding to T, with the same cv-qualifiers.Otherwise, the behavior is undefined."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nint main() {\n    typedef std::make_signed<unsigned char>::type char_type;\n    typedef std::make_signed<unsigned int>::type int_type;\n    typedef std::make_signed<volatile unsigned long>::type long_type;\n \n    bool ok1 = std::is_same<char_type, signed char>::value;\n    bool ok2 = std::is_same<int_type, signed int>::value;\n    bool ok3 = std::is_same<long_type, volatile signed long>::value;\n \n    std::cout << std::boolalpha\n    << \"char_type is 'signed char'?          : \" << ok1 << '\\n'\n    << \"int_type  is 'signed int'?           : \" << ok2 << '\\n'\n    << \"long_type is 'volatile signed long'? : \" << ok3 << '\\n';\n}",
            "output": "char_type is 'signed char'?          : true\nint_type  is 'signed int'?           : true\nlong_type is 'volatile signed long'? : true"
        }
    },
    "make_unsigned": {
        "description": {
            "texte": "If T is an integral (except bool) or enumeration type, provides the member typedef type which is the unsigned integer type corresponding to T, with the same cv-qualifiers. The unsigned integer type corresponding to an enumeration type is the unsigned integer type with the smallest rank having the same sizeof as the enumeration.Otherwise, the behavior is undefined."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nint main() {\n    typedef std::make_unsigned<char>::type char_type;\n    typedef std::make_unsigned<int>::type int_type;\n    typedef std::make_unsigned<volatile long>::type long_type;\n \n    bool ok1 = std::is_same<char_type, unsigned char>::value; \n    bool ok2 = std::is_same<int_type, unsigned int>::value;\n    bool ok3 = std::is_same<long_type, volatile unsigned long>::value;\n \n    std::cout << std::boolalpha\n    << \"char_type is 'unsigned char'?          : \" << ok1 << '\\n'\n    << \"int_type  is 'unsigned int'?           : \" << ok2 << '\\n'\n    << \"long_type is 'volatile unsigned long'? : \" << ok3 << '\\n';\n}",
            "output": "char_type is 'unsigned char'?          : true\nint_type  is 'unsigned int'?           : true\nlong_type is 'volatile unsigned long'? : true"
        }
    },
    "remove_extent": {
        "description": {
            "texte": "If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T. Note that if T is a multidimensional array, only the first dimension is removed."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n#include <algorithm>\n#include <type_traits>\n \ntemplate<class A>\ntypename std::enable_if< std::rank<A>::value == 1 >::type\nprint_1d(const A& a)\n{\n    copy(a, a+std::extent<A>::value,\n         std::ostream_iterator<typename std::remove_extent<A>::type>(std::cout, \" \"));\n    std::cout << '\\n';\n}\n \nint main()\n{\n    int a[][3] = {{1,2,3},{4,5,6}};\n//  print_1d(a); // compile-time error\n    print_1d(a[1]);\n}",
            "output": "4 5 6"
        }
    },
    "remove_all_extents": {
        "description": {
            "texte": "If T is a multidimensional array of some type X, provides the member typedef type equal to X, otherwise type is T."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n#include <typeinfo>\n \ntemplate<class A>\nvoid foo(const A&)\n{\n    typedef typename std::remove_all_extents<A>::type Type;\n    std::cout << \"underlying type: \" << typeid(Type).name() << '\\n';\n}\n \nint main()\n{\n    float a1[1][2][3];\n    int a2[3][2];\n    float a3[1][1][1][1][2];\n    double a4[2][3];\n \n    foo(a1);\n    foo(a2);\n    foo(a3);\n    foo(a4);\n}",
            "output": "underlying type: f\nunderlying type: i\nunderlying type: f\nunderlying type: d"
        }
    },
    "aligned_storage": {
        "description": {
            "texte": "Provides the nested type type, which is a trivial standard-layout type suitable for use as uninitialized storage for any object whose size is at most Len and whose alignment requirement is a divisor of Align.The default value of Align is the most stringent (the largest) alignment requirement for any object whose size is at most Len. If the default value is not used, Align must be the value of alignof(T) for some type T, or the behavior is undefined.The behavior is undefined if Len == 0.It is implementation-defined whether any extended alignment is supported."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n#include <string>\n \ntemplate<class T, std::size_t N>\nclass static_vector\n{\n    // properly aligned uninitialized storage for N T's\n    typename std::aligned_storage<sizeof(T), alignof(T)>::type data[N];\n    std::size_t m_size = 0;\n \npublic:\n    // Create an object in aligned storage\n    template<typename ...Args> void emplace_back(Args&&... args) \n    {\n        if( m_size >= N ) // possible error handling\n            throw std::bad_alloc{};\n \n        // construct value in memory of aligned storage\n        // using inplace operator new\n        new(&data[m_size]) T(std::forward<Args>(args)...);\n        ++m_size;\n    }\n \n    // Access an object in aligned storage\n    const T& operator[](std::size_t pos) const \n    {\n        // note: needs std::launder as of C++17\n        return *reinterpret_cast<const T*>(&data[pos]);\n    }\n \n    // Delete objects from aligned storage\n    ~static_vector() \n    {\n        for(std::size_t pos = 0; pos < m_size; ++pos) {\n            // note: needs std::launder as of C++17\n            reinterpret_cast<T*>(&data[pos])->~T();\n        }\n    }\n};\n \nint main()\n{\n    static_vector<std::string, 10> v1;\n    v1.emplace_back(5, '*');\n    v1.emplace_back(10, '*');\n    std::cout << v1[0] << '\\n' << v1[1] << '\\n';\n}",
            "output": "*****\n**********"
        }
    },
    "aligned_union": {
        "description": {
            "texte": "Provides the nested type type, which is a trivial standard-layout type of a size and alignment suitable for use as uninitialized storage for an object of any of the types listed in Types. The size of the storage is at least Len. std::aligned_union also determines the strictest (largest) alignment requirement among all Types and makes it available as the constant alignment_value.If sizeof...(Types) == 0 or if any of the types in Types is not a complete object type, the behavior is undefined.It is implementation-defined whether any extended alignment is supported."
        }
    },
    "decay": {
        "description": {
            "texte": "Applies lvalue-to-rvalue, array-to-pointer, and function-to-pointer implicit conversions to the type T, removes cv-qualifiers, and defines the resulting type as the member typedef type. Formally:These conversions model the type conversion applied to all function arguments when passed by value."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \ntemplate <typename T, typename U>\nstruct decay_equiv : \n    std::is_same<typename std::decay<T>::type, U>::type \n{};\n \nint main()\n{\n    std::cout << std::boolalpha\n              << decay_equiv<int, int>::value << '\\n'\n              << decay_equiv<int&, int>::value << '\\n'\n              << decay_equiv<int&&, int>::value << '\\n'\n              << decay_equiv<const int&, int>::value << '\\n'\n              << decay_equiv<int[2], int*>::value << '\\n'\n              << decay_equiv<int(int), int(*)(int)>::value << '\\n';\n}",
            "output": "true\ntrue\ntrue\ntrue\ntrue\ntrue"
        }
    },
    "remove_cvref": {
        "description": {
            "texte": "If the type T is a reference type, provides the member typedef type which is the type referred to by T with its topmost cv-qualifiers removed. Otherwise type is T with its topmost cv-qualifiers removed."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nint main()\n{\n    std::cout << std::boolalpha\n              << std::is_same_v<std::remove_cvref_t<int>, int> << '\\n'\n              << std::is_same_v<std::remove_cvref_t<int&>, int> << '\\n'\n              << std::is_same_v<std::remove_cvref_t<int&&>, int> << '\\n'\n              << std::is_same_v<std::remove_cvref_t<const int&>, int> << '\\n'\n              << std::is_same_v<std::remove_cvref_t<const int[2]>, int[2]> << '\\n'\n              << std::is_same_v<std::remove_cvref_t<const int(&)[2]>, int[2]> << '\\n'\n              << std::is_same_v<std::remove_cvref_t<int(int)>, int(int)> << '\\n';\n}",
            "output": "true\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue"
        }
    },
    "enable_if": {
        "description": {
            "texte": "If B is true, std::enable_if has a public member typedef type, equal to T; otherwise, there is no member typedef.This metafunction is a convenient way to leverage SFINAE to conditionally remove functions from overload resolution based on type traits and to provide separate function overloads and specializations for different type traits. std::enable_if can be used as an additional function argument (not applicable to operator overloads), as a return type (not applicable to constructors and destructors), or as a class template or function template parameter."
        },
        "exemple": {
            "input": "#include <type_traits>\n#include <iostream>\n#include <string>\n \nnamespace detail { struct inplace_t{}; }\nvoid* operator new(std::size_t, void* p, detail::inplace_t) {\n    return p;\n}\n \n// #1, enabled via the return type\ntemplate<class T,class... Args>\ntypename std::enable_if<std::is_trivially_constructible<T,Args&&...>::value>::type \n    construct(T* t,Args&&... args) \n{\n    std::cout << \"constructing trivially constructible T\\n\";\n}\n \n// #2\ntemplate<class T, class... Args>\nstd::enable_if_t<!std::is_trivially_constructible<T,Args&&...>::value> //Using helper type\n    construct(T* t,Args&&... args) \n{\n    std::cout << \"constructing non-trivially constructible T\\n\";\n    new(t, detail::inplace_t{}) T(args...);\n}\n \n// #3, enabled via a parameter\ntemplate<class T>\nvoid destroy(\n    T* t, \n    typename std::enable_if<\n        std::is_trivially_destructible<T>::value\n    >::type* = 0\n){\n    std::cout << \"destroying trivially destructible T\\n\";\n}\n \n// #4, enabled via a template parameter\ntemplate<class T,\n         typename std::enable_if<\n             !std::is_trivially_destructible<T>{} &&\n             (std::is_class<T>{} || std::is_union<T>{}),\n            int>::type = 0>\nvoid destroy(T* t)\n{\n    std::cout << \"destroying non-trivially destructible T\\n\";\n    t->~T();\n}\n \n// #5, enabled via a template parameter\ntemplate<class T,\n        typename = std::enable_if_t<std::is_array<T>::value> >\nvoid destroy(T* t) // note, function signature is unmodified\n{\n    for(std::size_t i = 0; i < std::extent<T>::value; ++i) {\n        destroy((*t)[i]);\n    }\n}\n/*\ntemplate<class T,\n        typename = std::enable_if_t<std::is_void<T>::value> >\nvoid destroy(T* t){} // error: has the same signature with #5\n*/\n \n// the partial specialization of A is enabled via a template parameter\ntemplate<class T, class Enable = void>\nclass A {}; // primary template\n \ntemplate<class T>\nclass A<T, typename std::enable_if<std::is_floating_point<T>::value>::type> {\n}; // specialization for floating point types\n \nint main()\n{\n    std::aligned_union_t<0,int,std::string> u;\n \n    construct(reinterpret_cast<int*>(&u));\n    destroy(reinterpret_cast<int*>(&u));\n \n    construct(reinterpret_cast<std::string*>(&u),\"Hello\");\n    destroy(reinterpret_cast<std::string*>(&u));\n \n    A<int> a1; // OK, matches the primary template\n    A<double> a2; // OK, matches the partial specialization\n}",
            "output": "constructing trivially constructible T\ndestroying trivially destructible T\nconstructing non-trivially constructible T\ndestroying non-trivially destructible T"
        }
    },
    "conditional": {
        "description": {
            "texte": "Provides member typedef type, which is defined as T if B is true at compile time, or as F if B is false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n#include <typeinfo>\n \nint main() \n{\n    typedef std::conditional<true, int, double>::type Type1;\n    typedef std::conditional<false, int, double>::type Type2;\n    typedef std::conditional<sizeof(int) >= sizeof(double), int, double>::type Type3;\n \n    std::cout << typeid(Type1).name() << '\\n';\n    std::cout << typeid(Type2).name() << '\\n';\n    std::cout << typeid(Type3).name() << '\\n';\n}",
            "output": "int\ndouble\ndouble"
        }
    },
    "common_type": {
        "description": {
            "texte": "Determines the common type among all types T..., that is the type all T... can be implicitly converted to. If such a type exists (as determined according to the rules below), the member type names that type. Otherwise, there is no member type.The types in the parameter pack T shall each be a complete type, (possibly cv-qualified) void, or an array of unknown bound. Otherwise, the behavior is undefined.If an instantiation of a template above depends, directly or indirectly, on an incomplete type, and that instantiation could yield a different result if that type were hypothetically completed, the behavior is undefined."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \ntemplate <class T>\nstruct Number { T n; };\n \ntemplate <class T, class U>\nNumber<typename std::common_type<T, U>::type> operator+(const Number<T>& lhs,\n                                                        const Number<U>& rhs) \n{\n    return {lhs.n + rhs.n};\n}\n \nint main()\n{\n    Number<int> i1 = {1}, i2 = {2};\n    Number<double> d1 = {2.3}, d2 = {3.5};\n    std::cout << \"i1i2: \" << (i1 + i2).n << \"\\ni1d2: \" << (i1 + d2).n << '\\n'\n              << \"d1i2: \" << (d1 + i2).n << \"\\nd1d2: \" << (d1 + d2).n << '\\n';\n}",
            "output": "i1i2: 3\ni1d2: 4.5\nd1i2: 4.3\nd1d2: 5.8"
        }
    },
    "underlying_type": {
        "description": {
            "texte": "If T is a complete enumeration type, provides a member typedef type that names the underlying type of T."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nenum e1 {};\nenum class e2: int {};\n \nint main() {\n    bool e1_type = std::is_same<\n        unsigned\n       ,typename std::underlying_type<e1>::type\n    >::value; \n \n    bool e2_type = std::is_same<\n        int\n       ,typename std::underlying_type<e2>::type\n    >::value;\n \n    std::cout\n    << \"underlying type for 'e1' is \" << (e1_type?\"unsigned\":\"non-unsigned\") << '\\n'\n    << \"underlying type for 'e2' is \" << (e2_type?\"int\":\"non-int\") << '\\n';\n}",
            "output": "underlying type for 'e1' is unsigned\nunderlying type for 'e2' is int"
        }
    },
    "result_of, std::invoke_result": {
        "description": {
            "texte": "Deduces the return type of an INVOKE expression at compile time."
        },
        "exemple": {
            "input": "#include <type_traits>\n#include <iostream>\n \nstruct S {\n    double operator()(char, int&);\n    float operator()(int) { return 1.0;}\n};\n \ntemplate<class T>\ntypename std::result_of<T(int)>::type f(T& t)\n{\n    std::cout << \"overload of f for callable T\\n\";\n    return t(0);\n}\n \ntemplate<class T, class U>\nint f(U u)\n{\n    std::cout << \"overload of f for non-callable T\\n\";\n    return u;\n}\n \nint main()\n{\n    // the result of invoking S with char and int& arguments is double\n    std::result_of<S(char, int&)>::type d = 3.14; // d has type double\n    static_assert(std::is_same<decltype(d), double>::value, \"\");\n \n    // the result of invoking S with int argument is float\n    std::result_of<S(int)>::type x = 3.14; // x has type float\n    static_assert(std::is_same<decltype(x), float>::value, \"\");\n \n    // result_of can be used with a pointer to member function as follows\n    struct C { double Func(char, int&); };\n    std::result_of<decltype(&C::Func)(C, char, int&)>::type g = 3.14;\n    static_assert(std::is_same<decltype(g), double>::value, \"\");\n \n    f<C>(1); // may fail to compile in C++11; calls the non-callable overload in C++14\n}",
            "output": "overload of f for non-callable T"
        }
    },
    "void_t": {
        "description": {
            "texte": "Utility metafunction that maps a sequence of any types to the type void."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n#include <vector>\n#include <map>\n \nclass A {};\n \ntemplate <typename T, typename = void>\nstruct is_iterable : std::false_type {};\ntemplate <typename T>\nstruct is_iterable<T, std::void_t<decltype(std::declval<T>().begin()),\n                                  decltype(std::declval<T>().end())>>\n    : std::true_type {};\n \n// An iterator trait which value_type is always the value_type of the \n// iterated container, even with back_insert_iterator which value_type is void\n \ntemplate <typename T, typename = void>\nstruct iterator_trait \n: std::iterator_traits<T> {};\ntemplate <typename T>\nstruct iterator_trait<T, std::void_t<typename T::container_type>> \n: std::iterator_traits<typename T::container_type::iterator> {};\n \nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << is_iterable<std::vector<double>>::value << '\\n';\n    std::cout << is_iterable<std::map<int, double>>::value << '\\n';\n    std::cout << is_iterable<double>::value << '\\n';\n    std::cout << is_iterable<A>::value << '\\n';\n \n \n    std::vector<int> v;\n \n    std::cout << std::is_same<iterator_trait<decltype(std::back_inserter(v))>::value_type\n    , iterator_trait<decltype(v.cbegin())>::value_type >::value << '\\n';\n}",
            "output": "true\ntrue\nfalse\nfalse\ntrue"
        }
    },
    "conjunction": {
        "description": {
            "texte": "Forms the logical conjunction of the type traits B..., effectively performing a logical AND on the sequence of traits.The specialization std::conjunction<B1, ..., BN> has a public and unambiguous base that is.The member names of the base class, other than conjunction and operator=, are not hidden and are unambiguously available in conjunction.Conjunction is short-circuiting: if there is a template type argument Bi with bool(Bi::value) == false, then instantiating conjunction<B1, ..., BN>::value does not require the instantiation of Bj::value for j > i."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \n// func is enabled if all Ts... have the same type as T\ntemplate<typename T, typename... Ts>\nstd::enable_if_t<std::conjunction_v<std::is_same<T, Ts>...>>\nfunc(T, Ts...) {\n    std::cout << \"all types in pack are T\\n\";\n}\n \n// otherwise\ntemplate<typename T, typename... Ts>\nstd::enable_if_t<!std::conjunction_v<std::is_same<T, Ts>...>>\nfunc(T, Ts...) {\n    std::cout << \"not all types in pack are T\\n\";\n}\n \nint main() {\n    func(1, 2, 3);\n    func(1, 2, \"hello!\");\n}",
            "output": "all types in pack are T\nnot all types in pack are T"
        }
    },
    "disjunction": {
        "description": {
            "texte": "Forms the logical disjunction of the type traits B..., effectively performing a logical OR on the sequence of traits.The specialization std::disjunction<B1, ..., BN> has a public and unambiguous base that is.The member names of the base class, other than disjunction and operator=, are not hidden and are unambiguously available in disjunction.Disjunction is short-circuiting: if there is a template type argument Bi with bool(Bi::value) != false, then instantiating disjunction<B1, ..., BN>::value does not require the instantiation of Bj::value for j > i."
        },
        "exemple": {
            "input": "#include <type_traits>\n#include <string>\n \n// checking if Foo is constructible from double will cause a hard error\nstruct Foo {\n    template<class T>\n    struct sfinae_unfriendly_check { static_assert(!std::is_same_v<T, double>); };\n \n    template<class T>\n    Foo(T, sfinae_unfriendly_check<T> = {} );\n};\n \ntemplate<class... Ts>\nstruct first_constructible {\n    template<class T, class...Args>\n    struct is_constructible_x : std::is_constructible<T, Args...> {\n        using type = T;\n    };\n    struct fallback {\n        static constexpr bool value = true;\n        using type = void; // type to return if nothing is found\n    };\n \n    template<class... Args>\n    using with = typename std::disjunction<is_constructible_x<Ts, Args...>...,\n                                           fallback>::type;\n};\n \n// OK, is_constructible<Foo, double> not instantiated\nstatic_assert(std::is_same_v<first_constructible<std::string, int, Foo>::with<double>,\n                             int>);\n \nstatic_assert(std::is_same_v<first_constructible<std::string, int>::with<>, std::string>);\nstatic_assert(std::is_same_v<first_constructible<std::string, int>::with<const char*>,\n                             std::string>);\nstatic_assert(std::is_same_v<first_constructible<std::string, int>::with<void*>, void>);\n \nint main() { }"
        }
    },
    "negation": {
        "description": {
            "texte": "Forms the logical negation of the type trait B.The type std::negation<B> is a UnaryTypeTrait with a BaseCharacteristic of std::bool_constant<!bool(B::value)>."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n \nstatic_assert(\n    std::is_same<\n        std::bool_constant<false>,\n        typename std::negation<std::bool_constant<true>>::type>::value,\n    \"\");\nstatic_assert(\n    std::is_same<\n        std::bool_constant<true>,\n        typename std::negation<std::bool_constant<false>>::type>::value,\n    \"\");\n \nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << std::negation<std::bool_constant<true>>::value << '\\n';\n    std::cout << std::negation<std::bool_constant<false>>::value << '\\n';\n}",
            "output": "false\ntrue"
        }
    },
    "endian": {
        "description": {
            "texte": "Indicates the endianness of all scalar types:Corner case platforms are also supported:"
        }
    },
    "is_constant_evaluated": {
        "description": {
            "texte": "Detects whether the function call occurs within a constant-evaluated context. Returns true if the evaluation of the call occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated; otherwise returns false.The following expressions (including conversions to the destination type) are manifestly constant-evaluated:To test the last two conditions, compilers may first perform a trial constant evaluation of the initializers. It is not recommended to depend on the result in this case.",
            "code": "int y;\nconst int a = std::is_constant_evaluated() ? y : 1;\n// Trial constant evaluation fails. The constant evaluation is discarded.\n// Variable a is dynamically initialized with 1\n \nconst int b = std::is_constant_evaluated() ? 2 : y;\n// Constant evaluation with std::is_constant_evaluation() == true succeeds.\n// Variable b is statically initialized with 2"
        }
    },
    "ratio": {
        "description": {
            "texte": "The class template std::ratio provides compile-time rational arithmetic support. Each instantiation of this template exactly represents any finite rational number as long as its numerator Num and denominator Denom are representable as compile-time constants of type std::intmax_t. In addition, Denom may not be zero and may not be equal to the most negative value.The static data members nom and den representing the numerator and denominator are calculated by dividing Num and Denom by their greatest common divisor. However, two std::ratio with different Num or Denom are distinct types even if they represent the same rational number (after reduction). A ratio type can be reduced to the lowest terms via its type member: std::ratio<3, 6>::type is std::ratio<1, 2>.Several convenience typedefs that correspond to the SI ratios are provided by the standard library:"
        }
    },
    "ratio_add": {
        "description": {
            "texte": "The alias template std::ratio_add denotes the result of adding two exact rational fractions represented by the std::ratio specializations R1 and R2.The result is a std::ratio specialization std::ratio<U, V>, such that given Num == R1::num * R2::den + R2::num * R1::den and Denom == R1::den * R2::den (computed without arithmetic overflow), U is std::ratio<Num, Denom>::num and V is std::ratio<Num, Denom>::den."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <ratio>\n \nint main()\n{\n    typedef std::ratio<2, 3> two_third;\n    typedef std::ratio<1, 6> one_sixth;\n \n    typedef std::ratio_add<two_third, one_sixth> sum;\n    std::cout << \"2/3 + 1/6 = \" << sum::num << '/' << sum::den << '\\n';\n}",
            "output": "2/3 + 1/6 = 5/6"
        }
    },
    "ratio_subtract": {
        "description": {
            "texte": "The alias template std::ratio_subtract denotes the result of subtracting two exact rational fractions represented by the std::ratio specializations R1 and R2.The result is a std::ratio specialization std::ratio<U, V>, such that given Num == R1::num * R2::den - R2::num * R1::den and Denom == R1::den * R2::den (computed without arithmetic overflow), U is std::ratio<Num, Denom>::num and V is std::ratio<Num, Denom>::den."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <ratio>\n \nint main()\n{\n    typedef std::ratio<2, 3> two_third;\n    typedef std::ratio<1, 6> one_sixth;\n \n    typedef std::ratio_subtract<two_third, one_sixth> diff;\n    std::cout << \"2/3 - 1/6 = \" << diff::num << '/' << diff::den << '\\n';\n}",
            "output": "2/3 - 1/6 = 1/2"
        }
    },
    "ratio_multiply": {
        "description": {
            "texte": " The alias template std::ratio_multiply denotes the result of multiplying two exact rational fractions represented by the std::ratio specializations R1 and R2.The result is a std::ratio specialization std::ratio<U, V>, such that given Num == R1::num * R2::num and Denom == R1::den * R2::den (computed without arithmetic overflow), U is std::ratio<Num, Denom>::num and V is std::ratio<Num, Denom>::den."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <ratio>\n \nint main()\n{\n    typedef std::ratio<2, 3> two_third;\n    typedef std::ratio<1, 6> one_sixth;\n    typedef std::ratio_multiply<two_third, one_sixth> r;\n    std::cout << \"2/3 * 1/6 = \" << r::num << '/' << r::den << '\\n';\n}",
            "output": "2/3 * 1/6 = 1/9"
        }
    },
    "ratio_divide": {
        "description": {
            "texte": "The alias template std::ratio_divide denotes the result of dividing two exact rational fractions represented by the std::ratio specializations R1 and R2.The result is a std::ratio specialization std::ratio<U, V>, such that given Num == R1::num * R2::den and Denom == R1::den * R2::num (computed without arithmetic overflow), U is std::ratio<Num, Denom>::num and V is std::ratio<Num, Denom>::den."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <ratio>\n \nint main()\n{\n    typedef std::ratio<2, 3> two_third;\n    typedef std::ratio<1, 6> one_sixth;\n    typedef std::ratio_divide<two_third, one_sixth> r;\n    std::cout << \"2/3 / 1/6 = \" << r::num << '/' << r::den << '\\n';\n}",
            "output": "2/3 / 1/6 = 4/1"
        }
    },
    "ratio_equal": {
        "description": {
            "texte": "If the ratios R1 and R2 are equal, provides the member constant value equal true. Otherwise, value is false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <ratio>\n \nint main()\n{\n    if(std::ratio_equal<std::ratio<2,3>, std::ratio<4,6>>::value) {\n        std::cout << \"2/3 == 4/6\\n\";\n    } else {\n        std::cout << \"2/3 != 4/6\\n\";\n    }\n}",
            "output": "2/3 == 4/6"
        }
    },
    "ratio_not_equal": {
        "description": {
            "texte": "If the ratios R1 and R2 are not equal, provides the member constant value equal true. Otherwise, value is false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <ratio>\n \nint main()\n{\n    if(std::ratio_not_equal<std::ratio<2,3>, std::ratio<1,3>>::value) {\n        std::cout << \"2/3 != 1/3\\n\";\n    } else {\n        std::cout << \"2/3 == 1/3\\n\";\n    }\n}",
            "output": "2/3 != 1/3"
        }
    },
    "ratio_less": {
        "description": {
            "texte": "If the ratio R1 is less than the ratio R2, provides the member constant value equal true. Otherwise, value is false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <ratio>\n \nint main()\n{\n    if (std::ratio_less<std::ratio<23,37>, std::ratio<57,90>>::value) {\n        std::cout << \"23/37 < 57/90\\n\";\n    }\n}",
            "output": "23/37 < 57/90"
        }
    },
    "ratio_less_equal": {
        "description": {
            "texte": "If the ratio R1 is less than or equal to the ratio R2, provides the member constant value equal true. Otherwise, value is false."
        }
    },
    "ratio_greater": {
        "description": {
            "texte": "If the ratio R1 is greater than than the ratio R2, provides the member constant value equal true. Otherwise, value is false."
        }
    },
    "ratio_greater_equal": {
        "description": {
            "texte": "If the ratio R1 is greater than or equal to the ratio R2, provides the member constant value equal true. Otherwise, value is false."
        }
    },
    "chrono::system_clock": {
        "description": {
            "texte": "Class std::chrono::system_clock represents the system-wide real time wall clock.It may not be monotonic: on most systems, the system time can be adjusted at any moment. It is the only C++ clock that has the ability to map its time points to C-style time, and, therefore, to be displayed (until C++20).std::chrono::system_clock meets the requirements of TrivialClock."
        }
    },
    "chrono::steady_clock": {
        "description": {
            "texte": "Class std::chrono::steady_clock represents a monotonic clock. The time points of this clock cannot decrease as physical time moves forward and the time between ticks of this clock is constant. This clock is not related to wall clock time (for example, it can be time since last reboot), and is most suitable for measuring intervals.std::chrono::steady_clock meets the requirements of TrivialClock."
        }
    },
    "chrono::high_resolution_clock": {
        "description": {
            "texte": "Class std::chrono::high_resolution_clock represents the clock with the smallest tick period provided by the implementation. It may be an alias of std::chrono::system_clock or std::chrono::steady_clock, or a third, independent clock.std::chrono::high_resolution_clock meets the requirements of TrivialClock."
        }
    },
    "chrono::treat_as_floating_point": {
        "description": {
            "texte": "The std::chrono::treat_as_floating_point trait helps determine if a duration can be converted to another duration with a different tick period.Implicit conversions between two durations normally depends on the tick period of the durations. However, implicit conversions can happen regardless of tick period if std::chrono::treat_as_floating_point<Rep>::value == true."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n#include <thread>\n \nvoid timed_piece_of_code() \n{\n    std::chrono::milliseconds simulated_work(2);\n    std::this_thread::sleep_for(simulated_work);\n}\n \nint main() \n{\n    auto start = std::chrono::high_resolution_clock::now();\n \n    std::cout << \"Running some timed piece of code...\" << '\\n';\n    timed_piece_of_code();\n \n    auto stop = std::chrono::high_resolution_clock::now();\n \n    // A floating point milliseconds type\n    using FpMilliseconds = \n        std::chrono::duration<float, std::chrono::milliseconds::period>;\n \n    static_assert(std::chrono::treat_as_floating_point<FpMilliseconds::rep>::value, \n                  \"Rep required to be floating point\");\n \n    // Note that implicit conversion is not allowed here    \n    auto i_ms = std::chrono::duration_cast<std::chrono::milliseconds>(stop - start);\n \n    // Note that implicit conversion is allowed here\n    auto f_ms = FpMilliseconds(stop - start);\n \n    std::cout << \"Time in milliseconds, using default rep: \"\n              << i_ms.count() << '\\n';\n \n \n    std::cout << \"Time in milliseconds, using floating point rep: \"\n              << f_ms.count() << '\\n';\n \n}",
            "output": "Running some timed piece of code...\nTiming stats:\n  Time in milliseconds, using default rep: 2\n  Time in milliseconds, using floating point rep: 2.57307"
        }
    },
    "chrono::duration_values": {
        "description": {
            "texte": "The std::chrono::duration_values type defines three common durations:The zero, min, and max methods in std::chrono::duration forward their work to these methods.This type can be specialized if the representation Rep requires a specific implementation to return these duration objects."
        }
    },
    "common_type(std::chrono::duration)\n": {
        "description": {
            "texte": "Exposes the type named type, which is the common type of two std::chrono::durations."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n \n// std::chrono already finds the greatest common divisor,\n// likely using std::common_type<>. We make the type\n// deduction externally. \n \ntemplate <typename T,typename S>\nauto durationDiff(const T& t, const S& s)  -> typename std::common_type<T,S>::type\n{\n    typedef typename std::common_type<T,S>::type Common;\n    return Common(t) - Common(s);\n}\n \n \nint main() \n{\n    typedef std::chrono::milliseconds milliseconds;\n    typedef std::chrono::microseconds microseconds;\n \n    auto ms = milliseconds(30);\n    auto us = microseconds(1100);\n \n    std::cout << ms.count() << \"ms - \" << us.count() << \"us = \" \n              << durationDiff(ms,us).count() <<  \"\\n\";\n}",
            "output": "30ms - 1100us = 28900"
        }
    },
    "common_type(std::chrono::time_point)\n": {
        "description": {
            "texte": "Exposes the type named type, which is the common type of two std::chrono::time_points."
        }
    },
    "operator+,-,*,/,%(std::chrono::duration)\n": {
        "description": {
            "texte": "Performs basic arithmetic operations between two durations or between a duration and a tick count."
        },
        "parametres": "   lhs   -   duration on the left-hand side of the operator \n   rhs   -   duration on the right-hand side of the operator \n   d   -   the duration argument for mixed-argument operators \n   s   -   tick count argument for mixed-argument operators \n\n",
        "exemple": {
            "input": "#include <chrono>\n#include <iostream>\nint main()\n{\n    // simple arithmetic\n    std::chrono::seconds s = std::chrono::hours(1) \n                             + 2*std::chrono::minutes(10)\n                             + std::chrono::seconds(70)/10;\n \n    std::cout << \"1 hour + 2*10 min + 70/10 sec = \" << s.count() << \" seconds\\n\";\n \n    // difference between dividing a duration by a number\n    // and dividing a duration by another duration\n    std::cout << \"Dividing that by 2 minutes gives \"\n              << s / std::chrono::minutes(2) << '\\n';\n    std::cout << \"Dividing that by 2 gives \"\n              << (s / 2).count() << \" seconds\\n\";\n \n   // the remainder operator is useful in determining where in a time\n   // frame is this particular duration, e.g. to break it down into hours,\n   // minutes, and seconds:\n   std::cout << s.count() << \" seconds is \"\n             << std::chrono::duration_cast<std::chrono::hours>(\n                    s\n                ).count() << \" hours, \"\n             << std::chrono::duration_cast<std::chrono::minutes>(\n                    s % std::chrono::hours(1)\n                ).count() << \" minutes, \"\n             << std::chrono::duration_cast<std::chrono::seconds>(\n                    s % std::chrono::minutes(1)\n                ).count() << \" seconds\\n\";\n}",
            "output": "1 hour + 2*10 min + 70/10 sec = 4807 seconds\nDividing that by 2 minutes gives 40\nDividing that by 2 gives 2403 seconds\n4807 seconds is 1 hours, 20 minutes, 7 seconds"
        }
    },
    "operator==,!=,,>=(std::chrono::duration)\n": {
        "description": {
            "texte": "Compares two durations.1-2) Checks if lhs and rhs are equal, i.e. the number of ticks for the type common to both durations are equal.3-6) Compares lhs to rhs, i.e. compares the number of ticks for the type common to both durations."
        },
        "parametres": "   lhs   -   duration on the left-hand side of the operator \n   rhs   -   duration on the right-hand side of the operator \n\n",
        "exemple": {
            "input": "#include <chrono>\n#include <iostream>\nint main()\n{\n    if(std::chrono::seconds(2) == std::chrono::milliseconds(2000))\n        std::cout <<  \"2 s == 2000 ms\\n\";\n    else\n        std::cout <<  \"2 s != 2000 ms\\n\";\n \n    if(std::chrono::seconds(61) > std::chrono::minutes(1))\n        std::cout <<  \"61 s > 1 min\\n\";\n    else\n        std::cout <<  \"61 s <= 1 min\\n\";\n \n}",
            "output": "2 s == 2000 ms\n61 s > 1 min"
        }
    },
    "chrono::duration_cast": {
        "description": {
            "texte": "Converts a std::chrono::duration to a duration of different type ToDuration.No implicit conversions are used. Multiplications and divisions are avoided where possible, if it is known at compile time that one or more parameters are 1. Computations are done in the widest type available and converted, as if by static_cast, to the result type only when finished."
        },
        "parametres": "   d   -   duration to convert \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n#include <ratio>\n#include <thread>\n \nvoid f()\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nint main()\n{\n    auto t1 = std::chrono::high_resolution_clock::now();\n    f();\n    auto t2 = std::chrono::high_resolution_clock::now();\n \n    // floating-point duration: no duration_cast needed\n    std::chrono::duration<double, std::milli> fp_ms = t2 - t1;\n \n    // integral duration: requires duration_cast\n    auto int_ms = std::chrono::duration_cast<std::chrono::milliseconds>(t2 - t1);\n \n    // converting integral duration to integral duration of shorter divisible time unit:\n    // no duration_cast needed\n    std::chrono::duration<long, std::micro> int_usec = int_ms;\n \n    std::cout << \"f() took \" << fp_ms.count() << \" ms, \"\n              << \"or \" << int_ms.count() << \" whole milliseconds \"\n              << \"(which is \" << int_usec.count() << \" whole microseconds)\" << std::endl;\n}",
            "output": "f() took 1000.23 ms, or 1000 whole milliseconds (which is 1000000 whole microseconds)"
        }
    },
    "chrono::floor(std::chrono::duration)": {
        "description": {
            "texte": "Returns the greatest duration t representable in ToDuration that is less or equal to d.The function does not participate in the overload resolution unless ToDuration is an instance of std::chrono::duration."
        },
        "parametres": "   d   -   duration to convert \n\n"
    },
    "chrono::ceil(std::chrono::duration)": {
        "description": {
            "texte": "Returns the smallest duration t representable in ToDuration that is greater or equal to d.The function does not participate in the overload resolution unless ToDuration is an instance of std::chrono::duration."
        },
        "parametres": "   d   -   duration to convert \n\n"
    },
    "chrono::round(std::chrono::duration)": {
        "description": {
            "texte": "Returns the value t representable in ToDuration that is the closest to d. If there are two such values, returns the even value (that is, the value t such that t % 2 == 0).The function does not participate in the overload resolution unless ToDuration is an instance of std::chrono::duration and std::chrono::treat_as_floating_point<typename ToDuration::rep>::value is false."
        },
        "parametres": "   d   -   duration to convert \n\n"
    },
    "chrono::abs(std::chrono::duration)": {
        "description": {
            "texte": "Returns the absolute value of the duration d. Specifically, if d >= d.zero(), return d, otherwise return -d.The function does not participate in the overload resolution unless std::numeric_limits<Rep>::is_signed is true."
        },
        "parametres": "   d   -   duration \n\n"
    },
    "operator+, operator-(std::time_point)\n": {
        "description": {
            "texte": "Performs add and subtract operations involving a time_point."
        },
        "parametres": "   pt   -   a time point to apply the offset to \n   d   -   a time offset \n   pt_lhs, pt_rhs   -   time points to extract difference from \n\n"
    },
    "operator==,!=,,>=(std::time_point)\n": {
        "description": {
            "texte": "Compares two time points. The comparison is done by comparing the results time_since_epoch() for the time points."
        },
        "parametres": "   lhs, rhs   -   time points to compare \n\n"
    },
    "chrono::time_point_cast": {
        "description": {
            "texte": "Converts a std::chrono::time_point from one duration to another."
        },
        "parametres": "   t   -   time_point to convert from \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n \nusing Clock = std::chrono::high_resolution_clock;\nusing Ms = std::chrono::milliseconds;\nusing Sec = std::chrono::seconds;\n \ntemplate<class Duration>\nusing TimePoint = std::chrono::time_point<Clock, Duration>;\n \ninline void print_ms(const TimePoint<Ms>& time_point) \n{\n    std::cout << time_point.time_since_epoch().count() << \" ms\\n\";\n}\n \nint main() \n{\n    TimePoint<Sec> time_point_sec(Sec(4));\n \n    // implicit cast, no precision loss\n    TimePoint<Ms> time_point_ms(time_point_sec);\n    print_ms(time_point_ms); // 4000 ms\n \n    time_point_ms = TimePoint<Ms>(Ms(5756));\n \n    // explicit cast, need when precision loss may happens\n    // 5756 truncated to 5000\n    time_point_sec = std::chrono::time_point_cast<Sec>(time_point_ms);\n    print_ms(time_point_sec); // 5000 ms\n}",
            "output": "4000 ms\n5000 ms"
        }
    },
    "chrono::floor(std::chrono::time_point)": {
        "description": {
            "texte": "Returns the largest time point t representable in ToDuration that is smaller or equal to tp.The function does not participate in the overload resolution unless ToDuration is an specialization of std::chrono::duration."
        },
        "parametres": "   tp   -   time point to round down \n\n"
    },
    "chrono::ceil(std::chrono::time_point)": {
        "description": {
            "texte": "Returns the smallest time point t representable in ToDuration that is greater or equal to tp.The function does not participate in the overload resolution unless ToDuration is an instance of std::chrono::duration."
        },
        "parametres": "   tp   -   time point to convert \n\n"
    },
    "chrono::round(std::chrono::time_point)": {
        "description": {
            "texte": "Returns the nearest time point to tp representable in ToDuration, rounding to even in halfway cases.The function does not participate in the overload resolution unless ToDuration is an specialization of std::chrono::duration and std::chrono::treat_as_floating_point<typename ToDuration::rep>::value is false."
        },
        "parametres": "   tp   -   time point to round to nearest \n\n"
    },
    "literals::chrono_literals::operator\"\"h": {
        "description": {
            "texte": "Forms a std::chrono::duration literal representing hours."
        },
        "parametres": "   hrs   -   the number of hours \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n \nint main()\n{\n    using namespace std::chrono_literals;\n    auto day = 24h;\n    auto halfhour = 0.5h;\n    std::cout << \"one day is \" << day.count() << \" hours\\n\"\n              << \"half an hour is \" << halfhour.count() << \" hours\\n\";\n}",
            "output": "one day is 24 hours\nhalf an hour is 0.5 hours"
        }
    },
    "literals::chrono_literals::operator\"\"min": {
        "description": {
            "texte": "Forms a std::chrono::duration literal representing minutes."
        },
        "parametres": "   minutes   -   the number of minutes \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n \nint main()\n{\n    using namespace std::chrono_literals;\n    auto lesson = 45min;\n    auto halfmin = 0.5min;\n    std::cout << \"one lesson is \" << lesson.count() << \" minutes\\n\"\n              << \"half a minute is \" << halfmin.count() << \" minutes\\n\";\n}",
            "output": "one lesson is 45 minutes\nhalf a minute is 0.5 minutes"
        }
    },
    "literals::chrono_literals::operator\"\"s": {
        "description": {
            "texte": "Forms a std::chrono::duration literal representing seconds."
        },
        "parametres": "   secs   -   the number of seconds \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n \nint main()\n{\n    using namespace std::chrono_literals;\n    auto halfmin = 30s;\n    std::cout << \"half a minute is \" << halfmin.count() << \" seconds\\n\"\n              << \"a minute and a second is \" << (1min + 1s).count() << \" seconds\\n\";\n}",
            "output": "half a minute is 30 seconds\na minute and a second is 61 seconds"
        }
    },
    "literals::chrono_literals::operator\"\"ms": {
        "description": {
            "texte": "Forms a std::chrono::duration literal representing milliseconds."
        },
        "parametres": "   ms   -   the number of milliseconds \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n \nint main()\n{\n    using namespace std::chrono_literals;\n    auto d1 = 250ms;\n    std::chrono::milliseconds d2 = 1s;\n    std::cout << \"250ms = \" << d1.count() << \" milliseconds\\n\"\n              << \"1s = \" << d2.count() << \" milliseconds\\n\";\n}",
            "output": "250ms = 250 milliseconds\n1s = 1000 milliseconds"
        }
    },
    "literals::chrono_literals::operator\"\"us": {
        "description": {
            "texte": "Forms a std::chrono::duration literal representing microseconds."
        },
        "parametres": "   us   -   the number of microseconds \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n \nint main()\n{\n    using namespace std::chrono_literals;\n    auto d1 = 250us;\n    std::chrono::microseconds d2 = 1ms;\n    std::cout << \"250us = \" << d1.count() << \" microseconds\\n\"\n              << \"1ms = \" << d2.count() << \" microseconds\\n\";\n}",
            "output": "250us = 250 microseconds\n1ms = 1000 microseconds"
        }
    },
    "literals::chrono_literals::operator\"\"ns": {
        "description": {
            "texte": "Forms a std::chrono::duration literal representing nanoseconds."
        },
        "parametres": "   nsec   -   the number of nanoseconds \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n \nint main()\n{\n    using namespace std::chrono_literals;\n    auto d1 = 250ns;\n    std::chrono::nanoseconds d2 = 1us;\n    std::cout << \"250ns = \" << d1.count() << \" nanoseconds\\n\"\n              << \"1us = \" << d2.count() << \" nanoseconds\\n\";\n}",
            "output": "250ns = 250 nanoseconds\n1us = 1000 nanoseconds"
        }
    },
    "bad_function_call": {
        "description": {
            "texte": "std::bad_function_call is the type of the exception thrown by  std::function::operator()  if the function wrapper has no target."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <functional>\n \nint main()\n{\n    std::function<int()> f = nullptr;\n    try {\n        f();\n    } catch(const std::bad_function_call& e) {\n        std::cout << e.what() << '\\n';\n    }\n}",
            "output": "bad function call"
        }
    },
    "is_bind_expression": {
        "description": {
            "texte": "If T is the type produced by a call to std::bind, this template is derived from std::true_type. For any other type, this template is derived from std::false_type.This template may be specialized for a user-defined type T to implement UnaryTypeTrait with BaseCharacteristic of std::true_type to indicate that T should be treated by std::bind as if it were the type of a bind subexpression: when a bind-generated function object is invoked, a bound argument of this type will be invoked as a function object and will be given all the unbound arguments passed to the bind-generated object."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n#include <functional>\n \nstruct MyBind {\n    typedef int result_type;\n    int operator()(int a, int b) const { return a + b; }\n};\n \nnamespace std {\n    template<>\n    struct is_bind_expression<MyBind> : public true_type {};\n}\n \nint f(int n1, int n2)\n{\n    return n1+n2;\n}\n \nint main()\n{\n    // as if bind(f, bind(MyBind(), _1, _2), 2)\n    auto b = std::bind(f, MyBind(), 2); \n \n    std::cout << \"Adding 2 to the sum of 10 and 11 gives \" << b(10, 11) << '\\n';\n}",
            "output": "Adding 2 to the sum of 10 and 11 gives 23"
        }
    },
    "is_placeholder": {
        "description": {
            "texte": "If T is the type of a standard placeholder (_1, _2, _3, ...), then this template is derived from std::integral_constant<int,1>, std::integral_constant<int,2>, std::integral_constant<int,3>, respectively.If T is not a standard placeholder type, this template is derived from std::integral_constant<int,0>The template may be specialized for any user-defined T type: the specialization must satisfy UnaryTypeTrait with BaseCharacteristic of std::integral_constant<int, N> with N > 0 to indicate that T should be treated as N'th placeholder type.std::bind uses std::is_placeholder to detect placeholders for unbound arguments."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n#include <functional>\n \nstruct My_2 {\n} my_2;\n \nnamespace std {\n    template<>\n    struct is_placeholder<My_2> : public integral_constant<int, 2> {};\n}\n \nint f(int n1, int n2)\n{\n    return n1+n2;\n}\n \nint main()\n{\n    std::cout << \"Standard placeholder _5 is for the argument number \"\n              << std::is_placeholder<decltype(std::placeholders::_5)>::value\n              << '\\n';\n \n    auto b = std::bind(f, my_2, 2);\n    std::cout << \"Adding 2 to 11 selected with a custom placeholder gives \" \n              << b(10, 11) // the first argument, namely 10, is ignored\n              << '\\n';\n}",
            "output": "Standard placeholder _5 is for the argument number 5\nAdding 2 to 11 selected with a custom placeholder gives 13"
        }
    },
    "reference_wrapper": {
        "description": {
            "texte": "std::reference_wrapper is a class template that wraps a reference in a copyable, assignable object. It is frequently used as a mechanism to store references inside standard containers (like std::vector) which cannot normally hold references.Specifically, std::reference_wrapper is a CopyConstructible and CopyAssignable wrapper around a reference to object or reference to function of type T. Instances of std::reference_wrapper are objects (they can be copied or stored in containers) but they are implicitly convertible to T&, so that they can be used as arguments with the functions that take the underlying type by reference.If the stored reference is Callable, std::reference_wrapper is callable with the same arguments.Helper functions std::ref and std::cref are often used to generate std::reference_wrapper objects.std::reference_wrapper is also used to pass objects by reference to std::bind, the constructor of std::thread, or the helper functions std::make_pair and std::make_tuple."
        },
        "exemple": {
            "input": "#include <algorithm>\n#include <list>\n#include <vector>\n#include <iostream>\n#include <numeric>\n#include <random>\n#include <functional>\n \nint main()\n{\n    std::list<int> l(10);\n \n    std::iota(l.begin(), l.end(), -4);\n    std::vector<std::reference_wrapper<int>> v(l.begin(), l.end());\n \n    // can't use shuffle on a list (requires random access), but can use it on a vector\n    std::shuffle(v.begin(), v.end(), std::mt19937{std::random_device{}()});\n \n    std::cout << \"Contents of the list: \";\n    for (int n : l){ \n        std::cout << n << ' ';\n    }\n \n    std::cout << \"\\nContents of the list, as seen through a shuffled vector: \";\n    for (int i : v){\n        std::cout << i << ' ';\n    }\n \n    std::cout << \"\\n\\nDoubling the values in the initial list...\\n\\n\";\n    for (int& i : l) {\n        i *= 2;\n    }\n \n    std::cout << \"Contents of the list, as seen through a shuffled vector: \";\n    for (int i : v){\n       std::cout << i << ' ';\n    }\n}",
            "output": "Contents of the list: -4 -3 -2 -1 0 1 2 3 4 5 \nContents of the list, as seen through a shuffled vector: -1 2 -2 1 5 0 3 -3 -4 4 \nDoubling the values in the initial list...\nContents of the list, as seen through a shuffled vector: -2 4 -4 2 10 0 6 -6 -8 8"
        }
    },
    "minus": {
        "description": {
            "texte": "std::minus<> is a specialization of std::minus with parameter and return type deduced."
        },
        "parametres": "   lhs, rhs   -   values to subtract \n\n"
    },
    "multiplies": {
        "description": {
            "texte": "std::multiplies<> is a specialization of std::multiplies with parameter and return type deduced."
        },
        "parametres": "   lhs, rhs   -   values to multiply \n\n"
    },
    "divides": {
        "description": {
            "texte": "std::divides<> is a specialization of std::divides with parameter and return type deduced."
        },
        "parametres": "   lhs, rhs   -   values to divide \n\n"
    },
    "modulus": {
        "description": {
            "texte": "std::modulus<> is a specialization of std::modulus with parameter and return type deduced."
        },
        "parametres": "   lhs, rhs   -   values to divide \n\n"
    },
    "negate": {
        "description": {
            "texte": "std::negate<> is a specialization of std::negate with parameter and return type deduced."
        },
        "parametres": "   arg   -   value to negate \n\n"
    },
    "not_equal_to": {
        "description": {
            "texte": "std::not_equal_to<> is a specialization of std::not_equal_to with parameter and return type deduced."
        },
        "parametres": "   lhs, rhs   -   values to compare \n\n"
    },
    "greater": {
        "description": {
            "texte": "std::greater<> is a specialization of std::greater with parameter and return type deduced."
        },
        "parametres": "   lhs, rhs   -   values to compare \n\n"
    },
    "less": {
        "description": {
            "texte": "std::less<> is a specialization of std::less with parameter and return type deduced."
        },
        "parametres": "   lhs, rhs   -   values to compare \n\n"
    },
    "greater_equal": {
        "description": {
            "texte": "std::greater_equal<> is a specialization of std::greater_equal with parameter and return type deduced."
        },
        "parametres": "   lhs, rhs   -   values to compare \n\n"
    },
    "less_equal": {
        "description": {
            "texte": "std::less_equal<> is a specialization of std::less_equal with parameter and return type deduced."
        },
        "parametres": "   lhs, rhs   -   values to compare \n\n"
    },
    "logical_and": {
        "description": {
            "texte": "std::logical_and<> is a specialization of std::logical_and with parameter and return type deduced."
        },
        "parametres": "   lhs, rhs   -   values to AND \n\n"
    },
    "logical_or": {
        "description": {
            "texte": "std::logical_or<> is a specialization of std::logical_or with parameter and return type deduced."
        },
        "parametres": "   lhs, rhs   -   values to OR \n\n"
    },
    "logical_not": {
        "description": {
            "texte": "std::logical_not<> is a specialization of std::logical_not with parameter and return type deduced."
        },
        "parametres": "   arg   -   value to apply logical NOT to \n\n"
    },
    "bit_and": {
        "description": {
            "texte": "std::bit_and<> is a specialization of std::bit_and with parameter and return type deduced."
        },
        "parametres": "   lhs, rhs   -   values to compute bitwise AND for \n\n"
    },
    "bit_or": {
        "description": {
            "texte": "std::bit_or<> is a specialization of std::bit_or with parameter and return type deduced."
        },
        "parametres": "   lhs, rhs   -   values to compute bitwise OR for \n\n"
    },
    "bit_xor": {
        "description": {
            "texte": "std::bit_xor<> is a specialization of std::bit_xor with parameter and return type deduced."
        },
        "parametres": "   lhs, rhs   -   values to compute bitwise XOR for \n\n"
    },
    "bit_not": {
        "description": {
            "texte": "std::bit_not<> is a specialization of std::bit_not with parameter and return type deduced."
        },
        "parametres": "   arg   -   value to apply bitwise NOT to \n\n"
    },
    "not_fn": {
        "description": {
            "texte": "Creates a forwarding call wrapper that returns the negation of the callable object it holds."
        },
        "parametres": "   f   -   the object from which the Callable object held by the wrapper is constructed \n   Type requirements \n   -std::decay_t<F> must meet the requirements of Callable and MoveConstructible. \n   -std::is_constructible_v<std::decay_t<F>, F> is required to be true \n\n"
    },
    "default_searcher": {
        "description": {
            "texte": "A class suitable for use with Searcher overload of std::search that delegates the search operation to the pre-C++17 standard library's std::search.default_searcher is CopyConstructible and CopyAssignable."
        },
        "parametres": "   pat_first, pat_last   -   a pair of iterators designating the string to be searched for \n   pred   -   a callable object used to determine equality \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n \nint main()\n{\n    std::string in = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit,\"\n                     \" sed do eiusmod tempor incididunt ut labore et dolore magna aliqua\";\n    std::string needle = \"pisci\";\n    auto it = std::search(in.begin(), in.end(),\n                   std::default_searcher(\n                       needle.begin(), needle.end()));\n    if(it != in.end())\n        std::cout << \"The string \" << needle << \" found at offset \"\n                  << it - in.begin() << '\\n';\n    else\n        std::cout << \"The string \" << needle << \" not found\\n\";\n}",
            "output": "The string pisci found at offset 43"
        }
    },
    "boyer_moore_searcher": {
        "description": {
            "texte": "A searcher suitable for use with the Searcher overload of std::search that implements the Boyer-Moore string searching algorithm.boyer_moore_searcher is CopyConstructible and CopyAssignable.RandomIt1 must meet the requirements of LegacyRandomAccessIterator."
        },
        "parametres": "   pat_first, pat_last   -   a pair of iterators designating the string to be searched for \n   hf   -   a callable object used to hash the elements of the string \n   pred   -   a callable object used to determine equality \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n \nint main()\n{\n    std::string in = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit,\"\n                     \" sed do eiusmod tempor incididunt ut labore et dolore magna aliqua\";\n    std::string needle = \"pisci\";\n    auto it = std::search(in.begin(), in.end(),\n                   std::boyer_moore_searcher(\n                       needle.begin(), needle.end()));\n    if(it != in.end())\n        std::cout << \"The string \" << needle << \" found at offset \"\n                  << it - in.begin() << '\\n';\n    else\n        std::cout << \"The string \" << needle << \" not found\\n\";\n}",
            "output": "The string pisci found at offset 43"
        }
    },
    "boyer_moore_horspool_searcher": {
        "description": {
            "texte": "A searcher suitable for use with the Searcher overload of std::search that implements the Boyer-Moore-Horspool string searching algorithm.boyer_moore_horspool_searcher is CopyConstructible and CopyAssignable.RandomIt1 must meet the requirements of LegacyRandomAccessIterator."
        },
        "parametres": "   pat_first, pat_last   -   a pair of iterators designating the string to be searched for \n   hf   -   a callable object used to hash the elements of the string \n   pred   -   a callable object used to determine equality \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n \nint main()\n{\n    std::string in = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit,\"\n                     \" sed do eiusmod tempor incididunt ut labore et dolore magna aliqua\";\n    std::string needle = \"pisci\";\n    auto it = std::search(in.begin(), in.end(),\n                   std::boyer_moore_horspool_searcher(\n                       needle.begin(), needle.end()));\n    if(it != in.end())\n        std::cout << \"The string \" << needle << \" found at offset \"\n                  << it - in.begin() << '\\n';\n    else\n        std::cout << \"The string \" << needle << \" not found\\n\";\n}",
            "output": "The string pisci found at offset 43"
        }
    },
    "unary_function": {
        "description": {
            "texte": "unary_function is a base class for creating function objects with one argument.unary_function does not define operator(); it is expected that derived classes will define this. unary_function provides only two types - argument_type and result_type - defined by the template parameters.Some standard library function object adaptors, such as std::not1, require the function objects they adapt to have certain types defined; std::not1 requires the function object being adapted to have a type named argument_type. Deriving function objects that take one argument from unary_function is an easy way to make them compatible with those adaptors.unary_function is deprecated in C++11."
        },
        "exemple": {
            "input": "#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <vector>\n \nstruct less_than_7 : std::unary_function<int, bool>\n{\n    bool operator()(int i) const { return i < 7; }\n};\n \nint main()\n{\n    std::vector<int> v;\n    for (int i = 0; i < 10; ++i) v.push_back(i);\n \n    std::cout << std::count_if(v.begin(), v.end(), std::not1(less_than_7()));\n \n    /* C++11 solution:\n        // Cast to std::function<bool (int)> somehow - even with a lambda\n        std::cout << std::count_if(v.begin(), v.end(),\n            std::not1(std::function<bool (int)>([](int i){ return i < 7; }))\n        );\n    */\n}",
            "output": "3"
        }
    },
    "binary_function": {
        "description": {
            "texte": "binary_function is a base class for creating function objects with two arguments.binary_function does not define operator(); it is expected that derived classes will define this. binary_function provides only three types - first_argument_type, second_argument_type and result_type - defined by the template parameters.Some standard library function object adaptors, such as std::not2, require the function objects they adapt to have certain types defined; std::not2 requires the function object being adapted to have two types named first_argument_type and second_argument_type. Deriving function objects that take two arguments from binary_function is an easy way to make them compatible with those adaptors.binary_function is deprecated in C++11 and removed in C++17."
        },
        "exemple": {
            "input": "#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <vector>\n \nstruct same : std::binary_function<int, int, bool>\n{\n    bool operator()(int a, int b) const { return a == b; }\n};\n \nint main()\n{\n    std::vector<int> v1{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    std::vector<int> v2{10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };\n    std::vector<bool> v3(v1.size());\n \n    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(), std::not2(same()));\n \n    std::cout << std::boolalpha;\n    for (std::size_t i = 0; i < v1.size(); ++i)\n        std::cout << v1[i] << ' ' << v2[i] << ' ' << v3[i] << '\\n';\n}",
            "output": "0 10 true\n1 9 true\n2 8 true\n3 7 true\n4 6 true\n5 5 false\n6 4 true\n7 3 true\n8 2 true\n9 1 true\n10 0 true"
        }
    },
    "binder1st, std::binder2nd": {
        "description": {
            "texte": "A function object that binds an argument to a binary function.The value of the parameter is passed to the object at the construction time and stored within the object. Whenever the function object is invoked though operator(), the stored value is passed as one of the arguments, the other argument is passed as an argument of operator(). The resulting function object is an unary function."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <functional>\n#include <cmath>\n#include <vector>\nconst double pi = std::acos(-1);\nint main()\n{\n    // deprecated in C++11, removed in C++17\n    std::binder1st<std::multiplies<double>> f1 = std::bind1st(\n                                                   std::multiplies<double>(), pi / 180.);\n \n    // C++11 replacement\n    auto f2 = [](double a){ return a*pi/180.; };\n \n    for(double n : {0, 30, 45, 60, 90, 180})\n        std::cout << n << \" deg = \" << f1(n) << \" rad (using binder) \"\n                                    << f2(n) << \" rad (using lambda)\\n\";\n}",
            "output": "0 deg = 0 rad (using binder) 0 rad (using lambda)\n30 deg = 0.523599 rad (using binder) 0.523599 rad (using lambda)\n45 deg = 0.785398 rad (using binder) 0.785398 rad (using lambda)\n60 deg = 1.0472 rad (using binder) 1.0472 rad (using lambda)\n90 deg = 1.5708 rad (using binder) 1.5708 rad (using lambda)\n180 deg = 3.14159 rad (using binder) 3.14159 rad (using lambda)"
        }
    },
    "bind1st, std::bind2nd": {
        "description": {
            "texte": "Binds a given argument x to a first or second parameter of the given binary function object f. That is, stores x within the resulting wrapper, which, if called, passes x as the first or the second parameter of f.1) Binds the first argument of f to x. Effectively calls std::binder1st<F>(f, typename F::first_argument_type(x)).2) Binds the second argument of f to x. Effectively calls std::binder2nd<F>(f, typename F::second_argument_type(x))."
        },
        "parametres": "   f   -   pointer to a function to bind an argument to \n   x   -   argument to bind to f \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <vector>\n \nint main()\n{\n    std::vector<double> a= {0, 30, 45, 60, 90, 180};\n    std::vector<double> r(a.size());\n    double pi = std::acos(-1);\n \n    std::transform(a.begin(), a.end(), r.begin(),\n        std::bind1st(std::multiplies<double>(), pi / 180.));\n// equivalent lambda: [pi](double a){ return a*pi/180.; });\n \n    for(size_t n = 0; n < a.size(); ++n)\n        std::cout << a[n] << \" deg = \" << r[n] << \" rad\\n\";\n}",
            "output": "0 deg = 0 rad\n30 deg = 0.523599 rad\n45 deg = 0.785398 rad\n60 deg = 1.0472 rad\n90 deg = 1.5708 rad\n180 deg = 3.14159 rad"
        }
    },
    "pointer_to_unary_function": {
        "description": {
            "texte": "std::pointer_to_unary_function is a function object that acts as a wrapper around a unary function."
        },
        "parametres": "   f   -   pointer to a function to store \n\n"
    },
    "pointer_to_binary_function": {
        "description": {
            "texte": "std::pointer_to_binary_function is a function object that acts as a wrapper around a binary function."
        },
        "parametres": "   f   -   pointer to a function to store \n\n"
    },
    "ptr_fun": {
        "description": {
            "texte": "Creates a function wrapper object (either std::pointer_to_unary_function or std::pointer_to_binary_function), deducing the target type from the template arguments.1) Effectively calls std::pointer_to_unary_function<Arg,Result>(f).2) Effectively calls std::pointer_to_binary_function<Arg1,Arg2,Result>(f).This function and the related types are deprecated as of C++11 in favor of the more general std::function and std::ref, both of which create callable adapter-compatible function objects from plain functions."
        },
        "parametres": "   f   -   pointer to a function to create a wrapper for \n\n",
        "exemple": {
            "input": "#include <string>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n \nbool isvowel(char c)\n{\n    return std::string(\"aeoiuAEIOU\").find(c) != std::string::npos;\n}\n \nint main()\n{\n    std::string s = \"Hello, world!\";\n    std::copy_if(s.begin(), s.end(), std::ostreambuf_iterator<char>(std::cout),\n                 std::not1(std::ptr_fun(isvowel)));\n// C++11 alternatives: \n//               std::not1(std::cref(isvowel)));\n//               std::not1(std::function<bool(char)>(isvowel)));\n \n}",
            "output": "Hll, wrld!"
        }
    },
    "mem_fun_t, std::mem_fun1_t, std::const_mem_fun_t, std::const_mem_fun1_t": {
        "description": {
            "texte": "Wrapper around a member function pointer. The class instance whose member function to call is passed as a pointer to the operator()."
        }
    },
    "mem_fun": {
        "description": {
            "texte": "Creates a member function wrapper object, deducing the target type from the template arguments. The wrapper object expects a pointer to an object of type T as the first parameter to its operator().This function and the related types were deprecated in C++11 and removed in C++17 in favor of the more general std::mem_fn and std::bind, both of which create callable adapter-compatible function objects from member functions."
        },
        "parametres": "   f   -   pointer to a member function to create a wrapper for \n\n"
    },
    "mem_fun_ref_t, std::mem_fun1_ref_t, std::const_mem_fun_ref_t, std::const_mem_fun1_ref_t": {
        "description": {
            "texte": "Wrapper around a member function pointer. The class instance whose member function to call is passed as a reference to the operator()."
        }
    },
    "mem_fun_ref": {
        "description": {
            "texte": "Creates a member function wrapper object, deducing the target type from the template arguments. The wrapper object expects a reference to an object of type T as the first parameter to its operator().1) Effectively calls std::mem_fun_ref_t<S,T>(f) or std::const_mem_fun_ref_t<S,T>(f).2) Effectively calls std::mem_fun1_ref_t<S,T>(f) or std::const_mem_fun1_ref_t<S,T>(f).This function and the related types were deprecated in C++11 and removed in C++17 in favor of the more general std::mem_fn and std::bind, both of which create callable adapter-compatible function objects from member functions."
        },
        "parametres": "   f   -   pointer to a member function to create a wrapper for \n\n",
        "exemple": {
            "input": "#include <functional>\n#include <vector>\n#include <string>\n#include <iterator>\n#include <algorithm>\n#include <iostream>\n \nint main()\n{\n    std::vector<std::string> v = {\"once\", \"upon\", \"a\", \"time\"};\n    std::transform(v.begin(), v.end(),\n                   std::ostream_iterator<std::size_t>(std::cout, \" \"),\n                   std::mem_fun_ref(&std::string::size));\n}",
            "output": "4 4 1 4"
        }
    },
    "unary_negate": {
        "description": {
            "texte": "unary_negate is a wrapper function object returning the complement of the unary predicate it holds.The unary predicate type must define a member type, argument_type, that is convertible to the predicate's parameter type. The unary function objects obtained from std::ref, std::cref, std::negate, std::logical_not, std::mem_fn, std::function, std::hash, or from another call to std::not1 have this type defined, as are function objects derived from the deprecated std::unary_function.unary_negate objects are easily constructed with helper function std::not1."
        },
        "parametres": "   pred   -   predicate function object \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <vector>\n \nstruct less_than_7 : std::unary_function<int, bool>\n{\n    bool operator()(int i) const { return i < 7; }\n};\n \nint main()\n{\n    std::vector<int> v;\n    for (int i = 0; i < 10; ++i) v.push_back(i);\n \n    std::unary_negate<less_than_7> not_less_than_7((less_than_7()));\n \n    std::cout << std::count_if(v.begin(), v.end(), not_less_than_7);\n \n    /* C++11 solution:\n        // Use std::function<bool (int)>\n        std::function<bool (int)> not_less_than_7 =\n            [](int x)->bool{ return !less_than_7()(x); };\n \n        std::cout << std::count_if(v.begin(), v.end(), not_less_than_7);\n    */\n}",
            "output": "3"
        }
    },
    "binary_negate": {
        "description": {
            "texte": "binary_negate is a wrapper function object returning the complement of the binary predicate it holds.The binary predicate type must define two member types, first_argument_type and second_argument_type, that are convertible to the predicate's parameter types. The function objects obtained from std::owner_less, std::ref, std::cref, std::plus, std::minus, std::multiplies, std::divides, std::modulus, std::equal_to, std::not_equal_to, std::greater, std::less, std::greater_equal, std::less_equal, std::logical_not, std::logical_or, std::bit_and, std::bit_or, std::bit_xor, std::mem_fn, std::map::value_comp, std::multimap::value_comp, std::function, or from a call to std::not2 have these types defined, as are function objects derived from the deprecated std::binary_function.binary_negate objects are easily constructed with helper function std::not2."
        },
        "parametres": "   pred   -   predicate function object \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <vector>\n \nstruct same : std::binary_function<int, int, bool>\n{\n    bool operator()(int a, int b) const { return a == b; }\n};\n \nint main()\n{\n    std::vector<int> v1;\n    std::vector<int> v2;\n    for (int i = 0; i < 10; ++i) v1.push_back(i);\n    for (int i = 0; i < 10; ++i) v2.push_back(10 - i);\n \n    std::vector<bool> v3(v1.size());\n \n    std::binary_negate<same> not_same((same()));\n \n    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(), not_same);\n \n    /* C++11 solution:\n        // Use std::function<bool (int, int)>\n        std::function<bool (int, int)> not_same =\n            [](int x, int y)->bool{ return !same()(x, y); };\n \n        std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(), not_same);\n    */\n \n    std::cout.setf(std::ios_base::boolalpha);\n    for (int i = 0; i < 10; ++i)\n        std::cout << v1[i] << ' ' << v2[i] << ' ' << v3[i] << '\\n';\n}",
            "output": "0 10 true\n1 9 true\n2 8 true\n3 7 true\n4 6 true\n5 5 false\n6 4 true\n7 3 true\n8 2 true\n9 1 true"
        }
    },
    "not1": {
        "description": {
            "texte": "not1 is a helper function to create a function object that returns the complement of the unary predicate function passed. The function object created is of type std::unary_negate<Predicate>.The unary predicate type must define a member type, argument_type, that is convertible to the predicate's parameter type. The unary function objects obtained from std::ref, std::cref, std::negate, std::logical_not, std::mem_fn, std::function, std::hash, or from another call to std::not1 have this type defined, as are function objects derived from the deprecated std::unary_function."
        },
        "parametres": "   pred   -   unary predicate \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <numeric>\n#include <iterator>\n#include <functional>\n#include <iostream>\n#include <vector>\n \nstruct LessThan7 : std::unary_function<int, bool>\n{\n    bool operator()(int i) const { return i < 7; }\n};\n \nint main()\n{\n    std::vector<int> v(10);\n    std::iota(begin(v), end(v), 0);\n \n    std::cout << std::count_if(begin(v), end(v), std::not1(LessThan7())) << \"\\n\";\n \n    //same as above, but using `std::function`\n    std::function<bool(int)> less_than_9 = [](int x){ return x < 9; };\n    std::cout << std::count_if(begin(v), end(v), std::not1(less_than_9)) << \"\\n\";\n}",
            "output": "3\n1"
        }
    },
    "not2": {
        "description": {
            "texte": "not2 is a helper function to create a function object that returns the complement of the binary predicate function passed. The function object created is of type std::binary_negate<Predicate>.The binary predicate type must define two member types, first_argument_type and second_argument_type, that are convertible to the predicate's parameter types. The function objects obtained from std::owner_less, std::ref, std::cref, std::plus, std::minus, std::multiplies, std::divides, std::modulus, std::equal_to, std::not_equal_to, std::greater, std::less, std::greater_equal, std::less_equal, std::logical_not, std::logical_or, std::bit_and, std::bit_or, std::bit_xor, std::mem_fn, std::map::value_comp, std::multimap::value_comp, std::function, or from another call to std::not2 have these types defined, as are function objects derived from the deprecated std::binary_function."
        },
        "parametres": "   pred   -   binary predicate \n\n",
        "exemple": {
            "input": "#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <vector>\n \nstruct old_same : std::binary_function<int, int, bool>\n{\n    bool operator()(int a, int b) const { return a == b; }\n};\n \nstruct new_same\n{\n    bool operator()(int a, int b) const { return a == b; }\n};\n \nbool same_fn(int a, int b)\n{\n    return a == b;\n}\n \n \nint main()\n{\n    std::vector<int> v1{0, 1, 2};\n    std::vector<int> v2{2, 1, 0};\n    std::vector<bool> v3(v1.size());\n \n    std::cout << \"negating a binary_function:\\n\";\n    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(),\n                   std::not2(old_same()));\n \n    std::cout << std::boolalpha;\n    for (std::size_t i = 0; i < v1.size(); ++i)\n        std::cout << v1[i] << ' ' << v2[i] << ' ' << v3[i] << '\\n';\n \n    std::cout << \"negating a standard functor:\\n\";\n    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(),\n                   std::not2(std::equal_to<int>()));\n \n    for (std::size_t i = 0; i < v1.size(); ++i)\n        std::cout << v1[i] << ' ' << v2[i] << ' ' << v3[i] << '\\n';\n \n    std::cout << \"negating a std::function:\\n\";\n    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(),\n                   std::not2(std::function<bool(int,int)>(new_same())));\n \n    for (std::size_t i = 0; i < v1.size(); ++i)\n        std::cout << v1[i] << ' ' << v2[i] << ' ' << v3[i] << '\\n';\n \n    std::cout << \"negating a std::reference_wrapper:\\n\";\n    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(),\n                   std::not2(std::ref(same_fn)));\n \n    for (std::size_t i = 0; i < v1.size(); ++i)\n        std::cout << v1[i] << ' ' << v2[i] << ' ' << v3[i] << '\\n';\n \n}",
            "output": "negating a binary_function:\n0 2 true\n1 1 false\n2 0 true\nnegating a standard functor:\n0 2 true\n1 1 false\n2 0 true\nnegating a std::function:\n0 2 true\n1 1 false\n2 0 true\nnegating a std::reference_wrapper:\n0 2 true\n1 1 false\n2 0 true"
        }
    },
    "thread::id": {
        "description": {
            "texte": "The class thread::id is a lightweight, trivially copyable class that serves as a unique identifier of std::thread objects.Instances of this class may also hold the special distinct value that does not represent any thread. Once a thread has finished, the value of std::thread::id may be reused by another thread.This class is designed for use as key in associative containers, both ordered and unordered."
        }
    },
    "CLOCKS_PER_SEC": {
        "description": {
            "texte": "Expands to an expression (not necessarily a compile-time constant) of type std::clock_t equal to the number of clock ticks per second, as returned by std::clock()."
        }
    },
    "clock_t": {
        "description": {
            "texte": "Arithmetic type capable of representing the process running time of implementation-defined range and precision."
        }
    },
    "time_t": {
        "description": {
            "texte": "Arithmetic type capable of representing times.Although not defined, this is almost always an integral value holding the number of seconds (not counting leap seconds) since 00:00, Jan 1 1970 UTC, corresponding to  POSIX time."
        }
    },
    "timespec": {
        "description": {
            "texte": "Structure holding an interval broken down into seconds and nanoseconds."
        }
    },
    "difftime": {
        "description": {
            "texte": "Computes difference between two calendar times as std::time_t objects (time_end - time_beg) in seconds. If time_end refers to time point before time_beg then the result is negative."
        },
        "parametres": "   time_beg, time_end   -   times to compare \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <ctime>\n \nint main()\n{\n    std::time_t start = std::time(nullptr);\n    volatile double d;\n \n    // some time-consuming operation\n    for (int n=0; n<10000; ++n) {\n        for (int m=0; m<100000; ++m) {\n           d += d*n*m;\n        }\n    }\n \n    std::cout << \"Wall time passed: \"\n              << std::difftime(std::time(nullptr), start) << \" s.\\n\";\n}",
            "output": "Wall time passed: 7 s."
        }
    },
    "timespec_get": {
        "description": {
            "texte": "Other macro constants beginning with TIME_ may be provided by the implementation to indicate additional time bases.If base is TIME_UTC, then."
        },
        "parametres": "   ts   -   pointer to an object of type std::timespec \n   base   -   TIME_UTC or another nonzero integer value indicating the time base \n\n",
        "exemple": {
            "input": "#include <cstdio>\n#include <ctime>\n \nint main()\n{\n    std::timespec ts;\n    std::timespec_get(&ts, TIME_UTC);\n    char buf[100];\n    std::strftime(buf, sizeof buf, \"%D %T\", std::gmtime(&ts.tv_sec));\n    std::printf(\"Current time: %s.%09ld UTC\\n\", buf, ts.tv_nsec);\n}",
            "output": "Current time: 06/24/16 20:07:42.949494132 UTC"
        }
    },
    "ctime": {
        "description": {
            "texte": "Converts given time since epoch to a calendar local time and then to a textual representation, as if by calling std::asctime(std::localtime(time)). The resulting string has the following format:The function does not support localization.",
            "code": "Www Mmm dd hh:mm:ss yyyy"
        },
        "parametres": "   time   -   pointer to a std::time_t object specifying the time to print \n\n",
        "exemple": {
            "input": "#include <ctime>\n#include <iostream>\n \nint main()\n{\n    std::time_t result = std::time(nullptr);\n    std::cout << std::ctime(&result);\n}",
            "output": "Tue Dec 27 17:21:29 2011"
        }
    },
    "asctime": {
        "description": {
            "texte": "Converts given calendar time std::tm to a textual representation of the following fixed 25-character form: Www Mmm dd hh:mm:ss yyyy\\n.The behavior is undefined if any member of *time_ptr is outside its normal range.The behavior is undefined if the calendar year indicated by time_ptr->tm_year has more than 4 digits or is less than the year 1000.The function does not support localization, and the newline character cannot be removed.The function modifies static storage and is not thread-safe."
        },
        "parametres": "   time_ptr   -   pointer to a std::tm object specifying the time to print \n\n",
        "exemple": {
            "input": "#include <ctime>\n#include <iostream>\n \nint main()\n{\n    std::time_t result = std::time(nullptr);\n    std::cout << std::asctime(std::localtime(&result));\n}",
            "output": "Mon Apr  3 20:26:26 2017"
        }
    },
    "strftime": {
        "description": {
            "texte": "Converts the date and time information from a given calendar time time to a null-terminated multibyte character string str according to format string format. Up to count bytes are written."
        },
        "parametres": "   str   -   pointer to the first element of the char array for output \n   count   -   maximum number of bytes to write \n   format   -   pointer to a null-terminated multibyte character string specifying the format of conversion. The format string consists of zero or more conversion specifiers and ordinary characters (except %). All ordinary characters, including the terminating null character, are copied to the output string without modification. Each conversion specification begins with % character, optionally followed by E or O modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The following format specifiers are available:\n   Conversion specifier   Explanation   Used fields \n   %   writes literal %. The full conversion specification must be %%.   \n   n(C++11)   writes newline character   \n   t(C++11)   writes horizontal tab character   \n   Year \n   Y   writes year as a decimal number, e.g. 2017   tm_year \n   EY(C++11)   writes year in the alternative representation, e.g.\u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   tm_year \n   y   writes last 2 digits of year as a decimal number (range [00,99])   tm_year \n   Oy(C++11)   writes last 2 digits of year using the alternative numeric system, e.g. \u5341\u4e00 instead of 11 in ja_JP locale   tm_year \n   Ey(C++11)   writes year as offset from locale's alternative calendar period %EC (locale-dependent)   tm_year \n   C(C++11)   writes first 2 digits of year as a decimal number (range [00,99])   tm_year \n   EC(C++11)   writes name of the base year (period) in the locale's alternative representation, e.g. \u5e73\u6210 (Heisei era) in ja_JP   tm_year \n   G(C++11)   writes ISO 8601 week-based year, i.e. the year that contains the specified week. In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday \n   g(C++11)   writes last 2 digits of ISO 8601 week-based year, i.e. the year that contains the specified week (range [00,99]). In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday \n   Month \n   b   writes abbreviated month name, e.g. Oct (locale dependent)   tm_mon \n   h(C++11)   synonym of b   tm_mon \n   B   writes full month name, e.g. October (locale dependent)   tm_mon \n   m   writes month as a decimal number (range [01,12])   tm_mon \n   Om(C++11)   writes month using the alternative numeric system, e.g. \u5341\u4e8c instead of 12 in ja_JP locale   tm_mon \n   Week \n   U   writes week of the year as a decimal number (Sunday is the first day of the week) (range [00,53])   tm_year, tm_wday, tm_yday \n   OU(C++11)   writes week of the year, as by %U, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday \n   W   writes week of the year as a decimal number (Monday is the first day of the week) (range [00,53])   tm_year, tm_wday, tm_yday \n   OW(C++11)   writes week of the year, as by %W, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday \n   V(C++11)   writes ISO 8601 week of the year (range [01,53]). In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday \n   OV(C++11)   writes week of the year, as by %V, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday \n   Day of the year/month \n   j   writes day of the year as a decimal number (range [001,366])   tm_yday \n   d   writes day of the month as a decimal number (range [01,31])   tm_mday \n   Od(C++11)   writes zero-based day of the month using the alternative numeric system, e.g \u4e8c\u5341\u4e03 instead of 27 in ja_JP locale Single character is preceded by a space.\n  tm_mday \n   e(C++11)   writes day of the month as a decimal number (range [1,31]). Single digit is preceded by a space.\n  tm_mday \n   Oe(C++11)   writes one-based day of the month using the alternative numeric system, e.g. \u4e8c\u5341\u4e03 instead of 27 in ja_JP locale Single character is preceded by a space.\n  tm_mday \n   Day of the week \n   a   writes abbreviated weekday name, e.g. Fri (locale dependent)   tm_wday \n   A   writes full weekday name, e.g. Friday (locale dependent)   tm_wday \n   w   writes weekday as a decimal number, where Sunday is 0 (range [0-6])   tm_wday \n   Ow(C++11)   writes weekday, where Sunday is 0, using the alternative numeric system, e.g. \u4e8c instead of 2 in ja_JP locale   tm_wday \n   u(C++11)   writes weekday as a decimal number, where Monday is 1 (ISO 8601 format) (range [1-7])   tm_wday \n   Ou(C++11)   writes weekday, where Monday is 1, using the alternative numeric system, e.g. \u4e8c instead of 2 in ja_JP locale   tm_wday \n   Hour, minute, second \n   H   writes hour as a decimal number, 24 hour clock (range [00-23])   tm_hour \n   OH(C++11)   writes hour from 24-hour clock using the alternative numeric system, e.g. \u5341\u516b instead of 18 in ja_JP locale   tm_hour \n   I   writes hour as a decimal number, 12 hour clock (range [01,12])   tm_hour \n   OI(C++11)   writes hour from 12-hour clock using the alternative numeric system, e.g. \u516d instead of 06 in ja_JP locale   tm_hour \n   M   writes minute as a decimal number (range [00,59])   tm_min \n   OM(C++11)   writes minute using the alternative numeric system, e.g. \u4e8c\u5341\u4e94 instead of 25 in ja_JP locale   tm_min \n   S   writes second as a decimal number (range [00,60])   tm_sec \n   OS(C++11)   writes second using the alternative numeric system, e.g. \u4e8c\u5341\u56db instead of 24 in ja_JP locale   tm_sec \n   Other \n   c   writes standard date and time string, e.g. Sun Oct 17 04:41:13 2010 (locale dependent)   all \n   Ec(C++11)   writes alternative date and time string, e.g. using \u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   all \n   x   writes localized date representation (locale dependent)   all \n   Ex(C++11)   writes alternative date representation, e.g. using \u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   all \n   X   writes localized time representation (locale dependent)   all \n   EX(C++11)   writes alternative time representation (locale dependent)   all \n   D(C++11)   equivalent to \"%m/%d/%y\"   tm_mon, tm_mday, tm_year \n   F(C++11)   equivalent to \"%Y-%m-%d\" (the ISO 8601 date format)   tm_mon, tm_mday, tm_year \n   r(C++11)   writes localized 12-hour clock time (locale dependent)   tm_hour, tm_min, tm_sec \n   R(C++11)   equivalent to \"%H:%M\"   tm_hour, tm_min \n   T(C++11)   equivalent to \"%H:%M:%S\" (the ISO 8601 time format)   tm_hour, tm_min, tm_sec \n   p   writes localized a.m. or p.m. (locale dependent)   tm_hour \n   z(C++11)   writes offset from UTC in the ISO 8601 format (e.g. -0430), or no characters if the time zone information is not available   tm_isdst \n   Z   writes locale-dependent time zone name or abbreviation, or no characters if the time zone information is not available   tm_isdst \n\n \n   time   -   pointer to the date and time information to be converted \n\n",
        "exemple": {
            "input": "#include <ctime>\n#include <iostream>\n#include <locale>\n \nint main()\n{\n    std::locale::global(std::locale(\"ja_JP.utf8\"));\n    std::time_t t = std::time(nullptr);\n    char mbstr[100];\n    if (std::strftime(mbstr, sizeof(mbstr), \"%A %c\", std::localtime(&t))) {\n        std::cout << mbstr << '\\n';\n    }\n}",
            "output": "\u706b\u66dc\u65e5 2011\u5e7412\u670827\u65e5 17\u664239\u520603\u79d2"
        }
    },
    "wcsftime": {
        "description": {
            "texte": "Converts the date and time information from a given calendar time time to a null-terminated wide character string str according to format string format. Up to count wide characters are written."
        },
        "parametres": "   str   -   pointer to the first element of the wchar_t array for output \n   count   -   maximum number of wide characters to write \n   format   -   pointer to a null-terminated wide character string specifying the format of conversion. The format string consists of zero or more conversion specifiers and ordinary characters (except %). All ordinary characters, including the terminating null character, are copied to the output string without modification. Each conversion specification begins with % character, optionally followed by E or O modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The following format specifiers are available:\n   Conversion specifier   Explanation   Used fields \n   %   writes literal %. The full conversion specification must be %%.   \n   n(C++11)   writes newline character   \n   t(C++11)   writes horizontal tab character   \n   Year \n   Y   writes year as a decimal number, e.g. 2017   tm_year \n   EY(C++11)   writes year in the alternative representation, e.g.\u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   tm_year \n   y   writes last 2 digits of year as a decimal number (range [00,99])   tm_year \n   Oy(C++11)   writes last 2 digits of year using the alternative numeric system, e.g. \u5341\u4e00 instead of 11 in ja_JP locale   tm_year \n   Ey(C++11)   writes year as offset from locale's alternative calendar period %EC (locale-dependent)   tm_year \n   C(C++11)   writes first 2 digits of year as a decimal number (range [00,99])   tm_year \n   EC(C++11)   writes name of the base year (period) in the locale's alternative representation, e.g. \u5e73\u6210 (Heisei era) in ja_JP   tm_year \n   G(C++11)   writes ISO 8601 week-based year, i.e. the year that contains the specified week. In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday \n   g(C++11)   writes last 2 digits of ISO 8601 week-based year, i.e. the year that contains the specified week (range [00,99]). In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday \n   Month \n   b   writes abbreviated month name, e.g. Oct (locale dependent)   tm_mon \n   h(C++11)   synonym of b   tm_mon \n   B   writes full month name, e.g. October (locale dependent)   tm_mon \n   m   writes month as a decimal number (range [01,12])   tm_mon \n   Om(C++11)   writes month using the alternative numeric system, e.g. \u5341\u4e8c instead of 12 in ja_JP locale   tm_mon \n   Week \n   U   writes week of the year as a decimal number (Sunday is the first day of the week) (range [00,53])   tm_year, tm_wday, tm_yday \n   OU(C++11)   writes week of the year, as by %U, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday \n   W   writes week of the year as a decimal number (Monday is the first day of the week) (range [00,53])   tm_year, tm_wday, tm_yday \n   OW(C++11)   writes week of the year, as by %W, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday \n   V(C++11)   writes ISO 8601 week of the year (range [01,53]). In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday \n   OV(C++11)   writes week of the year, as by %V, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday \n   Day of the year/month \n   j   writes day of the year as a decimal number (range [001,366])   tm_yday \n   d   writes day of the month as a decimal number (range [01,31])   tm_mday \n   Od(C++11)   writes zero-based day of the month using the alternative numeric system, e.g \u4e8c\u5341\u4e03 instead of 27 in ja_JP locale Single character is preceded by a space.\n  tm_mday \n   e(C++11)   writes day of the month as a decimal number (range [1,31]). Single digit is preceded by a space.\n  tm_mday \n   Oe(C++11)   writes one-based day of the month using the alternative numeric system, e.g. \u4e8c\u5341\u4e03 instead of 27 in ja_JP locale Single character is preceded by a space.\n  tm_mday \n   Day of the week \n   a   writes abbreviated weekday name, e.g. Fri (locale dependent)   tm_wday \n   A   writes full weekday name, e.g. Friday (locale dependent)   tm_wday \n   w   writes weekday as a decimal number, where Sunday is 0 (range [0-6])   tm_wday \n   Ow(C++11)   writes weekday, where Sunday is 0, using the alternative numeric system, e.g. \u4e8c instead of 2 in ja_JP locale   tm_wday \n   u(C++11)   writes weekday as a decimal number, where Monday is 1 (ISO 8601 format) (range [1-7])   tm_wday \n   Ou(C++11)   writes weekday, where Monday is 1, using the alternative numeric system, e.g. \u4e8c instead of 2 in ja_JP locale   tm_wday \n   Hour, minute, second \n   H   writes hour as a decimal number, 24 hour clock (range [00-23])   tm_hour \n   OH(C++11)   writes hour from 24-hour clock using the alternative numeric system, e.g. \u5341\u516b instead of 18 in ja_JP locale   tm_hour \n   I   writes hour as a decimal number, 12 hour clock (range [01,12])   tm_hour \n   OI(C++11)   writes hour from 12-hour clock using the alternative numeric system, e.g. \u516d instead of 06 in ja_JP locale   tm_hour \n   M   writes minute as a decimal number (range [00,59])   tm_min \n   OM(C++11)   writes minute using the alternative numeric system, e.g. \u4e8c\u5341\u4e94 instead of 25 in ja_JP locale   tm_min \n   S   writes second as a decimal number (range [00,60])   tm_sec \n   OS(C++11)   writes second using the alternative numeric system, e.g. \u4e8c\u5341\u56db instead of 24 in ja_JP locale   tm_sec \n   Other \n   c   writes standard date and time string, e.g. Sun Oct 17 04:41:13 2010 (locale dependent)   all \n   Ec(C++11)   writes alternative date and time string, e.g. using \u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   all \n   x   writes localized date representation (locale dependent)   all \n   Ex(C++11)   writes alternative date representation, e.g. using \u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   all \n   X   writes localized time representation (locale dependent)   all \n   EX(C++11)   writes alternative time representation (locale dependent)   all \n   D(C++11)   equivalent to \"%m/%d/%y\"   tm_mon, tm_mday, tm_year \n   F(C++11)   equivalent to \"%Y-%m-%d\" (the ISO 8601 date format)   tm_mon, tm_mday, tm_year \n   r(C++11)   writes localized 12-hour clock time (locale dependent)   tm_hour, tm_min, tm_sec \n   R(C++11)   equivalent to \"%H:%M\"   tm_hour, tm_min \n   T(C++11)   equivalent to \"%H:%M:%S\" (the ISO 8601 time format)   tm_hour, tm_min, tm_sec \n   p   writes localized a.m. or p.m. (locale dependent)   tm_hour \n   z(C++11)   writes offset from UTC in the ISO 8601 format (e.g. -0430), or no characters if the time zone information is not available   tm_isdst \n   Z   writes locale-dependent time zone name or abbreviation, or no characters if the time zone information is not available   tm_isdst \n\n \n   time   -   pointer to the date and time information to be converted \n\n",
        "exemple": {
            "input": "#include <ctime>\n#include <cwchar>\n#include <iostream>\n#include <locale>\n \nint main()\n{\n    std::locale::global(std::locale(\"ja_JP.utf8\"));\n    std::time_t t = std::time(nullptr);\n    wchar_t wstr[100];\n    if(std::wcsftime(wstr, 100, L\"%A %c\", std::localtime(&t))) {\n        std::wcout << wstr << '\\n';\n    }\n}",
            "output": "\u706b\u66dc\u65e5 2011\u5e7412\u670827\u65e5 17\u664243\u520613\u79d2"
        }
    },
    "gmtime": {
        "description": {
            "texte": "Converts given time since epoch as std::time_t value into calendar time, expressed in Coordinated Universal Time (UTC)."
        },
        "parametres": "   time   -   pointer to a time_t object to convert \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <ctime>\n \nint main()\n{\n    std::time_t t = std::time(nullptr);\n    std::cout << \"UTC:   \" << std::put_time(std::gmtime(&t), \"%c %Z\") << '\\n';\n    std::cout << \"local: \" << std::put_time(std::localtime(&t), \"%c %Z\") << '\\n';\n}",
            "output": "UTC:   Wed Dec 28 11:44:28 2011 GMT\nlocal: Wed Dec 28 06:44:28 2011 EST"
        }
    },
    "localtime": {
        "description": {
            "texte": "Converts given time since epoch as std::time_t value into calendar time, expressed in local time."
        },
        "parametres": "   time   -   pointer to a time_t object to convert \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <ctime>\n#include <stdlib.h> // defines putenv in POSIX\n \nint main()\n{\n    std::time_t t = std::time(nullptr);\n    std::cout << \"UTC:       \" << std::put_time(std::gmtime(&t), \"%c %Z\") << '\\n';\n    std::cout << \"local:     \" << std::put_time(std::localtime(&t), \"%c %Z\") << '\\n';\n    // POSIX-specific:\n    std::string tz = \"TZ=Asia/Singapore\";\n    putenv(tz.data());\n    std::cout << \"Singapore: \" << std::put_time(std::localtime(&t), \"%c %Z\") << '\\n';\n}",
            "output": "UTC:       Fri Sep 15 14:16:29 2017 GMT\nlocal:     Fri Sep 15 14:16:29 2017 UTC\nSingapore: Fri Sep 15 22:16:29 2017 SGT"
        }
    },
    "mktime": {
        "description": {
            "texte": "Converts local calendar time to a time since epoch as a time_t object. time->tm_wday and time->tm_yday are ignored. The values in time are permitted to be outside their normal ranges.A negative value of time->tm_isdst causes mktime to attempt to determine if Daylight Saving Time was in effect.If the conversion is successful, the time object is modified. All fields of time are updated to fit their proper ranges. time->tm_wday and time->tm_yday are recalculated using information available in other fields."
        },
        "parametres": "   time   -   pointer to a std::tm object specifying local calendar time to convert \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <ctime>\n#include <stdlib.h>\n \nint main()\n{\n    setenv(\"TZ\", \"/usr/share/zoneinfo/America/New_York\", 1); // POSIX-specific\n \n    std::time_t t = std::time(nullptr);\n    std::tm tm = *std::localtime(&t);\n    std::cout << \"Today is           \" << std::put_time(&tm, \"%c %Z\")\n              << \" and DST is \" << (tm.tm_isdst ? \"in effect\" : \"not in effect\") << '\\n';\n    tm.tm_mon -= 100;  // tm_mon is now outside its normal range\n    std::mktime(&tm);  // tm_dst is not set to -1; today's DST status is used\n    std::cout << \"100 months ago was \" << std::put_time(&tm, \"%c %Z\")\n              << \" and DST was \" << (tm.tm_isdst ? \"in effect\" : \"not in effect\") << '\\n';\n}",
            "output": "Today is           Fri Apr 22 11:40:36 2016 EDT and DST is in effect\n100 months ago was Sat Dec 22 10:40:36 2007 EST and DST was not in effect"
        }
    },
    "EXIT_SUCCESS, EXIT_FAILURE": {
        "description": {
            "texte": "The EXIT_SUCCESS and EXIT_FAILURE macros expand into integral expressions that can be used as arguments to the std::exit function (and, therefore, as the values to return from the main function), and indicate program execution status."
        }
    },
    "RAND_MAX": {
        "description": {
            "texte": "Expands to an integer constant expression equal to the maximum value returned by the function std::rand. This value is implementation dependent. It's guaranteed that this value is at least 32767."
        }
    },
    "div, std::ldiv, std::lldiv": {
        "description": {
            "texte": "Computes both the quotient and the remainder of the division of the numerator x by the denominator y."
        },
        "parametres": "   x, y   -   integer values \n\n",
        "exemple": {
            "input": "#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n \nstd::string itoa(int n, int base)\n{\n    std::string buf;\n    std::div_t dv{}; dv.quot = n;\n    do {\n        dv = std::div(dv.quot, base);\n        buf += \"0123456789abcdef\"[std::abs(dv.rem)];  // string literals are arrays\n    } while(dv.quot);\n    if(n<0) buf += '-';\n    return {buf.rbegin(), buf.rend()};\n}\n \nint main()\n{\n    std::cout << itoa(12345, 10) << '\\n'\n              << itoa(-12345, 10) << '\\n'\n              << itoa(65535, 16) << '\\n';\n}",
            "output": "12345\n-12345\nffff"
        }
    },
    "_Exit": {
        "description": {
            "texte": "Causes normal program termination to occur without completely cleaning the resources.Destructors of variables with automatic, thread local and static storage durations are not called. Functions passed to std::at_quick_exit() or std::atexit() are not called. Whether open resources such as files are closed is implementation defined.If exit_code is 0 or EXIT_SUCCESS, an implementation-defined status indicating successful termination is returned to the host environment. If exit_code is EXIT_FAILURE, an implementation-defined status, indicating unsuccessful termination, is returned. In other cases implementation-defined status value is returned."
        },
        "parametres": "   exit_code   -   exit status of the program \n\n",
        "exemple": {
            "input": "#include <iostream>\n \nclass Static {\npublic:\n    ~Static() \n    {\n        std::cout << \"Static dtor\\n\";\n    }\n};\n \nclass Local {\npublic:\n    ~Local() \n    {\n        std::cout << \"Local dtor\\n\";\n    }\n};\n \nStatic static_variable; // dtor of this object will *not* be called\n \nvoid atexit_handler()\n{\n    std::cout << \"atexit handler\\n\";\n}\n \nint main()\n{\n    Local local_variable; // dtor of this object will *not* be called\n \n    // handler will *not* be called\n    const int result = std::atexit(atexit_handler);\n \n    if (result != 0) {\n        std::cerr << \"atexit registration failed\\n\";\n        return EXIT_FAILURE;\n    }\n \n    std::cout << \"test\" << std::endl; // flush from std::endl\n        // needs to be here, otherwise nothing will be printed\n    std::_Exit(EXIT_FAILURE);\n}",
            "output": "test"
        }
    },
    "getenv": {
        "description": {
            "texte": "Searches the environment list provided by the host environment (the OS), for a string that matches the C string pointed to by env_var and returns a pointer to the C string that is associated with the matched environment list member.Modifying the string returned by getenv invokes undefined behavior."
        },
        "parametres": "   env_var   -   null-terminated character string identifying the name of the environmental variable to look for \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstdlib>\n \nint main()\n{\n    if(const char* env_p = std::getenv(\"PATH\"))\n        std::cout << \"Your PATH is: \" << env_p << '\\n';\n}",
            "output": "Your PATH is: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games"
        }
    },
    "aligned_alloc": {
        "description": {
            "texte": "Allocate size bytes of uninitialized storage whose alignment is specified by alignment. The size parameter must be an integral multiple of alignment."
        },
        "parametres": "   alignment   -   specifies the alignment. Must be a valid alignment supported by the implementation. \n   size   -   number of bytes to allocate. An integral multiple of alignment \n\n",
        "exemple": {
            "input": "#include <cstdio>\n#include <cstdlib>\n \nint main()\n{\n    int* p1 = static_cast<int*>(std::malloc(10*sizeof *p1));\n    std::printf(\"default-aligned address:   %p\\n\", static_cast<void*>(p1));\n    std::free(p1);\n \n    int* p2 = static_cast<int*>(std::aligned_alloc(1024, 1024));\n    std::printf(\"1024-byte aligned address: %p\\n\", static_cast<void*>(p2));\n    std::free(p2);\n}",
            "output": "default-aligned address:   0x2221c20\n1024-byte aligned address: 0x2222400"
        }
    },
    "calloc": {
        "description": {
            "texte": "Allocates memory for an array of num objects of size size and initializes it to all bits zero.If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type.If size is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage)."
        },
        "parametres": "   num   -   number of objects \n   size   -   size of each object \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstdlib>\n \nint main()\n{\n    int* p1 = (int*)std::calloc(4, sizeof(int)); // allocate and zero out an array of 4 int\n    int* p2 = (int*)std::calloc(1, sizeof(int[4])); // same, naming the array type directly\n    int* p3 = (int*)std::calloc(4, sizeof *p3);   // same, without repeating the type name\n \n    if(p2)\n        for(int n=0; n<4; ++n) // print the array\n            std::cout << \"p2[\" << n << \"] == \" << p2[n] << '\\n';\n \n    std::free(p1);\n    std::free(p2);\n    std::free(p3);\n}",
            "output": "p2[0] == 0\np2[1] == 0\np2[2] == 0\np2[3] == 0"
        }
    },
    "realloc": {
        "description": {
            "texte": "Reallocates the given area of memory. It must be previously allocated by std::malloc(), std::calloc() or std::realloc() and not yet freed with std::free(), otherwise, the results are undefined.The reallocation is done by either:If there is not enough memory, the old memory block is not freed and null pointer is returned.If ptr is a null pointer, the behavior is the same as calling std::malloc(new_size).If new_size is zero, the behavior is implementation defined: null pointer may be returned (in which case the old memory block may or may not be freed) or some non-null pointer may be returned that may not be used to access storage."
        },
        "parametres": "   ptr   -   pointer to the memory area to be reallocated \n   new_size   -   new size of the array \n\n",
        "exemple": {
            "input": "#include <cstdlib>\n#include <new>\n#include <cassert>\n \nclass MallocDynamicBuffer\n{\n    char* p;\npublic:\n    explicit MallocDynamicBuffer(std::size_t initial = 0) : p(nullptr) {\n       resize(initial);\n    }\n    ~MallocDynamicBuffer() { std::free(p); }\n    void resize(std::size_t newSize) {\n        if(newSize == 0) { // this check is not strictly needed, \n            std::free(p);  // but zero-size realloc is deprecated in C\n            p = nullptr;\n        } else {\n            if(void* mem = std::realloc(p, newSize))\n                p = static_cast<char*>(mem);\n            else\n                throw std::bad_alloc();\n        }\n    }\n    char& operator[](size_t n) { return p[n]; }\n    char operator[](size_t n) const { return p[n]; }\n};\n \nint main()\n{\n    MallocDynamicBuffer buf1(1024);\n    buf1[5] = 'f';\n    buf1.resize(10); // shrink\n    assert(buf1[5] == 'f');\n    buf1.resize(1024); // grow\n    assert(buf1[5] == 'f');\n}"
        }
    },
    "free": {
        "description": {
            "texte": "Deallocates the space previously allocated by std::malloc, std::calloc, std::aligned_alloc (since C++17), or std::realloc.If ptr is a null pointer, the function does nothing.The behavior is undefined if the value of ptr does not equal a value returned earlier by std::malloc, std::calloc, std::aligned_alloc (since C++17), or std::realloc.The behavior is undefined if the memory area referred to by ptr has already been deallocated, that is, std::free or std::realloc has already been called with ptr as the argument and no calls to std::malloc, std::calloc, std::aligned_alloc (since C++17), or std::realloc resulted in a pointer equal to ptr afterwards.The behavior is undefined if after std::free returns, an access is made through the pointer ptr (unless another allocation function happened to result in a pointer value equal to ptr)."
        },
        "parametres": "   ptr   -   pointer to the memory to deallocate \n\n",
        "exemple": {
            "input": "#include <cstdlib>\n \nint main()\n{\n    int* p1 = (int*)std::malloc(10*sizeof *p1);\n    std::free(p1); // every allocated pointer must be freed\n \n    int* p2 = (int*)std::calloc(10, sizeof *p2);\n    int* p3 = (int*)std::realloc(p2, 1000*sizeof *p3);\n    if(p3) // p3 not null means p2 was freed by std::realloc\n       std::free(p3);\n    else // p3 null means p2 was not freed\n       std::free(p2);\n}"
        }
    },
    "atof": {
        "description": {
            "texte": "Interprets a floating point value in a byte string pointed to by str.Function discards any whitespace characters (as determined by std::isspace()) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:"
        },
        "parametres": "   str   -   pointer to the null-terminated byte string to be interpreted \n\n",
        "exemple": {
            "input": "#include <cstdlib>\n#include <iostream>\n \nint main()\n{\n    std::cout << std::atof(\"0.0000000123\") << \"\\n\"\n              << std::atof(\"0.012\") << \"\\n\"\n              << std::atof(\"15e16\") << \"\\n\"\n              << std::atof(\"-0x1afp-2\") << \"\\n\"\n              << std::atof(\"inF\") << \"\\n\"\n              << std::atof(\"Nan\") << \"\\n\";\n}",
            "output": "1.23e-08\n0.012\n1.5e+17\n-107.75\ninf\nnan"
        }
    },
    "atoi, std::atol, std::atoll": {
        "description": {
            "texte": "Interprets an integer value in a byte string pointed to by str.Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. The valid integer value consists of the following parts:"
        },
        "parametres": "   str   -   pointer to the null-terminated byte string to be interpreted \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstdlib>\n \nint main()\n{\n    const char *str1 = \"42\";\n    const char *str2 = \"3.14159\";\n    const char *str3 = \"31337 with words\";\n    const char *str4 = \"words and 2\";\n \n    int num1 = std::atoi(str1);\n    int num2 = std::atoi(str2);\n    int num3 = std::atoi(str3);\n    int num4 = std::atoi(str4);\n \n    std::cout << \"std::atoi(\\\"\" << str1 << \"\\\") is \" << num1 << '\\n';\n    std::cout << \"std::atoi(\\\"\" << str2 << \"\\\") is \" << num2 << '\\n';\n    std::cout << \"std::atoi(\\\"\" << str3 << \"\\\") is \" << num3 << '\\n';\n    std::cout << \"std::atoi(\\\"\" << str4 << \"\\\") is \" << num4 << '\\n';\n}",
            "output": "std::atoi(\"42\") is 42\nstd::atoi(\"3.14159\") is 3\nstd::atoi(\"31337 with words\") is 31337\nstd::atoi(\"words and 2\") is 0"
        }
    },
    "strtol, std::strtoll": {
        "description": {
            "texte": "Interprets an integer value in a byte string pointed to by str.Discards any whitespace characters (as identified by calling isspace()) until the first non-whitespace character is found, then takes as many characters as possible to form a valid base-n (where n=base) integer number representation and converts them to an integer value. The valid integer value consists of the following parts:The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is {0,1}, for base-3 integers is {0,1,2}, and so on. For bases larger than 10, valid digits include alphabetic characters, starting from Aa for base-11 integer, to Zz for base-36 integer. The case of the characters is ignored.Additional numeric formats may be accepted by the currently installed C locale.If the value of base is \u200b0\u200b, the numeric base is auto-detected: if the prefix is 0, the base is octal, if the prefix is 0x or 0X, the base is hexadecimal, otherwise the base is decimal.If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type.The functions sets the pointer pointed to by str_end to point to the character past the last character interpreted. If str_end is NULL, it is ignored.If the str is empty or does not have the expected form, no conversion is performed, and (if str_end is not NULL) the value of str is stored in the object pointed to by str_end."
        },
        "parametres": "   str   -   pointer to the null-terminated byte string to be interpreted \n   str_end   -   pointer to a pointer to character. \n   base   -   base of the interpreted integer value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <cerrno>\n#include <cstdlib>\n \nint main()\n{\n    const char* p = \"10 200000000000000000000000000000 30 -40\";\n    char *end;\n    std::cout << \"Parsing '\" << p << \"':\\n\";\n    for (long i = std::strtol(p, &end, 10);\n         p != end;\n         i = std::strtol(p, &end, 10))\n    {\n        std::cout << \"'\" << std::string(p, end-p) << \"' -> \";\n        p = end;\n        if (errno == ERANGE){\n            std::cout << \"range error, got \";\n            errno = 0;\n        }\n        std::cout << i << '\\n';\n    }\n}",
            "output": "Parsing '10 200000000000000000000000000000 30 -40':\n'10' -> 10\n' 200000000000000000000000000000' -> range error, got 9223372036854775807\n' 30' -> 30\n' -40' -> -40"
        }
    },
    "strtoul, std::strtoull": {
        "description": {
            "texte": "Interprets an unsigned integer value in a byte string pointed to by str.Discards any whitespace characters (as identified by calling isspace()) until the first non-whitespace character is found, then takes as many characters as possible to form a valid base-n (where n=base) unsigned integer number representation and converts them to an integer value. The valid unsigned integer value consists of the following parts:The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is {0,1}, for base-3 integers is {0,1,2}, and so on. For bases larger than 10, valid digits include alphabetic characters, starting from Aa for base-11 integer, to Zz for base-36 integer. The case of the characters is ignored.Additional numeric formats may be accepted by the currently installed C locale.If the value of base is \u200b0\u200b, the numeric base is auto-detected: if the prefix is 0, the base is octal, if the prefix is 0x or 0X, the base is hexadecimal, otherwise the base is decimal.If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type, which applies unsigned integer wraparound rules.The functions sets the pointer pointed to by str_end to point to the character past the last character interpreted. If str_end is NULL, it is ignored."
        },
        "parametres": "   str   -   pointer to the null-terminated byte string to be interpreted \n   str_end   -   pointer to a pointer to character. \n   base   -   base of the interpreted integer value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <errno.h>\n#include <cstdlib>\n \nint main()\n{\n    const char* p = \"10 200000000000000000000000000000 30 -40\";\n    char *end;\n    std::cout << \"Parsing '\" << p << \"':\\n\";\n    for (unsigned long i = std::strtoul(p, &end, 10);\n         p != end;\n         i = std::strtoul(p, &end, 10))\n    {\n        std::cout << \"'\" << std::string(p, end-p) << \"' -> \";\n        p = end;\n        if (errno == ERANGE){\n            std::cout << \"range error, got \";\n            errno = 0;\n        }\n        std::cout << i << '\\n';\n    }\n}",
            "output": "Parsing '10 200000000000000000000000000000 30 -40':\n'10' -> 10\n' 200000000000000000000000000000' -> range error, got 18446744073709551615\n' 30' -> 30\n' -40' -> 18446744073709551576"
        }
    },
    "strtof, std::strtod, std::strtold": {
        "description": {
            "texte": "Interprets a floating point value in a byte string pointed to by str.Function discards any whitespace characters (as determined by std::isspace()) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:The functions sets the pointer pointed to by str_end to point to the character past the last character interpreted. If str_end is NULL, it is ignored."
        },
        "parametres": "   str   -   pointer to the null-terminated byte string to be interpreted \n   str_end   -   pointer to a pointer to character. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <cerrno>\n#include <cstdlib>\n \nint main()\n{\n    const char* p = \"111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz\";\n    char* end;\n    std::cout << \"Parsing \\\"\" << p << \"\\\":\\n\";\n    for (double f = std::strtod(p, &end); p != end; f = std::strtod(p, &end))\n    {\n        std::cout << \"'\" << std::string(p, end-p) << \"' -> \";\n        p = end;\n        if (errno == ERANGE){\n            std::cout << \"range error, got \";\n            errno = 0;\n        }\n        std::cout << f << '\\n';\n    }\n}",
            "output": "Parsing \"111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz\":\n'111.11' -> 111.11\n' -2.22' -> -2.22\n' 0X1.BC70A3D70A3D7P+6' -> 111.11\n'  1.18973e+4932' -> range error, got inf"
        }
    },
    "mblen": {
        "description": {
            "texte": "Determines the size, in bytes, of the multibyte character whose first byte is pointed to by s.If s is a null pointer, resets the global conversion state and determines whether shift sequences are used.This function is equivalent to the call std::mbtowc((wchar_t*)0, s, n), except that conversion state of std::mbtowc is unaffected."
        },
        "parametres": "   s   -   pointer to the multibyte character \n   n   -   limit on the number of bytes in s that can be examined \n\n",
        "exemple": {
            "input": "#include <clocale>\n#include <string>\n#include <iostream>\n#include <cstdlib>\n#include <stdexcept>\n \n// the number of characters in a multibyte string is the sum of mblen()'s\n// note: the simpler approach is std::mbstowcs(NULL, s.c_str(), s.size())\nstd::size_t strlen_mb(const std::string& s)\n{\n    std::size_t result = 0;\n    const char* ptr = s.data();\n    const char* end = ptr + s.size();\n    std::mblen(NULL, 0); // reset the conversion state\n    while (ptr < end) {\n        int next = std::mblen(ptr, end-ptr);\n        if (next == -1) {\n            throw std::runtime_error(\"strlen_mb(): conversion error\");\n        }\n        ptr += next;\n        ++result;\n    }\n    return result;\n}\n \nint main()\n{\n    // allow mblen() to work with UTF-8 multibyte encoding\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    // UTF-8 narrow multibyte encoding\n    std::string str = u8\"z\\u00df\\u6c34\\U0001f34c\"; // or u8\"z\u00df\u6c34\ud83c\udf4c\"\n    std::cout << str << \" is \" << str.size() << \" bytes, but only \"\n              << strlen_mb(str) << \" characters\\n\";\n}",
            "output": "z\u00df\u6c34\ud83c\udf4c is 10 bytes, but only 4 characters"
        }
    },
    "mbtowc": {
        "description": {
            "texte": "Converts a multibyte character whose first byte is pointed to by s to a wide character, written to *pwc if pwc is not null.If s is a null pointer, resets the global conversion state and determines whether shift sequences are used."
        },
        "parametres": "   s   -   pointer to the multibyte character \n   n   -   limit on the number of bytes in s that can be examined \n   pwc   -   pointer to the wide character for output \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <clocale>\n#include <cstring>\n#include <cstdlib>\n \nint print_mb(const char* ptr)\n{\n    std::mbtowc(NULL, 0, 0); // reset the conversion state\n    const char* end = ptr + std::strlen(ptr);\n    int ret;\n    for (wchar_t wc; (ret = std::mbtowc(&wc, ptr, end-ptr)) > 0; ptr+=ret) {\n        std::wcout << wc;\n    }\n    std::wcout << '\\n';\n    return ret;\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    // UTF-8 narrow multibyte encoding\n    const char* str = u8\"z\\u00df\\u6c34\\U0001d10b\"; // or u8\"z\u00df\u6c34\ud834\udd0b\"\n                      // or \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9d\\x84\\x8b\";\n    print_mb(str);\n}",
            "output": "z\u00df\u6c34\ud834\udd0b"
        }
    },
    "wctomb": {
        "description": {
            "texte": "Converts a wide character wc to multibyte encoding and stores it (including any shift sequences) in the char array whose first element is pointed to by s. No more than MB_CUR_MAX characters are stored.If wc is the null character, the null byte is written to s, preceded by any shift sequences necessary to restore the initial shift state.If s is a null pointer, resets the global conversion state and determines whether shift sequences are used."
        },
        "parametres": "   s   -   pointer to the character array for output \n   wc   -   wide character to convert \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <clocale>\n#include <string>\n#include <cstdlib>\n \nvoid print_wide(const std::wstring& wstr)\n{\n    bool shifts = std::wctomb(nullptr, 0); // reset the conversion state\n    std::cout << \"shift sequences \" << (shifts ? \"are\" : \"not\" ) << \" used\\n\";\n    for (wchar_t wc : wstr) {\n        std::string mb(MB_CUR_MAX, '\\0');\n        int ret = std::wctomb(&mb[0], wc);\n        std::cout << \"multibyte char \" << mb << \" is \" << ret << \" bytes\\n\";\n    }\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    // UTF-8 narrow multibyte encoding\n    std::wstring wstr = L\"z\\u00df\\u6c34\\U0001d10b\"; // or L\"z\u00df\u6c34\ud834\udd0b\"\n    print_wide(wstr);\n}",
            "output": "shift sequences not used\nmultibyte char z is 1 bytes\nmultibyte char \u00df is 2 bytes\nmultibyte char \u6c34 is 3 bytes\nmultibyte char \ud834\udd0b is 4 bytes"
        }
    },
    "mbstowcs": {
        "description": {
            "texte": "Converts a multibyte character string from the array whose first element is pointed to by src to its wide character representation. Converted characters are stored in the successive elements of the array pointed to by dst. No more than len wide characters are written to the destination array.Each character is converted as if by a call to std::mbtowc, except that the mbtowc conversion state is unaffected. The conversion stops if:"
        },
        "parametres": "   dst   -   pointer to wide character array where the wide string will be stored \n   src   -   pointer to the first element of a null-terminated multibyte string to convert \n   len   -   number of wide characters available in the array pointed to by dst \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <clocale>\n#include <cstdlib>\nint main()\n{\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::wcout.imbue(std::locale(\"en_US.utf8\"));\n    const char* mbstr = u8\"z\\u00df\\u6c34\\U0001f34c\"; // or u8\"z\u00df\u6c34\ud83c\udf4c\"\n                        // or \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9f\\x8d\\x8c\";\n    wchar_t wstr[5];\n    std::mbstowcs(wstr, mbstr, 5);\n    std::wcout << \"wide string: \" << wstr << '\\n';\n}",
            "output": "wide string: z\u00df\u6c34\ud83c\udf4c"
        }
    },
    "wcstombs": {
        "description": {
            "texte": "Converts a sequence of wide characters from the array whose first element is pointed to by src to its narrow multibyte representation that begins in the initial shift state. Converted characters are stored in the successive elements of the char array pointed to by dst. No more than len bytes are written to the destination array.Each character is converted as if by a call to std::wctomb, except that the wctomb's conversion state is unaffected. The conversion stops if:"
        },
        "parametres": "   dst   -   pointer to narrow character array where the multibyte character will be stored \n   src   -   pointer to the first element of a null-terminated wide string to convert \n   len   -   number of byte available in the array pointed to by dst \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <clocale>\n#include <cstdlib>\n \nint main()\n{\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    // UTF-8 narrow multibyte encoding\n    const wchar_t* wstr = L\"z\\u00df\\u6c34\\U0001d10b\"; // or L\"z\u00df\u6c34\ud834\udd0b\"\n    char mbstr[11];\n    std::wcstombs(mbstr, wstr, 11);\n    std::cout << \"multibyte string: \" << mbstr << '\\n';\n}",
            "output": "multibyte string: z\u00df\u6c34\ud834\udd0b"
        }
    },
    "abs, std::labs, std::llabs, std::imaxabs": {
        "description": {
            "texte": "Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type."
        },
        "parametres": "   n   -   integer value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstdlib>\n#include <climits>\n \nint main()\n{\n    std::cout << \"abs(+3) = \" << std::abs(3) << '\\n'\n              << \"abs(-3) = \" << std::abs(-3) << '\\n';\n \n//  std::cout << std::abs(INT_MIN); // undefined behavior on 2's complement systems\n}",
            "output": "abs(+3) = 3\nabs(-3) = 3"
        }
    },
    "operator==,!=,,>=(std::basic_string)\n": {
        "description": {
            "texte": "Compares the contents of a string with another string or a null-terminated array of CharT.All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):"
        },
        "parametres": "   lhs, rhs   -   strings whose contents to compare \n\n"
    },
    "swap(std::basic_string)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::basic_string. Swaps the contents of lhs and rhs. Equivalent to lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   strings whose contents to swap \n\n"
    },
    "operator>(std::basic_string)": {
        "description": {
            "texte": "1) Behaves as a FormattedOutputFunction. After constructing and checking the sentry object, determines the output format padding as follows:Then stores each character from the resulting sequence (the contents of str plus padding) to the output stream os as if by calling os.rdbuf()->sputn(seq, n), where n=std::max(os.width(), str.size()).Finally, calls os.width(0) to cancel the effects of std::setw, if any.2) Behaves as a FormattedInputFunction. After constructing and checking the sentry object, which may skip leading whitespace, first clears str with str.erase(), then reads characters from is and appends them to str as if by str.append(1, c), until one of the following conditions becomes true:If no characters are extracted then std::ios::failbit is set on is, which may throw std::ios_base::failure.Finally, calls is.width(0) to cancel the effects of std::setw, if any."
        },
        "parametres": "   os   -   a character output stream \n   is   -   a character input stream \n   str   -   the string to be inserted or extracted \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <sstream>\n \nint main()\n{\n    std::string greeting = \"Hello, whirled!\";\n    std::istringstream is(greeting);\n    std::string hello_comma;\n    is >> hello_comma;\n    std::cout << greeting << '\\n' << hello_comma << '\\n';\n}",
            "output": "Hello, whirled!\nHello,"
        }
    },
    "getline": {
        "description": {
            "texte": "getline reads characters from an input stream and places them into a string:"
        },
        "parametres": "   input   -   the stream to get data from \n   str   -   the string to put the data into \n   delim   -   the delimiter character \n\n",
        "exemple": {
            "input": "#include <string>\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    // greet the user\n    std::string name;\n    std::cout << \"What is your name? \";\n    std::getline(std::cin, name);\n    std::cout << \"Hello \" << name << \", nice to meet you.\\n\";\n \n    // read file line by line\n    std::istringstream input;\n    input.str(\"1\\n2\\n3\\n4\\n5\\n6\\n7\\n\");\n    int sum = 0;\n    for (std::string line; std::getline(input, line); ) {\n        sum += std::stoi(line);\n    }\n    std::cout << \"\\nThe sum is: \" << sum << \"\\n\";\n}",
            "output": "What is your name? John Q. Public\nHello John Q. Public, nice to meet you.\n \nThe sum is 28"
        }
    },
    "stoi, std::stol, std::stoll": {
        "description": {
            "texte": "Interprets a signed integer value in the string str.Discards any whitespace characters (as identified by calling isspace()) until the first non-whitespace character is found, then takes as many characters as possible to form a valid base-n (where n=base) integer number representation and converts them to an integer value. The valid integer value consists of the following parts:The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is {0,1}, for base-3 integers is {0,1,2}, and so on. For bases larger than 10, valid digits include alphabetic characters, starting from Aa for base-11 integer, to Zz for base-36 integer. The case of the characters is ignored.Additional numeric formats may be accepted by the currently installed C locale.If the value of base is \u200b0\u200b, the numeric base is auto-detected: if the prefix is 0, the base is octal, if the prefix is 0x or 0X, the base is hexadecimal, otherwise the base is decimal.If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type.If pos is not a null pointer, then a pointer ptr - internal to the conversion functions - will receive the address of the first unconverted character in str.c_str(), and the index of that character will be calculated and stored in *pos, giving the number of characters that were processed by the conversion."
        },
        "parametres": "   str   -   the string to convert \n   pos   -   address of an integer to store the number of characters processed \n   base   -   the number base \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n \nint main()\n{\n    std::string str1 = \"45\";\n    std::string str2 = \"3.14159\";\n    std::string str3 = \"31337 with words\";\n    std::string str4 = \"words and 2\";\n \n    int myint1 = std::stoi(str1);\n    int myint2 = std::stoi(str2);\n    int myint3 = std::stoi(str3);\n    // error: 'std::invalid_argument'\n    // int myint4 = std::stoi(str4);\n \n    std::cout << \"std::stoi(\\\"\" << str1 << \"\\\") is \" << myint1 << '\\n';\n    std::cout << \"std::stoi(\\\"\" << str2 << \"\\\") is \" << myint2 << '\\n';\n    std::cout << \"std::stoi(\\\"\" << str3 << \"\\\") is \" << myint3 << '\\n';\n    //std::cout << \"std::stoi(\\\"\" << str4 << \"\\\") is \" << myint4 << '\\n';\n}",
            "output": "std::stoi(\"45\") is 45\nstd::stoi(\"3.14159\") is 3\nstd::stoi(\"31337 with words\") is 31337"
        }
    },
    "stoul, std::stoull": {
        "description": {
            "texte": "Interprets an unsigned integer value in the string str.Discards any whitespace characters (as identified by calling isspace()) until the first non-whitespace character is found, then takes as many characters as possible to form a valid base-n (where n=base) unsigned integer number representation and converts them to an integer value. The valid unsigned integer value consists of the following parts:The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is {0,1}, for base-3 integers is {0,1,2}, and so on. For bases larger than 10, valid digits include alphabetic characters, starting from Aa for base-11 integer, to Zz for base-36 integer. The case of the characters is ignored.Additional numeric formats may be accepted by the currently installed C locale.If the value of base is \u200b0\u200b, the numeric base is auto-detected: if the prefix is 0, the base is octal, if the prefix is 0x or 0X, the base is hexadecimal, otherwise the base is decimal.If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type, which applies unsigned integer wraparound rules.If pos is not a null pointer, then a pointer ptr, internal to the conversion functions, will receive the address of the first unconverted character in str.c_str(), and the index of that character will be calculated and stored in *pos, giving the number of characters that were processed by the conversion."
        },
        "parametres": "   str   -   the string to convert \n   pos   -   address of an integer to store the number of characters processed \n   base   -   the number base \n\n"
    },
    "stof, std::stod, std::stold": {
        "description": {
            "texte": "Interprets a floating point value in a string str.Function discards any whitespace characters (as determined by std::isspace()) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:If pos is not a null pointer, then a pointer ptr, internal to the conversion functions, will receive the address of the first unconverted character in str.c_str(), and the index of that character will be calculated and stored in *pos, giving the number of characters that were processed by the conversion."
        },
        "parametres": "   str   -   the string to convert \n   pos   -   address of an integer to store the number of characters processed \n\n"
    },
    "to_string": {
        "description": {
            "texte": "Converts a numeric value to std::string."
        },
        "parametres": "   value   -   a numeric value to convert \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n \nint main() \n{\n    double f = 23.43;\n    double f2 = 1e-9;\n    double f3 = 1e40;\n    double f4 = 1e-40;\n    double f5 = 123456789;\n    std::string f_str = std::to_string(f);\n    std::string f_str2 = std::to_string(f2); // Note: returns \"0.000000\"\n    std::string f_str3 = std::to_string(f3); // Note: Does not return \"1e+40\".\n    std::string f_str4 = std::to_string(f4); // Note: returns \"0.000000\"\n    std::string f_str5 = std::to_string(f5);\n    std::cout << \"std::cout: \" << f << '\\n'\n              << \"to_string: \" << f_str  << \"\\n\\n\"\n              << \"std::cout: \" << f2 << '\\n'\n              << \"to_string: \" << f_str2 << \"\\n\\n\"\n              << \"std::cout: \" << f3 << '\\n'\n              << \"to_string: \" << f_str3 << \"\\n\\n\"\n              << \"std::cout: \" << f4 << '\\n'\n              << \"to_string: \" << f_str4 << \"\\n\\n\"\n              << \"std::cout: \" << f5 << '\\n'\n              << \"to_string: \" << f_str5 << '\\n';\n}",
            "output": "std::cout: 23.43\nto_string: 23.430000\n \nstd::cout: 1e-09\nto_string: 0.000000\n \nstd::cout: 1e+40\nto_string: 10000000000000000303786028427003666890752.000000\n \nstd::cout: 1e-40\nto_string: 0.000000\n \nstd::cout: 1.23457e+08\nto_string: 123456789.000000"
        }
    },
    "to_wstring": {
        "description": {
            "texte": "Converts a numeric value to std::wstring."
        },
        "parametres": "   value   -   a numeric value to convert \n\n",
        "exemple": {
            "input": "#include <string>\n#include <iostream>\n \nint main() {\n    double f = 23.43;        \n    std::wstring f_str = std::to_wstring(f);\n    std::wcout << f_str;\n}",
            "output": "23.430000"
        }
    },
    "literals::string_literals::operator\"\"s": {
        "description": {
            "texte": "Forms a string literal of the desired type."
        },
        "parametres": "   str   -   pointer to the beginning of the raw character array literal \n   len   -   length of the raw character array literal \n\n",
        "exemple": {
            "input": "#include <string>\n#include <iostream>\n \nint main()\n{\n    using namespace std::string_literals;\n \n    std::string s1 = \"abc\\0\\0def\";\n    std::string s2 = \"abc\\0\\0def\"s;\n    std::cout << \"s1: \" << s1.size() << \" \\\"\" << s1 << \"\\\"\\n\";\n    std::cout << \"s2: \" << s2.size() << \" \\\"\" << s2 << \"\\\"\\n\";\n}",
            "output": "s1: 3 \"abc\"\ns2: 8 \"abc^@^@def\""
        }
    },
    "hash (std::string_view, std::wstring_view, std::u16string_view, std::u32string_view)\n": {
        "description": {
            "texte": "Template specializations of std::hash for the various view classes for hashing views.These hashes equal the hashes of corresponding std::basic_string classes: If S is one of the standard basic_string types, SV is the corresponding string view type, and s is an object of type S, then std::hash<S>()(s) == std::hash<SV>()(SV(s))."
        }
    },
    "operator==,!=,,>=(std::basic_string_view)\n": {
        "description": {
            "texte": "Compares two views.All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):The implementation shall provide sufficient additional constexpr and noexcept overloads of these functions so that a basic_string_view<CharT,Traits> object sv may be compared to another object t with an implicit conversion to basic_string_view<CharT,Traits>, with semantics identical to comparing sv and basic_string_view<CharT,Traits>(t)."
        },
        "parametres": "   lhs, rhs   -   views to compare \n\n"
    },
    "operator<<(std::basic_string_view)": {
        "description": {
            "texte": "Behaves as a FormattedOutputFunction. After constructing and checking the sentry object, determines the output format padding as follows:Then stores each character from the resulting sequence (the contents of v plus padding) to the output stream os as if by calling os.rdbuf()->sputn(seq, n), where n=std::max(os.width(), str.size()).Finally, calls os.width(0) to cancel the effects of std::setw, if any."
        },
        "parametres": "   os   -   a character output stream \n   v   -   the view to be inserted \n\n"
    },
    "isalnum": {
        "description": {
            "texte": "Checks if the given character is an alphanumeric character as classified by the current C locale. In the default locale, the following characters are alphanumeric:The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF."
        },
        "parametres": "   ch   -   character to classify \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cctype>\n#include <clocale>\n \nint main()\n{\n    unsigned char c = '\\xdf'; // German letter \u00df in ISO-8859-1\n \n    std::cout << \"isalnum(\\'\\\\xdf\\', default C locale) returned \"\n               << std::boolalpha << (bool)std::isalnum(c) << '\\n';\n \n    if(std::setlocale(LC_ALL, \"de_DE.iso88591\"))\n        std::cout << \"isalnum(\\'\\\\xdf\\', ISO-8859-1 locale) returned \"\n                  << std::boolalpha << (bool)std::isalnum(c) << '\\n';\n \n}",
            "output": "isalnum('\\xdf', default C locale) returned false\nisalnum('\\xdf', ISO-8859-1 locale) returned true"
        }
    },
    "isalpha": {
        "description": {
            "texte": "Checks if the given character is an alphabetic character as classified by the currently installed C locale. In the default locale, the following characters are alphabetic:In locales other than \"C\", an alphabetic character is a character for which std::isupper() or std::islower() returns non-zero or any other character considered alphabetic by the locale. In any case, std::iscntrl(), std::isdigit(), std::ispunct() and std::isspace() will return zero for this character.The behavior is undefined if the value of ch is not representable as unsigned char or is not equal to EOF."
        },
        "parametres": "   ch   -   character to classify \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cctype> \n#include <clocale>\n \nint main()\n{        \n    unsigned char c = '\\xdf'; // German letter \u00df in ISO-8859-1\n \n    std::cout << \"isalpha(\\'\\\\xdf\\', default C locale) returned \"\n               << std::boolalpha << (bool)std::isalpha(c) << '\\n';\n \n    std::setlocale(LC_ALL, \"de_DE.iso88591\");\n    std::cout << \"isalpha(\\'\\\\xdf\\', ISO-8859-1 locale) returned \"\n              << std::boolalpha << (bool)std::isalpha(c) << '\\n';\n \n}",
            "output": "isalpha('\\xdf', default C locale) returned false\nisalpha('\\xdf', ISO-8859-1 locale) returned true"
        }
    },
    "islower": {
        "description": {
            "texte": "Checks if the given character is classified as a lowercase character according to the current C locale. In the default \"C\" locale, islower returns a nonzero value only for the lowercase letters (abcdefghijklmnopqrstuvwxyz).If islower returns a nonzero value, it is guaranteed that iscntrl, isdigit, ispunct, and isspace return zero for the same character in the same C locale.The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF."
        },
        "parametres": "   ch   -   character to classify \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cctype>\n#include <clocale>\n \nint main()\n{\n    unsigned char c = '\\xe5'; // letter \u00e5 in ISO-8859-1\n \n    std::cout << \"islower(\\'\\\\xe5\\', default C locale) returned \"\n               << std::boolalpha << (bool)std::islower(c) << '\\n';\n \n    std::setlocale(LC_ALL, \"en_GB.iso88591\");\n    std::cout << \"islower(\\'\\\\xe5\\', ISO-8859-1 locale) returned \"\n              << std::boolalpha << (bool)std::islower(c) << '\\n';\n \n}",
            "output": "islower('\\xe5', default C locale) returned false\nislower('\\xe5', ISO-8859-1 locale) returned true"
        }
    },
    "isupper": {
        "description": {
            "texte": "Checks if the given character is an uppercase character as classified by the currently installed C locale. In the default \"C\" locale, isupper returns a nonzero value only for the uppercase letters (ABCDEFGHIJKLMNOPQRSTUVWXYZ).If isupper returns a nonzero value, it is guaranteed that iscntrl, isdigit, ispunct, and isspace return zero for the same character in the same C locale.The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF."
        },
        "parametres": "   ch   -   character to classify \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cctype>\n#include <clocale>\n \nint main()\n{\n    unsigned char c = '\\xc6'; // letter \u00c6 in ISO-8859-1\n \n    std::cout << \"isupper(\\'\\\\xc6\\', default C locale) returned \"\n               << std::boolalpha << (bool)std::isupper(c) << '\\n';\n \n    std::setlocale(LC_ALL, \"en_GB.iso88591\");\n    std::cout << \"isupper(\\'\\\\xc6\\', ISO-8859-1 locale) returned \"\n              << std::boolalpha << (bool)std::isupper(c) << '\\n';\n \n}",
            "output": "isupper('\\xc6', default C locale) returned false\nisupper('\\xc6', ISO-8859-1 locale) returned true"
        }
    },
    "isdigit": {
        "description": {
            "texte": "Checks if the given character is one of the 10 decimal digits: 0123456789.The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF."
        },
        "parametres": "   ch   -   character to classify \n\n"
    },
    "isxdigit": {
        "description": {
            "texte": "Checks if the given character is a hexadecimal numeric character (0123456789abcdefABCDEF).The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF."
        },
        "parametres": "   ch   -   character to classify \n\n"
    },
    "iscntrl": {
        "description": {
            "texte": "Checks if the given character is a control character as classified by the currently installed C locale. In the default, \"C\" locale, the control characters are the characters with the codes 0x00-0x1F and 0x7F.The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF."
        },
        "parametres": "   ch   -   character to classify \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cctype>\n#include <clocale>\n \nint main()\n{\n    unsigned char c = '\\x94'; // the control code CCH in ISO-8859-1\n \n    std::cout << \"iscntrl(\\'\\\\x94\\', default C locale) returned \"\n               << std::boolalpha << (bool)std::iscntrl(c) << '\\n';\n \n    std::setlocale(LC_ALL, \"en_GB.iso88591\");\n    std::cout << \"iscntrl(\\'\\\\x94\\', ISO-8859-1 locale) returned \"\n              << std::boolalpha << (bool)std::iscntrl(c) << '\\n';\n \n}",
            "output": "iscntrl('\\x94', default C locale) returned false\niscntrl('\\x94', ISO-8859-1 locale) returned true"
        }
    },
    "isgraph": {
        "description": {
            "texte": "Checks if the given character is graphic (has a graphical representation) as classified by the currently installed C locale. In the default C locale, the following characters are graphic:The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF."
        },
        "parametres": "   ch   -   character to classify \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cctype>\n#include <clocale>\n \nint main()\n{\n    unsigned char c = '\\xb6'; // the character \u00b6 in ISO-8859-1\n \n    std::cout << \"isgraph(\\'\\\\xb6\\', default C locale) returned \"\n               << std::boolalpha << (bool)std::isgraph(c) << '\\n';\n \n    std::setlocale(LC_ALL, \"en_GB.iso88591\");\n    std::cout << \"isgraph(\\'\\\\xb6\\', ISO-8859-1 locale) returned \"\n              << std::boolalpha << (bool)std::isgraph(c) << '\\n';\n}",
            "output": "isgraph('\\xb6', default C locale) returned false\nisgraph('\\xb6', ISO-8859-1 locale) returned true"
        }
    },
    "isspace": {
        "description": {
            "texte": "Checks if the given character is whitespace character as classified by the currently installed C locale. In the default locale, the whitespace characters are the following:The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF."
        },
        "parametres": "   ch   -   character to classify \n\n"
    },
    "isblank": {
        "description": {
            "texte": "Checks if the given character is a blank character as classified by the currently installed C locale. Blank characters are whitespace characters used to separate words within a sentence. In the default C locale, only space (0x20) and horizontal tab (0x09) are classified as blank characters.The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF."
        },
        "parametres": "   ch   -   character to classify \n\n"
    },
    "isprint": {
        "description": {
            "texte": "Checks if ch is a printable character as classified by the currently installed C locale. In the default, \"C\" locale, the following characters are printable:The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF."
        },
        "parametres": "   ch   -   character to classify \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cctype>\n#include <clocale>\n \nint main()\n{\n    unsigned char c = '\\xa0'; // the non-breaking space in ISO-8859-1\n \n    std::cout << \"isprint(\\'\\\\xa0\\', default C locale) returned \"\n               << std::boolalpha << (bool)std::isprint(c) << '\\n';\n \n    std::setlocale(LC_ALL, \"en_GB.iso88591\");\n    std::cout << \"isprint(\\'\\\\xa0\\', ISO-8859-1 locale) returned \"\n              << std::boolalpha << (bool)std::isprint(c) << '\\n';\n}",
            "output": "isprint('\\xa0', default C locale) returned false\nisprint('\\xa0', ISO-8859-1 locale) returned true"
        }
    },
    "ispunct": {
        "description": {
            "texte": "Checks if the given character is a punctuation character as classified by the current C locale. The default C locale classifies the characters !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ as punctuation.The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF."
        },
        "parametres": "   ch   -   character to classify \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cctype>\n#include <clocale>\n \nint main()\n{\n    unsigned char c = '\\xd7'; // the character \u00d7 (multiplication sign) in ISO-8859-1\n \n    std::cout << \"ispunct(\\'\\\\xd7\\', default C locale) returned \"\n               << std::boolalpha << (bool)std::ispunct(c) << '\\n';\n \n    std::setlocale(LC_ALL, \"en_GB.iso88591\");\n    std::cout << \"ispunct(\\'\\\\xd7\\', ISO-8859-1 locale) returned \"\n              << std::boolalpha << (bool)std::ispunct(c) << '\\n';\n}",
            "output": "ispunct('\\xd7', default C locale) returned false\nispunct('\\xd7', ISO-8859-1 locale) returned true"
        }
    },
    "tolower": {
        "description": {
            "texte": "Converts the given character to lowercase according to the character conversion rules defined by the currently installed C locale.In the default \"C\" locale, the following uppercase letters ABCDEFGHIJKLMNOPQRSTUVWXYZ are replaced with respective lowercase letters abcdefghijklmnopqrstuvwxyz."
        },
        "parametres": "   ch   -   character to be converted. If the value of ch is not representable as unsigned char and does not equal EOF, the behavior is undefined \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cctype>\n#include <clocale>\n \nint main()\n{\n    unsigned char c = '\\xb4'; // the character \u017d in ISO-8859-15\n                              // but \u00b4 (acute accent) in ISO-8859-1 \n \n    std::setlocale(LC_ALL, \"en_US.iso88591\");\n    std::cout << std::hex << std::showbase;\n    std::cout << \"in iso8859-1, tolower('0xb4') gives \"\n              << std::tolower(c) << '\\n';\n    std::setlocale(LC_ALL, \"en_US.iso885915\");\n    std::cout << \"in iso8859-15, tolower('0xb4') gives \"\n              << std::tolower(c) << '\\n';\n}",
            "output": "in iso8859-1, tolower('0xb4') gives 0xb4\nin iso8859-15, tolower('0xb4') gives 0xb8"
        }
    },
    "toupper": {
        "description": {
            "texte": "Converts the given character to uppercase according to the character conversion rules defined by the currently installed C locale.In the default \"C\" locale, the following lowercase letters abcdefghijklmnopqrstuvwxyz are replaced with respective uppercase letters ABCDEFGHIJKLMNOPQRSTUVWXYZ."
        },
        "parametres": "   ch   -   character to be converted. If the value of ch is not representable as unsigned char and does not equal EOF, the behavior is undefined. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cctype>\n#include <clocale>\n \nint main()\n{\n    unsigned char c = '\\xb8'; // the character \u017e in ISO-8859-15\n                              // but \u00b8 (cedilla) in ISO-8859-1 \n \n    std::setlocale(LC_ALL, \"en_US.iso88591\");\n    std::cout << std::hex << std::showbase;\n    std::cout << \"in iso8859-1, toupper('0xb8') gives \" << std::toupper(c) << '\\n';\n    std::setlocale(LC_ALL, \"en_US.iso885915\");\n    std::cout << \"in iso8859-15, toupper('0xb8') gives \" << std::toupper(c) << '\\n';\n}",
            "output": "in iso8859-1, toupper('0xb8') gives 0xb8\nin iso8859-15, toupper('0xb8') gives 0xb4"
        }
    },
    "iswalnum": {
        "description": {
            "texte": "Checks if the given wide character is an alphanumeric character, i.e. either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz) or any alphanumeric character specific to the current locale.If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined."
        },
        "parametres": "   ch   -   wide character \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\\u13ad'; // the Cherokee letter HA ('\u13ad')\n \n    std::cout << std::hex << std::showbase << std::boolalpha;\n    std::cout << \"in the default locale, iswalnum(\" << (std::wint_t)c << \") = \"\n              << (bool)std::iswalnum(c) << '\\n';\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::cout << \"in Unicode locale, iswalnum(\" << (std::wint_t)c << \") = \"\n              << (bool)std::iswalnum(c) << '\\n';\n}",
            "output": "in the default locale, iswalnum(0x13ad) = false\nin Unicode locale, iswalnum(0x13ad) = true"
        }
    },
    "iswalpha": {
        "description": {
            "texte": "Checks if the given wide character is an alphabetic character, i.e. either an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz) or any alphabetic character specific to the current locale.If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined."
        },
        "parametres": "   ch   -   wide character \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\\u0b83'; // Tamil sign Visarga ('\u0b83')\n \n    std::cout << std::hex << std::showbase << std::boolalpha;\n    std::cout << \"in the default locale, iswalpha(\" << (std::wint_t)c << \") = \"\n              << (bool)std::iswalpha(c) << '\\n';\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::cout << \"in Unicode locale, iswalpha(\" << (std::wint_t)c << \") = \"\n              << (bool)std::iswalpha(c) << '\\n';\n}",
            "output": "in the default locale, iswalpha(0xb83) = false\nin Unicode locale, iswalpha(0xb83) = true"
        }
    },
    "iswlower": {
        "description": {
            "texte": "Checks if the given wide character is a lowercase letter, i.e. one of abcdefghijklmnopqrstuvwxyz or any lowercase letter specific to the current locale.If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined."
        },
        "parametres": "   ch   -   wide character \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\\u0444'; // Cyrillic small letter ef ('\u0444')\n \n    std::cout << std::hex << std::showbase << std::boolalpha;\n    std::cout << \"in the default locale, iswlower(\" << (std::wint_t)c << \") = \"\n              << (bool)std::iswlower(c) << '\\n';\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::cout << \"in Unicode locale, iswlower(\" << (std::wint_t)c << \") = \"\n              << (bool)std::iswlower(c) << '\\n';\n}",
            "output": "in the default locale, iswlower(0x444) = false\nin Unicode locale, iswlower(0x444) = true"
        }
    },
    "iswupper": {
        "description": {
            "texte": "Checks if the given wide character is an uppercase letter, i.e. one of ABCDEFGHIJKLMNOPQRSTUVWXYZ or any uppercase letter specific to the current locale.If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined."
        },
        "parametres": "   ch   -   wide character \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\\u053d'; // Armenian capital letter xeh ('\u053d')\n \n    std::cout << std::hex << std::showbase << std::boolalpha;\n    std::cout << \"in the default locale, iswupper(\" << (std::wint_t)c << \") = \"\n              << (bool)std::iswupper(c) << '\\n';\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::cout << \"in Unicode locale, iswupper(\" << (std::wint_t)c << \") = \"\n              << (bool)std::iswupper(c) << '\\n';\n}",
            "output": "in the default locale, iswupper(0x53d) = false\nin Unicode locale, iswupper(0x53d) = true"
        }
    },
    "iswdigit": {
        "description": {
            "texte": "Checks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters 0123456789.If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined."
        },
        "parametres": "   ch   -   wide character \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwctype>\n#include <clocale>\nvoid test(wchar_t a3, wchar_t u3, wchar_t j3)\n{\n    std::wcout << std::boolalpha\n               << \"          '\" << a3 << \"'   '\" << u3 << \"'  '\" << j3  << \"'\\n\"\n               << \"iswdigit \"\n               << (bool)std::iswdigit(a3) << \"  \"\n               << (bool)std::iswdigit(u3) << \" \"\n               << (bool)std::iswdigit(j3) << '\\n'\n               << \"jdigit:  \"\n               << (bool)std::iswctype(a3, std::wctype(\"jdigit\")) << ' '\n               << (bool)std::iswctype(u3, std::wctype(\"jdigit\")) << ' '\n               << (bool)std::iswctype(j3, std::wctype(\"jdigit\")) << '\\n';\n}\nint main()\n{\n    wchar_t a3 = L'3';  // the ASCII digit 3\n    wchar_t u3 = L'\u4e09'; // the CJK numeral 3\n    wchar_t j3 = L'\uff13'; // the fullwidth digit 3\n \n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::wcout << \"In american locale:\\n\";\n    test(a3, u3, j3);\n \n    std::wcout << \"\\nIn japanese locale:\\n\";\n    std::setlocale(LC_ALL, \"ja_JP.utf8\");\n    test(a3, u3, j3);\n}",
            "output": "In american locale:\n          '3'   '\u4e09'  '\uff13'\niswdigit true  false false\njdigit:  false false false\n \nIn japanese locale:\n          '3'   '\u4e09'  '\uff13'\niswdigit true  false false\njdigit:  false false true"
        }
    },
    "iswxdigit": {
        "description": {
            "texte": "Checks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e. one of 0123456789abcdefABCDEF.If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined."
        },
        "parametres": "   ch   -   wide character \n\n"
    },
    "iswcntrl": {
        "description": {
            "texte": "Checks if the given wide character is a control character, i.e. codes 0x00-0x1F and 0x7F and any control characters specific to the current locale.If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined."
        },
        "parametres": "   ch   -   wide character \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\\u2028'; // the Unicode character \"line separator\" \n \n    std::cout << std::hex << std::showbase << std::boolalpha;\n    std::cout << \"in the default locale, iswcntrl(\" << (std::wint_t)c << \") = \"\n              << (bool)std::iswcntrl(c) << '\\n';\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::cout << \"in Unicode locale, iswcntrl(\" << (std::wint_t)c << \") = \"\n              << (bool)std::iswcntrl(c) << '\\n';\n}",
            "output": "in the default locale, iswcntrl(0x2028) = false\nin Unicode locale, iswcntrl(0x2028) = true"
        }
    },
    "iswgraph": {
        "description": {
            "texte": "Checks if the given wide character has a graphical representation, i.e. it is either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz), a punctuation character(!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~) or any graphical character specific to the current C locale.If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined."
        },
        "parametres": "   ch   -   wide character \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\\u2602'; // the Unicode character Umbrella ('\u2602')\n \n    std::cout << std::hex << std::showbase << std::boolalpha;\n    std::cout << \"in the default locale, iswgraph(\" << (std::wint_t)c << \") = \"\n              << (bool)std::iswgraph(c) << '\\n';\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::cout << \"in Unicode locale, iswgraph(\" << (std::wint_t)c << \") = \"\n              << (bool)std::iswgraph(c) << '\\n';\n}",
            "output": "in the default locale, iswgraph(0x2602) = false\nin Unicode locale, iswgraph(0x2602) = true"
        }
    },
    "iswspace": {
        "description": {
            "texte": "Checks if the given wide character is a wide whitespace character as classified by the currently installed C locale. In the default locale, the whitespace characters are the following:If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined."
        },
        "parametres": "   ch   -   wide character \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <clocale>\n#include <cwctype>\nvoid try_with(wchar_t c, const char* loc)\n{\n    std::setlocale(LC_ALL, loc);\n    std::wcout << \"isspace('\" << c << \"') in \" << loc << \" locale returned \"\n               << std::boolalpha << (bool)std::iswspace(c) << '\\n';\n}\nint main()\n{\n    wchar_t EM_SPACE = L'\\u2003'; // Unicode character 'EM SPACE'\n    try_with(EM_SPACE, \"C\");\n    try_with(EM_SPACE, \"en_US.UTF8\");\n}",
            "output": "isspace(' ') in C locale returned false\nisspace(' ') in en_US.UTF8 locale returned true"
        }
    },
    "iswblank": {
        "description": {
            "texte": "Checks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale. In the default C locale, only space (0x20) and horizontal tab (0x09) are blank characters.If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined."
        },
        "parametres": "   ch   -   wide character \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\\u3000'; // Ideographic space ('\u3000')\n \n    std::cout << std::hex << std::showbase << std::boolalpha;\n    std::cout << \"in the default locale, iswblank(\" << (std::wint_t)c << \") = \"\n              << (bool)std::iswblank(c) << '\\n';\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::cout << \"in Unicode locale, iswblank(\" << (std::wint_t)c << \") = \"\n              << (bool)std::iswblank(c) << '\\n';\n}",
            "output": "in the default locale, iswblank(0x3000) = false\nin Unicode locale, iswblank(0x3000) = true"
        }
    },
    "iswprint": {
        "description": {
            "texte": "Checks if the given wide character can be printed, i.e. it is either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz), a punctuation character(!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~), space or any printable character specific to the current C locale.If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined."
        },
        "parametres": "   ch   -   wide character \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\\u2002'; // en-space\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::cout << std::boolalpha << std::hex << std::showbase\n              << \"in Unicode locale,\\n\"\n              << \"iswprint('\" << c << \"') = \"\n              << (bool)std::iswprint(c) << '\\n';\n \n    c = L'\\u0082'; // break permitted\n    std::cout << \"iswprint('\" << c << \"') = \"\n              << (bool)std::iswprint(c) << '\\n';\n}",
            "output": "in Unicode locale,\niswprint('0x2002') = true\niswprint('0x82') = false"
        }
    },
    "iswpunct": {
        "description": {
            "texte": "Checks if the given wide character is a punctuation character, i.e. it is one of !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ or any punctuation character specific to the current locale.If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined."
        },
        "parametres": "   ch   -   wide character \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\\u2051'; // Two asterisks ('\u2051')\n \n    std::cout << std::hex << std::showbase << std::boolalpha;\n    std::cout << \"in the default locale, iswpunct(\" << (std::wint_t)c << \") = \"\n              << (bool)std::iswpunct(c) << '\\n';\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::cout << \"in Unicode locale, iswpunct(\" << (std::wint_t)c << \") = \"\n              << (bool)std::iswpunct(c) << '\\n';\n}",
            "output": "in the default locale, iswpunct(0x2051) = false\nin Unicode locale, iswpunct(0x2051) = true"
        }
    },
    "iswctype": {
        "description": {
            "texte": "Classifies the wide character wc using the current C locale's LC_CTYPE category identified by desc.If the value of wc is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined."
        },
        "parametres": "   wc   -   the wide character to classify \n   desc   -   the LC_CTYPE category, obtained from a call to std::wctype \n\n",
        "exemple": {
            "input": "#include <clocale>\n#include <cwctype>\n#include <iostream>\nbool classify(wchar_t wc, const std::string& cat)\n{\n    return std::iswctype(wc, std::wctype(cat.c_str()));\n}\nint main()\n{\n    std::setlocale(LC_ALL, \"ja_JP.UTF-8\");\n    std::cout << \"The character \\u6c34 is...\\n\";\n    for(std::string s : {\"digit\", \"alpha\", \"space\", \"cntrl\", \"jkanji\"})\n        std::cout << s << \"? \" << std::boolalpha << classify(L'\\u6c34', s) << '\\n';\n}",
            "output": "The character \u6c34 is...\ndigit? false\nalpha? true\nspace? false\ncntrl? false\njkanji? true"
        }
    },
    "wctype": {
        "description": {
            "texte": "Constructs a value of type std::wctype_t that describes a LC_CTYPE category of wide character classification. It may be one of the standard classification categories, or a locale-specific category, such as \"jkanji\"."
        },
        "parametres": "   str   -   C string holding the name of the desired category \n\n"
    },
    "towlower": {
        "description": {
            "texte": "Converts the given wide character to lowercase, if possible.If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined."
        },
        "parametres": "   ch   -   wide character to be converted \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\\u0190'; // Latin capital open E ('\u0190')\n \n    std::cout << std::hex << std::showbase;\n    std::cout << \"in the default locale, towlower(\" << (std::wint_t)c << \") = \"\n              << std::towlower(c) << '\\n';\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::cout << \"in Unicode locale, towlower(\" << (std::wint_t)c << \") = \"\n              << std::towlower(c) << '\\n';\n}",
            "output": "in the default locale, towlower(0x190) = 0x190\nin Unicode locale, towlower(0x190) = 0x25b"
        }
    },
    "towupper": {
        "description": {
            "texte": "Converts the given wide character to uppercase, if possible.If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined."
        },
        "parametres": "   ch   -   wide character to be converted \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwctype>\n#include <clocale>\n \nint main()\n{\n    wchar_t c = L'\\u017f'; // Latin small letter Long S ('\u017f')\n \n    std::cout << std::hex << std::showbase;\n    std::cout << \"in the default locale, towupper(\" << (std::wint_t)c << \") = \"\n              << std::towupper(c) << '\\n';\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::cout << \"in Unicode locale, towupper(\" << (std::wint_t)c << \") = \"\n              << std::towupper(c) << '\\n';\n}",
            "output": "in the default locale, towupper(0x17f) = 0x17f\nin Unicode locale, towupper(0x17f) = 0x53"
        }
    },
    "towctrans": {
        "description": {
            "texte": "Maps the wide character wc using the current C locale's LC_CTYPE mapping category identified by desc.If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined."
        },
        "parametres": "   ch   -   the wide character to map \n   desc   -   the LC_CTYPE mapping, obtained from a call to std::wctrans \n\n",
        "exemple": {
            "input": "#include <clocale>\n#include <cwctype>\n#include <iostream>\n#include <algorithm>\n \nstd::wstring tohira(std::wstring str)\n{\n    std::transform(str.begin(), str.end(), str.begin(), [](wchar_t c) {\n         return std::towctrans(c, std::wctrans(\"tojhira\"));\n    });\n    return str;\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, \"ja_JP.UTF-8\");\n    std::wstring kana = L\"\u30d2\u30e9\u30ac\u30ca\";\n    std::wcout << \"katakana characters \" << kana\n               << \" are \" << tohira(kana) << \" in hiragana\\n\";\n}",
            "output": "katakana characters \u30d2\u30e9\u30ac\u30ca are \u3072\u3089\u304c\u306a in hiragana"
        }
    },
    "wctrans": {
        "description": {
            "texte": "Constructs a value of type std::wctrans_t that describes a LC_CTYPE category of wide character mapping. It may be one of the standard mappings, or a locale-specific mapping, such as \"tojhira\" or \"tojkana\"."
        },
        "parametres": "   str   -   C string holding the name of the desired mapping. The following values of str are supported in all C locales:\n   Value of str   Effect \n   \"toupper\"   identifies the mapping used by towupper \n   \"tolower\"   identifies the mapping used by towlower \n  \n\n"
    },
    "mbstate_t": {
        "description": {
            "texte": "The type mbstate_t is a trivial non-array type that can represent any of the conversion states that can occur in an implementation-defined set of supported multibyte character encoding rules. Zero-initialized value of mbstate_t represents the initial conversion state, although other values of mbstate_t may exist that also represent the initial conversion state.Possible implementation of mbstate_t is a struct type holding an array representing the incomplete multibyte character, an integer counter indicating the number of bytes in the array that have been processed, and a representation of the current shift state.The following functions should not be called from multiple threads without synchronization with the std::mbstate_t* argument of NULL due to possible data races: std::mbrlen, std::mbrtowc, std::mbsrtowcs, std::mbtowc, std::wcrtomb, std::wcsrtombs, std::wctomb."
        }
    },
    "wcscpy": {
        "description": {
            "texte": "Copies the wide string pointed to by src (including the terminating null wide character) to wide character array pointed to by dest.If the strings overlap, the behavior is undefined."
        },
        "parametres": "   dest   -   pointer to the wide character array to copy to \n   src   -   pointer to the null-terminated wide string to copy from \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwchar>\n#include <memory>\n#include <clocale>\n \nint main()\n{\n    const wchar_t* src = L\"\u72ac means dog\";\n//  src[0] = L'\u72d7'; // can't modify string literal\n    auto dst = std::make_unique<wchar_t[]>(std::wcslen(src)+1); // +1 for the null\n    std::wcscpy(dst.get(), src);\n    dst[0] = L'\u72d7';\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::wcout.imbue(std::locale(\"\"));\n    std::wcout << src << '\\n' << dst.get() << '\\n';\n}",
            "output": "\u72ac means dog\n\u72d7 means dog"
        }
    },
    "wcsncpy": {
        "description": {
            "texte": "Copies at most count characters of the wide string pointed to by src (including the terminating null wide character) to wide character array pointed to by dest.If count is reached before the entire string src was copied, the resulting wide character array is not null-terminated.If, after copying the terminating null wide character from src, count is not reached, additional null wide characters are written to dest until the total of count characters have been written.If the strings overlap, the behavior is undefined."
        },
        "parametres": "   dest   -   pointer to the wide character array to copy to \n   src   -   pointer to the wide string to copy from \n   count   -   maximum number of wide characters to copy \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwchar>\n \nint main()\n{\n    wchar_t src[] = L\"hi\";\n    wchar_t dest[6] = {L'a', L'b', L'c', L'd', L'e', L'f'};\n \n    std::wcsncpy(dest, src, 5); // this will copy hi and repeat \\0 three times\n \n    std::wcout << \"The contents of dest are: \";\n    for(wchar_t c : dest) {\n        if(c)\n            std::wcout << c << ' ';\n        else\n            std::wcout << \"\\\\0\" << ' ';\n    }\n    std::wcout << '\\n';\n}",
            "output": "The contents of dest are: h i \\0 \\0 \\0 f"
        }
    },
    "wcscat": {
        "description": {
            "texte": "Appends a copy of the wide string pointed to by src to the end of the wide string pointed to by dest. The wide character src[0] replaces the null terminator at the end of dest. The resulting wide string is null-terminated.The behavior is undefined if the destination array is not large enough for the contents of both str and dest and the terminating null wide character.The behavior is undefined if the strings overlap."
        },
        "parametres": "   dest   -   pointer to the null-terminated wide string to append to \n   src   -   pointer to the null-terminated wide string to copy from \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwchar> \n#include <clocale>\n \nint main(void) \n{\n    wchar_t str[50] = L\"\u0417\u0435\u043c\u043b\u044f, \u043f\u0440\u043e\u0449\u0430\u0439.\";\n    std::wcscat(str, L\" \");\n    std::wcscat(str, L\"\u0412 \u0434\u043e\u0431\u0440\u044b\u0439 \u043f\u0443\u0442\u044c.\");\n \n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::wcout.imbue(std::locale(\"en_US.utf8\"));\n    std::wcout << str << '\\n';\n}",
            "output": "\u0417\u0435\u043c\u043b\u044f, \u043f\u0440\u043e\u0449\u0430\u0439. \u0412 \u0434\u043e\u0431\u0440\u044b\u0439 \u043f\u0443\u0442\u044c."
        }
    },
    "wcsncat": {
        "description": {
            "texte": "Appends at most count wide characters from the wide string pointed to by src to the end of the character string pointed to by dest, stopping if the null terminator is copied. The wide character src[0] replaces the null terminator at the end of dest. The null terminator is always appended in the end (so the maximum number of wide characters the function may write is count+1).The behavior is undefined if the destination array is not large enough for the contents of both str and dest and the terminating null wide character.The behavior is undefined if the strings overlap."
        },
        "parametres": "   dest   -   pointer to the null-terminated wide string to append to \n   src   -   pointer to the null-terminated wide string to copy from \n   count   -   maximum number of wide characters to copy \n\n",
        "exemple": {
            "input": "#include <cwchar> \n#include <iostream>\n#include <clocale>\n \nint main(void) \n{\n    wchar_t str[50] = L\"\u0417\u0435\u043c\u043b\u044f, \u043f\u0440\u043e\u0449\u0430\u0439.\";\n    std::wcsncat(str, L\" \", 1);\n    std::wcsncat(str, L\"\u0412 \u0434\u043e\u0431\u0440\u044b\u0439 \u043f\u0443\u0442\u044c.\", 8); // only append the first 8 wide chars\n \n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::wcout.imbue(std::locale(\"en_US.utf8\"));\n    std::wcout << str << '\\n';\n}",
            "output": "\u0417\u0435\u043c\u043b\u044f, \u043f\u0440\u043e\u0449\u0430\u0439. \u0412 \u0434\u043e\u0431\u0440\u044b\u0439"
        }
    },
    "wcsxfrm": {
        "description": {
            "texte": "Transforms the null-terminated wide string pointed to by src into the implementation-defined form such that comparing two transformed strings with std::wcscmp gives the same result as comparing the original strings with std::wcscoll, in the current C locale.The first count characters of the transformed string are written to destination, including the terminating null character, and the length of the full transformed string is returned, excluding the terminating null character.If count is \u200b0\u200b, then dest is allowed to be a null pointer."
        },
        "parametres": "   dest   -   pointer to the first element of a wide null-terminated string to write the transformed string to \n   src   -   pointer to the null-terminated wide character string to transform \n   count   -   maximum number of characters to output \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwchar>\n \nint main()\n{\n    std::setlocale(LC_ALL, \"sv_SE.utf8\");\n \n    std::wstring in1 = L\"\\u00e5r\";\n    std::wstring out1(1+std::wcsxfrm(nullptr, in1.c_str(), 0), L' ');\n    std::wstring in2 = L\"\\u00e4ngel\";\n    std::wstring out2(1+std::wcsxfrm(nullptr, in2.c_str(), 0), L' ');\n \n    std::wcsxfrm(&out1[0], in1.c_str(), out1.size());\n    std::wcsxfrm(&out2[0], in2.c_str(), out2.size());\n \n    std::wcout << \"In the Swedish locale: \";\n    if(out1 < out2)\n         std::wcout << in1 << \" before \" << in2 << '\\n';\n    else\n         std::wcout << in2 << \" before \" << in1 << '\\n';\n \n    std::wcout << \"In lexicographical comparison: \";\n    if(in1 < in2)\n         std::wcout << in1 << \" before \" << in2 << '\\n';\n    else\n         std::wcout << in2 << \" before \" << in1 << '\\n';\n \n}",
            "output": "In the Swedish locale: \u00e5r before \u00e4ngel\nIn lexicographical comparison: \u00e4ngel before \u00e5r"
        }
    },
    "wcslen": {
        "description": {
            "texte": "Returns the length of a wide string, that is the number of non-null wide characters that precede the terminating null wide character.The behavior is undefined if there is no null character in the wide character array pointed to by str."
        },
        "parametres": "   str   -   pointer to the null-terminated wide string to be examined \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwchar>\n#include <clocale>\n \nint main()\n{\n    const wchar_t* str = L\"\u7206\u305c\u308d\u30ea\u30a2\u30eb\uff01\u5f3e\u3051\u308d\u30b7\u30ca\u30d7\u30b9\uff01\u30d1\u30cb\u30c3\u30b7\u30e5\u30e1\u30f3\u30c8\u30c7\u30a3\u30b9\u3001\u30ef\u30fc\u30eb\u30c9\uff01\";\n \n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::wcout.imbue(std::locale(\"en_US.utf8\"));\n    std::wcout << \"The length of \\\"\" << str << \"\\\" is \" << std::wcslen(str) << '\\n';\n}",
            "output": "The length of \"\u7206\u305c\u308d\u30ea\u30a2\u30eb\uff01\u5f3e\u3051\u308d\u30b7\u30ca\u30d7\u30b9\uff01\u30d1\u30cb\u30c3\u30b7\u30e5\u30e1\u30f3\u30c8\u30c7\u30a3\u30b9\u3001\u30ef\u30fc\u30eb\u30c9\uff01\" is 32"
        }
    },
    "wcscmp": {
        "description": {
            "texte": "Compares two null-terminated wide strings lexicographically.The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.The behavior is undefined if lhs or rhs are not pointers to null-terminated wide strings."
        },
        "parametres": "   lhs, rhs   -   pointers to the null-terminated wide strings to compare \n\n",
        "exemple": {
            "input": "#include <vector>\n#include <cwchar>\n#include <algorithm>\n#include <iostream>\n \nint main()\n{\n    std::vector<const wchar_t*> leaders{L\"\u041b\u0435\u043d\u0438\u043d\", L\"\u0421\u0442\u0430\u043b\u0438\u043d\", L\"\u041c\u0430\u043b\u0435\u043d\u043a\u043e\u0432\",\n        L\"\u0425\u0440\u0443\u0449\u0451\u0432\", L\"\u0411\u0440\u0435\u0436\u043d\u0435\u0432\", L\"\u0410\u043d\u0434\u0440\u043e\u043f\u043e\u0432\", L\"\u0427\u0435\u0440\u043d\u0435\u043d\u043a\u043e\", L\"\u0413\u043e\u0440\u0431\u0430\u0447\u0451\u0432\"};\n \n    std::sort(leaders.begin(), leaders.end(), [](auto strA, auto strB) {\n        return std::wcscmp(strA, strB) < 0;\n    });\n \n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::wcout.imbue(std::locale(\"en_US.utf8\"));\n    for (auto leader : leaders)\n        std::wcout << leader << '\\n';\n}",
            "output": "\u0410\u043d\u0434\u0440\u043e\u043f\u043e\u0432\n\u0411\u0440\u0435\u0436\u043d\u0435\u0432\n\u0413\u043e\u0440\u0431\u0430\u0447\u0451\u0432\n\u041b\u0435\u043d\u0438\u043d\n\u041c\u0430\u043b\u0435\u043d\u043a\u043e\u0432\n\u0421\u0442\u0430\u043b\u0438\u043d\n\u0425\u0440\u0443\u0449\u0451\u0432\n\u0427\u0435\u0440\u043d\u0435\u043d\u043a\u043e"
        }
    },
    "wcsncmp": {
        "description": {
            "texte": "Compares at most count wide characters of two null-terminated wide strings. The comparison is done lexicographically.The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.The behavior is undefined if lhs or rhs are not pointers to null-terminated strings."
        },
        "parametres": "   lhs, rhs   -   pointers to the null-terminated wide strings to compare \n   count   -   maximum number of characters to compare \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwchar>\n#include <clocale>\n#include <locale>\n \nvoid demo(const wchar_t* lhs, const wchar_t* rhs, int sz)\n{\n    int rc = std::wcsncmp(lhs, rhs, sz);\n    if(rc == 0)\n        std::wcout << \"First \" << sz << \" characters of [\"\n                  << lhs << \"] equal [\" << rhs << \"]\\n\";\n    else if(rc < 0)\n        std::wcout << \"First \" << sz << \" characters of [\"\n                  << lhs << \"] precede [\" << rhs << \"]\\n\";\n    else if(rc > 0)\n        std::wcout << \"First \" << sz << \" characters of [\"\n                  << lhs << \"] follow [\" << rhs << \"]\\n\";\n}\n \nint main()\n{\n    const wchar_t str1[] = L\"\uc548\ub155\ud558\uc138\uc694\";\n    const wchar_t str2[] = L\"\uc548\ub155\ud788 \uac00\uc2ed\uc2dc\uc624\";\n \n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::wcout.imbue(std::locale(\"en_US.utf8\"));\n    demo(str1, str2, 5);\n    demo(str2, str1, 8);\n    demo(str1, str2, 2);\n}",
            "output": "First 5 characters of [\uc548\ub155\ud558\uc138\uc694] precede [\uc548\ub155\ud788 \uac00\uc2ed\uc2dc\uc624]\nFirst 8 characters of [\uc548\ub155\ud788 \uac00\uc2ed\uc2dc\uc624] follow [\uc548\ub155\ud558\uc138\uc694]\nFirst 2 characters of [\uc548\ub155\ud558\uc138\uc694] equal [\uc548\ub155\ud788 \uac00\uc2ed\uc2dc\uc624]"
        }
    },
    "wcscoll": {
        "description": {
            "texte": "Compares two null-terminated wide strings according to the locale most recently installed by std::setlocale, as defined by the LC_COLLATE category."
        },
        "parametres": "   lhs, rhs   -   pointers to the null-terminated wide strings to compare \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <clocale>\n \nvoid try_compare(const wchar_t* p1, const wchar_t* p2)\n{\n    if(std::wcscoll(p1, p2) < 0)\n         std::wcout << p1 << \" before \" << p2 << '\\n';\n    else\n         std::wcout << p2 << \" before \" << p1 << '\\n';\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::wcout << \"In the American locale: \";\n    try_compare(L\"hrnec\", L\"chrt\");\n \n    std::setlocale(LC_COLLATE, \"cs_CZ.utf8\");\n    std::wcout << \"In the Czech locale: \";\n    try_compare(L\"hrnec\", L\"chrt\");\n \n    std::setlocale(LC_COLLATE, \"en_US.utf8\");\n    std::wcout << \"In the American locale: \";\n    try_compare(L\"\u00e5r\", L\"\u00e4ngel\");\n \n    std::setlocale(LC_COLLATE, \"sv_SE.utf8\");\n    std::wcout << \"In the Swedish locale: \";\n    try_compare(L\"\u00e5r\", L\"\u00e4ngel\");\n}",
            "output": "In the American locale: chrt before hrnec\nIn the Czech locale: hrnec before chrt\nIn the American locale: \u00e4ngel before \u00e5r\nIn the Swedish locale: \u00e5r before \u00e4ngel"
        }
    },
    "wcschr": {
        "description": {
            "texte": "Finds the first occurrence of the wide character ch in the wide string pointed to by str."
        },
        "parametres": "   str   -   pointer to the null-terminated wide string to be analyzed \n   ch   -   wide character to search for \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwchar>\n#include <locale>\n \nint main()\n{\n    wchar_t arr[] = L\"\u62db\u304d\u732b \u043a\u043e\u0448\u043a\u0430\";\n    const wchar_t* cat = std::wcschr(arr, L'\u732b');\n    const wchar_t* dog = std::wcschr(arr, L'\u72ac');\n \n    std::cout.imbue(std::locale(\"en_US.utf8\"));\n \n    if(cat)\n        std::cout << \"The character \u732b found at position \" << cat - arr << '\\n';\n    else\n        std::cout << \"The character \u732b not found\\n\";\n \n    if(dog)\n        std::cout << \"The character \u72ac found at position \" << dog - arr << '\\n';\n    else\n        std::cout << \"The character \u72ac not found\\n\";\n}",
            "output": "The character \u732b found at position 2\nThe character \u72ac not found"
        }
    },
    "wcsrchr": {
        "description": {
            "texte": "Finds the last occurrence of the wide character ch in the wide string pointed to by str."
        },
        "parametres": "   str   -   pointer to the null-terminated wide string to be analyzed \n   ch   -   wide character to search for \n\n"
    },
    "wcsspn": {
        "description": {
            "texte": "Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters found in wide string pointed to by src."
        },
        "parametres": "   dest   -   pointer to the null-terminated wide string to be analyzed \n   src   -   pointer to the null-terminated wide string that contains the characters to search for \n\n"
    },
    "wcscspn": {
        "description": {
            "texte": "Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters not found in wide string pointed to by src."
        },
        "parametres": "   dest   -   pointer to the null-terminated wide string to be analyzed \n   src   -   pointer to the null-terminated wide string that contains the characters to search for \n\n"
    },
    "wcspbrk": {
        "description": {
            "texte": "Finds the first character in wide string pointed to by dest, that is also in wide string pointed to by str."
        },
        "parametres": "   dest   -   pointer to the null-terminated wide string to be analyzed \n   src   -   pointer to the null-terminated wide string that contains the characters to search for \n\n"
    },
    "wcsstr": {
        "description": {
            "texte": "Finds the first occurrence of the wide string src in the wide string pointed to by dest. The terminating null characters are not compared."
        },
        "parametres": "   dest   -   pointer to the null-terminated wide string to examine \n   src   -   pointer to the null-terminated wide string to search for \n\n"
    },
    "wcstok": {
        "description": {
            "texte": "Finds the next token in a null-terminated wide string pointed to by str. The separator characters are identified by null-terminated wide string pointed to by delim."
        },
        "parametres": "   str   -   pointer to the null-terminated wide string to tokenize \n   delim   -   pointer to the null-terminated wide string identifying delimiters \n   ptr   -   pointer to an object of type wchar_t*, which is used by wcstok to store its internal state \n\n",
        "exemple": {
            "input": "#include <cwchar>\n#include <iostream>\n \nint main()\n{\n    wchar_t input[100] = L\"A bird came down the walk\";\n    wchar_t* buffer;\n    wchar_t* token = std::wcstok(input, L\" \", &buffer);\n    while (token) {\n        std::wcout << token << '\\n';\n        token = std::wcstok(nullptr, L\" \", &buffer);\n    }\n}",
            "output": "A\nbird\ncame\ndown\nthe\nwalk"
        }
    },
    "wmemcpy": {
        "description": {
            "texte": "Copies exactly count successive wide characters from the wide character array pointed to by src to the wide character array pointed to by dest. If the objects overlap, the behavior is undefined. If count is zero, the function does nothing."
        },
        "parametres": "   dest   -   pointer to the wide character array to copy to \n   src   -   pointer to the wide character array to copy from \n   count   -   number of wide characters to copy \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwchar>\n#include <clocale>\n#include <locale>\n \nint main(void)\n{\n    wchar_t from1[] = L\"\u0928\u092e\u0938\u094d\u0924\u0947\";\n    const size_t sz1 = sizeof from1 / sizeof *from1;\n    wchar_t from2[] = L\"\u0532\u0561\u0580\u0587\";\n    const size_t sz2 = sizeof from2 / sizeof *from2;\n    wchar_t to[sz1 + sz2];\n \n    std::wmemcpy(to, from1, sz1); // copy from1, along with its null terminator\n    std::wmemcpy(to + sz1, from2, sz2); // append from2, along with its null terminator\n \n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::cout.imbue(std::locale(\"en_US.utf8\"));\n    std::wcout << \"Wide array contains: \";\n    for(size_t n = 0; n < sizeof to / sizeof *to; ++n)\n        if(to[n])\n            std::wcout << to[n];\n        else\n            std::wcout << \"\\\\0\";\n    std::wcout << '\\n';\n}",
            "output": "Wide array contains: \u0928\u092e\u0938\u094d\u0924\u0947\\0\u0532\u0561\u0580\u0587\\0"
        }
    },
    "wmemmove": {
        "description": {
            "texte": "Copies exactly count successive wide characters from the wide character array pointed to by src to the wide character array pointed to by dest.If count is zero, the function does nothing.The arrays may overlap: copying takes place as if the wide characters were copied to a temporary wide character array and then copied from the temporary array to dest."
        },
        "parametres": "   dest   -   pointer to the wide character array to copy to \n   src   -   pointer to the wide character array to copy from \n   count   -   number of wide characters to copy \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwchar>\n#include <locale>\n#include <clocale>\n \nint main()\n{\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::wcout.imbue(std::locale(\"en_US.utf8\"));\n \n    wchar_t str[] = L\"\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\";\n    std::wcout << str << '\\n';\n    std::wmemmove(str+4, str+3, 3); // copy from [\u03b4\u03b5\u03b6] to [\u03b5\u03b6\u03b7]\n    std::wcout << str << '\\n';\n}",
            "output": "\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\n\u03b1\u03b2\u03b3\u03b4\u03b4\u03b5\u03b6\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9"
        }
    },
    "wmemcmp": {
        "description": {
            "texte": "Compares the first count wide characters of the wide character arrays pointed to by lhs and rhs. The comparison is done lexicographically.The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the arrays being compared.If count is zero, the function does nothing."
        },
        "parametres": "   lhs, rhs   -   pointers to the wide character arrays to compare \n   count   -   number of wide characters to examine \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <cwchar>\n#include <locale>\n#include <clocale>\n \nvoid demo(const wchar_t* lhs, const wchar_t* rhs, std::size_t sz)\n{\n    std::wcout << std::wstring(lhs, sz);\n    int rc = std::wmemcmp(lhs, rhs, sz);\n    if(rc == 0)\n        std::wcout << \" compares equal to \";\n    else if(rc < 0)\n        std::wcout << \" precedes \";\n    else if(rc > 0)\n        std::wcout << \" follows \";\n    std::wcout << std::wstring(rhs, sz) << \" in lexicographical order\\n\";\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::wcout.imbue(std::locale(\"en_US.utf8\"));\n \n    wchar_t a1[] = {L'\u03b1',L'\u03b2',L'\u03b3'};\n    constexpr std::size_t sz = sizeof a1 / sizeof *a1;\n    wchar_t a2[sz] = {L'\u03b1',L'\u03b2',L'\u03b4'};\n \n    demo(a1, a2, sz);\n    demo(a2, a1, sz);\n    demo(a1, a1, sz);\n}",
            "output": "\u03b1\u03b2\u03b3 precedes \u03b1\u03b2\u03b4 in lexicographical order\n\u03b1\u03b2\u03b4 follows \u03b1\u03b2\u03b3 in lexicographical order\n\u03b1\u03b2\u03b3 compares equal to \u03b1\u03b2\u03b3 in lexicographical order"
        }
    },
    "wmemchr": {
        "description": {
            "texte": "Locates the first occurrence of wide character ch in the initial count wide characters of the wide character array pointed to by ptr.If count is zero, the function returns a null pointer."
        },
        "parametres": "   ptr   -   pointer to the wide character array to be examined \n   ch   -   wide character to search for \n   count   -   number of wide characters to examine \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwchar>\n#include <clocale>\n#include <locale>\n \nint main()\n{\n    const wchar_t str[] = L\"\u8bfa\u4e0d\u8f7b\u4fe1\uff0c\u6545\u4eba\u4e0d\u8d1f\u6211\\0\u8bfa\u4e0d\u8f7b\u8bb8\uff0c\u6545\u6211\u4e0d\u8d1f\u4eba\u3002\";\n    wchar_t target = L'\u8bb8';\n    const std::size_t sz = sizeof str / sizeof *str;\n    if (const wchar_t* result = std::wmemchr(str, target, sz)) {\n        std::setlocale(LC_ALL, \"en_US.utf8\");\n        std::wcout.imbue(std::locale(\"en_US.utf8\"));\n        std::wcout << \"Found '\" << target\n                   << \"' at position \" << result - str << \"\\n\";\n    }\n}",
            "output": "Found '\u8bb8' at position 14"
        }
    },
    "wmemset": {
        "description": {
            "texte": "Copies the wide character ch into each of the first count wide characters of the wide character array pointed to by dest.If overflow occurs, the behavior is undefined.If count is zero, the function does nothing."
        },
        "parametres": "   dest   -   pointer to the wide character array to fill \n   ch   -   fill wide character \n   count   -   number of wide characters to fill \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwchar>\n#include <clocale>\n#include <locale>\n \nint main()\n{\n    wchar_t ar[4] = {L'1', L'2', L'3', L'4'};\n    std::wmemset(ar, L'\\U0001f34c', 2); // replaces [12] with the \ud83c\udf4c bananas\n    std::wmemset(ar+2, L'\u8549', 2); // replaces [34] with the \u8549 bananas\n \n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::wcout.imbue(std::locale(\"en_US.utf8\"));\n    std::wcout << std::wstring(ar, 4) << '\\n';\n}",
            "output": "\ud83c\udf4c\ud83c\udf4c\u8549\u8549"
        }
    },
    "mbsinit": {
        "description": {
            "texte": "If ps is not a null pointer, the mbsinit function determines whether the pointed-to std::mbstate_t object describes the initial conversion state."
        },
        "parametres": "   ps   -   pointer to the std::mbstate_t object to examine \n\n",
        "exemple": {
            "input": "#include <clocale>\n#include <string>\n#include <iostream>\n#include <cwchar>\n \nint main()\n{\n    // allow mbrlen() to work with UTF-8 multibyte encoding\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    // UTF-8 narrow multibyte encoding\n    std::string str = u8\"\u6c34\"; // or u8\"\\u6c34\" or \"\\xe6\\xb0\\xb4\"\n    std::mbstate_t mb = std::mbstate_t();\n    (void)std::mbrlen(&str[0], 1, &mb);\n    if (!std::mbsinit(&mb)) {\n        std::cout << \"After processing the first 1 byte of \" << str\n                  << \" the conversion state is not initial\\n\";\n    }\n \n    (void)std::mbrlen(&str[1], str.size()-1, &mb);\n    if (std::mbsinit(&mb)) {\n        std::cout << \"After processing the remaining 2 bytes of \" << str\n                  << \", the conversion state is initial conversion state\\n\";\n    }\n}",
            "output": "After processing the first 1 byte of \u6c34 the conversion state is not initial\nAfter processing the remaining 2 bytes of \u6c34, the conversion state is initial conversion state"
        }
    },
    "btowc": {
        "description": {
            "texte": "Widens a single-byte character c to its wide character equivalent.Most multibyte character encodings use single-byte codes to represent the characters from the ASCII character set. This function may be used to convert such characters to wchar_t."
        },
        "parametres": "   c   -   single-byte character to widen \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cwchar>\n#include <clocale>\n \nvoid try_widen(char c)\n{\n    std::wint_t w = std::btowc(c);\n    if(w != WEOF)\n        std::cout << \"The single-byte character \" << +(unsigned char)c\n                  << \" widens to \" << +w << '\\n';\n    else\n        std::cout << \"The single-byte character \" << +(unsigned char)c\n                  << \" failed to widen\\n\";\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, \"lt_LT.iso88594\");\n    std::cout << std::hex << std::showbase << \"In Lithuanian ISO-8859-4 locale:\\n\";\n    try_widen('A');\n    try_widen('\\xdf'); // German letter \u00df (U+00df) in ISO-8859-4\n    try_widen('\\xf9'); // Lithuanian letter \u0173 (U+0173) in ISO-8859-4\n \n    std::setlocale(LC_ALL, \"lt_LT.utf8\");\n    std::cout << \"In Lithuanian UTF-8 locale:\\n\";\n    try_widen('A');\n    try_widen('\\xdf');\n    try_widen('\\xf9');\n}",
            "output": "In Lithuanian ISO-8859-4 locale:\nThe single-byte character 0x41 widens to 0x41\nThe single-byte character 0xdf widens to 0xdf\nThe single-byte character 0xf9 widens to 0x173\nIn Lithuanian UTF-8 locale:\nThe single-byte character 0x41 widens to 0x41\nThe single-byte character 0xdf failed to widen\nThe single-byte character 0xf9 failed to widen"
        }
    },
    "wctob": {
        "description": {
            "texte": "Narrows a wide character c if its multibyte character equivalent in the initial shift state is a single byte.This is typically possible for the characters from the ASCII character set, since most multibyte encodings (such as UTF-8) use single bytes to encode those characters."
        },
        "parametres": "   c   -   wide character to narrow \n\n",
        "exemple": {
            "input": "#include <clocale>\n#include <cwchar>\n#include <iostream>\n \nvoid try_narrowing(wchar_t c)\n{\n    int cn = std::wctob(c);\n    if(cn != EOF)\n        std::cout << '\\'' << c << \"' narrowed to \" << +cn << '\\n';\n    else\n        std::cout << '\\'' << c << \"' could not be narrowed\\n\";\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, \"th_TH.utf8\");\n    std::cout << std::hex << std::showbase << \"In Thai UTF-8 locale:\\n\";\n    try_narrowing(L'a');\n    try_narrowing(L'\u0e5b');\n \n    std::setlocale(LC_ALL, \"th_TH.tis620\");\n    std::cout << \"In Thai TIS-620 locale:\\n\";\n    try_narrowing(L'a');\n    try_narrowing(L'\u0e5b');\n}",
            "output": "In Thai UTF-8 locale:\n'0x61' narrowed to 0x61\n'0xe5b' could not be narrowed\nIn Thai TIS-620 locale:\n'0x61' narrowed to 0x61\n'0xe5b' narrowed to 0xfb"
        }
    },
    "mbrlen": {
        "description": {
            "texte": "Determines the size, in bytes, of the remainder of the multibyte character whose first byte is pointed to by s, given the current conversion state ps.This function is equivalent to the call std::mbrtowc(nullptr, s, n, ps?ps:&internal) for some hidden object internal of type std::mbstate_t, except that the expression ps is evaluated only once."
        },
        "parametres": "   s   -   pointer to an element of a multibyte character string \n   n   -   limit on the number of bytes in s that can be examined \n   ps   -   pointer to the variable holding the conversion state \n\n",
        "exemple": {
            "input": "#include <clocale>\n#include <string>\n#include <iostream>\n#include <cwchar>\n \nint main()\n{\n    // allow mbrlen() to work with UTF-8 multibyte encoding\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    // UTF-8 narrow multibyte encoding\n    std::string str = u8\"\u6c34\"; // or u8\"\\u6c34\" or \"\\xe6\\xb0\\xb4\"\n    std::mbstate_t mb = std::mbstate_t();\n    int len1 = std::mbrlen(&str[0], 1, &mb);\n    if(len1 == -2) {\n        std::cout << \"The first 1 byte of \" << str\n                  << \" is an incomplete multibyte char (mbrlen returns -2)\\n\";\n    }\n    int len2 = std::mbrlen(&str[1], str.size()-1, &mb);\n    std::cout << \"The remaining \" << str.size()-1 << \" bytes of \" << str\n              << \" hold \" << len2 << \" bytes of the multibyte character\\n\";\n    std::cout << \"Attempting to call mbrlen() in the middle of \" << str\n              << \" while in initial shift state returns \"\n              << (int)mbrlen(&str[1], str.size(), &mb) << '\\n';\n \n}",
            "output": "The first 1 byte of \u6c34 is an incomplete multibyte char (mbrlen returns -2)\nThe remaining 2 bytes of \u6c34 hold 2 bytes of the multibyte character\nAttempting to call mbrlen() in the middle of \u6c34 while in initial shift state returns -1"
        }
    },
    "mbrtowc": {
        "description": {
            "texte": "Converts a narrow multibyte character to a wide character.If s is not a null pointer, inspects at most n bytes of the multibyte character string, beginning with the byte pointed to by s to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in s is complete and valid, converts it to the corresponding wide character and stores it in *pwc (if pwc is not null).If s is a null pointer, the values of n and pwc are ignored and call is equivalent to std::mbrtowc(NULL, \"\", 1, ps).If the wide character produced is the null character, the conversion state stored in *ps is the initial shift state."
        },
        "parametres": "   pwc   -   pointer to the location where the resulting wide character will be written \n   s   -   pointer to the multibyte character string used as input \n   n   -   limit on the number of bytes in s that can be examined \n   ps   -   pointer to the conversion state used when interpreting the multibyte string \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <clocale>\n#include <cstring>\n#include <cwchar>\n \nvoid print_mb(const char* ptr)\n{\n    std::mbstate_t state = std::mbstate_t(); // initial state\n    const char* end = ptr + std::strlen(ptr);\n    int len;\n    wchar_t wc;\n    while((len = std::mbrtowc(&wc, ptr, end-ptr, &state)) > 0) {\n        std::wcout << \"Next \" << len << \" bytes are the character \" << wc << '\\n';\n        ptr += len;\n    }\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    // UTF-8 narrow multibyte encoding\n    const char* str = u8\"z\\u00df\\u6c34\\U0001d10b\"; // or u8\"z\u00df\u6c34\ud834\udd0b\"\n                      // or \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9d\\x84\\x8b\";\n    print_mb(str);\n}",
            "output": "Next 1 bytes are the character z\nNext 2 bytes are the character \u00df\nNext 3 bytes are the character \u6c34\nNext 4 bytes are the character \ud834\udd0b"
        }
    },
    "wcrtomb": {
        "description": {
            "texte": "Converts a wide character to its narrow multibyte representation.If s is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of wc (including any shift sequences, and taking into account the current multibyte conversion state *ps), and stores the multibyte character representation in the character array whose first element is pointed to by s, updating *ps as necessary. At most MB_CUR_MAX bytes can be written by this function.If s is a null pointer, the call is equivalent to std::wcrtomb(buf, L'\\0', ps) for some internal buffer buf.If wc is the null wide character L'\\0', a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter *ps is updated to represent the initial shift state."
        },
        "parametres": "   s   -   pointer to narrow character array where the multibyte character will be stored \n   wc   -   the wide character to convert \n   ps   -   pointer to the conversion state object used when interpreting the multibyte string \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <clocale>\n#include <string>\n#include <cwchar>\n \nvoid print_wide(const std::wstring& wstr)\n{\n    std::mbstate_t state {};\n    for(wchar_t wc : wstr) {\n        std::string mb(MB_CUR_MAX, '\\0');\n        std::size_t ret = std::wcrtomb(&mb[0], wc, &state);\n        std::cout << \"multibyte char \" << mb << \" is \" << ret << \" bytes\\n\";\n    }\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::wstring wstr = L\"z\\u00df\\u6c34\\U0001f34c\"; // or L\"z\u00df\u6c34\ud83c\udf4c\"\n    print_wide(wstr);\n}",
            "output": "multibyte char z is 1 bytes\nmultibyte char \u00df is 2 bytes\nmultibyte char \u6c34 is 3 bytes\nmultibyte char \ud83c\udf4c is 4 bytes"
        }
    },
    "mbsrtowcs": {
        "description": {
            "texte": "Converts a null-terminated multibyte character sequence, which begins in the conversion state described by *ps, from the array whose first element is pointed to by *src to its wide character representation. If dst is not null, converted characters are stored in the successive elements of the wchar_t array pointed to by dst. No more than len wide characters are written to the destination array.Each multibyte character is converted as if by a call to std::mbrtowc. The conversion stops if:"
        },
        "parametres": "   dst   -   pointer to wide character array where the results will be stored \n   src   -   pointer to pointer to the first element of a null-terminated multibyte string \n   len   -   number of wide characters available in the array pointed to by dst \n   ps   -   pointer to the conversion state object \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <clocale>\n#include <cwchar>\n \nvoid print_as_wide(const char* mbstr)\n{\n    std::mbstate_t state = std::mbstate_t();\n    std::size_t len = 1 + std::mbsrtowcs(NULL, &mbstr, 0, &state);\n    std::vector<wchar_t> wstr(len);\n    std::mbsrtowcs(&wstr[0], &mbstr, wstr.size(), &state);\n    std::wcout << \"Wide string: \" << &wstr[0] << '\\n'\n               << \"The length, including '\\\\0': \" << wstr.size() << '\\n';\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    const char* mbstr = u8\"z\\u00df\\u6c34\\U0001f34c\"; // or u8\"z\u00df\u6c34\ud83c\udf4c\"\n    print_as_wide(mbstr);\n}",
            "output": "Wide string: z\u00df\u6c34\ud83c\udf4c\nThe length, including '\\0': 5"
        }
    },
    "wcsrtombs": {
        "description": {
            "texte": "Converts a sequence of wide characters from the array whose first element is pointed to by *src to its narrow multibyte representation that begins in the conversion state described by *ps. If dst is not null, converted characters are stored in the successive elements of the char array pointed to by dst. No more than len bytes are written to the destination array.Each character is converted as if by a call to std::wcrtomb. The conversion stops if:"
        },
        "parametres": "   dst   -   pointer to narrow character array where the multibyte characters will be stored \n   src   -   pointer to pointer to the first element of a null-terminated wide string \n   len   -   number of bytes available in the array pointed to by dst \n   ps   -   pointer to the conversion state object \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <clocale>\n#include <string>\n#include <cwchar>\n \nvoid print_wide(const wchar_t* wstr)\n{\n    std::mbstate_t state = std::mbstate_t();\n    std::size_t len = 1 + std::wcsrtombs(nullptr, &wstr, 0, &state);\n    std::vector<char> mbstr(len);\n    std::wcsrtombs(&mbstr[0], &wstr, mbstr.size(), &state);\n    std::cout << \"multibyte string: \" << &mbstr[0] << '\\n'\n              << \"Length, including '\\\\0': \" << mbstr.size() << '\\n';\n}\n \nint main()\n{\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    // UTF-8 narrow multibyte encoding\n    const wchar_t* wstr = L\"z\\u00df\\u6c34\\U0001d10b\"; // or L\"z\u00df\u6c34\ud834\udd0b\"\n    print_wide(wstr);\n}",
            "output": "multibyte string: z\u00df\u6c34\ud834\udd0b\nLength, including '\\0': 11"
        }
    },
    "fgetwc": {
        "description": {
            "texte": "Reads the next wide character from the given input stream. getwc() may be implemented as a macro and may evaluate stream more than once."
        },
        "parametres": "   stream   -   to read the wide character from \n\n"
    },
    "fgetws": {
        "description": {
            "texte": "Reads at most count - 1 wide characters from the given file stream and stores them in str. The produced wide string is always null-terminated. Parsing stops if end-of-file occurs or a newline wide character is found, in which case str will contain that wide newline character."
        },
        "parametres": "   str   -   wide string to read the characters to \n   count   -   the length of str \n   stream   -   file stream to read the data from \n\n"
    },
    "fputwc": {
        "description": {
            "texte": "Writes a wide character ch to the given output stream stream. putwc() may be implemented as a macro and may evaluate stream more than once."
        },
        "parametres": "   ch   -   wide character to be written \n   stream   -   the output stream \n\n"
    },
    "fputws": {
        "description": {
            "texte": "Writes every wide character from the null-terminated wide string str to the output stream stream, as if by repeatedly executing std::fputwc.The terminating null wide character from str is not written."
        },
        "parametres": "   str   -   null-terminated wide string to be written \n   stream   -   output stream \n\n",
        "exemple": {
            "input": "#include <clocale>\n#include <cstdio>\n#include <cwchar>\n \nint main()\n{\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    int rc = std::fputws(L\"\u5fa1\u4f11\u307f\u306a\u3055\u3044\", stdout);\n \n    if (rc == EOF)\n       std::perror(\"fputws()\"); // POSIX requires that errno is set\n}",
            "output": "\u5fa1\u4f11\u307f\u306a\u3055\u3044"
        }
    },
    "getwchar": {
        "description": {
            "texte": "Reads the next wide character from stdin."
        }
    },
    "putwchar": {
        "description": {
            "texte": "Writes a wide character ch to stdout."
        },
        "parametres": "   ch   -   wide character to be written \n\n"
    },
    "ungetwc": {
        "description": {
            "texte": "If ch does not equal WEOF, pushes the wide character ch into the input buffer associated with the stream stream in such a manner than subsequent read operation from stream will retrieve that wide character. The external device associated with the stream is not modified.Stream repositioning operations std::fseek, std::fsetpos, and std::rewind discard the effects of ungetwc.If ungetwc is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful ungetwc were performed, read operations retrieve the pushed-back wide characters in reverse order of ungetwc.If ch equals WEOF, the operation fails and the stream is not affected.A successful call to ungetwc clears the end of file status flag feof.A successful call to ungetwc on a stream (whether text or binary) modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back wide characters are retrieved with a read operation, the stream position indicator is equal to its value before ungetwc."
        },
        "parametres": "   ch   -   wide character to be put back \n   stream   -   file stream to put the wide character back to \n\n"
    },
    "fwide": {
        "description": {
            "texte": "If mode > 0, attempts to make stream wide-oriented. If mode < 0, attempts to make stream byte-oriented. If mode==0, only queries the current orientation of the stream.If the orientation of the stream has already been decided (by executing output or by an earlier call to fwide), this function does nothing."
        },
        "parametres": "   stream   -   pointer to the C I/O stream to modify or query \n   mode   -   integer value greater than zero to set the stream wide, less than zero to set the stream narrow, or zero to query only \n\n"
    },
    "wscanf, std::fwscanf, std::swscanf": {
        "description": {
            "texte": "Reads data from the a variety of sources, interprets it according to format and stores the results into given locations."
        },
        "parametres": "   stream   -   input file stream to read from \n   buffer   -   pointer to a null-terminated wide string to read from \n   format   -   pointer to a null-terminated wide string specifying how to read the input. The format string consists of.\n\n non-whitespace wide characters except %: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal. \n whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling iswspace in a loop). Note that there is no difference between \"\\n\", \" \", \"\\t\\t\", or other whitespace in the format string. \n conversion specifications. Each conversion specification has the following format: \n\n introductory % character \n (optional) assignment-suppressing character *. If this option is present, the function does not assign the result of the conversion to any receiving argument. \n (optional) integer number (greater than zero) that specifies maximum field width, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that %s and %[ may lead to buffer overflow if the width is not provided. \n (optional) length modifier that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below). \n conversion format specifier \n\n      The following format specifiers are available:\n   Conversion specifier   Explanation   Argument type \n   length modifier   hh (C++11).\n  h   (none)   l   ll (C++11).\n  j (C++11).\n  z (C++11).\n  t (C++11).\n  L \n   %   matches literal %   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A \n   c    matches a character or a sequence of characters  If a width specifier is used, matches exactly width wide characters (the argument must be a pointer to an array with sufficient room). Unlike %s and %[, does not append the null character to the array.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A \n   s    matches a sequence of non-whitespace characters (a string)  If width specifier is used, matches up to width or until the first whitespace character, whichever appears first. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\n\n   [set]   matches a non-empty sequence of character from set of characters.  If the first character of the set is ^, then all characters not in the set are matched. If the set begins with ] or ^] then the ] character is also included into the set. It is implementation-defined whether the character - in the non-initial position in the scanset may be indicating a range, as in [0-9]. If width specifier is used, matches only up to width. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\n\n   d   matches a decimal integer.  The format of the number is the same as expected by wcstol() with the value 10 for the base argument.\n  \nsigned char* or unsigned char*\n   \nsigned short* or unsigned short*\n   \nsigned int* or unsigned int*\n   \nsigned long* or unsigned long*\n   \nsigned long long* or unsigned long long*\n   \nintmax_t* or uintmax_t*\n   size_t*   ptrdiff_t*   N/A \n   i   matches an integer.  The format of the number is the same as expected by wcstol() with the value \u200b0\u200b for the base argument (base is determined by the first characters parsed).\n\n   u   matches an unsigned decimal integer.  The format of the number is the same as expected by wcstoul() with the value 10 for the base argument.\n\n   o   matches an unsigned octal integer.  The format of the number is the same as expected by wcstoul() with the value 8 for the base argument.\n\n   x, X   matches an unsigned hexadecimal integer.  The format of the number is the same as expected by wcstoul() with the value 16 for the base argument.\n\n   n   returns the number of characters read so far.  No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined.\n\n   a, A(C++11) e, E f, F g, G   matches a floating-point number.  The format of the number is the same as expected by wcstof().\n  N/A   N/A   float*   double*   N/A   N/A   N/A   N/A   long double* \n   p   matches implementation defined character sequence defining a pointer.  printf family of functions should produce the same sequence using %p format specifier.\n  N/A   N/A   void**   N/A   N/A   N/A   N/A   N/A   N/A \n\n For every conversion specifier other than n, the longest sequence of input characters which does not exceed any speci\ufb01ed \ufb01eld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The \ufb01rst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-\ufb01le, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\nAll conversion specifiers other than [, c, and n consume and discard all leading whitespace characters (determined as if by calling iswspace) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\nIf the length specifier l is not used, the conversion specifiers c, s, and [ perform wide-to-multibyte character conversion as if by calling wcrtomb() with an mbstate_t object initialized to zero before the first character is converted.\nThe conversion specifiers s and [ always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of %s or %[, without specifying the destination array size, is as unsafe as std::gets.\nThe correct conversion specifications for the fixed-width integer types (int8_t, etc) are defined in the header <cinttypes> (although SCNdMAX, SCNuMAX, etc is synonymous with %jd, %ju, etc).\nThere is a sequence point after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing \"100er\" with the conversion specifier %f, the sequence \"100e\" (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with \"r\" remaining. Some existing implementations do not follow this rule and roll back to consume only \"100\", leaving \"er\", e.g. glibc bug 1765.\n\n   ...   -   receiving arguments \n\n"
    },
    "vwscanf, std::vfwscanf, std::vswscanf": {
        "description": {
            "texte": "Reads data from the a variety of sources, interprets it according to format and stores the results into locations defined by vlist."
        },
        "parametres": "   stream   -   input file stream to read from \n   buffer   -   pointer to a null-terminated wide string to read from \n   format   -   pointer to a null-terminated wide string specifying how to read the input. The format string consists of.\n\n non-whitespace wide characters except %: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal. \n whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling iswspace in a loop). Note that there is no difference between \"\\n\", \" \", \"\\t\\t\", or other whitespace in the format string. \n conversion specifications. Each conversion specification has the following format: \n\n introductory % character \n (optional) assignment-suppressing character *. If this option is present, the function does not assign the result of the conversion to any receiving argument. \n (optional) integer number (greater than zero) that specifies maximum field width, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that %s and %[ may lead to buffer overflow if the width is not provided. \n (optional) length modifier that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below). \n conversion format specifier \n\n      The following format specifiers are available:\n   Conversion specifier   Explanation   Argument type \n   length modifier   hh (C++11).\n  h   (none)   l   ll (C++11).\n  j (C++11).\n  z (C++11).\n  t (C++11).\n  L \n   %   matches literal %   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A \n   c    matches a character or a sequence of characters  If a width specifier is used, matches exactly width wide characters (the argument must be a pointer to an array with sufficient room). Unlike %s and %[, does not append the null character to the array.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A \n   s    matches a sequence of non-whitespace characters (a string)  If width specifier is used, matches up to width or until the first whitespace character, whichever appears first. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\n\n   [set]   matches a non-empty sequence of character from set of characters.  If the first character of the set is ^, then all characters not in the set are matched. If the set begins with ] or ^] then the ] character is also included into the set. It is implementation-defined whether the character - in the non-initial position in the scanset may be indicating a range, as in [0-9]. If width specifier is used, matches only up to width. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\n\n   d   matches a decimal integer.  The format of the number is the same as expected by wcstol() with the value 10 for the base argument.\n  \nsigned char* or unsigned char*\n   \nsigned short* or unsigned short*\n   \nsigned int* or unsigned int*\n   \nsigned long* or unsigned long*\n   \nsigned long long* or unsigned long long*\n   \nintmax_t* or uintmax_t*\n   size_t*   ptrdiff_t*   N/A \n   i   matches an integer.  The format of the number is the same as expected by wcstol() with the value \u200b0\u200b for the base argument (base is determined by the first characters parsed).\n\n   u   matches an unsigned decimal integer.  The format of the number is the same as expected by wcstoul() with the value 10 for the base argument.\n\n   o   matches an unsigned octal integer.  The format of the number is the same as expected by wcstoul() with the value 8 for the base argument.\n\n   x, X   matches an unsigned hexadecimal integer.  The format of the number is the same as expected by wcstoul() with the value 16 for the base argument.\n\n   n   returns the number of characters read so far.  No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined.\n\n   a, A(C++11) e, E f, F g, G   matches a floating-point number.  The format of the number is the same as expected by wcstof().\n  N/A   N/A   float*   double*   N/A   N/A   N/A   N/A   long double* \n   p   matches implementation defined character sequence defining a pointer.  printf family of functions should produce the same sequence using %p format specifier.\n  N/A   N/A   void**   N/A   N/A   N/A   N/A   N/A   N/A \n\n For every conversion specifier other than n, the longest sequence of input characters which does not exceed any speci\ufb01ed \ufb01eld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The \ufb01rst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-\ufb01le, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\nAll conversion specifiers other than [, c, and n consume and discard all leading whitespace characters (determined as if by calling iswspace) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\nIf the length specifier l is not used, the conversion specifiers c, s, and [ perform wide-to-multibyte character conversion as if by calling wcrtomb() with an mbstate_t object initialized to zero before the first character is converted.\nThe conversion specifiers s and [ always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of %s or %[, without specifying the destination array size, is as unsafe as std::gets.\nThe correct conversion specifications for the fixed-width integer types (int8_t, etc) are defined in the header <cinttypes> (although SCNdMAX, SCNuMAX, etc is synonymous with %jd, %ju, etc).\nThere is a sequence point after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing \"100er\" with the conversion specifier %f, the sequence \"100e\" (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with \"r\" remaining. Some existing implementations do not follow this rule and roll back to consume only \"100\", leaving \"er\", e.g. glibc bug 1765.\n\n   vlist   -   variable argument list containing the receiving arguments \n\n"
    },
    "wprintf, std::fwprintf, std::swprintf": {
        "description": {
            "texte": "Loads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks."
        },
        "parametres": "   stream   -   output file stream to write to \n   buffer   -   pointer to a wide character string to write to \n   size   -   up to size - 1 characters may be written, plus the null terminator \n   format   -   pointer to a null-terminated wide string specifying how to interpret the data. The format string consists of ordinary wide characters (except %), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n introductory % character \n (optional) one or more flags that modify the behavior of the conversion: \n\n -: the result of the conversion is left-justified within the field (by default it is right-justified) \n +: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative) \n space: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if + flag is present. \n # : alternative form of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined. \n 0 : for integer and floating point number conversions, leading zeros are used to pad the field instead of space characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if - flag is present. \n\n (optional) integer value or * that specifies minimum field width. The result is padded with space characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when * is used, the width is specified by an additional argument of type int. If the value of the argument is negative, it results with the - flag specified and positive field width. (Note: This is the minimum width: The value is never truncated.) \n\n (optional) . followed by integer number or *, or neither that specifies precision of the conversion. In the case when * is used, the precision is specified by an additional argument of type int. If the value of this argument is negative, it is ignored. If neither a number nor * is used, the precision is taken as zero. See the table below for exact effects of precision. \n (optional) length modifier that specifies the size of the argument \n conversion format specifier \n\n        The following format specifiers are available:\n   Conversion specifier   Explanation   Argument type \n   length modifier   hh (C++11).\n  h   (none)   l   ll (C++11).\n  j (C++11).\n  z (C++11).\n  t (C++11).\n  L \n   %   writes literal %. The full conversion specification must be %%.   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A \n   c    writes a single character.  The argument is first converted to wchar_t as if by calling btowc. If the l modifier is used, the wint_t argument is first converted to wchar_t.\n  N/A   N/A   int   wint_t   N/A   N/A   N/A   N/A   N/A \n   s    writes a character string  The argument must be a pointer to the initial element of a character array containing a multibyte character sequence beginning in the initial shift state, which is converted to wide character array as if by a call to mbrtowc with zero-initialized conversion state. Precision specifies the maximum number of wide characters to be written. If Precision is not specified, writes every wide characters up to and not including the first null terminator. If the l specifier is used, the argument must be a pointer to the initial element of an array of wchar_t.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A \n   d i   converts a signed integer into decimal representation [-]dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  signed char   short   int   long   long long   intmax_t   signed size_t\n   ptrdiff_t   N/A \n   o   converts a unsigned integer into octal representation oooo.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation precision is increased if necessary, to write one leading zero. In that case if both the converted value and the precision are \u200b0\u200b, single \u200b0\u200b is written.\n  unsigned char   unsigned short   unsigned int   unsigned long   unsigned long long   uintmax_t   size_t   unsigned version of ptrdiff_t\n   N/A \n   x X   converts an unsigned integer into hexadecimal representation hhhh.  For the x conversion letters abcdef are used. For the X conversion letters ABCDEF are used. Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation 0x or 0X is prefixed to results if the converted value is nonzero.\n  N/A \n   u   converts an unsigned integer into decimal representation dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  N/A \n   f F   converts floating-point number to the decimal notation in the style [-]ddd.ddd.  Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   double   \ndouble (C++11)\n   N/A   N/A   N/A   N/A   long double \n   e E   converts floating-point number to the decimal exponent notation.  For the e conversion style [-]d.ddde\u00b1dd is used. For the E conversion style [-]d.dddE\u00b1dd is used. The exponent contains at least two digits, more digits are used only if necessary. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   a A (C++11).\n  converts floating-point number to the hexadecimal exponent notation.  For the a conversion style [-]0xh.hhhp\u00b1d is used. For the A conversion style [-]0Xh.hhhP\u00b1d is used. The first hexadecimal digit is not 0 if the argument is a normalized floating point value. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is sufficient for exact representation of the value. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   g G   converts floating-point number to decimal or decimal exponent notation depending on the value and the precision.  For the g conversion style conversion with style e or f will be performed. For the G conversion style conversion with style E or F will be performed. Let P equal the precision if nonzero, 6 if the precision is not specified, or 1 if the precision is \u200b0\u200b. Then, if a conversion with style E would have an exponent of X:\n\n if P > X \u2265 \u22124, the conversion is with style f or F and precision P \u2212 1 \u2212 X. \n otherwise, the conversion is with style e or E and precision P \u2212 1. \n Unless alternative representation is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   n   returns the number of characters written so far by this call to the function.  The result is written to the value pointed to by the argument. The specification may not contain any flag, field width, or precision.\n  signed char*   short*   int*   long*   long long*   intmax_t*   signed size_t*\n   ptrdiff_t*   N/A \n   p   writes an implementation defined character sequence defining a pointer.   N/A   N/A   void*   N/A   N/A   N/A   N/A   N/A   N/A \n\n The floating point conversion functions convert infinity to inf or infinity. Which one is used is implementation defined.\nNot-a-number is converted to nan or nan(char_sequence). Which one is used is implementation defined.\nThe conversions F, E, G, A output INF, INFINITY, NAN instead.\nEven though %c expects int argument, it is safe to pass a char because of the integer promotion that takes place when a variadic function is called.\nThe correct conversion specifications for the fixed-width character types (int8_t, etc) are defined in the header <cinttypes> (although PRIdMAX, PRIuMAX, etc is synonymous with %jd, %ju, etc).\nThe memory-writing conversion specifier %n is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked printf_s family of functions.\nThere is a sequence point after the action of each conversion specifier; this permits storing multiple %n results in the same variable or, as an edge case, printing a string modified by an earlier %n within the same call.\nIf a conversion specification is invalid, the behavior is undefined.\n\n   ...   -   arguments specifying data to print. If any argument after default conversions is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by format, the behavior is undefined. If there are more arguments than required by format, the extraneous arguments are evaluated and ignored \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n#include <clocale>\n#include <cwchar>\n \nint main()\n{\n    char narrow_str[] = \"z\\u00df\\u6c34\\U0001f34c\";\n                    // or \"z\u00df\u6c34\ud83c\udf4c\"\n                    // or \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9f\\x8d\\x8c\";\n    wchar_t warr[29]; // the expected string is 28 characters plus 1 null terminator\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n \n    std::swprintf(warr, sizeof warr/sizeof *warr,\n                  L\"Converted from UTF-8: '%s'\", narrow_str);\n \n    std::wcout.imbue(std::locale(\"en_US.utf8\"));\n    std::wcout << warr << '\\n';\n}",
            "output": "Converted from UTF-8: 'z\u00df\u6c34\ud83c\udf4c'"
        }
    },
    "vwprintf, std::vfwprintf, std::vswprintf": {
        "description": {
            "texte": "Loads the data from locations, defined by vlist,, converts them to wide string equivalents and writes the results to a variety of sinks."
        },
        "parametres": "   stream   -   output wide stream to write to \n   buffer   -   pointer to a wide string to write to \n   buf_size   -   maximum number of wide characters to write \n   format   -   pointer to a null-terminated wide string specifying how to interpret the data. The format string consists of ordinary wide characters (except %), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n introductory % character \n (optional) one or more flags that modify the behavior of the conversion: \n\n -: the result of the conversion is left-justified within the field (by default it is right-justified) \n +: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative) \n space: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if + flag is present. \n # : alternative form of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined. \n 0 : for integer and floating point number conversions, leading zeros are used to pad the field instead of space characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if - flag is present. \n\n (optional) integer value or * that specifies minimum field width. The result is padded with space characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when * is used, the width is specified by an additional argument of type int. If the value of the argument is negative, it results with the - flag specified and positive field width. (Note: This is the minimum width: The value is never truncated.) \n\n (optional) . followed by integer number or *, or neither that specifies precision of the conversion. In the case when * is used, the precision is specified by an additional argument of type int. If the value of this argument is negative, it is ignored. If neither a number nor * is used, the precision is taken as zero. See the table below for exact effects of precision. \n (optional) length modifier that specifies the size of the argument \n conversion format specifier \n\n        The following format specifiers are available:\n   Conversion specifier   Explanation   Argument type \n   length modifier   hh (C++11).\n  h   (none)   l   ll (C++11).\n  j (C++11).\n  z (C++11).\n  t (C++11).\n  L \n   %   writes literal %. The full conversion specification must be %%.   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A \n   c    writes a single character.  The argument is first converted to wchar_t as if by calling btowc. If the l modifier is used, the wint_t argument is first converted to wchar_t.\n  N/A   N/A   int   wint_t   N/A   N/A   N/A   N/A   N/A \n   s    writes a character string  The argument must be a pointer to the initial element of a character array containing a multibyte character sequence beginning in the initial shift state, which is converted to wide character array as if by a call to mbrtowc with zero-initialized conversion state. Precision specifies the maximum number of wide characters to be written. If Precision is not specified, writes every wide characters up to and not including the first null terminator. If the l specifier is used, the argument must be a pointer to the initial element of an array of wchar_t.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A \n   d i   converts a signed integer into decimal representation [-]dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  signed char   short   int   long   long long   intmax_t   signed size_t\n   ptrdiff_t   N/A \n   o   converts a unsigned integer into octal representation oooo.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation precision is increased if necessary, to write one leading zero. In that case if both the converted value and the precision are \u200b0\u200b, single \u200b0\u200b is written.\n  unsigned char   unsigned short   unsigned int   unsigned long   unsigned long long   uintmax_t   size_t   unsigned version of ptrdiff_t\n   N/A \n   x X   converts an unsigned integer into hexadecimal representation hhhh.  For the x conversion letters abcdef are used. For the X conversion letters ABCDEF are used. Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation 0x or 0X is prefixed to results if the converted value is nonzero.\n  N/A \n   u   converts an unsigned integer into decimal representation dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  N/A \n   f F   converts floating-point number to the decimal notation in the style [-]ddd.ddd.  Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   double   \ndouble (C++11)\n   N/A   N/A   N/A   N/A   long double \n   e E   converts floating-point number to the decimal exponent notation.  For the e conversion style [-]d.ddde\u00b1dd is used. For the E conversion style [-]d.dddE\u00b1dd is used. The exponent contains at least two digits, more digits are used only if necessary. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   a A (C++11).\n  converts floating-point number to the hexadecimal exponent notation.  For the a conversion style [-]0xh.hhhp\u00b1d is used. For the A conversion style [-]0Xh.hhhP\u00b1d is used. The first hexadecimal digit is not 0 if the argument is a normalized floating point value. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is sufficient for exact representation of the value. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   g G   converts floating-point number to decimal or decimal exponent notation depending on the value and the precision.  For the g conversion style conversion with style e or f will be performed. For the G conversion style conversion with style E or F will be performed. Let P equal the precision if nonzero, 6 if the precision is not specified, or 1 if the precision is \u200b0\u200b. Then, if a conversion with style E would have an exponent of X:\n\n if P > X \u2265 \u22124, the conversion is with style f or F and precision P \u2212 1 \u2212 X. \n otherwise, the conversion is with style e or E and precision P \u2212 1. \n Unless alternative representation is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   n   returns the number of characters written so far by this call to the function.  The result is written to the value pointed to by the argument. The specification may not contain any flag, field width, or precision.\n  signed char*   short*   int*   long*   long long*   intmax_t*   signed size_t*\n   ptrdiff_t*   N/A \n   p   writes an implementation defined character sequence defining a pointer.   N/A   N/A   void*   N/A   N/A   N/A   N/A   N/A   N/A \n\n The floating point conversion functions convert infinity to inf or infinity. Which one is used is implementation defined.\nNot-a-number is converted to nan or nan(char_sequence). Which one is used is implementation defined.\nThe conversions F, E, G, A output INF, INFINITY, NAN instead.\nEven though %c expects int argument, it is safe to pass a char because of the integer promotion that takes place when a variadic function is called.\nThe correct conversion specifications for the fixed-width character types (int8_t, etc) are defined in the header <cinttypes> (although PRIdMAX, PRIuMAX, etc is synonymous with %jd, %ju, etc).\nThe memory-writing conversion specifier %n is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked printf_s family of functions.\nThere is a sequence point after the action of each conversion specifier; this permits storing multiple %n results in the same variable or, as an edge case, printing a string modified by an earlier %n within the same call.\nIf a conversion specification is invalid, the behavior is undefined.\n\n   vlist   -   variable argument list containing the data to print \n\n"
    },
    "wcstol, std::wcstoll": {
        "description": {
            "texte": "Interprets an integer value in a wide string pointed to by str.Discards any whitespace characters (as identified by calling isspace()) until the first non-whitespace character is found, then takes as many characters as possible to form a valid base-n (where n=base) integer number representation and converts them to an integer value. The valid integer value consists of the following parts:The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is {0,1}, for base-3 integers is {0,1,2}, and so on. For bases larger than 10, valid digits include alphabetic characters, starting from Aa for base-11 integer, to Zz for base-36 integer. The case of the characters is ignored.Additional numeric formats may be accepted by the currently installed C locale.If the value of base is \u200b0\u200b, the numeric base is auto-detected: if the prefix is 0, the base is octal, if the prefix is 0x or 0X, the base is hexadecimal, otherwise the base is decimal.If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type.The functions sets the pointer pointed to by str_end to point to the wide character past the last character interpreted. If str_end is NULL, it is ignored."
        },
        "parametres": "   str   -   pointer to the null-terminated wide string to be interpreted \n   str_end   -   pointer to a pointer to wide character \n   base   -   base of the interpreted integer value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <errno.h>\n#include <cwchar>\n \nint main()\n{\n    const wchar_t* p = L\"10 200000000000000000000000000000 30 -40\";\n    wchar_t *end;\n    std::wcout << \"Parsing L'\" << p << \"':\\n\";\n    for (long i = std::wcstol(p, &end, 10);\n         p != end;\n         i = std::wcstol(p, &end, 10))\n    {\n        std::wcout << \"'\" << std::wstring(p, end-p) << \"' -> \";\n        p = end;\n        if (errno == ERANGE){\n            std::wcout << \"range error, got \";\n            errno = 0;\n        }\n        std::wcout << i << '\\n';\n    }\n}",
            "output": "Parsing L'10 200000000000000000000000000000 30 -40':\n'10' -> 10\n' 200000000000000000000000000000' -> range error, got 9223372036854775807\n' 30' -> 30\n' -40' -> -40"
        }
    },
    "wcstoul, std::wcstoull": {
        "description": {
            "texte": "Interprets an unsigned integer value in a wide string pointed to by str.Discards any whitespace characters (as identified by calling isspace()) until the first non-whitespace character is found, then takes as many characters as possible to form a valid base-n (where n=base) unsigned integer number representation and converts them to an integer value. The valid unsigned integer value consists of the following parts:The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is {0,1}, for base-3 integers is {0,1,2}, and so on. For bases larger than 10, valid digits include alphabetic characters, starting from Aa for base-11 integer, to Zz for base-36 integer. The case of the characters is ignored.Additional numeric formats may be accepted by the currently installed C locale.If the value of base is \u200b0\u200b, the numeric base is auto-detected: if the prefix is 0, the base is octal, if the prefix is 0x or 0X, the base is hexadecimal, otherwise the base is decimal.If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type, which applies unsigned integer wraparound rules.The functions sets the pointer pointed to by str_end to point to the wide character past the last character interpreted. If str_end is NULL, it is ignored."
        },
        "parametres": "   str   -   pointer to the null-terminated wide string to be interpreted \n   str_end   -   pointer to a pointer to a wide character. \n   base   -   base of the interpreted integer value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <errno.h>\n#include <cwchar>\n \nint main()\n{\n    const wchar_t* p = L\"10 200000000000000000000000000000 30 40\";\n    wchar_t *end;\n    std::wcout << \"Parsing L'\" << p << \"':\\n\";\n    for (unsigned long i = std::wcstoul(p, &end, 10);\n         p != end;\n         i = std::wcstoul(p, &end, 10))\n    {\n        std::wcout << \"'\" << std::wstring(p, end-p) << \"' -> \";\n        p = end;\n        if (errno == ERANGE){\n            std::wcout << \"range error, got \";\n            errno = 0;\n        }\n        std::wcout << i << '\\n';\n    }\n}",
            "output": "Parsing L'10 200000000000000000000000000000 30 40':\n'10' -> 10\n' 200000000000000000000000000000' -> range error, got 18446744073709551615\n' 30' -> 30\n' 40' -> 40"
        }
    },
    "wcstof, std::wcstod, std::wcstold": {
        "description": {
            "texte": "Interprets a floating point value in a wide string pointed to by str.Function discards any whitespace characters (as determined by std::iswspace()) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:The functions sets the pointer pointed to by str_end to point to the wide character past the last character interpreted. If str_end is NULL, it is ignored."
        },
        "parametres": "   str   -   pointer to the null-terminated wide string to be interpreted \n   str_end   -   pointer to a pointer to a wide character. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <cerrno>\n#include <cwchar>\n \nint main()\n{\n    const wchar_t* p = L\"111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz\";\n    wchar_t* end;\n    std::wcout << \"Parsing L\\\"\" << p << \"\\\":\\n\";\n    for (double f = std::wcstod(p, &end); p != end; f = std::wcstod(p, &end))\n    {\n        std::wcout << \"'\" << std::wstring(p, end-p) << \"' -> \";\n        p = end;\n        if (errno == ERANGE){\n            std::wcout << \"range error, got \";\n            errno = 0;\n        }\n        std::wcout << f << '\\n';\n    }\n}",
            "output": "Parsing L\"111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz\":\n'111.11' -> 111.11\n' -2.22' -> -2.22\n' 0X1.BC70A3D70A3D7P+6' -> 111.11\n'  1.18973e+4932' -> range error, got inf"
        }
    },
    "mbrtoc16": {
        "description": {
            "texte": "Converts a narrow multibyte character to UTF-16 character representation.If s is not a null pointer, inspects at most n bytes of the multibyte character string, beginning with the byte pointed to by s to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in s is complete and valid, converts it to the corresponding 16-bit character and stores it in *pc16 (if pc16 is not null).If the multibyte character in *s corresponds to a multi-char16_t sequence (e.g. a surrogate pair in UTF-16), then after the first call to this function, *ps is updated in such a way that the next call to mbrtoc16 will write out the additional char16_t, without considering *s.If s is a null pointer, the values of n and pc16 are ignored and the call is equivalent to std::mbrtoc16(NULL, \"\", 1, ps).If the wide character produced is the null character, the conversion state *ps represents the initial shift state.The multibyte encoding used by this function is specified by the currently active C locale."
        },
        "parametres": "   pc16   -   pointer to the location where the resulting 16-bit character will be written \n   s   -   pointer to the multibyte character string used as input \n   n   -   limit on the number of bytes in s that can be examined \n   ps   -   pointer to the conversion state object used when interpreting the multibyte string \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <clocale>\n#include <cstring>\n#include <cwchar>\n#include <cuchar>\n \nint main()\n{\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n \n    std::string str = u8\"z\\u00df\\u6c34\\U0001F34C\"; // or u8\"z\u00df\u6c34\ud83c\udf4c\"\n \n    std::cout << \"Processing \" << str.size() << \" bytes: [ \" << std::showbase;\n    for(unsigned char c: str) std::cout << std::hex << +c << ' ';\n    std::cout << \"]\\n\";\n \n    std::mbstate_t state{}; // zero-initialized to initial state\n    char16_t c16;\n    const char *ptr = &str[0], *end = &str[0] + str.size();\n \n    while(std::size_t rc = std::mbrtoc16(&c16, ptr, end - ptr + 1, &state))\n    {\n        std::cout << \"Next UTF-16 char: \" << std::hex << c16 << \" obtained from \";\n        if(rc == (std::size_t)-3)\n            std::cout << \"earlier surrogate pair\\n\";\n        else if(rc == (std::size_t)-2)\n            break;\n        else if(rc == (std::size_t)-1)\n            break;\n        else {\n            std::cout << std::dec << rc << \" bytes [ \";\n            for(std::size_t n = 0; n < rc; ++n)\n                std::cout << std::hex << +(unsigned char)ptr[n] << ' ';\n            std::cout << \"]\\n\";\n            ptr += rc;\n        }\n    }\n}",
            "output": "Processing 10 bytes: [ 0x7a 0xc3 0x9f 0xe6 0xb0 0xb4 0xf0 0x9f 0x8d 0x8c ]\nNext UTF-16 char: 0x7a obtained from 1 bytes [ 0x7a ]\nNext UTF-16 char: 0xdf obtained from 2 bytes [ 0xc3 0x9f ]\nNext UTF-16 char: 0x6c34 obtained from 3 bytes [ 0xe6 0xb0 0xb4 ]\nNext UTF-16 char: 0xd83c obtained from 4 bytes [ 0xf0 0x9f 0x8d 0x8c ]\nNext UTF-16 char: 0xdf4c obtained from earlier surrogate pair"
        }
    },
    "c16rtomb": {
        "description": {
            "texte": "Converts a single code point from variable-length 16-bit character representation (typically, UTF-16) to a narrow multibyte character representation.If s is not a null pointer and c16 is the last 16-bit code unit in a valid variable-length encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences, and taking into account the current multibyte conversion state *ps), and stores the multibyte character representation in the character array whose first element is pointed to by s, updating *ps as necessary. At most MB_CUR_MAX bytes can be written by this function.If s is a null pointer, the call is equivalent to std::c16rtomb(buf, u'\\0', ps) for some internal buffer buf.If c16 is not the final code unit in a 16-bit representation of a wide character, it does not write to the array pointed to by s, only *ps is updated.If c16 is the null wide character u'\\0', a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter *ps is updated to represent the initial shift state.The multibyte encoding used by this function is specified by the currently active C locale."
        },
        "parametres": "   s   -   pointer to narrow character array where the multibyte character will be stored \n   c16   -   the 16-bit character to convert \n   ps   -   pointer to the conversion state object used when interpreting the multibyte string \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <string_view>\n#include <clocale>\n#include <cuchar>\n#include <climits>\n \nint main()\n{\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::u16string_view strv = u\"z\u00df\u6c34\ud83c\udf4c\"; // or z\\u00df\\u6c34\\U0001F34C\n    std::cout << \"Processing \" << strv.size() << \" UTF-16 code units: [ \";\n    for(char16_t c : strv)\n        std::cout << std::showbase << std::hex << c << ' ';\n    std::cout << \"]\\n\";\n \n    std::mbstate_t state{};\n    char out[MB_LEN_MAX]{};\n    for(char16_t c : strv)\n    {   \n        std::size_t rc = std::c16rtomb(out, c, &state);\n        std::cout << c << \" converted to [ \";\n        if(rc != (std::size_t)-1)\n            for(unsigned char c8 : std::string_view{out, rc})\n                std::cout << +c8 << ' ';\n        std::cout << \"]\\n\";\n    }\n}",
            "output": "Processing 5 UTF-16 code units: [ 0x7a 0xdf 0x6c34 0xd83c 0xdf4c ]\n0x7a converted to [ 0x7a ]\n0xdf converted to [ 0xc3 0x9f ]\n0x6c34 converted to [ 0xe6 0xb0 0xb4 ]\n0xd83c converted to [ ]\n0xdf4c converted to [ 0xf0 0x9f 0x8d 0x8c ]"
        }
    },
    "mbrtoc32": {
        "description": {
            "texte": "Converts a narrow multibyte character to its UTF-32 character representation.If s is not a null pointer, inspects at most n bytes of the multibyte character string, beginning with the byte pointed to by s to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in s is complete and valid, converts it to the corresponding 32-bit character and stores it in *pc32 (if pc32 is not null).If the multibyte character in *s corresponds to a multi-char32_t sequence (not possible with UTF-32), then after the first call to this function, *ps is updated in such a way that the next calls to mbrtoc32 will write out the additional char32_t, without considering *s.If s is a null pointer, the values of n and pc32 are ignored and the call is equivalent to std::mbrtoc32(NULL, \"\", 1, ps).If the wide character produced is the null character, the conversion state *ps represents the initial shift state.The multibyte encoding used by this function is specified by the currently active C locale."
        },
        "parametres": "   pc32   -   pointer to the location where the resulting 32-bit character will be written \n   s   -   pointer to the multibyte character string used as input \n   n   -   limit on the number of bytes in s that can be examined \n   ps   -   pointer to the conversion state object used when interpreting the multibyte string \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <clocale>\n#include <cstring>\n#include <cwchar>\n#include <cuchar>\n#include <cassert>\n \nint main()\n{\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n \n    std::string str = u8\"z\\u00df\\u6c34\\U0001F34C\"; // or u8\"z\u00df\u6c34\ud83c\udf4c\"\n \n    std::cout << \"Processing \" << str.size() << \" bytes: [ \" << std::showbase;\n    for(unsigned char c: str) std::cout << std::hex << +c << ' ';\n    std::cout << \"]\\n\";\n \n    std::mbstate_t state{}; // zero-initialized to initial state\n    char32_t c32;\n    const char *ptr = str.c_str(), *end = str.c_str() + str.size() + 1;\n \n    while(std::size_t rc = std::mbrtoc32(&c32, ptr, end - ptr, &state))\n    {   \n        std::cout << \"Next UTF-32 char: \" << std::hex << c32 << \" obtained from \";\n        assert(rc != (std::size_t)-3); // no surrogates in UTF-32\n        if(rc == (std::size_t)-1) break;\n        if(rc == (std::size_t)-2) break;\n        std::cout << std::dec << rc << \" bytes [ \";\n        for(std::size_t n = 0; n < rc; ++n)\n            std::cout << std::hex << +(unsigned char)ptr[n] << ' ';\n        std::cout << \"]\\n\";\n        ptr += rc;\n    }\n}",
            "output": "Processing 10 bytes: [ 0x7a 0xc3 0x9f 0xe6 0xb0 0xb4 0xf0 0x9f 0x8d 0x8c ]\nNext UTF-32 char: 0x7a obtained from 1 bytes [ 0x7a ]\nNext UTF-32 char: 0xdf obtained from 2 bytes [ 0xc3 0x9f ]\nNext UTF-32 char: 0x6c34 obtained from 3 bytes [ 0xe6 0xb0 0xb4 ]\nNext UTF-32 char: 0x1f34c obtained from 4 bytes [ 0xf0 0x9f 0x8d 0x8c ]"
        }
    },
    "c32rtomb": {
        "description": {
            "texte": "Converts a UTF-32 character to its narrow multibyte representation.If s is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of c32 (including any shift sequences, and taking into account the current multibyte conversion state *ps), and stores the multibyte character representation in the character array whose first element is pointed to by s, updating *ps as necessary. At most MB_CUR_MAX bytes can be written by this function.If s is a null pointer, the call is equivalent to std::c32rtomb(buf, U'\\0', ps) for some internal buffer buf.If c32 is the null wide character U'\\0', a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter *ps is updated to represent the initial shift state.The multibyte encoding used by this function is specified by the currently active C locale."
        },
        "parametres": "   s   -   pointer to narrow character array where the multibyte character will be stored \n   c32   -   the 32-bit character to convert \n   ps   -   pointer to the conversion state object used when interpreting the multibyte string \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <string_view>\n#include <clocale>\n#include <cuchar>\n#include <climits>\n \nint main()\n{\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::u32string_view strv = U\"z\u00df\u6c34\ud83c\udf4c\"; // or z\\u00df\\u6c34\\U0001F34C\n    std::cout << \"Processing \" << strv.size() << \" UTF-32 code units: [ \";\n    for(char32_t c : strv)\n        std::cout << std::showbase << std::hex << c << ' ';\n    std::cout << \"]\\n\";\n \n    std::mbstate_t state{};\n    char out[MB_LEN_MAX]{};\n    for(char32_t c : strv)\n    {\n        std::size_t rc = std::c32rtomb(out, c, &state);\n        std::cout << c << \" converted to [ \";\n        if(rc != (std::size_t)-1)\n            for(unsigned char c8 : std::string_view{out, rc})\n                std::cout << +c8 << ' ';\n        std::cout << \"]\\n\";\n    }\n}",
            "output": "Processing 4 UTF-32 code units: [ 0x7a 0xdf 0x6c34 0x1f34c ]\n0x7a converted to [ 0x7a ]\n0xdf converted to [ 0xc3 0x9f ]\n0x6c34 converted to [ 0xe6 0xb0 0xb4 ]\n0x1f34c converted to [ 0xf0 0x9f 0x8d 0x8c ]"
        }
    },
    "mbrtoc8": {
        "description": {
            "texte": "Converts a narrow multibyte character to UTF-8 encoding.If s is not a null pointer, inspects at most n bytes of the multibyte character string, beginning with the byte pointed to by s to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in s is complete and valid, converts it to UTF-8 and stores the first UTf-8 code unit in *pc8 (if pc8 is not null).If UTF-8 encoding of the multibyte character in *s consists of more than one UTF-8 code unit, then after the first call to this function, *ps is updated in such a way that the next call to mbrtoc8 will write out the additional UTF-8 code units, without considering *s.If s is a null pointer, the values of n and pc8 are ignored and the call is equivalent to std::mbrtoc8(NULL, \"\", 1, ps).If UTF-8 code unit produced is u8'\\0', the conversion state *ps represents the initial shift state.The multibyte encoding used by this function is specified by the currently active C locale."
        },
        "parametres": "   pc8   -   pointer to the location where the resulting UTF-8 code units will be written \n   s   -   pointer to the multibyte character string used as input \n   n   -   limit on the number of bytes in s that can be examined \n   ps   -   pointer to the conversion state object used when interpreting the multibyte string \n\n"
    },
    "c8rtomb": {
        "description": {
            "texte": "Converts a single code point from UTF-8 to a narrow multibyte character representation.If s is not a null pointer and c8 is the last code unit in a valid UTF-8 encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences, and taking into account the current multibyte conversion state *ps), and stores the multibyte character representation in the character array whose first element is pointed to by s, updating *ps as necessary. At most MB_CUR_MAX bytes can be written by this function.If c8 is not the final UTF-8 code unit in a representation of a code point, the function does not write to the array pointed to by s, only *ps is updated.If s is a null pointer, the call is equivalent to std::c8rtomb(buf, u8'\\0', ps) for some internal buffer buf.If c8 is the null character u8'\\0', a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter *ps is updated to represent the initial shift state.The multibyte encoding used by this function is specified by the currently active C locale."
        },
        "parametres": "   s   -   pointer to narrow character array where the multibyte character will be stored \n   c8   -   the UTF-8 code unit to convert \n   ps   -   pointer to the conversion state object used when interpreting the multibyte string \n\n"
    },
    "strcpy": {
        "description": {
            "texte": "Copies the character string pointed to by src, including the null terminator, to the character array whose first element is pointed to by dest.The behavior is undefined if the dest array is not large enough. The behavior is undefined if the strings overlap."
        },
        "parametres": "   dest   -   pointer to the character array to write to \n   src   -   pointer to the null-terminated byte string to copy from \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstring>\n#include <memory>\n \nint main()\n{\n    const char* src = \"Take the test.\";\n//  src[0] = 'M'; // can't modify string literal\n    auto dst = std::make_unique<char[]>(std::strlen(src)+1); // +1 for the null terminator\n    std::strcpy(dst.get(), src);\n    dst[0] = 'M';\n    std::cout << src << '\\n' << dst.get() << '\\n';\n}",
            "output": "Take the test.\nMake the test."
        }
    },
    "strncpy": {
        "description": {
            "texte": "Copies at most count characters of the byte string pointed to by src (including the terminating null character) to character array pointed to by dest.If count is reached before the entire string src was copied, the resulting character array is not null-terminated.If, after copying the terminating null character from src, count is not reached, additional null characters are written to dest until the total of count characters have been written.If the strings overlap, the behavior is undefined."
        },
        "parametres": "   dest   -   pointer to the character array to copy to \n   src   -   pointer to the byte string to copy from \n   count   -   maximum number of characters to copy \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstring>\n \nint main()\n{\n    const char* src = \"hi\";\n    char dest[6] = {'a', 'b', 'c', 'd', 'e', 'f'};\n    std::strncpy(dest, src, 5);\n \n    std::cout << \"The contents of dest are: \";\n    for (char c : dest) {\n        if (c) {\n            std::cout << c << ' ';\n        } else {\n            std::cout << \"\\\\0\" << ' ';\n        }\n    }\n    std::cout << '\\n';\n}",
            "output": "The contents of dest are: h i \\0 \\0 \\0 f"
        }
    },
    "strcat": {
        "description": {
            "texte": "Appends a copy of the character string pointed to by src to the end of the character string pointed to by dest. The character src[0] replaces the null terminator at the end of dest. The resulting byte string is null-terminated.The behavior is undefined if the destination array is not large enough for the contents of both src and dest and the terminating null character.The behavior is undefined if the strings overlap."
        },
        "parametres": "   dest   -   pointer to the null-terminated byte string to append to \n   src   -   pointer to the null-terminated byte string to copy from \n\n",
        "exemple": {
            "input": "#include <cstring>\n#include <cstdio>\n \nint main() \n{\n    char str[50] = \"Hello \";\n    char str2[50] = \"World!\";\n    std::strcat(str, str2);\n    std::strcat(str, \" Goodbye World!\");\n    std::puts(str);\n}",
            "output": "Hello World! Goodbye World!"
        }
    },
    "strncat": {
        "description": {
            "texte": "Appends a byte string pointed to by src to a byte string pointed to by dest. At most count characters are copied. The resulting byte string is null-terminated.The destination byte string must have enough space for the contents of both dest and src plus the terminating null character, except that the size of src is limited to count.The behavior is undefined if the strings overlap."
        },
        "parametres": "   dest   -   pointer to the null-terminated byte string to append to \n   src   -   pointer to the null-terminated byte string to copy from \n   count   -   maximum number of characters to copy \n\n",
        "exemple": {
            "input": "#include <cstring>\n#include <cstdio>\n \nint main() \n{\n    char str[50] = \"Hello \";\n    char str2[50] = \"World!\";\n    std::strcat(str, str2);\n    std::strncat(str, \" Goodbye World!\", 3);\n    std::puts(str);\n}",
            "output": "Hello World! Go"
        }
    },
    "strxfrm": {
        "description": {
            "texte": "Transforms the null-terminated byte string pointed to by src into the implementation-defined form such that comparing two transformed strings with std::strcmp gives the same result as comparing the original strings with std::strcoll, in the current C locale.The first count characters of the transformed string are written to destination, including the terminating null character, and the length of the full transformed string is returned, excluding the terminating null character.The behavior is undefined if the dest array is not large enough. The behavior is undefined if dest and src overlap.If count is \u200b0\u200b, then dest is allowed to be a null pointer."
        },
        "parametres": "   dest   -   pointer to the first element of the array where the transformed string will be written \n   src   -   pointer to the first character of a null-terminated byte string to transform \n   count   -   maximum number of characters to be written \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <cassert>\n \nint main()\n{\n    char* loc = std::setlocale(LC_COLLATE, \"cs_CZ.iso88592\");\n    assert(loc);\n \n    std::string in1 = \"hrnec\";\n    std::string out1(1+std::strxfrm(nullptr, in1.c_str(), 0), ' ');\n    std::string in2 = \"chrt\";\n    std::string out2(1+std::strxfrm(nullptr, in2.c_str(), 0), ' ');\n \n    std::strxfrm(&out1[0], in1.c_str(), out1.size());\n    std::strxfrm(&out2[0], in2.c_str(), out2.size());\n \n    std::cout << \"In the Czech locale: \";\n    if(out1 < out2)\n         std::cout << in1 << \" before \" << in2 << '\\n';\n    else\n         std::cout << in2 << \" before \" << in1 << '\\n';\n \n    std::cout << \"In lexicographical comparison: \";\n    if(in1 < in2)\n         std::cout << in1 << \" before \" << in2 << '\\n';\n    else\n         std::cout << in2 << \" before \" << in1 << '\\n';\n \n}",
            "output": "In the Czech locale: hrnec before chrt\nIn lexicographical comparison: chrt before hrnec"
        }
    },
    "strlen": {
        "description": {
            "texte": "Returns the length of the given byte string, that is, the number of characters in a character array whose first element is pointed to by str up to and not including the first null character. The behavior is undefined if there is no null character in the character array pointed to by str."
        },
        "parametres": "   str   -   pointer to the null-terminated byte string to be examined \n\n",
        "exemple": {
            "input": "#include <cstring>\n#include <iostream>\n \nint main()\n{\n   const char str[] = \"How many characters does this string contain?\";\n \n   std::cout << \"without null character: \" << std::strlen(str) << '\\n'\n             << \"with null character: \" << sizeof str << '\\n';\n}",
            "output": "without null character: 45\nwith null character: 46"
        }
    },
    "strcmp": {
        "description": {
            "texte": "Compares two null-terminated byte strings lexicographically.The sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as unsigned char) that differ in the strings being compared.The behavior is undefined if lhs or rhs are not pointers to null-terminated strings."
        },
        "parametres": "   lhs, rhs   -   pointers to the null-terminated byte strings to compare \n\n",
        "exemple": {
            "input": "#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n \nint main() \n{\n    std::vector<const char*> cats {\"Heathcliff\", \"Snagglepuss\", \"Hobbes\", \"Garfield\"};\n    std::sort(cats.begin(), cats.end(), [](const char *strA, const char *strB) {\n        return std::strcmp(strA, strB) < 0;\n    }); \n \n    for (const char *cat : cats) {\n        std::cout << cat << '\\n';\n    }\n}",
            "output": "Garfield\nHeathcliff\nHobbes\nSnagglepuss"
        }
    },
    "strncmp": {
        "description": {
            "texte": "Compares at most count characters of two null-terminated byte strings. The comparison is done lexicographically.The sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as unsigned char) that differ in the strings being compared.The behavior is undefined if lhs or rhs are not pointers to null-terminated strings.Characters following the null character are not compared."
        },
        "parametres": "   lhs, rhs   -   pointers to the null-terminated byte strings to compare \n   count   -   maximum number of characters to compare \n\n",
        "exemple": {
            "input": "#include <cstring>\n#include <iostream>\n \nvoid demo(const char* lhs, const char* rhs, int sz)\n{\n    int rc = std::strncmp(lhs, rhs, sz);\n    if(rc == 0)\n        std::cout << \"First \" << sz << \" chars of [\"\n                  << lhs << \"] equal [\" << rhs << \"]\\n\";\n    else if(rc < 0)\n        std::cout << \"First \" << sz << \" chars of [\"\n                  << lhs << \"] precede [\" << rhs << \"]\\n\";\n    else if(rc > 0)\n        std::cout << \"First \" << sz << \" chars of [\"\n                  << lhs << \"] follow [\" << rhs << \"]\\n\";\n}\nint main()\n{\n    demo(\"Hello, world!\", \"Hello, everybody!\", 13);\n    demo(\"Hello, everybody!\", \"Hello, world!\", 13);\n    demo(\"Hello, everybody!\", \"Hello, world!\", 7);\n    demo(\"Hello, everybody!\" + 12, \"Hello, somebody!\" + 11, 5);\n}",
            "output": "First 13 chars of [Hello, world!] follow [Hello, everybody!]\nFirst 13 chars of [Hello, everybody!] precede [Hello, world!]\nFirst 7 chars of [Hello, everybody!] equal [Hello, world!]\nFirst 5 chars of [body!] equal [body!]"
        }
    },
    "strcoll": {
        "description": {
            "texte": "Compares two null-terminated byte strings according to the current locale as defined by the LC_COLLATE category."
        },
        "parametres": "   lhs, rhs   -   pointers to the null-terminated byte strings to compare \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstring>\n#include <clocale>\n \nint main()\n{\n    std::setlocale(LC_COLLATE, \"cs_CZ.iso88592\");\n \n    const char* s1 = \"hrnec\";\n    const char* s2 = \"chrt\";\n \n    std::cout << \"In the Czech locale: \";\n    if(std::strcoll(s1, s2) < 0)\n         std::cout << s1 << \" before \" << s2 << '\\n';\n    else\n         std::cout << s2 << \" before \" << s1 << '\\n';\n \n    std::cout << \"In lexicographical comparison: \";\n    if(std::strcmp(s1, s2) < 0)\n         std::cout << s1 << \" before \" << s2 << '\\n';\n    else\n         std::cout << s2 << \" before \" << s1 << '\\n';\n}",
            "output": "In the Czech locale: hrnec before chrt\nIn lexicographical comparison: chrt before hrnec"
        }
    },
    "strchr": {
        "description": {
            "texte": "Finds the first occurrence of the character static_cast<char>(ch) in the byte string pointed to by str.The terminating null character is considered to be a part of the string and can be found if searching for '\\0'."
        },
        "parametres": "   str   -   pointer to the null-terminated byte string to be analyzed \n   ch   -   character to search for \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstring>\n \nint main()\n{\n  const char *str = \"Try not. Do, or do not. There is no try.\";\n  char target = 'T';\n  const char *result = str;\n \n  while ((result = std::strchr(result, target)) != NULL) {\n    std::cout << \"Found '\" << target\n              << \"' starting at '\" << result << \"'\\n\";\n \n    // Increment result, otherwise we'll find target at the same location\n    ++result;\n  }\n}",
            "output": "Found 'T' starting at 'Try not. Do, or do not. There is no try.'\nFound 'T' starting at 'There is no try.'"
        }
    },
    "strrchr": {
        "description": {
            "texte": "Finds the last occurrence of ch (after conversion to char) in the byte string pointed to by str. The terminating null character is considered to be a part of the string and can be found if searching for '\\0'."
        },
        "parametres": "   str   -   pointer to the null-terminated byte string to be analyzed \n   ch   -   character to search for \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstring>\n \nint main()\n{\n    char input[] = \"/home/user/hello.c\";\n    char* output = std::strrchr(input, '/');\n    if(output)\n        std::cout << output+1 << '\\n';\n}",
            "output": "hello.c"
        }
    },
    "strspn": {
        "description": {
            "texte": "Returns the length of the maximum initial segment (span) of the byte string pointed to by dest, that consists of only the characters found in byte string pointed to by src."
        },
        "parametres": "   dest   -   pointer to the null-terminated byte string to be analyzed \n   src   -   pointer to the null-terminated byte string that contains the characters to search for \n\n",
        "exemple": {
            "input": "#include <cstring>\n#include <string>\n#include <iostream>\n \nconst char *low_alpha = \"qwertyuiopasdfghjklzxcvbnm\";\nint main()\n{\n    std::string s = \"abcde312$#@\";\n \n    std::size_t spnsz = std::strspn(s.c_str(), low_alpha);\n    std::cout << \"After skipping initial lowercase letters from '\" << s\n              << \"'\\nThe remainder is '\" << s.substr(spnsz) << \"'\\n\";\n}",
            "output": "After skipping initial lowercase letters from 'abcde312$#@'\nThe remainder is '312$#@'"
        }
    },
    "strcspn": {
        "description": {
            "texte": "Returns the length of the maximum initial segment of the byte string pointed to by dest, that consists of only the characters not found in byte string pointed to by src.The function name stands for \"complementary span\""
        },
        "parametres": "   dest   -   pointer to the null-terminated byte string to be analyzed \n   src   -   pointer to the null-terminated byte string that contains the characters to search for \n\n",
        "exemple": {
            "input": "#include <string>\n#include <cstring>\n#include <iostream>\n \nconst char* invalid = \"*$#\";\nint main()\n{\n    std::string s = \"abcde312$#@\";\n \n    size_t valid_len = std::strcspn(s.c_str(), invalid);\n    if(valid_len != s.size())\n       std::cout << \"'\" << s << \"' contains invalid chars starting at position \"\n                 << valid_len << '\\n';\n}",
            "output": "'abcde312$#@' contains invalid chars starting at position 8"
        }
    },
    "strpbrk": {
        "description": {
            "texte": "Scans the null-terminated byte string pointed to by dest for any character from the null-terminated byte string pointed to by breakset, and returns a pointer to that character."
        },
        "parametres": "   dest   -   pointer to the null-terminated byte string to be analyzed \n   breakset   -   pointer to the null-terminated byte string that contains the characters to search for \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstring>\n#include <iomanip>\n \nint main()\n{\n    const char* str = \"hello world, friend of mine!\";\n    const char* sep = \" ,!\";\n \n    unsigned int cnt = 0;\n    do {\n       str = std::strpbrk(str, sep); // find separator\n       std::cout << std::quoted(str) << '\\n';\n       if(str) str += std::strspn(str, sep); // skip separator\n       ++cnt; // increment word count\n    } while(str && *str);\n \n    std::cout << \"There are \" << cnt << \" words\\n\";\n}",
            "output": "\" world, friend of mine!\"\n\", friend of mine!\"\n\" of mine!\"\n\" mine!\"\n\"!\"\nThere are 5 words"
        }
    },
    "strstr": {
        "description": {
            "texte": "Finds the first occurrence of the byte string target in the byte string pointed to by str. The terminating null characters are not compared."
        },
        "parametres": "   str   -   pointer to the null-terminated byte string to examine \n   target   -   pointer to the null-terminated byte string to search for \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstring>\n \nint main()\n{\n    const char *str = \"Try not. Do, or do not. There is no try.\";\n    const char *target = \"not\";\n    const char *result = str;\n \n    while ((result = std::strstr(result, target)) != NULL) {\n        std::cout << \"Found '\" << target \n                  << \"' starting at '\" << result << \"'\\n\";\n \n        // Increment result, otherwise we'll find target at the same location\n        ++result;\n    }   \n}",
            "output": "Found 'not' starting at 'not. Do, or do not. There is no try.'\nFound 'not' starting at 'not. There is no try.'"
        }
    },
    "strtok": {
        "description": {
            "texte": "Finds the next token in a null-terminated byte string pointed to by str. The separator characters are identified by null-terminated byte string pointed to by delim.This function is designed to be called multiple times to obtain successive tokens from the same string."
        },
        "parametres": "   str   -   pointer to the null-terminated byte string to tokenize \n   delim   -   pointer to the null-terminated byte string identifying delimiters \n\n",
        "exemple": {
            "input": "#include <cstring>\n#include <iostream>\n \nint main() \n{\n    char input[100] = \"A bird came down the walk\";\n    char *token = std::strtok(input, \" \");\n    while (token != NULL) {\n        std::cout << token << '\\n';\n        token = std::strtok(NULL, \" \");\n    }\n}",
            "output": "A\nbird\ncame\ndown\nthe\nwalk"
        }
    },
    "memchr": {
        "description": {
            "texte": "Converts ch to unsigned char and locates the first occurrence of that value in the initial count characters (each interpreted as unsigned char) of the object pointed to by ptr."
        },
        "parametres": "   ptr   -   pointer to the object to be examined \n   ch   -   character to search for \n   count   -   max number of characters to examine \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstring>\n \nint main()\n{\n    char arr[] = {'a','\\0','a','A','a','a','A','a'};\n    char *pc = (char*)std::memchr(arr,'A',sizeof arr);\n    if (pc != NULL)\n       std::cout << \"search character found\\n\";\n    else\n       std::cout << \"search character not found\\n\";\n}",
            "output": "search character found"
        }
    },
    "memcmp": {
        "description": {
            "texte": "Reinterprets the objects pointed to by lhs and rhs as arrays of unsigned char and compares the first count characters of these arrays. The comparison is done lexicographically.The sign of the result is the sign of the difference between the values of the first pair of bytes (both interpreted as unsigned char) that differ in the objects being compared."
        },
        "parametres": "   lhs, rhs   -   pointers to the memory buffers to compare \n   count   -   number of bytes to examine \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstring>\n \nvoid demo(const char* lhs, const char* rhs, std::size_t sz)\n{\n    std::cout << std::string(lhs, sz);\n    int rc = std::memcmp(lhs, rhs, sz);\n    if(rc == 0)\n        std::cout << \" compares equal to \";\n    else if(rc < 0)\n        std::cout << \" precedes \";\n    else if(rc > 0)\n        std::cout << \" follows \";\n    std::cout << std::string(rhs, sz) << \" in lexicographical order\\n\";\n}\n \nint main()\n{\n    char a1[] = {'a','b','c'};\n    char a2[sizeof a1] = {'a','b','d'};\n \n    demo(a1, a2, sizeof a1);\n    demo(a2, a1, sizeof a1);\n    demo(a1, a1, sizeof a1);\n}",
            "output": "abc precedes abd in lexicographical order\nabd follows abc in lexicographical order\nabc compares equal to abc in lexicographical order"
        }
    },
    "memset": {
        "description": {
            "texte": "Converts the value ch to unsigned char and copies it into each of the first count characters of the object pointed to by dest. If the object is a potentially-overlapping subobject or is not TriviallyCopyable (e.g., scalar, C-compatible struct, or an array of trivially copyable type), the behavior is undefined. If count is greater than the size of the object pointed to by dest, the behavior is undefined."
        },
        "parametres": "   dest   -   pointer to the object to fill \n   ch   -   fill byte \n   count   -   number of bytes to fill \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstring>\n \nint main()\n{\n    int a[20];\n    std::memset(a, 0, sizeof a);\n    for (int ai : a) std::cout << ai;\n}",
            "output": "00000000000000000000"
        }
    },
    "memcpy": {
        "description": {
            "texte": "Copies count bytes from the object pointed to by src to the object pointed to by dest. Both objects are reinterpreted as arrays of unsigned char.If the objects overlap, the behavior is undefined.If either dest or src is a null pointer, the behavior is undefined, even if count is zero.If the objects are potentially-overlapping or not TriviallyCopyable, the behavior of memcpy is not specified and may be undefined."
        },
        "parametres": "   dest   -   pointer to the memory location to copy to \n   src   -   pointer to the memory location to copy from \n   count   -   number of bytes to copy \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstdint>\n#include <cstring>\n \nint main()\n{\n    // simple usage\n    char source[] = \"once upon a midnight dreary...\", dest[4];\n    std::memcpy(dest, source, sizeof dest);\n    for (char c : dest)\n        std::cout << c << '\\n';\n \n    // reinterpreting\n    double d = 0.1;\n//  std::int64_t n = *reinterpret_cast<std::int64_t*>(&d); // aliasing violation\n    std::int64_t n;\n    std::memcpy(&n, &d, sizeof d); // OK\n \n    std::cout << std::hexfloat << d << \" is \" << std::hex << n\n              << \" as an std::int64_t\\n\";\n}",
            "output": "o\nn\nc\ne\n0x1.999999999999ap-4 is 3fb999999999999a as an std::int64_t"
        }
    },
    "memmove": {
        "description": {
            "texte": "Copies count characters from the object pointed to by src to the object pointed to by dest. Both objects are reinterpreted as arrays of unsigned char.The objects may overlap: copying takes place as if the characters were copied to a temporary character array and then the characters were copied from the array to dest.If the objects are potentially-overlapping or not TriviallyCopyable, the behavior of memmove is not specified and may be undefined."
        },
        "parametres": "   dest   -   pointer to the memory location to copy to \n   src   -   pointer to the memory location to copy from \n   count   -   number of bytes to copy \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstring>\n \nint main()\n{\n    char str[] = \"1234567890\";\n    std::cout << str << '\\n';\n    std::memmove(str + 4, str + 3, 3); // copies from [4, 5, 6] to [5, 6, 7]\n    std::cout << str << '\\n';\n}",
            "output": "1234567890\n1234456890"
        }
    },
    "strerror": {
        "description": {
            "texte": "Returns a pointer to the textual description of the system error code errnum, identical to the description that would be printed by std::perror().errnum is usually acquired from the errno variable, however the function accepts any value of type int. The contents of the string are locale-specific.The returned string must not be modified by the program, but may be overwritten by a subsequent call to the strerror function. strerror is not required to be thread-safe. Implementations may be returning different pointers to static read-only string literals or may be returning the same pointer over and over, pointing at a static buffer in which strerror places the string."
        },
        "parametres": "   errnum   -   integral value referring to a error code \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <clocale>\n \nint main()\n{\n    double not_a_number = std::log(-1.0);\n    if (errno == EDOM) {\n        std::cout << \"log(-1) failed: \" << std::strerror(errno) << '\\n';\n        std::setlocale(LC_MESSAGES, \"de_DE.utf8\");\n        std::cout << \"Or, in German, \" << std::strerror(errno) << '\\n';\n    }\n}",
            "output": "log(-1) failed: Numerical argument out of domain\nOr, in German, Das numerische Argument ist ausserhalb des Definitionsbereiches"
        }
    },
    "as_bytes, std::as_writable_bytes": {
        "description": {
            "texte": "Obtains a view to the object representation of the elements of the span s.If N is std::dynamic_extent, the extent of the returned span S is also std::dynamic_extent; otherwise it is sizeof(T) * N.as_writable_bytes only participates in overload resolution if std::is_const_v<T> is false."
        }
    },
    "dynamic_extent": {
        "description": {
            "texte": "std::dynamic_extent is a constant of type std::size_t that is used to differentiate std::span of static and dynamic extent."
        }
    },
    "tuple_size(std::array)\n": {
        "description": {
            "texte": "Provides access to the number of elements in an std::array as a compile-time constant expression."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <array>\n \ntemplate<class T>\nvoid test(T t)\n{\n    int a[std::tuple_size<T>::value]; // can be used at compile time\n    std::cout << std::tuple_size<T>::value << '\\n';\n}\n \nint main()\n{\n    std::array<float, 3> arr;\n    test(arr);\n}",
            "output": "3"
        }
    },
    "operator==,!=,,>=(std::array)": {
        "description": {
            "texte": "Compares the contents of two arrays."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to compare \n   -T must meet the requirements of EqualityComparable in order to use overloads (1-2). \n   -T must meet the requirements of LessThanComparable in order to use overloads (3-6). The ordering relation must establish total order. \n\n"
    },
    "get(std::array)\n": {
        "description": {
            "texte": "Extracts the Ith element element from the array.I must be an integer value in range [0, N). This is enforced at compile time as opposed to at() or operator[]."
        },
        "parametres": "   a   -   array whose contents to extract \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <array>\n \nint main()\n{\n    std::array<int, 3> arr;\n \n    // set values:\n    std::get<0>(arr) = 1;\n    std::get<1>(arr) = 2;\n    std::get<2>(arr) = 3;\n \n    // get values:\n    std::cout << \"(\" << std::get<0>(arr) << \", \" << std::get<1>(arr)\n              << \", \" << std::get<2>(arr) << \")\\n\";\n}",
            "output": "(1, 2, 3)"
        }
    },
    "swap(std::array)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::array. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to swap \n\n"
    },
    "vector": {
        "description": {
            "texte": "std::vector<bool> is a possibly space-efficient specialization of std::vector for the type bool.The manner in which std::vector<bool> is made space efficient (as well as whether it is optimized at all) is implementation defined. One potential optimization involves coalescing vector elements such that each element occupies a single bit instead of sizeof(bool) bytes.std::vector<bool> behaves similarly to std::vector, but in order to be space efficient, it:"
        }
    },
    "hash (std::vector)\n": {
        "description": {
            "texte": "The template specialization of std::hash for std::vector<bool> allows users to obtain hashes of objects of type std::vector<bool>."
        }
    },
    "operator==,!=,,>=(std::vector)": {
        "description": {
            "texte": "Compares the contents of two containers."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to compare \n   -T must meet the requirements of EqualityComparable in order to use overloads (1-2). \n   -T must meet the requirements of LessThanComparable in order to use overloads (3-6). The ordering relation must establish total order. \n\n"
    },
    "swap(std::vector)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::vector. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to swap \n\n"
    },
    "operator==,!=,,>=(std::deque)": {
        "description": {
            "texte": "Compares the contents of two containers."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to compare \n   -T must meet the requirements of EqualityComparable in order to use overloads (1-2). \n   -T must meet the requirements of LessThanComparable in order to use overloads (3-6). The ordering relation must establish total order. \n\n"
    },
    "swap(std::deque)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::deque. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to swap \n\n"
    },
    "operator==,!=,,>=(std::forward_list)": {
        "description": {
            "texte": "Compares the contents of two containers."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to compare \n   -T must meet the requirements of EqualityComparable in order to use overloads (1-2). \n   -T must meet the requirements of LessThanComparable in order to use overloads (3-6). The ordering relation must establish total order. \n\n"
    },
    "swap(std::forward_list)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::forward_list. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to swap \n\n"
    },
    "operator==,!=,,>=(std::list)": {
        "description": {
            "texte": "Compares the contents of two containers."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to compare \n   -T must meet the requirements of EqualityComparable in order to use overloads (1-2). \n   -T must meet the requirements of LessThanComparable in order to use overloads (3-6). The ordering relation must establish total order. \n\n"
    },
    "swap(std::list)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::list. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to swap \n\n"
    },
    "operator==,!=,,>=(std::map)": {
        "description": {
            "texte": "Compares the contents of two containers."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to compare \n   -T, Key must meet the requirements of EqualityComparable in order to use overloads (1-2). \n   -Key must meet the requirements of LessThanComparable in order to use overloads (3-6). The ordering relation must establish total order. \n\n"
    },
    "swap(std::map)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::map. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to swap \n\n"
    },
    "operator==,!=,,>=(std::multimap)": {
        "description": {
            "texte": "Compares the contents of two containers."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to compare \n   -T, Key must meet the requirements of EqualityComparable in order to use overloads (1-2). \n   -Key must meet the requirements of LessThanComparable in order to use overloads (3-6). The ordering relation must establish total order. \n\n"
    },
    "swap(std::multimap)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::multimap. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to swap \n\n"
    },
    "operator==,!=,,>=(std::set)": {
        "description": {
            "texte": "Compares the contents of two containers."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to compare \n   -Key must meet the requirements of EqualityComparable in order to use overloads (1-2). \n\n"
    },
    "swap(std::set)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::set. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to swap \n\n"
    },
    "operator==,!=,,>=(std::multiset)": {
        "description": {
            "texte": "Compares the contents of two containers."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to compare \n   -Key must meet the requirements of EqualityComparable in order to use overloads (1-2). \n\n"
    },
    "swap(std::multiset)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::multiset. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to swap \n\n"
    },
    "operator==,!=,,>=(std::queue)": {
        "description": {
            "texte": "Compares the contents of the underlying containers of two container adaptors. The comparison is done by applying the corresponding operator to the underlying containers."
        },
        "parametres": "   lhs, rhs   -   container adaptors whose contents to compare \n   -T must meet the requirements of EqualityComparable. \n\n"
    },
    "swap(std::queue)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::queue. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to swap \n\n"
    },
    "swap(std::priority_queue)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::priority_queue. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to swap \n\n"
    },
    "operator==,!=(std::unordered_map)\n": {
        "description": {
            "texte": "Compares the contents of two unordered containers.The contents of two unordered containers lhs and rhs are equal if the following conditions hold:The behavior is undefined if Key or T are not EqualityComparable.The behavior is also undefined if hash_function() and key_eq() do (until C++20)key_eq() does (since C++20) not have the same behavior on lhs and rhs or if operator== for Key is not a refinement of the partition into equivalent-key groups introduced by key_eq() (that is, if two elements that compare equal using operator== fall into different partitions)."
        },
        "parametres": "   lhs, rhs   -   unordered containers to compare \n\n"
    },
    "swap(std::unordered_map)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::unordered_map. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to swap \n\n"
    },
    "operator==,!=(std::unordered_multimap)\n": {
        "description": {
            "texte": "Compares the contents of two unordered containers.The contents of two unordered containers lhs and rhs are equal if the following conditions hold:The behavior is undefined if Key or T are not EqualityComparable.The behavior is also undefined if hash_function() and key_eq() do (until C++20)key_eq() does (since C++20) not have the same behavior on lhs and rhs or if operator== for Key is not a refinement of the partition into equivalent-key groups introduced by key_eq() (that is, if two elements that compare equal using operator== fall into different partitions)."
        },
        "parametres": "   lhs, rhs   -   unordered containers to compare \n\n"
    },
    "swap(std::unordered_multimap)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::unordered_multimap. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to swap \n\n"
    },
    "operator==,!=(std::unordered_set)\n": {
        "description": {
            "texte": "Compares the contents of two unordered containers.The contents of two unordered containers lhs and rhs are equal if the following conditions hold:The behavior is undefined if Key is not EqualityComparable.The behavior is also undefined if hash_function() and key_eq() do (until C++20)key_eq() does (since C++20) not have the same behavior on lhs and rhs or if operator== for Key is not a refinement of the partition into equivalent-key groups introduced by key_eq() (that is, if two elements that compare equal using operator== fall into different partitions)."
        },
        "parametres": "   lhs, rhs   -   unordered containers to compare \n\n"
    },
    "swap(std::unordered_set)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::unordered_set. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to swap \n\n"
    },
    "operator==,!=(std::unordered_multiset)\n": {
        "description": {
            "texte": "Compares the contents of two unordered containers.The contents of two unordered containers lhs and rhs are equal if the following conditions hold:The behavior is undefined if Key is not EqualityComparable.The behavior is also undefined if hash_function() and key_eq() do (until C++20)key_eq() does (since C++20) not have the same behavior on lhs and rhs or if operator== for Key is not a refinement of the partition into equivalent-key groups introduced by key_eq() (that is, if two elements that compare equal using operator== fall into different partitions)."
        },
        "parametres": "   lhs, rhs   -   unordered containers to compare \n\n"
    },
    "swap(std::unordered_multiset)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::unordered_multiset. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to swap \n\n"
    },
    "operator==,!=,,>=(std::stack)": {
        "description": {
            "texte": "Compares the contents of the underlying containers of two container adaptors. The comparison is done by applying the corresponding operator to the underlying containers."
        },
        "parametres": "   lhs, rhs   -   container adaptors whose contents to compare \n   -T must meet the requirements of EqualityComparable. \n\n"
    },
    "swap(std::stack)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::stack. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   containers whose contents to swap \n\n"
    },
    "operator,>=(std::move_iterator)\n": {
        "description": {
            "texte": "Compares the underlying iterators."
        },
        "parametres": "   lhs, rhs   -   iterator adaptors to compare \n\n"
    },
    "operator-(std::move_iterator)\n": {
        "description": {
            "texte": "Returns the distance between two iterator adaptors."
        },
        "parametres": "   lhs, rhs   -   iterator adaptors to compute the difference of \n\n"
    },
    "operator,>=(std::reverse_iterator)\n": {
        "description": {
            "texte": "Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed."
        },
        "parametres": "   lhs, rhs   -   iterator adaptors to compare \n\n"
    },
    "operator-(std::reverse_iterator)\n": {
        "description": {
            "texte": "Returns the distance between two iterator adaptors."
        },
        "parametres": "   lhs, rhs   -   iterator adaptors to compute the difference of \n\n"
    },
    "operator==,!=(std::istream_iterator)": {
        "description": {
            "texte": "Checks whether both lhs and rhs are equal. Two stream iterators are equal if both of them are end-of-stream iterators or both of them refer to the same stream."
        },
        "parametres": "   lhs, rhs   -   stream iterators to compare \n\n"
    },
    "operator==,!=(std::istreambuf_iterator)": {
        "description": {
            "texte": "Checks whether both lhs and rhs are valid, or both are invalid, regardless of the stream buffer objects they use."
        },
        "parametres": "   lhs, rhs   -   stream buffer iterators to compare \n\n"
    },
    "ranges::all_of, std::ranges::any_of, std::ranges::none_of": {
        "description": {
            "texte": "The function-like entities described on this page are niebloids, that is:In practice, they may be implemented as function objects, or with special compiler extensions."
        },
        "parametres": "   first, last   -   the range of the elements to examine \n   r   -   the range of the elements to examine \n   pred   -   predicate to apply to the projected elements \n   proj   -   projection to apply to the elements \n\n",
        "exemple": {
            "input": "#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <iterator>\n#include <iostream>\n#include <functional>\n \nnamespace ranges = std::ranges;\n \nint main()\n{\n    std::vector<int> v(10, 2);\n    std::partial_sum(v.cbegin(), v.cend(), v.begin());\n    std::cout << \"Among the numbers: \";\n    ranges::copy(v, std::ostream_iterator<int>(std::cout, \" \"));\n    std::cout << '\\n';\n \n    if (ranges::all_of(v.cbegin(), v.cend(), [](int i){ return i % 2 == 0; })) {\n        std::cout << \"All numbers are even\\n\";\n    }\n    if (ranges::none_of(v, std::bind(std::modulus<int>(), std::placeholders::_1, 2))) {\n        std::cout << \"None of them are odd\\n\";\n    }\n    struct DivisibleBy\n    {\n        const int d;\n        DivisibleBy(int n) : d(n) {}\n        bool operator()(int n) const { return n % d == 0; }\n    };\n \n    if (ranges::any_of(v, DivisibleBy(7))) {\n        std::cout << \"At least one number is divisible by 7\\n\";\n    }\n}",
            "output": "Among the numbers: 2 4 6 8 10 12 14 16 18 20 \nAll numbers are even\nNone of them are odd\nAt least one number is divisible by 7"
        }
    },
    "complex::operator+(unary), operator-(unary)\n": {
        "description": {
            "texte": "Implements the analogs of the unary arithmetic operators for complex numbers."
        },
        "parametres": "   val   -   the complex number argument \n\n"
    },
    "operator+,-,*,/ (std::complex)": {
        "description": {
            "texte": "Implements the binary operators for complex arithmetic and for mixed complex/scalar arithmetic. Scalar arguments are treated as complex numbers with the real part equal to the argument and the imaginary part set to zero."
        },
        "parametres": "   lhs, rhs   -   the arguments: either both complex numbers or one complex and one scalar of matching type (float, double, long double) \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <complex>\nint main()\n{\n    std::complex<double> c2(2, 0);\n    std::complex<double> ci(0, 1);\n \n    std::cout << ci << \" + \" << c2 << \" = \" << ci+c2 << '\\n'\n              << ci << \" * \" << ci << \" = \" << ci*ci << '\\n'\n              << ci << \" + \" << c2 << \" / \" << ci << \" = \" << ci+c2/ci << '\\n'\n              << 1  << \" / \" << ci << \" = \" << 1./ci << '\\n';\n \n//    std::cout << 1.f/ci; // compile error\n//    std::cout << 1/ci; // compile error\n}",
            "output": "(0,1) + (2,0) = (2,1)\n(0,1) * (0,1) = (-1,0)\n(0,1) + (2,0) / (0,1) = (0,-1)\n1 / (0,1) = (0,-1)"
        }
    },
    "operator==,!=(std::complex)\n": {
        "description": {
            "texte": "Compares two complex numbers. Scalar arguments are treated as complex numbers with the real part equal to the argument and the imaginary part set to zero."
        },
        "parametres": "   lhs, rhs   -   the arguments to compare: either both complex numbers or one complex and one scalar of matching type (float, double, long double) \n\n"
    },
    "operator>(std::complex)\n": {
        "description": {
            "texte": "Where the input for real and imaginary must be convertible to T.  If an error occurs calls is.setstate(ios_base::failbit)."
        },
        "parametres": "   os   -   a character output stream \n   is   -   a character input stream \n   x   -   the complex number to be inserted or extracted \n\n"
    },
    "real(std::complex)": {
        "description": {
            "texte": "the real component of z."
        },
        "parametres": "   z   -   complex value \n\n"
    },
    "imag(std::complex)": {
        "description": {
            "texte": "the imaginary component of z."
        },
        "parametres": "   z   -   complex value \n\n"
    },
    "abs(std::complex)": {
        "description": {
            "texte": "Returns the magnitude of the complex number z."
        },
        "parametres": "   z   -   complex value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <complex>\n \nint main()\n{\n    std::complex<double> z(1, 1);\n    std::cout << z << \" cartesian is rho = \" << std::abs(z)\n              << \" theta = \" << std::arg(z) << \" polar\\n\";\n}",
            "output": "(1,1) cartesian is rho = 1.41421 theta = 0.785398 polar"
        }
    },
    "arg(std::complex)": {
        "description": {
            "texte": "Calculates the phase angle (in radians) of the complex number z.(since C++11)Additional overloads are provided for float, double, long double, and all integer types, which are treated as complex numbers with zero imaginary component."
        },
        "parametres": "   z   -   complex value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <complex>\n \nint main() \n{\n    std::complex<double> z1(1, 0); \n    std::cout << \"phase angle of \" << z1 << \" is \" << std::arg(z1) << '\\n';\n \n    std::complex<double> z2(0, 1); \n    std::cout << \"phase angle of \" << z2 << \" is \" << std::arg(z2) << '\\n';\n \n    std::complex<double> z3(-1, 0); \n    std::cout << \"phase angle of \" << z3 << \" is \" << std::arg(z3) << '\\n';\n \n    std::complex<double> z4(-1, -0.0); \n    std::cout << \"phase angle of \" << z4 << \" (the other side of the cut) is \"\n              << std::arg(z4) << '\\n';\n}",
            "output": "phase angle of (1,0) is 0\nphase angle of (0,1) is 1.5708\nphase angle of (-1,0) is 3.14159\nphase angle of (-1,-0) (the other side of the cut) is -3.14159"
        }
    },
    "norm(std::complex)": {
        "description": {
            "texte": "the squared magnitude of z."
        },
        "parametres": "   z   -   complex value \n\n"
    },
    "conj(std::complex)": {
        "description": {
            "texte": "The complex conjugate of z."
        },
        "parametres": "   z   -   complex value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <complex>\n \nint main()\n{\n    std::complex<double> z(1,2);\n    std::cout << \"The conjugate of \" << z << \" is \" << std::conj(z) << '\\n'\n              << \"Their product is \" << z*std::conj(z) << '\\n';\n}",
            "output": "The conjugate of (1,2) is (1,-2)\nTheir product is (5,0)"
        }
    },
    "proj(std::complex)": {
        "description": {
            "texte": "Returns the projection of the complex number z onto the Riemann sphere.For most z, std::proj(z)==z, but all complex infinities, even the numbers where one component is infinite and the other is NaN, become positive real infinity, (INFINITY, 0) or (INFINITY, -0). The sign of the imaginary (zero) component is the sign of std::imag(z).Additional overloads are provided for float, double, long double, and all integer types, which are treated as complex numbers with zero imaginary component."
        },
        "parametres": "   z   -   complex value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <complex>\n \nint main()\n{\n    std::complex<double> c1(1, 2);\n    std::cout << \"proj\" << c1 << \" = \" << std::proj(c1) << '\\n';\n \n    std::complex<double> c2(INFINITY, -1);\n    std::cout << \"proj\" << c2 << \" = \" << std::proj(c2) << '\\n';\n \n    std::complex<double> c3(0, -INFINITY);\n    std::cout << \"proj\" << c3 << \" = \" << std::proj(c3) << '\\n';\n}",
            "output": "proj(1,2) = (1,2)\nproj(inf,-1) = (inf,-0)\nproj(0,-inf) = (inf,-0)"
        }
    },
    "polar(std::complex)": {
        "description": {
            "texte": "Returns a complex number with magnitude r and phase angle theta.The behavior is undefined if r is negative or NaN, or if theta is infinite."
        },
        "parametres": "   r   -   magnitude \n   theta   -   phase angle \n\n"
    },
    "exp(std::complex)": {
        "description": {
            "texte": "Compute base-e exponential of z, that is e (Euler's number, 2.7182818) raised to the z power."
        },
        "parametres": "   z   -   complex value \n\n",
        "exemple": {
            "input": "#include <complex>\n#include <iostream>\n \nint main()\n{\n   const double pi = std::acos(-1);\n   const std::complex<double> i(0, 1);\n \n   std::cout << std::fixed << \" exp(i*pi) = \" << std::exp(i * pi) << '\\n';\n}",
            "output": "exp(i*pi) = (-1.000000,0.000000)"
        }
    },
    "log(std::complex)": {
        "description": {
            "texte": "Computes complex natural (base e) logarithm of a complex value z with a branch cut along the negative real axis."
        },
        "parametres": "   z   -   complex value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <complex>\n \nint main()\n{\n    std::complex<double> z(0, 1); // // r = 1, \u03b8 = pi/2\n    std::cout << \"2*log\" << z << \" = \" << 2.*std::log(z) << '\\n';\n \n    std::complex<double> z2(sqrt(2)/2, sqrt(2)/2); // r = 1, \u03b8 = pi/4\n    std::cout << \"4*log\" << z2 << \" = \" << 4.*std::log(z2) << '\\n';\n \n    std::complex<double> z3(-1, 0); // r = 1, \u03b8 = pi\n    std::cout << \"log\" << z3 << \" = \" << std::log(z3) << '\\n';\n    std::complex<double> z4(-1, -0.0); // the other side of the cut\n    std::cout << \"log\" << z4 << \" (the other side of the cut) = \" << std::log(z4) << '\\n';\n}",
            "output": "2*log(0,1) = (0,3.14159)\n4*log(0.707107,0.707107) = (0,3.14159)\nlog(-1,0) = (0,3.14159)\nlog(-1,-0) (the other side of the cut) = (0,-3.14159)"
        }
    },
    "log10(std::complex)": {
        "description": {
            "texte": "Computes complex common (base 10) logarithm of a complex value z with a branch cut along the negative real axis.The behavior of this function is equivalent to std::log(z)/std::log(T(10))."
        },
        "parametres": "   z   -   complex value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <complex>\n \nint main()\n{\n    std::complex<double> z(0, 1); // // r = 0, \u03b8 = pi/2\n    std::cout << \"2*log10\" << z << \" = \" << 2.*std::log10(z) << '\\n';\n \n    std::complex<double> z2(sqrt(2)/2, sqrt(2)/2); // r = 1, \u03b8 = pi/4\n    std::cout << \"4*log10\" << z2 << \" = \" << 4.*std::log10(z2) << '\\n';\n \n    std::complex<double> z3(-100, 0); // r = 100, \u03b8 = pi\n    std::cout << \"log10\" << z3 << \" = \" << std::log10(z3) << '\\n';\n    std::complex<double> z4(-100, -0.0); // the other side of the cut\n    std::cout << \"log10\" << z4 << \" (the other side of the cut) = \"\n              << std::log10(z4) << '\\n'\n              << \"(note: pi/log(10) = \" << acos(-1)/log(10) << \")\\n\";\n}",
            "output": "2*log10(0,1) = (0,1.36438)\n4*log10(0.707107,0.707107) = (0,1.36438)\nlog10(-100,0) = (2,1.36438)\nlog10(-100,-0) (the other side of the cut) = (2,-1.36438)\n(note: pi/log(10) = 1.36438)"
        }
    },
    "pow(std::complex)": {
        "description": {
            "texte": "If no errors occur, the complex power xy, is returned.Errors and special cases are handled as if the operation is implemented by std::exp(y*std::log(x)).The result of std::pow(0, 0) is implementation-defined."
        },
        "parametres": "   x   -   base as a complex value \n   y   -   exponent as a complex value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n \n    std::complex<double> z(1, 2);\n    std::cout << \"(1,2)^2 = \" << std::pow(z, 2) << '\\n';\n \n    std::complex<double> z2(-1, 0);  // square root of -1\n    std::cout << \"-1^0.5 = \" << std::pow(z2, 0.5) << '\\n';\n \n    std::complex<double> z3(-1, -0.0);  // other side of the cut\n    std::cout << \"(-1, -0)^0.5 = \" << std::pow(z3, 0.5) << '\\n';\n \n    std::complex<double> i(0, 1); // i^i = exp(-pi/2)\n    std::cout << \"i^i = \" << std::pow(i, i) << '\\n';\n}",
            "output": "(1,2)^2 = (-3.000000,4.000000)\n-1^0.5 = (0.000000,1.000000)\n(-1, -0)^0.5 = (0.000000,-1.000000)\ni^i = (0.207880,0.000000)"
        }
    },
    "sqrt(std::complex)": {
        "description": {
            "texte": "Computes the square root of the complex number z with a branch cut along the negative real axis."
        },
        "parametres": "   z   -   complex number to take the square root of \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <complex>\n \nint main()\n{\n    std::cout << \"Square root of -4 is \"\n              << std::sqrt(std::complex<double>(-4, 0)) << '\\n'\n              << \"Square root of (-4,-0), the other side of the cut, is \"\n              << std::sqrt(std::complex<double>(-4, -0.0)) << '\\n';\n}",
            "output": "Square root of -4 is (0,2)\nSquare root of (-4,-0), the other side of the cut, is (0,-2)"
        }
    },
    "sin(std::complex)": {
        "description": {
            "texte": "Computes complex sine of a complex value z."
        },
        "parametres": "   z   -   complex value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z(1, 0); // behaves like real sine along the real line\n    std::cout << \"sin\" << z << \" = \" << std::sin(z)\n              << \" ( sin(1) = \" << std::sin(1) << \")\\n\";\n \n    std::complex<double> z2(0, 1); // behaves like sinh along the imaginary line\n    std::cout << \"sin\" << z2 << \" = \" << std::sin(z2)\n              << \" (sinh(1) = \" << std::sinh(1) << \")\\n\";\n}",
            "output": "sin(1.000000,0.000000) = (0.841471,0.000000) ( sin(1) = 0.841471)\nsin(0.000000,1.000000) = (0.000000,1.175201) (sinh(1) = 1.175201)"
        }
    },
    "cos(std::complex)": {
        "description": {
            "texte": "Computes complex cosine of a complex value z."
        },
        "parametres": "   z   -   complex value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z(1, 0); // behaves like real cosine along the real line\n    std::cout << \"cos\" << z << \" = \" << std::cos(z)\n              << \" ( cos(1) = \" << std::cos(1) << \")\\n\";\n \n    std::complex<double> z2(0, 1); // behaves like real cosh along the imaginary line\n    std::cout << \"cos\" << z2 << \" = \" << std::cos(z2)\n              << \" (cosh(1) = \" << std::cosh(1) << \")\\n\";\n}",
            "output": "cos(1.000000,0.000000) = (0.540302,-0.000000) ( cos(1) = 0.540302)\ncos(0.000000,1.000000) = (1.543081,-0.000000) (cosh(1) = 1.543081)"
        }
    },
    "tan(std::complex)": {
        "description": {
            "texte": "Computes complex tangent of a complex value z."
        },
        "parametres": "   z   -   complex value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z(1, 0); // behaves like real tangent along the real line\n    std::cout << \"tan\" << z << \" = \" << std::tan(z)\n              << \" ( tan(1) = \" << std::tan(1) << \")\\n\";\n \n    std::complex<double> z2(0, 1); // behaves like tanh along the imaginary line\n    std::cout << \"tan\" << z2 << \" = \" << std::tan(z2)\n              << \" (tanh(1) = \" << std::tanh(1) << \")\\n\";\n}",
            "output": "tan(1.000000,0.000000) = (1.557408,0.000000) ( tan(1) = 1.557408)\ntan(0.000000,1.000000) = (0.000000,0.761594) (tanh(1) = 0.761594)"
        }
    },
    "asin(std::complex)": {
        "description": {
            "texte": "Computes complex arc sine of a complex value z. Branch cut exists outside the interval [\u22121 ; +1] along the real axis."
        },
        "parametres": "   z   -   complex value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z1(-2, 0);\n    std::cout << \"acos\" << z1 << \" = \" << std::acos(z1) << '\\n';\n \n    std::complex<double> z2(-2, -0.0);\n    std::cout << \"acos\" << z2 << \" (the other side of the cut) = \"\n              << std::acos(z2) << '\\n';\n \n    // for any z, acos(z) = pi - acos(-z)\n    const double pi = std::acos(-1);\n    std::complex<double> z3 = pi - std::acos(z2);\n    std::cout << \"cos(pi - acos\" << z2 << \") = \" << std::cos(z3) << '\\n';\n}",
            "output": "asin(-2.000000,0.000000) = (-1.570796,1.316958)\nasin(-2.000000,-0.000000) (the other side of the cut) = (-1.570796,-1.316958)\nsin(acos(-2.000000,-0.000000) - pi/2) = (-2.000000,-0.000000)"
        }
    },
    "acos(std::complex)": {
        "description": {
            "texte": "Computes complex arc cosine of a complex value z. Branch cuts exist outside the interval [\u22121 ; +1] along the real axis."
        },
        "parametres": "   z   -   complex value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z1(-2, 0);\n    std::cout << \"acos\" << z1 << \" = \" << std::acos(z1) << '\\n';\n \n    std::complex<double> z2(-2, -0.0);\n    std::cout << \"acos\" << z2 << \" (the other side of the cut) = \"\n              << std::acos(z2) << '\\n';\n \n    // for any z, acos(z) = pi - acos(-z)\n    const double pi = std::acos(-1);\n    std::complex<double> z3 = pi - std::acos(z2);\n    std::cout << \"cos(pi - acos\" << z2 << \") = \" << std::cos(z3) << '\\n';\n}",
            "output": "acos(-2.000000,0.000000) = (3.141593,-1.316958)\nacos(-2.000000,-0.000000) (the other side of the cut) = (3.141593,1.316958)\ncos(pi - acos(-2.000000,-0.000000)) = (2.000000,0.000000)"
        }
    },
    "atan(std::complex)": {
        "description": {
            "texte": "Computes complex arc tangent of a complex value z. Branch cut exists outside the interval [\u2212i ; +i] along the imaginary axis."
        },
        "parametres": "   z   -   complex value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <complex>\n#include <cmath>\nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z1(0, 2);\n    std::cout << \"atan\" << z1 << \" = \" << std::atan(z1) << '\\n';\n \n    std::complex<double> z2(-0.0, 2);\n    std::cout << \"atan\" << z2 << \" (the other side of the cut) = \"\n              << std::atan(z2) << '\\n';\n \n    std::complex<double> z3(0, INFINITY);\n    std::cout << \"2*atan\" << z3 << \" = \" << 2.0*std::atan(z3) << '\\n';\n}",
            "output": "atan(0.000000,2.000000) = (1.570796,0.549306)\natan(-0.000000,2.000000) (the other side of the cut) = (-1.570796,0.549306)\n2*atan(0.000000,inf) = (3.141593,0.000000)"
        }
    },
    "sinh(std::complex)": {
        "description": {
            "texte": "Computes complex hyperbolic sine of a complex value z."
        },
        "parametres": "   z   -   complex value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z(1, 0); // behaves like real sinh along the real line\n    std::cout << \"sinh\" << z << \" = \" << std::sinh(z)\n              << \" (sinh(1) = \" << std::sinh(1) << \")\\n\";\n \n    std::complex<double> z2(0, 1); // behaves like sine along the imaginary line\n    std::cout << \"sinh\" << z2 << \" = \" << std::sinh(z2)\n              << \" ( sin(1) = \" << std::sin(1) << \")\\n\";\n}",
            "output": "sinh(1.000000,0.000000) = (1.175201,0.000000) (sinh(1) = 1.175201)\nsinh(0.000000,1.000000) = (0.000000,0.841471) ( sin(1) = 0.841471)"
        }
    },
    "cosh(std::complex)": {
        "description": {
            "texte": "Computes complex hyperbolic cosine of a complex value z."
        },
        "parametres": "   z   -   complex value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <complex>\n \nint main()\n{   \n    std::cout << std::fixed;\n    std::complex<double> z(1, 0); // behaves like real cosh along the real line\n    std::cout << \"cosh\" << z << \" = \" << std::cosh(z)\n              << \" (cosh(1) = \" << std::cosh(1) << \")\\n\";\n \n    std::complex<double> z2(0, 1); // behaves like real cosine along the imaginary line\n    std::cout << \"cosh\" << z2 << \" = \" << std::cosh(z2)\n              << \" ( cos(1) = \" << std::cos(1) << \")\\n\";\n}",
            "output": "cosh(1.000000,0.000000) = (1.543081,0.000000) (cosh(1) = 1.543081)\ncosh(0.000000,1.000000) = (0.540302,0.000000) ( cos(1) = 0.540302)"
        }
    },
    "tanh(std::complex)": {
        "description": {
            "texte": "Computes complex hyperbolic tangent of a complex value z."
        },
        "parametres": "   z   -   complex value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z(1, 0); // behaves like real tanh along the real line\n    std::cout << \"tanh\" << z << \" = \" << std::tanh(z)\n              << \" (tanh(1) = \" << std::tanh(1) << \")\\n\";\n \n    std::complex<double> z2(0, 1); // behaves like tangent along the imaginary line\n    std::cout << \"tanh\" << z2 << \" = \" << std::tanh(z2)\n              << \" ( tan(1) = \" << std::tan(1) << \")\\n\";\n}",
            "output": "tanh(1.000000,0.000000) = (0.761594,0.000000) (tanh(1) = 0.761594)\ntanh(0.000000,1.000000) = (0.000000,1.557408) ( tan(1) = 1.557408)"
        }
    },
    "asinh(std::complex)": {
        "description": {
            "texte": "Computes complex arc hyperbolic sine of a complex value z with branch cuts outside the interval [\u2212i; +i] along the imaginary axis."
        },
        "parametres": "   z   -   complex value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z1(0, -2);\n    std::cout << \"asinh\" << z1 << \" = \" << std::asinh(z1) << '\\n';\n \n    std::complex<double> z2(-0.0, -2);\n    std::cout << \"asinh\" << z2 << \" (the other side of the cut) = \"\n              << std::asinh(z2) << '\\n';\n \n    // for any z, asinh(z) = asin(iz)/i\n    std::complex<double> z3(1,2);\n    std::complex<double> i(0,1);\n    std::cout << \"asinh\" << z3 << \" = \" << std::asinh(z3) << '\\n'\n              << \"asin\" << z3*i << \"/i = \" << std::asin(z3*i)/i << '\\n';\n}",
            "output": "asinh(0.000000,-2.000000) = (1.316958,-1.570796)\nasinh(-0.000000,-2.000000) (the other side of the cut) = (-1.316958,-1.570796)\nasinh(1.000000,2.000000) = (1.469352,1.063440)\nasin(-2.000000,1.000000)/i = (1.469352,1.063440)"
        }
    },
    "acosh(std::complex)": {
        "description": {
            "texte": "Computes complex arc hyperbolic cosine of a complex value z with branch cut at values less than 1 along the real axis."
        },
        "parametres": "   z   -   complex value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z1(0.5, 0);\n    std::cout << \"acosh\" << z1 << \" = \" << std::acosh(z1) << '\\n';\n \n    std::complex<double> z2(0.5, -0.0);\n    std::cout << \"acosh\" << z2 << \" (the other side of the cut) = \"\n              << std::acosh(z2) << '\\n';\n \n    // in upper half-plane, acosh = i acos \n    std::complex<double> z3(1, 1), i(0, 1);\n    std::cout << \"acosh\" << z3 << \" = \" << std::acosh(z3) << '\\n'\n              << \"i*acos\" << z3 << \" = \" << i*std::acos(z3) << '\\n';\n}",
            "output": "acosh(0.500000,0.000000) = (0.000000,-1.047198)\nacosh(0.500000,-0.000000) (the other side of the cut) = (0.000000,1.047198)\nacosh(1.000000,1.000000) = (1.061275,0.904557)\ni*acos(1.000000,1.000000) = (1.061275,0.904557)"
        }
    },
    "atanh(std::complex)": {
        "description": {
            "texte": "Computes the complex arc hyperbolic tangent of z with branch cuts outside the interval [\u22121; +1] along the real axis."
        },
        "parametres": "   z   -   complex value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <complex>\n \nint main()\n{\n    std::cout << std::fixed;\n    std::complex<double> z1(2, 0);\n    std::cout << \"atanh\" << z1 << \" = \" << std::atanh(z1) << '\\n';\n \n    std::complex<double> z2(2, -0.0);\n    std::cout << \"atanh\" << z2 << \" (the other side of the cut) = \"\n              << std::atanh(z2) << '\\n';\n \n    // for any z, atanh(z) = atanh(iz)/i\n    std::complex<double> z3(1,2);\n    std::complex<double> i(0,1);\n    std::cout << \"atanh\" << z3 << \" = \" << std::atanh(z3) << '\\n'\n              << \"atan\" << z3*i << \"/i = \" << std::atan(z3*i)/i << '\\n';\n}",
            "output": "atanh(2.000000,0.000000) = (0.549306,1.570796)\natanh(2.000000,-0.000000) (the other side of the cut) = (0.549306,-1.570796)\natanh(1.000000,2.000000) = (0.173287,1.178097)\natan(-2.000000,1.000000)/i = (0.173287,1.178097)"
        }
    },
    "literals::complex_literals::operator\"\"i, operator\"\"if, operator\"\"il": {
        "description": {
            "texte": "Forms a std::complex literal representing an imaginary number."
        },
        "parametres": "   arg   -   the value of the imaginary number \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <complex>\n \nint main()\n{\n    using namespace std::complex_literals;\n    std::complex<double> c = 1.0 + 1i;\n    std::cout << \"abs\" << c << \" = \" << abs(c) << '\\n';\n}",
            "output": "abs(1,1) = 1.41421"
        }
    },
    "linear_congruential_engine": {
        "description": {
            "texte": "linear_congruential_engine is a random number engine based on Linear congruential generator (LCG). A LCG has a state that consists of a single integer.The transition algorithm of the LCG function is xi+1 \u2190 (axi+c) mod m.The following typedefs define the random number engine with two commonly used parameter sets:"
        }
    },
    "mersenne_twister_engine": {
        "description": {
            "texte": "mersenne_twister_engine is a random number engine based on Mersenne Twister algorithm. It produces high quality unsigned integer random numbers of type UIntType on the interval [0, 2w-1].The following type aliases define the random number engine with two commonly used parameter sets:"
        }
    },
    "subtract_with_carry_engine": {
        "description": {
            "texte": "subtract_with_carry_engine is a random number engine that uses subtract with carry algorithm.The following typedefs define the random number engine with two commonly used parameter sets:"
        }
    },
    "discard_block_engine": {
        "description": {
            "texte": "discard_block_engine is a pseudo-random number generator adaptor that discards a certain amount of data produced by the base engine. From each block of size P generated by the base engine, the adaptor keeps only R numbers, discarding the rest."
        }
    },
    "independent_bits_engine": {
        "description": {
            "texte": "independent_bits_engine is a random number engine adaptor that produces random numbers with different number of bits than that of the wrapped engine."
        }
    },
    "shuffle_order_engine": {
        "description": {
            "texte": "shuffle_order_engine is a random number engine adaptor that shuffles the random numbers generated by the base engine. It maintains a table of size K and delivers a randomly selected number from that table when requested, replacing it with a number generated by the base engine.The following typedef defines the random number engine with one commonly used parameter set:"
        }
    },
    "random_device": {
        "description": {
            "texte": "std::random_device is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.std::random_device may be implemented in terms of an implementation-defined pseudo-random number engine if a non-deterministic source (e.g. a hardware device) is not available to the implementation. In this case each std::random_device object may generate the same number sequence."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <map>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::map<int, int> hist;\n    std::uniform_int_distribution<int> dist(0, 9);\n    for (int n = 0; n < 20000; ++n) {\n        ++hist[dist(rd)]; // note: demo only: the performance of many \n                          // implementations of random_device degrades sharply\n                          // once the entropy pool is exhausted. For practical use\n                          // random_device is generally only used to seed \n                          // a PRNG such as mt19937\n    }\n    for (auto p : hist) {\n        std::cout << p.first << \" : \" << std::string(p.second/100, '*') << '\\n';\n    }\n}",
            "output": "0 : ********************\n1 : *******************\n2 : ********************\n3 : ********************\n4 : ********************\n5 : *******************\n6 : ********************\n7 : ********************\n8 : *******************\n9 : ********************"
        }
    },
    "uniform_int_distribution": {
        "description": {
            "texte": "Produces random integer values i, uniformly distributed on the closed interval [a, b], that is, distributed according to the discrete probability function  P(i|a,b) =std::uniform_int_distribution satisfies all requirements of RandomNumberDistribution."
        },
        "exemple": {
            "input": "#include <random>\n#include <iostream>\n \nint main()\n{\n    std::random_device rd;  //Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> dis(1, 6);\n \n    for (int n=0; n<10; ++n)\n        //Use dis to transform the random unsigned int generated by gen into an int in [1, 6]\n        std::cout << dis(gen) << ' ';\n    std::cout << '\\n';\n}",
            "output": "1 1 6 5 2 2 5 5 6 2"
        }
    },
    "uniform_real_distribution": {
        "description": {
            "texte": "Produces random floating-point values i, uniformly distributed on the interval [a, b), that is, distributed according to the probability density function:  P(i|a,b) =std::uniform_real_distribution satisfies all requirements of RandomNumberDistribution."
        },
        "exemple": {
            "input": "#include <random>\n#include <iostream>\n \nint main()\n{\n    std::random_device rd;  //Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()\n    std::uniform_real_distribution<> dis(1.0, 2.0);\n    for (int n = 0; n < 10; ++n) {\n        // Use dis to transform the random unsigned int generated by gen into a \n        // double in [1, 2). Each call to dis(gen) generates a new random double\n        std::cout << dis(gen) << ' ';\n    }\n    std::cout << '\\n';\n}",
            "output": "1.80829 1.15391 1.18483 1.38969 1.36094 1.0648 1.97798 1.27984 1.68261 1.57326"
        }
    },
    "bernoulli_distribution": {
        "description": {
            "texte": "Produces random boolean values, according to the discrete probability function. The probability of true is  P(b|p) =std::bernoulli_distribution satisfies RandomNumberDistribution."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    // give \"true\" 1/4 of the time\n    // give \"false\" 3/4 of the time\n    std::bernoulli_distribution d(0.25);\n \n    std::map<bool, int> hist;\n    for(int n=0; n<10000; ++n) {\n        ++hist[d(gen)];\n    }\n    for(auto p : hist) {\n        std::cout << std::boolalpha << std::setw(5) << p.first\n                  << ' ' << std::string(p.second/500, '*') << '\\n';\n    }\n}",
            "output": "false ***************\n true ****"
        }
    },
    "binomial_distribution": {
        "description": {
            "texte": "Produces random non-negative integer values i, distributed according to discrete probability function:  \\(P(i|t,p) = \\binom{t}{i} \\cdot p^i \\cdot (1-p)^{t-i}\\)P(i|t,p) =The value obtained is the number of successes in a sequence of t yes/no experiments, each of which succeeds with probability p.std::binomial_distribution satisfies RandomNumberDistribution."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    // perform 4 trials, each succeeds 1 in 2 times\n    std::binomial_distribution<> d(4, 0.5);\n \n    std::map<int, int> hist;\n    for (int n = 0; n < 10000; ++n) {\n        ++hist[d(gen)];\n    }\n    for (auto p : hist) {\n        std::cout << p.first << ' '\n                  << std::string(p.second/100, '*') << '\\n';\n    }\n}",
            "output": "0 ******\n1 ************************\n2 *************************************\n3 *************************\n4 ******"
        }
    },
    "negative_binomial_distribution": {
        "description": {
            "texte": "Produces random non-negative integer values i, distributed according to discrete probability function:  \\(P(i|k, p) = \\binom{k + i - 1}{i} \\cdot p^k \\cdot (1 - p)^i\\)P(i|k,p) =The value represents the number of failures in a series of independent yes/no trials (each succeeds with probability p), before exactly k successes occur.std::negative_binomial_distribution satisfies RandomNumberDistribution."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    // Pat goes door-to-door selling cookies\n    // At each house, there's a 75% chance that she sells one box\n    // how many times will she be turned away before selling 5 boxes?\n    std::negative_binomial_distribution<> d(5, 0.75);\n \n    std::map<int, int> hist;\n    for(int n=0; n<10000; ++n) {\n        ++hist[d(gen)];\n    }\n    for(auto p : hist) {\n        std::cout  << p.first << ' ' << std::string(p.second/100, '*') << '\\n';\n    }\n}",
            "output": "0 ***********************\n1 *****************************\n2 **********************\n3 *************\n4 ******\n5 ***\n6 *\n7 \n8 \n9 \n10 \n11"
        }
    },
    "geometric_distribution": {
        "description": {
            "texte": "Produces random non-negative integer values i, distributed according to discrete probability function:  \\(P(i|p) = p \\cdot (1-p)^i\\)P(i|p) = p \u00b7 (1 \u2212 p).The value represents the number of yes/no trials (each succeeding with probability p) which are necessary to obtain a single success.std::geometric_distribution<>(p) is exactly equivalent to std::negative_binomial_distribution<>(1, p). It is also the discrete counterpart of std::exponential_distribution.std::geometric_distribution satisfies RandomNumberDistribution."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n \n    std::geometric_distribution<> d; // same as std::negative_binomial_distribution<> d(1, 0.5);\n \n    std::map<int, int> hist;\n    for(int n=0; n<10000; ++n) {\n        ++hist[d(gen)];\n    }\n    for(auto p : hist) {\n        std::cout << p.first <<\n                ' ' << std::string(p.second/100, '*') << '\\n';\n    }\n}",
            "output": "0 *************************************************\n1 *************************\n2 ************\n3 ******\n4 **\n5 *\n6 \n7 \n8 \n9 \n10 \n11"
        }
    },
    "poisson_distribution": {
        "description": {
            "texte": "Produces random non-negative integer values i, distributed according to discrete probability function:  \\(P(i | \\mu) = \\frac{e^{-\\mu}\\mu^i}{i!}\\)P(i|\u03bc) =The value obtained is the probability of exactly i occurrences of a random event if the expected, mean number of its occurrence under the same conditions (on the same time/space interval) is \u03bc.std::poisson_distribution satisfies RandomNumberDistribution."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n \n    // if an event occurs 4 times a minute on average\n    // how often is it that it occurs n times in one minute?\n    std::poisson_distribution<> d(4);\n \n    std::map<int, int> hist;\n    for(int n=0; n<10000; ++n) {\n        ++hist[d(gen)];\n    }\n    for(auto p : hist) {\n        std::cout << p.first <<\n                ' ' << std::string(p.second/100, '*') << '\\n';\n    }\n}",
            "output": "0 *\n1 *******\n2 **************\n3 *******************\n4 *******************\n5 ***************\n6 **********\n7 *****\n8 **\n9 *\n10 \n11 \n12 \n13"
        }
    },
    "exponential_distribution": {
        "description": {
            "texte": "Produces random non-negative floating-point values x, distributed according to probability density function:  P(x|\u03bb) = \u03bbe.The value obtained is the time/distance until the next random event if random events occur at constant rate \u03bb per unit of time/distance. For example, this distribution describes the time between the clicks of a Geiger counter or the distance between point mutations in a DNA strand.This is the continuous counterpart of std::geometric_distribution.std::exponential_distribution satisfies RandomNumberDistribution."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n \n    // if particles decay once per second on average,\n    // how much time, in seconds, until the next one?\n    std::exponential_distribution<> d(1);\n \n    std::map<int, int> hist;\n    for(int n=0; n<10000; ++n) {\n        ++hist[2*d(gen)];\n    }\n    for(auto p : hist) {\n        std::cout << std::fixed << std::setprecision(1) \n                  << p.first/2.0 << '-' << (p.first+1)/2.0 <<\n                ' ' << std::string(p.second/200, '*') << '\\n';\n    }\n}",
            "output": "0.0-0.5 *******************\n0.5-1.0 ***********\n1.0-1.5 *******\n1.5-2.0 ****\n2.0-2.5 **\n2.5-3.0 *\n3.0-3.5 \n3.5-4.0"
        }
    },
    "gamma_distribution": {
        "description": {
            "texte": "Produces random positive floating-point values x, distributed according to probability density function:  \\(\\mathsf{p}(x\\mid\\alpha,\\beta) = \\frac{e^{-x/\\beta} }{\\beta^\\alpha\\cdot\\Gamma(\\alpha)}\\cdot x^{\\alpha-1} \\)P(x|\u03b1,\u03b2) =where \u03b1 is known as the shape parameter and \u03b2 is known as the scale parameter. The shape parameter is sometimes denoted by the letter k and the scale parameter is sometimes denoted by the letter \u03b8.For floating-point \u03b1, the value obtained is the sum of \u03b1 independent exponentially distributed random variables, each of which has a mean of \u03b2std::gamma_distribution satisfies RandomNumberDistribution."
        }
    },
    "weibull_distribution": {
        "description": {
            "texte": "The weibull_distribution meets the requirements of a RandomNumberDistribution and produces random numbers according to the Weibull distribution:  f(x;a,b) =a is the shape parameter and b the scale parameter.std::weibull_distribution satisfies RandomNumberDistribution."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\n#include <cmath>\nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n \n    std::weibull_distribution<> d;\n \n    std::map<int, int> hist;\n    for(int n=0; n<10000; ++n) {\n        ++hist[std::round(d(gen))];\n    }\n    for(auto p : hist) {\n        std::cout << std::fixed << std::setprecision(1) << std::setw(2)\n                  << p.first << ' ' << std::string(p.second/200, '*') << '\\n';\n    }\n}",
            "output": "0 *******************\n 1 *******************\n 2 ******\n 3 **\n 4 \n 5 \n 6 \n 7 \n 8"
        }
    },
    "extreme_value_distribution": {
        "description": {
            "texte": "Produces random numbers according to the extreme value distribution (it is also known as Gumbel Type I, log-Weibull, Fisher-Tippett Type I):  p(x;a,b) =std::extreme_value_distribution satisfies all requirements of RandomNumberDistribution."
        }
    },
    "normal_distribution": {
        "description": {
            "texte": "Generates random numbers according to the Normal (or Gaussian) random number distribution. It is defined as:   f(x; \u03bc,\u03c3) =Here \u03bc is the mean and \u03c3 is the standard deviation (stddev).std::normal_distribution satisfies all requirements of RandomNumberDistribution."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\n#include <cmath>\nint main()\n{\n    std::random_device rd{};\n    std::mt19937 gen{rd()};\n \n    // values near the mean are the most likely\n    // standard deviation affects the dispersion of generated values from the mean\n    std::normal_distribution<> d{5,2};\n \n    std::map<int, int> hist{};\n    for(int n=0; n<10000; ++n) {\n        ++hist[std::round(d(gen))];\n    }\n    for(auto p : hist) {\n        std::cout << std::setw(2)\n                  << p.first << ' ' << std::string(p.second/200, '*') << '\\n';\n    }\n}",
            "output": "-2 \n-1 \n 0 \n 1 *\n 2 ***\n 3 ******\n 4 ********\n 5 **********\n 6 ********\n 7 *****\n 8 ***\n 9 *\n10 \n11 \n12"
        }
    },
    "lognormal_distribution": {
        "description": {
            "texte": "The lognormal_distribution random number distribution produces random numbers x > 0 according to a log-normal distribution:  f(x; m,s) =The parameters m and s are, respectively, the mean and standard deviation of the natural logarithm of x.std::lognormal_distribution satisfies all requirements of RandomNumberDistribution."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\n#include <cmath>\nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n \n    std::lognormal_distribution<> d(1.6, 0.25);\n \n    std::map<int, int> hist;\n    for(int n=0; n<10000; ++n) {\n        ++hist[std::round(d(gen))];\n    }\n    for(auto p : hist) {\n        std::cout << std::fixed << std::setprecision(1) << std::setw(2)\n                  << p.first << ' ' << std::string(p.second/200, '*') << '\\n';\n    }\n}",
            "output": "2 \n 3 ***\n 4 *************\n 5 ***************\n 6 *********\n 7 ****\n 8 *\n 9 \n10 \n11 \n12"
        }
    },
    "chi_squared_distribution": {
        "description": {
            "texte": "The chi_squared_distribution produces random numbers x>0 according to the Chi-squared distribution:  f(x;n) =\u0393 is the Gamma function (See also std::tgamma) and n are the degrees of freedom (default 1).std::chi_squared_distribution satisfies all requirements of RandomNumberDistribution."
        }
    },
    "cauchy_distribution": {
        "description": {
            "texte": "Produces random numbers according to a Cauchy distribution (also called Lorentz distribution):  f(x; a,b) =std::cauchy_distribution satisfies all requirements of RandomNumberDistribution."
        }
    },
    "fisher_f_distribution": {
        "description": {
            "texte": "Produces random numbers according to the f-distribution:  p(x;m,n) =m and n are the degrees of freedom.std::fisher_f_distribution satisfies all requirements of RandomNumberDistribution."
        }
    },
    "student_t_distribution": {
        "description": {
            "texte": "Produces random floating-point values x, distributed according to probability density function:  \\(p(x|n) = \\frac{1}{\\sqrt{n\\pi} } \\cdot \\frac{\\Gamma(\\frac{n+1}{2})}{\\Gamma(\\frac{n}{2})} \\cdot (1+\\frac{x^2}{n})^{-\\frac{n+1}{2} } \\)p(x|n) =where n is known as the number of degrees of freedom. This distribution is used when estimating the mean of an unknown normally distributed value given n+1 independent measurements, each with additive errors of unknown standard deviation, as in physical measurements. Or, alternatively, when estimating the unknown mean of a normal distribution with unknown standard deviation, given n+1 samples.std::student_t_distribution satisfies all requirements of RandomNumberDistribution."
        }
    },
    "discrete_distribution": {
        "description": {
            "texte": "std::discrete_distribution produces random integers on the interval [0, n), where the probability of each individual integer i is defined as wi/S, that is the weight of the ith integer divided by the sum of all n weights.std::discrete_distribution satisfies all requirements of RandomNumberDistribution."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <map>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::discrete_distribution<> d({40, 10, 10, 40});\n    std::map<int, int> m;\n    for(int n=0; n<10000; ++n) {\n        ++m[d(gen)];\n    }\n    for(auto p : m) {\n        std::cout << p.first << \" generated \" << p.second << \" times\\n\";\n    }\n}",
            "output": "0 generated 4028 times\n1 generated 978 times\n2 generated 1012 times\n3 generated 3982 times"
        }
    },
    "piecewise_constant_distribution": {
        "description": {
            "texte": "std::piecewise_constant_distribution produces random floating-point numbers, which are uniformly distributed within each of the several subintervals [bi, bi+1), each with its own weight wi. The set of interval boundaries and the set of weights are the parameters of this distribution.  The probability density for any b.std::piecewise_constant_distribution satisfies all requirements of RandomNumberDistribution."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <map>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    // 50% of the time, generate a random number between 0 and 1\n    // 50% of the time, generate a random number between 10 and 15\n    std::vector<double> i{0,  1, 10, 15};\n    std::vector<double> w{  1,  0,  1};\n    std::piecewise_constant_distribution<> d(i.begin(), i.end(), w.begin());\n \n    std::map<int, int> hist;\n    for(int n=0; n<10000; ++n) {\n        ++hist[d(gen)];\n    }\n    for(auto p : hist) {\n        std::cout << p.first << ' ' << std::string(p.second/100, '*') << '\\n';\n    }\n}",
            "output": "0 **************************************************\n10 **********\n11 *********\n12 *********\n13 **********\n14 *********"
        }
    },
    "piecewise_linear_distribution": {
        "description": {
            "texte": "std::piecewise_linear_distribution produces random floating-point numbers, which are distributed according to a linear probability density function within each of the several subintervals [bi, bi+1). The distribution is such that the probability density at each interval boundary is exactly the predefined value pi.  The probability density for any b.The set of interval boundaries bi and the set of weights at boundaries wi are the parameters of this distribution.std::piecewise_linear_distribution satisfies all requirements of RandomNumberDistribution."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <map>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    // increase the probability from 0 to 5\n    // remain flat from 5 to 10\n    // decrease from 10 to 15 at the same rate\n    std::vector<double> i{0, 5, 10, 15};\n    std::vector<double> w{0, 1,   1, 0};\n    std::piecewise_linear_distribution<> d(i.begin(), i.end(), w.begin());\n \n    std::map<int, int> hist;\n    for(int n=0; n<10000; ++n) {\n        ++hist[d(gen)];\n    }\n    for(auto p : hist) {\n        std::cout << std::setw(2) << std::setfill('0') << p.first << ' '\n            << std::string(p.second/100,'*') << '\\n';\n    }\n}",
            "output": "00 *\n01 ***\n02 ****\n03 ******\n04 *********\n05 *********\n06 *********\n07 **********\n08 *********\n09 **********\n10 *********\n11 *******\n12 ****\n13 ***\n14 *"
        }
    },
    "generate_canonical": {
        "description": {
            "texte": "Generates a random floating point number in range [0, 1).To generate enough entropy, generate_canonical() will call g() exactly k times, where \\(k = max(1, \\lceil \\frac{b}{log_2 R} \\rceil)\\)k = max(1, \u2308 b / log2 R \u2309) and."
        },
        "parametres": "   g   -   generator to use to acquire entropy \n\n",
        "exemple": {
            "input": "#include <random>\n#include <iostream>\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    for(int n=0; n<10; ++n) {\n        std::cout << std::generate_canonical<double, 10>(gen) << ' ';\n    }\n}",
            "output": "0.208143 0.824147 0.0278604 0.343183 0.0173263 0.864057 0.647037 0.539467 0.0583497 0.609219"
        }
    },
    "seed_seq": {
        "description": {
            "texte": "std::seed_seq consumes a sequence of integer-valued data and produces a requested number of unsigned integer values i, 0 \u2264 i < 232, based on the consumed data. The produced values are distributed over the entire 32-bit range even if the consumed values are close.It provides a way to seed a large number of random number engines or to seed a generator that requires a lot of entropy, given a small seed or a poorly distributed initial seed sequence.std::seed_seq meets the requirements of SeedSequence."
        },
        "exemple": {
            "input": "#include <random>\n#include <cstdint>\n#include <iostream>\n \nint main()\n{\n    std::seed_seq seq{1,2,3,4,5};\n    std::vector<std::uint32_t> seeds(10);\n    seq.generate(seeds.begin(), seeds.end());\n    for (std::uint32_t n : seeds) {\n        std::cout << n << '\\n';\n    }\n}",
            "output": "4204997637\n4246533866\n1856049002\n1129615051\n690460811\n1075771511\n46783058\n3904109078\n1534123438\n1495905678"
        }
    },
    "slice": {
        "description": {
            "texte": "std::slice is the selector class that identifies a subset of std::valarray similar to BLAS slice. An object of type std::slice holds three values: the starting index, the stride, and the total number of values in the subset. Objects of type std::slice can be used as indexes with valarray's operator[]."
        },
        "parametres": "   start   -   the position of the first element \n   size   -   the number of elements in the slice \n   stride   -   the number of positions between successive elements in the slice \n   other   -   another slice to copy \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <valarray>\nclass Matrix {\n    std::valarray<int> data;\n    int dim;\n public:\n    Matrix(int r, int c) : data(r*c), dim(c) {}\n    int& operator()(int r, int c) {return data[r*dim + c];}\n    int trace() const {\n        return data[std::slice(0, dim, dim+1)].sum();\n    }\n};\nint main()\n{\n    Matrix m(3,3);\n    int n = 0;\n    for(int r=0; r<3; ++r)\n       for(int c=0; c<3; ++c)\n           m(r, c) = ++n;\n    std::cout << \"Trace of the matrix (1,2,3) (4,5,6) (7,8,9) is \" << m.trace() << '\\n';\n}",
            "output": "Trace of the matrix (1,2,3) (4,5,6) (7,8,9) is 15"
        }
    },
    "slice_array": {
        "description": {
            "texte": "std::slice_array is a helper template used by std::slice subscript operator. It has reference semantics to a subset of the array specified by the std::slice object."
        }
    },
    "gslice": {
        "description": {
            "texte": "std::gslice is the selector class that identifies a subset of std::valarray indices defined by a multi-level set of strides and sizes. Objects of type std::gslice can be used as indices with valarray's operator[] to select, for example, columns of a multidimensional array represented as a valarray.Given the starting value s, a list of strides ij and a list of sizes dj, a std::gslice constructed from these values selects the set of indices kj=s+\u03a3j(ijdj).For example, a gslice with starting index 3, strides {19,4,1} and lengths {2,4,3}  generates the following set of indices:3 + 0*19 + 0*4 + 0*1 = 3, 3 + 0*19 + 0*4 + 1*1 = 4, 3 + 0*19 + 0*4 + 2*1 = 5, 3 + 0*19 + 1*4 + 0*1 = 7, 3 + 0*19 + 1*4 + 1*1 = 8, ... 3 + 1*19 + 3*4 + 2*1 = 36.It is possible to construct std::gslice objects that select some indices more than once: if the above example used the strides {1,1,1} , the indices would have been {3, 4, 5, 4, 5, 6, ...} . Such gslices may only be used as arguments to the const version of std::valarray::operator[], otherwise the behavior is undefined."
        },
        "parametres": "   start   -   the position of the first element \n   sizes   -   an array that defines the number of elements in each dimension \n   strides   -   an array that defines the number of positions between successive elements in each dimension \n   other   -   another slice to copy \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <valarray>\nvoid test_print(std::valarray<int>& v, int rows, int cols, int planes)\n{\n    for(int r=0; r<rows; ++r) {\n        for(int c=0; c<cols; ++c) {\n            for(int z=0; z<planes; ++z)\n                std::cout << v[r*cols*planes + c*planes + z] << ' ';\n            std::cout << '\\n';\n        }\n        std::cout << '\\n';\n    }\n}\nint main()\n{\n    std::valarray<int> v = // 3d array: 2 x 4 x 3 elements\n    { 111,112,113 , 121,122,123 , 131,132,133 , 141,142,143,\n      211,212,213 , 221,222,223 , 231,232,233 , 241,242,243};\n    // int ar3d[2][4][3]\n    std::cout << \"Initial 2x4x3 array:\\n\";\n    test_print(v, 2, 4, 3);\n \n    // update every value in the first columns of both planes\n    v[std::gslice(0, {2, 4}, {4*3, 3})] = 1; // two level one strides of 12 elements\n                                             // then four level two strides of 3 elements\n \n    // subtract the third column from the second column in the 1st plane\n    v[std::gslice(1, {1, 4}, {4*3, 3})] -= v[std::gslice(2, {1, 4}, {4*3, 3})];\n \n    std::cout << \"After column operations: \\n\";\n    test_print(v, 2, 4, 3);\n}",
            "output": "Initial 2x4x3 array:\n111 112 113\n121 122 123\n131 132 133\n141 142 143\n \n211 212 213\n221 222 223\n231 232 233\n241 242 243\n \nAfter column operations:\n1 -1 113\n1 -1 123\n1 -1 133\n1 -1 143\n \n1 212 213\n1 222 223\n1 232 233\n1 242 243"
        }
    },
    "gslice_array": {
        "description": {
            "texte": "std::gslice_array is a helper template used by std::gslice subscript operator. It has reference semantics to a subset of the array specified by the std::gslice object."
        }
    },
    "mask_array": {
        "description": {
            "texte": "std::mask_array is a helper template used by the valarray subscript operator with std::valarray<bool> argument. It has reference semantics and provides access to the subset of the valarray consisting of the elements whose indices correspond to true values in the std::valarray<bool> mask."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <valarray>\n \nint main() \n{\n    std::valarray<int> data = {0,1,2,3,4,5,6,7,8,9};\n \n    std::cout << \"Initial valarray: \";\n    for(int n: data) std::cout << n << ' ';\n    std::cout << '\\n';\n \n    data[data > 5] = -1;\n    // the type of data>5 is std::valarray<bool>\n    // the type of data[data>5] is std::mask_array<int>\n \n    std::cout << \"After v[v>5]=-1:  \";\n    for(int n: data) std::cout << n << ' ';\n    std::cout << '\\n';\n}",
            "output": "Initial valarray: 0 1 2 3 4 5 6 7 8 9 \nAfter v[v>5]=-1:  0 1 2 3 4 5 -1 -1 -1 -1"
        }
    },
    "indirect_array": {
        "description": {
            "texte": "std::gslice_array is a helper template used by std::indirect_array subscript operator. It has reference semantics to a subset of the array specified by an indirect array (std::valarray<std::size_t> object)."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <valarray>\n \nint main()\n{\n    std::valarray<int> data = {0,1,2,3,4,5,6,7,8,9};\n \n    std::valarray<std::size_t> idx = {0,2,4,6,8};\n \n    std::cout << \"Original valarray: \";\n    for(int n: data) std::cout << n << ' ';\n    std::cout << '\\n';\n \n    data[idx] += data[idx]; // double the values at indexes 'idx'\n \n    // the type of data[idx] is std::indirect_array<int>\n \n    std::cout << \"After indirect modification: \";\n    for(int n: data) std::cout << n << ' ';\n    std::cout << '\\n';\n}",
            "output": "Original valarray: 0 1 2 3 4 5 6 7 8 9 \nAfter indirect modification: 0 1 4 3 8 5 12 7 16 9"
        }
    },
    "swap(std::valarray)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::valarray. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   valarrays whose contents to swap \n\n"
    },
    "begin(std::valarray)\n": {
        "description": {
            "texte": "The overload of std::begin for valarray returns an iterator of unspecified type referring to the first element in the numeric array.The iterator obtained from this function is invalidated when the member function resize() is called on the array v or when the lifetime of v ends, whichever comes first."
        },
        "parametres": "   v   -   a numeric array \n\n"
    },
    "end(std::valarray)\n": {
        "description": {
            "texte": "The overload of std::end for valarray returns an iterator of unspecified type referring to the one past the last element in the numeric array.The iterator obtained from this function template is invalidated when the member function resize() is called on the array v or when the lifetime of v ends, whichever comes first."
        },
        "parametres": "   v   -   a numeric array \n\n"
    },
    "operator+,-,*,/,%,&,|,^,>,&&,|| (std::valarray)": {
        "description": {
            "texte": "Apply binary operators to each element of two valarrays, or a valarray and a value."
        },
        "parametres": "   rhs   -   a numeric array \n   lhs   -   a numeric array \n   val   -   a value of type T \n\n",
        "exemple": {
            "input": "#include <valarray>\n#include <iostream>\n \nint main()\n{\n    std::valarray<double> a(1, 8);\n    std::valarray<double> b{1, 2, 3, 4, 5, 6, 7, 8};\n    std::valarray<double> c = -b;\n    // literals must also be of type T (double in this case)\n    std::valarray<double> d = std::sqrt((b * b - 4.0 * a * c));\n    std::valarray<double> x1 = (-b - d) / (2.0 * a);\n    std::valarray<double> x2 = (-b + d) / (2.0 * a);\n    std::cout << \"quadratic equation    root 1,  root 2\" << \"\\n\";\n    for (size_t i = 0; i < a.size(); ++i) {\n        std::cout << a[i] << \"x\\u00B2 + \" << b[i] << \"x + \" << c[i] << \" = 0   \";\n        std::cout << x1[i] << \", \" << x2[i] << \"\\n\";\n    }\n}",
            "output": "quadratic equation    root 1,  root 2\n1x\u00b2 + 1x + -1 = 0   -1.61803, 0.618034\n1x\u00b2 + 2x + -2 = 0   -2.73205, 0.732051\n1x\u00b2 + 3x + -3 = 0   -3.79129, 0.791288\n1x\u00b2 + 4x + -4 = 0   -4.82843, 0.828427\n1x\u00b2 + 5x + -5 = 0   -5.8541, 0.854102\n1x\u00b2 + 6x + -6 = 0   -6.87298, 0.872983\n1x\u00b2 + 7x + -7 = 0   -7.88748, 0.887482\n1x\u00b2 + 8x + -8 = 0   -8.89898, 0.898979"
        }
    },
    "operator==,!=,,>=(std::valarray)": {
        "description": {
            "texte": "Compares each value within the numeric array with another value.The behavior is undefined if size() != v.size()."
        },
        "parametres": "   lhs, rhs   -   numeric arrays to compare \n   lhsv, rhsv   -   values to compare to each element within a numeric array \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <valarray>\n \nint main()\n{\n    // zero all negatives in a valarray\n    std::valarray<int> v = {1, -1, 0, -3, 10, -1, -2};\n    std::cout << \"Before: \";\n    for(auto n: v) std::cout << n << ' '; std::cout << '\\n';\n    v[v < 0] = 0;\n    std::cout << \"After: \";\n    for(auto n: v) std::cout << n << ' '; std::cout << '\\n';\n \n    // convert the valarray<bool> result of == to a single bool\n    std::valarray<int> a = {1,2,3};\n    std::valarray<int> b = {2,4,6};\n \n    std::cout << \"2*a == b is \" << std::boolalpha\n              << (2*a == b).min() << '\\n';\n \n}",
            "output": "Before: 1 -1 0 -3 10 -1 -2\nAfter: 1 0 0 0 10 0 0\n2*a == b is true"
        }
    },
    "abs(std::valarray)": {
        "description": {
            "texte": "Computes absolute value of each element in the value array."
        },
        "parametres": "   va   -   value array to apply the operation to \n\n",
        "exemple": {
            "input": "#include <valarray>\n#include <iostream>\n \nint main()\n{\n    std::valarray<int> v{1, -2, 3, -4, 5, -6, 7, -8};\n    std::valarray<int> v2 = std::abs(v);\n    for(auto n : v2) {\n        std::cout << n << ' ';\n    }\n    std::cout << '\\n';\n}",
            "output": "1 2 3 4 5 6 7 8"
        }
    },
    "exp(std::valarray)": {
        "description": {
            "texte": "For each element in va computes e raised to the power equal to the value of the element."
        },
        "parametres": "   va   -   value array to apply the operation to \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <complex>\n#include <valarray>\n \nint main()\n{\n    const double pi = std::acos(-1);\n    std::valarray<std::complex<double>> v = {\n        {0, 0}, {0, pi/2}, {0, pi}, {0, 3*pi/2}, {0, 2*pi}\n    };\n    std::valarray<std::complex<double>> v2 = std::exp(v);\n    for(auto n : v2) {\n        std::cout << std::fixed << n << '\\n';\n    }\n}",
            "output": "(1.000000,0.000000)\n(0.000000,1.000000)\n(-1.000000,0.000000)\n(-0.000000,-1.000000)\n(1.000000,-0.000000)"
        }
    },
    "exp, std::expf, std::expl": {
        "description": {
            "texte": "Computes e (Euler's number, 2.7182818...) raised to the given power arg."
        },
        "parametres": "   arg   -   value of floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << \"exp(1) = \" << std::exp(1) << '\\n'\n              << \"FV of $100, continuously compounded at 3% for 1 year = \"\n              << 100*std::exp(0.03) << '\\n';\n    // special values\n    std::cout << \"exp(-0) = \" << std::exp(-0.0) << '\\n'\n              << \"exp(-Inf) = \" << std::exp(-INFINITY) << '\\n';\n    // error handling \n    errno = 0;\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"exp(710) = \" << std::exp(710) << '\\n';\n    if (errno == ERANGE)\n        std::cout << \"    errno == ERANGE: \" << std::strerror(errno) << '\\n';\n    if (std::fetestexcept(FE_OVERFLOW))\n        std::cout << \"    FE_OVERFLOW raised\\n\";\n}",
            "output": "exp(1) = 2.71828\nFV of $100, continuously compounded at 3% for 1 year = 103.045\nexp(-0) = 1\nexp(-Inf) = 0\nexp(710) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised"
        }
    },
    "log(std::valarray)": {
        "description": {
            "texte": "For each element in va computes natural logarithm of the value of the element."
        },
        "parametres": "   va   -   value array to apply the operation to \n\n"
    },
    "log, std::logf, std::logl": {
        "description": {
            "texte": "If no errors occur, the natural (base-e) logarithm of arg (ln(arg) or loge(arg)) is returned.If a domain error occurs, an implementation-defined value is returned (NaN where supported).If a pole error occurs, -HUGE_VAL, -HUGE_VALF, or -HUGE_VALL is returned."
        },
        "parametres": "   arg   -   value of floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << \"log(1) = \" << std::log(1) << '\\n'\n              << \"base-5 logarithm of 125 = \" << std::log(125)/std::log(5) << '\\n';\n    // special values\n    std::cout << \"log(1) = \" << std::log(1) << '\\n'\n              << \"log(+Inf) = \" << std::log(INFINITY) << '\\n';\n    // error handling\n    errno = 0;\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"log(0) = \" << std::log(0) << '\\n';\n    if (errno == ERANGE)\n        std::cout << \"    errno == ERANGE: \" << std::strerror(errno) << '\\n';\n    if (std::fetestexcept(FE_DIVBYZERO))\n        std::cout << \"    FE_DIVBYZERO raised\\n\";\n}",
            "output": "log(1) = 0\nbase-5 logarithm of 125 = 3\nlog(1) = 0\nlog(+Inf) = inf\nlog(0) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised"
        }
    },
    "log10(std::valarray)": {
        "description": {
            "texte": "For each element in va computes common (base 10) logarithm of the value of the element."
        },
        "parametres": "   va   -   value array to apply the operation to \n\n"
    },
    "log10, std::log10f, std::log10l": {
        "description": {
            "texte": "If no errors occur, the common (base-10) logarithm of arg (log10(arg) or lg(arg)) is returned.If a domain error occurs, an implementation-defined value is returned (NaN where supported).If a pole error occurs, -HUGE_VAL, -HUGE_VALF, or -HUGE_VALL is returned."
        },
        "parametres": "   arg   -   value of floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << \"log10(1000) = \" << std::log10(1000) << '\\n'\n              << \"log10(0.001) = \" << std::log10(0.001) << '\\n'\n              << \"base-5 logarithm of 125 = \" << std::log10(125)/std::log10(5) << '\\n';\n    // special values\n    std::cout << \"log10(1) = \" << std::log10(1) << '\\n'\n              << \"log10(+Inf) = \" << std::log10(INFINITY) << '\\n';\n    // error handling\n    errno = 0;\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"log10(0) = \" << std::log10(0) << '\\n';\n    if (errno == ERANGE)\n        std::cout << \"    errno == ERANGE: \" << std::strerror(errno) << '\\n';\n    if (std::fetestexcept(FE_DIVBYZERO))\n        std::cout << \"    FE_DIVBYZERO raised\\n\";\n}",
            "output": "log10(1000) = 3\nlog10(0.001) = -3\nbase-5 logarithm of 125 = 3\nlog10(1) = 0\nlog10(+Inf) = inf\nlog10(0) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised"
        }
    },
    "pow(std::valarray)": {
        "description": {
            "texte": "Raises a value to a power.The behavior is undefined if base.size() != exp.size()."
        },
        "parametres": "   base   -   numeric array containing the values of the base \n   exp   -   numeric array containing the values of the exponent \n   vbase   -   a value defining the base \n   vexp   -   a value defining the exponent \n\n"
    },
    "pow, std::powf, std::powl": {
        "description": {
            "texte": "If no errors occur, base raised to the power of exp (or iexp) (baseexp), is returned.If a domain error occurs, an implementation-defined value is returned (NaN where supported).If a pole error or a range error due to overflow occurs, \u00b1HUGE_VAL, \u00b1HUGE_VALF, or \u00b1HUGE_VALL is returned.If a range error occurs due to underflow, the correct result (after rounding) is returned."
        },
        "parametres": "   base   -   base as a value of floating-point or integral type \n   exp   -   exponent as a value of floating-point or integral type \n   iexp   -   exponent as integer value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cfenv>\n#include <cstring>\n \n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    // typical usage\n    std::cout << \"pow(2, 10) = \" << std::pow(2,10) << '\\n'\n              << \"pow(2, 0.5) = \" << std::pow(2,0.5) << '\\n'\n              << \"pow(-2, -3) = \" << std::pow(-2,-3) << '\\n';\n    // special values\n    std::cout << \"pow(-1, NAN) = \" << std::pow(-1,NAN) << '\\n'\n              << \"pow(+1, NAN) = \" << std::pow(+1,NAN) << '\\n'\n              << \"pow(INFINITY, 2) = \" << std::pow(INFINITY, 2) << '\\n'\n              << \"pow(INFINITY, -1) = \" << std::pow(INFINITY, -1) << '\\n';\n    // error handling\n    errno = 0;\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"pow(-1, 1/3) = \" << std::pow(-1, 1.0/3) << '\\n';\n    if (errno == EDOM)\n        std::cout << \"    errno == EDOM \" << std::strerror(errno) << '\\n';\n    if (std::fetestexcept(FE_INVALID))\n        std::cout << \"    FE_INVALID raised\\n\";\n \n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"pow(-0, -3) = \" << std::pow(-0.0, -3) << '\\n';\n    if (std::fetestexcept(FE_DIVBYZERO))\n        std::cout << \"    FE_DIVBYZERO raised\\n\";\n}",
            "output": "pow(2, 10) = 1024\npow(2, 0.5) = 1.41421\npow(-2, -3) = -0.125\npow(-1, NAN) = nan\npow(+1, NAN) = 1\npow(INFINITY, 2) = inf\npow(INFINITY, -1) = 0\npow(-1, 1/3) = -nan\n    errno == EDOM Numerical argument out of domain\n    FE_INVALID raised\npow(-0, -3) = -inf\n    FE_DIVBYZERO raised"
        }
    },
    "sqrt(std::valarray)": {
        "description": {
            "texte": "For each element in va computes the square root of the value of the element."
        },
        "parametres": "   va   -   value array to apply the operation to \n\n",
        "exemple": {
            "input": "#include <valarray>\n#include <iostream>\n \nint main()\n{\n    std::valarray<double> a(1, 8);\n    std::valarray<double> b{1, 2, 3, 4, 5, 6, 7, 8};\n    std::valarray<double> c = -b;\n    // literals must also be of type T (double in this case)\n    std::valarray<double> d = std::sqrt((b * b - 4.0 * a * c));\n    std::valarray<double> x1 = (-b - d) / (2.0 * a);\n    std::valarray<double> x2 = (-b + d) / (2.0 * a);\n    std::cout << \"quadratic equation    root 1,  root 2\" << \"\\n\";\n    for (size_t i = 0; i < a.size(); ++i) {\n        std::cout << a[i] << \"x\\u00B2 + \" << b[i] << \"x + \" << c[i] << \" = 0   \";\n        std::cout << x1[i] << \", \" << x2[i] << \"\\n\";\n    }\n}",
            "output": "quadratic equation    root 1,  root 2\n1x\u00b2 + 1x + -1 = 0   -1.61803, 0.618034\n1x\u00b2 + 2x + -2 = 0   -2.73205, 0.732051\n1x\u00b2 + 3x + -3 = 0   -3.79129, 0.791288\n1x\u00b2 + 4x + -4 = 0   -4.82843, 0.828427\n1x\u00b2 + 5x + -5 = 0   -5.8541, 0.854102\n1x\u00b2 + 6x + -6 = 0   -6.87298, 0.872983\n1x\u00b2 + 7x + -7 = 0   -7.88748, 0.887482\n1x\u00b2 + 8x + -8 = 0   -8.89898, 0.898979"
        }
    },
    "sin(std::valarray)": {
        "description": {
            "texte": "For each element in va computes sine of the value of the element."
        },
        "parametres": "   va   -   value array to apply the operation to \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <valarray>\n#include <cmath>\n \nconst double pi = std::acos(-1);\nint main()\n{\n    std::valarray<double> v1 = {0, 0.25, 0.5, 0.75, 1};\n    std::valarray<double> v2 = std::sin(v1 * pi);\n \n    for(double n : v2)\n        std::cout << std::fixed << n << ' ';\n    std::cout << '\\n';\n}",
            "output": "0.000000 0.707107 1.000000 0.707107 0.000000"
        }
    },
    "cos(std::valarray)": {
        "description": {
            "texte": "For each element in va computes cosine of the value of the element."
        },
        "parametres": "   va   -   value array to apply the operation to \n\n"
    },
    "cos, std::cosf, std::cosl": {
        "description": {
            "texte": "If no errors occur, the cosine of arg (cos(arg)) in the range [-1 ; +1], is returned.If a domain error occurs, an implementation-defined value is returned (NaN where supported).If a range error occurs due to underflow, the correct result (after rounding) is returned."
        },
        "parametres": "   arg   -   value representing angle in radians, of a floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\nconst double pi = std::acos(-1);\nint main()\n{\n    // typical usage\n    std::cout << \"cos(pi/3) = \" << std::cos(pi/3) << '\\n'\n              << \"cos(pi/2) = \" << std::cos(pi/2) << '\\n'\n              << \"cos(-3*pi/4) = \" << std::cos(-3*pi/4) << '\\n';\n    // special values\n    std::cout << \"cos(+0) = \" << std::cos(0.0) << '\\n'\n              << \"cos(-0) = \" << std::cos(-0.0) << '\\n';\n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"cos(INFINITY) = \" << std::cos(INFINITY) << '\\n';\n    if (std::fetestexcept(FE_INVALID))\n        std::cout << \"    FE_INVALID raised\\n\";\n}",
            "output": "cos(pi/3) = 0.5\ncos(pi/2) = 6.12323e-17\ncos(-3*pi/4) = -0.707107\ncos(+0) = 1\ncos(-0) = 1\ncos(INFINITY) = -nan\n    FE_INVALID raised"
        }
    },
    "tan(std::valarray)": {
        "description": {
            "texte": "For each element in va computes tangent of the value of the element."
        },
        "parametres": "   va   -   value array to apply the operation to \n\n"
    },
    "tan, std::tanf, std::tanl": {
        "description": {
            "texte": "If no errors occur, the tangent of arg (tan(arg)) is returned.If a domain error occurs, an implementation-defined value is returned (NaN where supported).If a range error occurs due to underflow, the correct result (after rounding) is returned."
        },
        "parametres": "   arg   -   value representing angle in radians, of a floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\nconst double pi = std::acos(-1);\nint main()\n{\n    // typical usage\n    std::cout << \"tan  (pi/4) = \" << std::tan(  pi/4) << '\\n' // 45 deg.\n              << \"tan(3*pi/4) = \" << std::tan(3*pi/4) << '\\n' // 135 deg\n              << \"tan(5*pi/4) = \" << std::tan(5*pi/4) << '\\n' // -135 deg\n              << \"tan(7*pi/4) = \" << std::tan(7*pi/4) << '\\n'; // -45 deg\n    // special values\n    std::cout << \"tan(+0) = \" << std::tan(0.0) << '\\n'\n              << \"tan(-0) = \" << std::tan(-0.0) << '\\n';\n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"tan(INFINITY) = \" << std::tan(INFINITY) << '\\n';\n    if (std::fetestexcept(FE_INVALID))\n        std::cout << \"    FE_INVALID raised\\n\";\n}",
            "output": "tan  (pi/4) = 1\ntan(3*pi/4) = -1\ntan(5*pi/4) = 1\ntan(7*pi/4) = -1\ntan(+0) = 0\ntan(-0) = -0\ntan(INFINITY) = -nan\n    FE_INVALID raised"
        }
    },
    "asin(std::valarray)": {
        "description": {
            "texte": "For each element in va computes arc sine of the value of the element."
        },
        "parametres": "   va   -   value array to apply the operation to \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\n#include <valarray>\n \nconst double pi = 4.0 * atan(1.0);\n \nint main()\n{\n    // take common y-values from unit circle\n    std::valarray<double> v1 = {-1.0, -sqrt(3.0)/2.0, -sqrt(2.0)/2.0, -0.5, 0.0, 0.5, sqrt(2.0)/2.0, sqrt(3.0)/2.0, 1.0};\n    std::valarray<double> v2 = std::asin(v1) * 180.0 / pi;;\n \n    for(double n : v2)\n        std::cout << std::fixed << n << ' ';\n    std::cout << '\\n';\n}",
            "output": "-90.000000 -60.000000 -45.000000 -30.000000 0.000000 30.000000 45.000000 60.000000 90.000000"
        }
    },
    "asin, std::asinf, std::asinl": {
        "description": {
            "texte": "If a domain error occurs, an implementation-defined value is returned (NaN where supported).If a range error occurs due to underflow, the correct result (after rounding) is returned."
        },
        "parametres": "   arg   -   value of a floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\n#include <cerrno>\n#include <cfenv>\n#include <cstring>\n \n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << \"asin(1.0) = \" << asin(1) << '\\n'\n              << \"2*asin(1.0) = \" << 2*asin(1) << '\\n'\n              << \"asin(-0.5) = \" << asin(-0.5) << '\\n'\n              << \"6*asin(-0.5) =\" << 6*asin(-0.5) << '\\n';\n    // special values\n    std::cout << \"asin(0.0) = \" << asin(0) << \" asin(-0.0)=\" << asin(-0.0) << '\\n';\n    // error handling\n    errno = 0;\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"asin(1.1) = \" << asin(1.1) << '\\n';\n    if (errno == EDOM)\n        std::cout << \"    errno == EDOM: \" << std::strerror(errno) << '\\n';\n    if (std::fetestexcept(FE_INVALID))\n        std::cout << \"    FE_INVALID raised\" << '\\n';\n}",
            "output": "asin(1.0) = 1.5708\n2*asin(1.0) = 3.14159\nasin(-0.5) = -0.523599\n6*asin(-0.5) = -3.14159\nasin(0.0) = 0 asin(-0.0)=-0\nasin(1.1) = nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised"
        }
    },
    "acos(std::valarray)": {
        "description": {
            "texte": "For each element in va computes arc cosine of the value of the element."
        },
        "parametres": "   va   -   value array to apply the operation to \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\n#include <valarray>\n \nconst double pi = 4.0 * atan(1.0);\n \nint main()\n{\n    // take common x-values from unit circle\n    std::valarray<double> v1 = {-1.0, -sqrt(3.0)/2.0, -sqrt(2.0)/2.0, -0.5, 0.0, 0.5, sqrt(2.0)/2.0, sqrt(3.0)/2.0, 1.0};\n    std::valarray<double> v2 = std::acos(v1) * 180.0 / pi;;\n \n    for(double n : v2)\n        std::cout << std::fixed << n << ' ';\n    std::cout << '\\n';\n}",
            "output": "180.000000 150.000000 135.000000 120.000000 90.000000 60.000000 45.000000 30.000000 0.000000"
        }
    },
    "acos, std::acosf, std::acosl": {
        "description": {
            "texte": "If no errors occur, the arc cosine of arg (arccos(arg)) in the range [0 , \u03c0], is returned.If a domain error occurs, an implementation-defined value is returned (NaN where supported).If a range error occurs due to underflow, the correct result (after rounding) is returned."
        },
        "parametres": "   arg   -   value of a floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\n#include <cerrno>\n#include <cfenv>\n#include <cstring>\n \n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << \"acos(-1) = \" << acos(-1) << '\\n'\n              << \"acos(0.0) = \" << acos(0.0) << \" 2*acos(0.0) = \" << 2*acos(0) << '\\n'\n              << \"acos(0.5) = \" << acos(0.5) << \" 3*acos(0.5) = \" << 3*acos(0.5) << '\\n'\n              << \"acos(1) = \" << acos(1) << '\\n';\n    // error handling\n    errno = 0;\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"acos(1.1) = \" << acos(1.1) << '\\n';\n    if (errno == EDOM)\n        std::cout << \"    errno == EDOM: \" << std::strerror(errno) << '\\n';\n    if (std::fetestexcept(FE_INVALID))\n        std::cout << \"    FE_INVALID raised\" << '\\n';\n}",
            "output": "acos(-1) = 3.14159\nacos(0.0) = 1.5708 2*acos(0.0) = 3.14159\nacos(0.5) = 1.0472 3*acos(0.5) = 3.14159\nacos(1) = 0\nacos(1.1) = nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised"
        }
    },
    "atan(std::valarray)": {
        "description": {
            "texte": "For each element in va computes arc tangent of the value of the element."
        },
        "parametres": "   va   -   value array to apply the operation to \n\n"
    },
    "atan, std::atanf, std::atanl": {
        "description": {
            "texte": "If a range error occurs due to underflow, the correct result (after rounding) is returned."
        },
        "parametres": "   arg   -   value of a floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n \nint main()\n{\n    std::cout << \"atan(1) = \" << atan(1) << \" 4*atan(1) = \" << 4*atan(1) << '\\n';\n    // special values\n    std::cout << \"atan(Inf) = \" << atan(INFINITY)\n              << \" 2*atan(Inf) = \" << 2*atan(INFINITY) << '\\n'\n              << \"atan(-0.0) = \" << atan(-0.0) << '\\n'\n              << \"atan(+0.0) = \" << atan(0) << '\\n';\n}",
            "output": "atan(1) = 0.785398 4*atan(1) = 3.14159\natan(Inf) = 1.5708 2*atan(Inf) = 3.14159\natan(-0.0) = -0\natan(+0.0) = 0"
        }
    },
    "atan2(std::valarray)": {
        "description": {
            "texte": "Computes the inverse tangent of y/x using the signs of arguments to correctly determine quadrant.The behavior is undefined if x.size() != y.size()."
        },
        "parametres": "   x, y   -   numeric arrays to compute inverse tangent of \n   vy, vx   -   values to compute inverse tangent of \n\n"
    },
    "atan2, std::atan2f, std::atan2l": {
        "description": {
            "texte": "If a domain error occurs, an implementation-defined value is returned (NaN where supported).If a range error occurs due to underflow, the correct result (after rounding) is returned."
        },
        "parametres": "   x, y   -   values of floating-point or integral types \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n \nint main()\n{\n    // normal usage: the signs of the two arguments determine the quadrant\n    std::cout << \"(+1,+1) cartesian is (\" << hypot(1,1)\n              << ',' << atan2(1,1) << \") polar\\n\"  // atan2(1,1) = +pi/4, Quad I\n              << \"(+1,-1) cartesian is (\" << hypot(1,-1)\n              << ',' << atan2(1,-1) << \") polar\\n\" // atan2(1, -1) = +3pi/4, Quad II\n              << \"(-1,-1) cartesian is (\" << hypot(-1,-1)\n              << ',' << atan2(-1,-1) << \") polar\\n\" // atan2(-1,-1) = -3pi/4, Quad III\n              << \"(-1,+1) cartesian is (\" << hypot(-1,1)\n              << ',' << atan2(-1,1) << \") polar\\n\"; // atan2(-1,-1) = -pi/4, Quad IV\n    // special values\n    std::cout << \"atan2(0, 0) = \" << atan2(0,0)\n              << \" atan2(0,-0) = \" << atan2(0,-0.0) << '\\n'\n              << \"atan2(7, 0) = \" << atan2(7,0)\n              << \" atan2(7,-0) = \" << atan2(7,-0.0) << '\\n';\n}",
            "output": "(+1,+1) cartesian is (1.41421,0.785398) polar\n(+1,-1) cartesian is (1.41421,2.35619) polar\n(-1,-1) cartesian is (1.41421,-2.35619) polar\n(-1,+1) cartesian is (1.41421,-0.785398) polar\natan2(0, 0) = 0 atan2(0,-0) = 3.14159\natan2(7, 0) = 1.5708 atan2(7,-0) = 1.5708"
        }
    },
    "sinh(std::valarray)": {
        "description": {
            "texte": "For each element in va computes hyperbolic sine of the value of the element."
        },
        "parametres": "   va   -   value array to apply the operation to \n\n"
    },
    "sinh, std::sinhf, std::sinhl": {
        "description": {
            "texte": "If a range error due to overflow occurs, \u00b1HUGE_VAL, \u00b1HUGE_VALF, or \u00b1HUGE_VALL is returned.If a range error occurs due to underflow, the correct result (after rounding) is returned."
        },
        "parametres": "   arg   -   value of a floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << \"sinh(1) = \" << std::sinh(1) << '\\n'\n              << \"sinh(-1) = \" << std::sinh(-1) << '\\n'\n              << \"log(sinh(1)+cosh(1)) = \"\n              << std::log(std::sinh(1)+std::cosh(1)) << '\\n';\n    // special values\n    std::cout << \"sinh(+0) = \" << std::sinh(0.0) << '\\n'\n              << \"sinh(-0) = \" << std::sinh(-0.0) << '\\n';\n    // error handling\n    errno = 0;\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"sinh(710.5) = \" << std::sinh(710.5) << '\\n';\n    if (errno == ERANGE)\n        std::cout << \"    errno == ERANGE: \" << std::strerror(errno) << '\\n';\n    if (std::fetestexcept(FE_OVERFLOW))\n        std::cout << \"    FE_OVERFLOW raised\\n\";\n}",
            "output": "sinh(1) = 1.1752\nsinh(-1) = -1.1752\nlog(sinh(1)+cosh(1)) = 1\nsinh(+0) = 0\nsinh(-0) = -0\nsinh(710.5) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised"
        }
    },
    "cosh(std::valarray)": {
        "description": {
            "texte": "For each element in va computes hyperbolic cosine of the value of the element."
        },
        "parametres": "   va   -   value array to apply the operation to \n\n"
    },
    "cosh, std::coshf, std::coshl": {
        "description": {
            "texte": "If a range error due to overflow occurs, +HUGE_VAL, +HUGE_VALF, or +HUGE_VALL is returned."
        },
        "parametres": "   arg   -   value of a floating-point or Integral type \n\n"
    },
    "tanh(std::valarray)": {
        "description": {
            "texte": "For each element in va computes hyperbolic tangent of the value of the element."
        },
        "parametres": "   va   -   value array to apply the operation to \n\n"
    },
    "tanh, std::tanhf, std::tanhl": {
        "description": {
            "texte": "If a range error occurs due to underflow, the correct result (after rounding) is returned."
        },
        "parametres": "   arg   -   value of a floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n \nint main()\n{\n    std::cout << \"tanh(1) = \" << std::tanh(1) << '\\n'\n              << \"tanh(-1) = \" << std::tanh(-1) << '\\n'\n              << \"tanh(0.1)*sinh(0.2)-cosh(0.2) = \"\n              << std::tanh(0.1) * std::sinh(0.2) - std::cosh(0.2) << '\\n';\n    // special values\n    std::cout << \"tanh(+0) = \" << std::tanh(+0.0) << '\\n'\n              << \"tanh(-0) = \" <<  std::tanh(-0.0) << '\\n';\n}",
            "output": "tanh(1) = 0.761594\ntanh(-1) = -0.761594\ntanh(0.1)*sinh(0.2)-cosh(0.2) = -1\ntanh(+0) = 0\ntanh(-0) = -0"
        }
    },
    "feclearexcept": {
        "description": {
            "texte": "Attempts to clear the floating-point exceptions that are listed in the bitmask argument excepts, which is a bitwise OR of the floating point exception macros."
        },
        "parametres": "   excepts   -   bitmask listing the exception flags to clear \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cfenv>\n#include <cmath>\n \n#pragma STDC FENV_ACCESS ON\n \nvolatile double zero = 0.0; // volatile not needed where FENV_ACCESS is supported\nvolatile double one = 1.0;  // volatile not needed where FENV_ACCESS is supported\n \nint main()\n{\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout <<  \"1.0/0.0 = \" << 1.0 / zero << '\\n';\n    if(std::fetestexcept(FE_DIVBYZERO)) {\n        std::cout << \"division by zero reported\\n\";\n    } else {\n        std::cout << \"divsion by zero not reported\\n\";\n    }\n \n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"1.0/10 = \" << one/10 << '\\n';\n    if(std::fetestexcept(FE_INEXACT)) {\n        std::cout << \"inexact result reported\\n\";\n    } else {\n        std::cout << \"inexact result not reported\\n\";\n    }\n \n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"sqrt(-1) = \" << std::sqrt(-1) << '\\n';\n    if(std::fetestexcept(FE_INVALID)) {\n        std::cout << \"invalid result reported\\n\";\n    } else {\n        std::cout << \"invalid result not reported\\n\";\n    }\n}",
            "output": "1.0/0.0 = inf\ndivision by zero reported\n1.0/10 = 0.1\ninexact result reported\nsqrt(-1) = -nan\ninvalid result reported"
        }
    },
    "fetestexcept": {
        "description": {
            "texte": "Determines which of the specified subset of the floating point exceptions are currently set. The argument excepts is a bitwise OR of the floating point exception macros."
        },
        "parametres": "   excepts   -   bitmask listing the exception flags to test \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cfenv>\n#include <cmath>\n \n#pragma STDC FENV_ACCESS ON\n \nvolatile double zero = 0.0; // volatile not needed where FENV_ACCESS is supported\nvolatile double one = 1.0;  // volatile not needed where FENV_ACCESS is supported\n \nint main()\n{\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout <<  \"1.0/0.0 = \" << 1.0 / zero << '\\n';\n    if(std::fetestexcept(FE_DIVBYZERO)) {\n        std::cout << \"division by zero reported\\n\";\n    } else {\n        std::cout << \"divsion by zero not reported\\n\";\n    }\n \n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"1.0/10 = \" << one/10 << '\\n';\n    if(std::fetestexcept(FE_INEXACT)) {\n        std::cout << \"inexact result reported\\n\";\n    } else {\n        std::cout << \"inexact result not reported\\n\";\n    }\n \n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"sqrt(-1) = \" << std::sqrt(-1) << '\\n';\n    if(std::fetestexcept(FE_INVALID)) {\n        std::cout << \"invalid result reported\\n\";\n    } else {\n        std::cout << \"invalid result not reported\\n\";\n    }\n}",
            "output": "1.0/0.0 = inf\ndivision by zero reported\n1.0/10 = 0.1\ninexact result reported\nsqrt(-1) = -nan\ninvalid result reported"
        }
    },
    "feraiseexcept": {
        "description": {
            "texte": "Attempts to raise all floating point exceptions listed in excepts (a bitwise OR of the floating point exception macros). If one of the exceptions is FE_OVERFLOW or FE_UNDERFLOW, this function may additionally raise FE_INEXACT. The order in which the exceptions are raised is unspecified, except that FE_OVERFLOW and FE_UNDERFLOW are always raised before FE_INEXACT."
        },
        "parametres": "   excepts   -   bitmask listing the exception flags to raise \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\n \nint main()\n{\n    std::feclearexcept(FE_ALL_EXCEPT);\n    int r = std::feraiseexcept(FE_UNDERFLOW | FE_DIVBYZERO);\n    std::cout <<  \"Raising divbyzero and underflow simultaneously \"\n              << (r?\"fails\":\"succeeds\") << \" and results in\\n\";\n    int e = std::fetestexcept(FE_ALL_EXCEPT);\n    if (e & FE_DIVBYZERO) {\n        std::cout << \"division by zero\\n\";\n    }\n    if (e & FE_INEXACT) {\n        std::cout << \"inexact\\n\";\n    }\n    if (e & FE_INVALID) {\n        std::cout << \"invalid\\n\";\n    }\n    if (e & FE_UNDERFLOW) {\n        std::cout << \"underflow\\n\";\n    }\n    if (e & FE_OVERFLOW) {\n        std::cout << \"overflow\\n\";\n    }\n}",
            "output": "Raising divbyzero and underflow simultaneously succeeds and results in\ndivision by zero\nunderflow"
        }
    },
    "fegetexceptflag, std::fesetexceptflag": {
        "description": {
            "texte": "1) Attempts to obtain the full contents of the floating-point exception flags that are listed in the bitmask argument excepts, which is a bitwise OR of the floating point exception macros.2) Attempts to copy the full contents of the floating-point exception flags that are listed in excepts from flagp into the floating-point environment. Does not raise any exceptions, only modifies the flags.The full contents of a floating-point exception flag is not necessarily a boolean value indicating whether the exception is raised or cleared. For example, it may be a struct which includes the boolean status and the address of the code that triggered the exception. These functions obtain all such content and obtain/store it in flagp in implementation-defined format."
        },
        "parametres": "   flagp   -   pointer to an std::fexcept_t object where the flags will be stored or read from \n   excepts   -   bitmask listing the exception flags to get/set \n\n"
    },
    "fegetround, std::fesetround": {
        "description": {
            "texte": "Manages the floating-point rounding direction."
        },
        "parametres": "   round   -   rounding direction, one of floating point rounding macros \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <cfenv>\n#include <iostream>\n \nint main()\n{\n    #pragma STDC FENV_ACCESS ON\n    std::fesetround(FE_DOWNWARD);\n    std::cout << \"rounding using FE_DOWNWARD: \\n\" << std::fixed\n              << \" 12.0 ->  \" << std::nearbyint(12.0) << '\\n'\n              << \" 12.1 ->  \" << std::nearbyint(12.1) << '\\n'\n              << \"-12.1 -> \" << std::nearbyint(-12.1) << '\\n'\n              << \" 12.5 ->  \" << std::nearbyint(12.5) << '\\n'\n              << \" 12.9 ->  \" << std::nearbyint(12.9) << '\\n'\n              << \"-12.9 -> \" << std::nearbyint(-12.9) << '\\n'\n              << \" 13.0 ->  \" << std::nearbyint(13.0) << '\\n';\n    std::fesetround(FE_TONEAREST);\n    std::cout << \"rounding using FE_TONEAREST: \\n\"\n              << \" 12.0 ->  \" << std::nearbyint(12.0) << '\\n'\n              << \" 12.1 ->  \" << std::nearbyint(12.1) << '\\n'\n              << \"-12.1 -> \" << std::nearbyint(-12.1) << '\\n'\n              << \" 12.5 ->  \" << std::nearbyint(12.5) << '\\n'\n              << \" 12.9 ->  \" << std::nearbyint(12.9) << '\\n'\n              << \"-12.9 -> \" << std::nearbyint(-12.9) << '\\n'\n              << \" 13.0 ->  \" << std::nearbyint(13.0) << '\\n';\n}",
            "output": "rounding using FE_DOWNWARD:\n 12.0 ->  12.000000\n 12.1 ->  12.000000\n-12.1 -> -13.000000\n 12.5 ->  12.000000\n 12.9 ->  12.000000\n-12.9 -> -13.000000\n 13.0 ->  13.000000\nrounding using FE_TONEAREST: \n 12.0 ->  12.000000\n 12.1 ->  12.000000\n-12.1 -> -12.000000\n 12.5 ->  12.000000\n 12.9 ->  13.000000\n-12.9 -> -13.000000\n 13.0 ->  13.000000"
        }
    },
    "fegetenv, std::fesetenv": {
        "description": {
            "texte": "Manages the status of the floating-point environment."
        },
        "parametres": "   envp   -   pointer to the object of type std::fenv_t which holds the status of the floating-point environment \n\n"
    },
    "feholdexcept": {
        "description": {
            "texte": "First, saves the current floating-point environment to the object pointed to by envp (similar to std::fegetenv), then clears all floating-point status flags, and then installs the non-stop mode: future floating-point exceptions will not interrupt execution (will not trap), until the floating-point environment is restored by std::feupdateenv or std::fesetenv.This function may be used in the beginning of a subroutine that must hide the floating-point exceptions it may raise from the caller. If only some exceptions must be suppressed, while others must be reported, the non-stop mode is usually ended with a call to std::feupdateenv after clearing the unwanted exceptions."
        },
        "parametres": "   envp   -   pointer to the object of type std::fenv_t where the floating-point environment will be stored \n\n"
    },
    "feupdateenv": {
        "description": {
            "texte": "First, remembers the currently raised floating-point exceptions, then restores the floating-point environment from the object pointed to by envp (similar to std::fesetenv), then raises the floating-point exceptions that were saved.This function may be used to end the non-stop mode established by an earlier call to std::feholdexcept."
        },
        "parametres": "   envp   -   pointer to the object of type std::fenv_t set by an earlier call to std::feholdexcept or std::fegetenv or equal to FE_DFL_ENV \n\n"
    },
    "FE_DIVBYZERO, FE_INEXACT, FE_INVALID, FE_OVERFLOW, FE_UNDERFLOW, FE_ALL_EXCEPT": {
        "description": {
            "texte": "All these macro constants (except FE_ALL_EXCEPT) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions. Each macro is only defined if it is supported.The macro constant FE_ALL_EXCEPT, which expands to the bitwise OR of all other FE_*, is always defined and is zero if floating-point exceptions are not supported by the implementation.The implementation may define additional macro constants in <cfenv> to identify additional floating-point exceptions. All such constants begin with FE_ followed by at least one uppercase letter.See math_errhandling for further details."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <cfenv>\n#include <cmath>\n \n#pragma STDC FENV_ACCESS ON\n \nvolatile double zero = 0.0; // volatile not needed where FENV_ACCESS is supported\nvolatile double one = 1.0;  // volatile not needed where FENV_ACCESS is supported\n \nint main()\n{\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout <<  \"1.0/0.0 = \" << 1.0 / zero << '\\n';\n    if(std::fetestexcept(FE_DIVBYZERO)) {\n        std::cout << \"division by zero reported\\n\";\n    } else {\n        std::cout << \"divsion by zero not reported\\n\";\n    }\n \n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"1.0/10 = \" << one/10 << '\\n';\n    if(std::fetestexcept(FE_INEXACT)) {\n        std::cout << \"inexact result reported\\n\";\n    } else {\n        std::cout << \"inexact result not reported\\n\";\n    }\n \n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"sqrt(-1) = \" << std::sqrt(-1) << '\\n';\n    if(std::fetestexcept(FE_INVALID)) {\n        std::cout << \"invalid result reported\\n\";\n    } else {\n        std::cout << \"invalid result not reported\\n\";\n    }\n}",
            "output": "1.0/0.0 = inf\ndivision by zero reported\n1.0/10 = 0.1\ninexact result reported\nsqrt(-1) = -nan\ninvalid result reported"
        }
    },
    "FE_DOWNWARD, FE_TONEAREST, FE_TOWARDZERO, FE_UPWARD": {
        "description": {
            "texte": "Each of these macro constants expands to a nonnegative integer constant expression, which can be used with std::fesetround and std::fegetround to indicate one of the supported floating-point rounding modes. The implementation may define additional rounding mode constants in <cfenv>, which should all begin with FE_ followed by at least one uppercase letter. Each macro is only defined if it is supported.Additional rounding modes may be supported by an implementation.The current rounding mode affects the following:The current rounding mode does NOT affect the following:As with any floating-point environment functionality, rounding is only guaranteed if #pragma STDC FENV_ACCESS ON is set.",
            "code": "std::lrint(2.1); // 2 or 3"
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <cfenv>\n#include <cmath>\nint main()\n{\n#pragma STDC FENV_ACCESS ON\n    std::fesetround(FE_DOWNWARD);\n    std::cout << \"rounding down: \\n\" << std::setprecision(50)\n              << \"         pi = \" << std::acos(-1.f) << '\\n'\n              << \"stof(\\\"1.1\\\") = \" << std::stof(\"1.1\") << '\\n'\n              << \"  rint(2.1) = \" << std::rint(2.1) << \"\\n\\n\";\n    std::fesetround(FE_UPWARD);\n    std::cout << \"rounding up: \\n\"\n              << \"         pi = \" << std::acos(-1.f) << '\\n'\n              << \"stof(\\\"1.1\\\") = \" << std::stof(\"1.1\") << '\\n'\n              << \"  rint(2.1) = \" << std::rint(2.1) << '\\n';\n}",
            "output": "rounding down: \n         pi = 3.141592502593994140625\nstof(\"1.1\") = 1.099999904632568359375\n  rint(2.1) = 2\n \nrounding up: \n         pi = 3.1415927410125732421875\nstof(\"1.1\") = 1.10000002384185791015625\n  rint(2.1) = 3"
        }
    },
    "FE_DFL_ENV": {
        "description": {
            "texte": "The macro constant FE_DFL_ENV expands to an expression of type const std::fenv_t*, which points to a full copy of the default floating-point environment, that is, the environment as loaded at program startup.Additional macros that begin with FE_ followed by uppercase letters, and have the type const std::fenv_t*, may be supported by an implementation."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\n \nvoid show_env()\n{\n    int e = std::fetestexcept(FE_ALL_EXCEPT);\n    if(e & FE_DIVBYZERO) std::cout << \"division by zero is raised\\n\";\n    if(e & FE_INEXACT)   std::cout << \"inexact is raised\\n\";\n    if(e & FE_INVALID)   std::cout << \"invalid is raised\\n\";\n    if(e & FE_UNDERFLOW) std::cout << \"underflow is raised\\n\";\n    if(e & FE_OVERFLOW)  std::cout << \"overflow is raised\\n\";\n    int r = std::fegetround();\n    switch(r)\n    {  \n        case FE_DOWNWARD: std::cout << \"rounding down\\n\"; break;\n        case FE_TONEAREST: std::cout << \"rounding to nearest\\n\"; break;\n        case FE_TOWARDZERO: std::cout << \"rounding to zero\\n\"; break;\n        case FE_UPWARD: std::cout << \"rounding up\\n\"; break;\n    }\n}\n \nint main()\n{\n    std::cout << \"On startup: \\n\";\n    show_env();\n \n    std::feraiseexcept(FE_UNDERFLOW | FE_OVERFLOW);\n    std::fesetround(FE_UPWARD);\n \n    std::cout << \"\\nBefore restoration: \\n\";\n    show_env();\n \n    std::fesetenv(FE_DFL_ENV);\n \n    std::cout << \"\\nAfter reset to default: \\n\";\n    show_env();\n}",
            "output": "On startup: \nrounding to nearest\n \nBefore restoration: \nunderflow is raised\noverflow is raised\nrounding up\n \nAfter reset to default: \nrounding to nearest"
        }
    },
    "HUGE_VALF, HUGE_VAL, HUGE_VALL": {
        "description": {
            "texte": "The HUGE_VALF, HUGE_VAL and HUGE_VALL macros expand to positive floating point constant expressions which compare equal to the values returned by floating-point functions and operators in case of overflow (see math_errhandling).On implementations that support floating-point infinities, these macros always expand to the positive infinities of float, double, and long double, respectively."
        }
    },
    "INFINITY": {
        "description": {
            "texte": "If the implementation supports floating-point infinities, the macro INFINITY expands to constant expression of type float which evaluates to positive or unsigned infinity.If the implementation does not support floating-point infinities, the macro INFINITY expands to a positive value that is guaranteed to overflow a float at compile time, and the use of this macro generates a compiler warning."
        }
    },
    "NAN": {
        "description": {
            "texte": "The macro NAN expands to constant expression of type float which evaluates to a quiet not-a-number (QNaN) value. If the implementation does not support QNaNs, this macro constant is not defined."
        }
    },
    "MATH_ERRNO, MATH_ERREXCEPT, math_errhandling": {
        "description": {
            "texte": "The macro constant math_errhandling expands to an expression of type int that is either equal to MATH_ERRNO, or equal to MATH_ERREXCEPT, or equal to their bitwise OR (MATH_ERRNO | MATH_ERREXCEPT).The value of math_errhandling indicates the type of error handling that is performed by the floating-point operators and functions:If the implementation supports IEEE floating-point arithmetic (IEC 60559), math_errhandling & MATH_ERREXCEPT is required to be non-zero.The following floating-point error conditions are recognized:"
        },
        "exemple": {
            "input": "#include <iostream>\n#include <cfenv>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << \"MATH_ERRNO is \"\n              << (math_errhandling & MATH_ERRNO ? \"set\" : \"not set\") << '\\n'\n              << \"MATH_ERREXCEPT is \"\n              << (math_errhandling & MATH_ERREXCEPT ? \"set\" : \"not set\") << '\\n';\n    std::feclearexcept(FE_ALL_EXCEPT);\n    errno = 0;\n    std::cout <<  \"log(0) = \" << std::log(0) << '\\n';\n    if(errno == ERANGE)\n            std::cout << \"errno = ERANGE (\" << std::strerror(errno) << \")\\n\";\n    if(std::fetestexcept(FE_DIVBYZERO))\n        std::cout << \"FE_DIVBYZERO (pole error) reported\\n\";\n}",
            "output": "MATH_ERRNO is set\nMATH_ERREXCEPT is set\nlog(0) = -inf\nerrno = ERANGE (Numerical result out of range)\nFE_DIVBYZERO (pole error) reported"
        }
    },
    "FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN": {
        "description": {
            "texte": "The FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN macros each represent a distinct category of floating-point numbers. They all expand to an integer constant expression."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cfloat>\n \nconst char* show_classification(double x) {\n    switch(std::fpclassify(x)) {\n        case FP_INFINITE:  return \"Inf\";\n        case FP_NAN:       return \"NaN\";\n        case FP_NORMAL:    return \"normal\";\n        case FP_SUBNORMAL: return \"subnormal\";\n        case FP_ZERO:      return \"zero\";\n        default:           return \"unknown\";\n    }\n}\nint main()\n{\n    std::cout << \"1.0/0.0 is \" << show_classification(1/0.0) << '\\n'\n              << \"0.0/0.0 is \" << show_classification(0.0/0.0) << '\\n'\n              << \"DBL_MIN/2 is \" << show_classification(DBL_MIN/2) << '\\n'\n              << \"-0.0 is \" << show_classification(-0.0) << '\\n'\n              << \"1.0 is \" << show_classification(1.0) << '\\n';\n}",
            "output": "1.0/0.0 is Inf\n0.0/0.0 is NaN\nDBL_MIN/2 is subnormal\n-0.0 is zero\n1.0 is normal"
        }
    },
    "fmod, std::fmodf, std::fmodl": {
        "description": {
            "texte": "The floating-point remainder of the division operation x/y calculated by this function is exactly the value x - n*y, where n is x/y with its fractional part truncated.The returned value has the same sign as x and is less than y in magnitude."
        },
        "parametres": "   x, y   -   floating point values \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << \"fmod(+5.1, +3.0) = \" << std::fmod(5.1,3) << '\\n'\n              << \"fmod(-5.1, +3.0) = \" << std::fmod(-5.1,3) << '\\n'\n              << \"fmod(+5.1, -3.0) = \" << std::fmod(5.1,-3) << '\\n'\n              << \"fmod(-5.1, -3.0) = \" << std::fmod(-5.1,-3) << '\\n';\n \n    // special values\n    std::cout << \"fmod(+0.0, 1.0) = \" << std::fmod(0, 1) << '\\n'\n              << \"fmod(-0.0, 1.0) = \" << std::fmod(-0.0, 1) << '\\n'\n              << \"fmod(5.1, Inf) = \" << std::fmod(5.1, INFINITY) << '\\n';\n \n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"fmod(+5.1, 0) = \" << std::fmod(5.1, 0) << '\\n';\n    if(std::fetestexcept(FE_INVALID))\n        std::cout << \"    FE_INVALID raised\\n\";\n}",
            "output": "fmod(+5.1, +3.0) = 2.1\nfmod(-5.1, +3.0) = -2.1\nfmod(+5.1, -3.0) = 2.1\nfmod(-5.1, -3.0) = -2.1\nfmod(+0.0, 1.0) = 0\nfmod(-0.0, 1.0) = -0\nfmod(5.1, Inf) = 5.1\nfmod(+5.1, 0) = -nan\n    FE_INVALID raised"
        }
    },
    "remainder, std::remainderf, std::remainderl": {
        "description": {
            "texte": "The IEEE floating-point remainder of the division operation x/y calculated by this function is exactly the value x - n*y, where the value n is the integral value nearest the exact value x/y. When |n-x/y| = \u00bd, the value n is chosen to be even.In contrast to std::fmod(), the returned value is not guaranteed to have the same sign as x.If the returned value is 0, it will have the same sign as x."
        },
        "parametres": "   x, y   -   values of floating-point or integral types \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << \"remainder(+5.1, +3.0) = \" << std::remainder(5.1,3) << '\\n'\n              << \"remainder(-5.1, +3.0) = \" << std::remainder(-5.1,3) << '\\n'\n              << \"remainder(+5.1, -3.0) = \" << std::remainder(5.1,-3) << '\\n'\n              << \"remainder(-5.1, -3.0) = \" << std::remainder(-5.1,-3) << '\\n';\n \n    // special values\n    std::cout << \"remainder(-0.0, 1.0) = \" << std::remainder(-0.0, 1) << '\\n'\n              << \"remainder(5.1, Inf) = \" << std::remainder(5.1, INFINITY) << '\\n';\n \n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"remainder(+5.1, 0) = \" << std::remainder(5.1, 0) << '\\n';\n    if(fetestexcept(FE_INVALID))\n        std::cout << \"    FE_INVALID raised\\n\";\n}",
            "output": "remainder(+5.1, +3.0) = -0.9\nremainder(-5.1, +3.0) = 0.9\nremainder(+5.1, -3.0) = -0.9\nremainder(-5.1, -3.0) = 0.9\nremainder(-0.0, 1.0) = -0\nremainder(5.1, Inf) = 5.1\nremainder(+5.1, 0) = -nan\n    FE_INVALID raised"
        }
    },
    "remquo, std::remquof, std::remquol": {
        "description": {
            "texte": "If successful, returns the floating-point remainder of the division x/y as defined in std::remainder, and stores, in *quo, the sign and at least three of the least significant bits of x/y (formally, stores a value whose sign is the sign of x/y and whose magnitude is congruent modulo 2n to the magnitude of the integral quotient of x/y, where n is an implementation-defined integer greater than or equal to 3).If y is zero, the value stored in *quo is unspecified.If a domain error occurs, an implementation-defined value is returned (NaN where supported).If a range error occurs due to underflow, the correct result is returned if subnormals are supported.If y is zero, but the domain error does not occur, zero is returned."
        },
        "parametres": "   x, y   -   floating point values \n   quo   -   pointer to an integer value to store the sign and some bits of x/y \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\nconst double pi = std::acos(-1);\ndouble cos_pi_x_naive(double x) { return std::cos(pi * x); }\n// the period is 2, values are (0;0.5) positive, (0.5;1.5) negative, (1.5,2) positive\ndouble cos_pi_x_smart(double x)\n{\n    int quadrant;\n    double rem = std::remquo(x, 1, &quadrant);\n    quadrant = (unsigned)quadrant % 2;  // The period is 2.\n    switch(quadrant) {\n        case 0: return std::cos(pi * rem);\n        case 1: return -std::cos(pi * rem);\n    };\n}\nint main()\n{\n    std::cout << \"cos(pi * 0.25) = \" << cos_pi_x_naive(0.25) << '\\n'\n              << \"cos(pi * 1.25) = \" << cos_pi_x_naive(1.25) << '\\n'\n              << \"cos(pi * 2.25) = \" << cos_pi_x_naive(2.25) << '\\n'\n              << \"cos(pi * 0.25) = \" << cos_pi_x_smart(0.25) << '\\n'\n              << \"cos(pi * 1.25) = \" << cos_pi_x_smart(1.25) << '\\n'\n              << \"cos(pi * 2.25) = \" << cos_pi_x_smart(2.25) << '\\n'\n              << \"cos(pi * 1000000000000.25) = \"\n              << cos_pi_x_naive(1000000000000.25) << '\\n'\n              << \"cos(pi * 1000000000001.25) = \"\n              << cos_pi_x_naive(1000000000001.25) << '\\n'\n              << \"cos(pi * 1000000000000.25) = \"\n              << cos_pi_x_smart(1000000000000.25) << '\\n'\n              << \"cos(pi * 1000000000001.25) = \"\n              << cos_pi_x_smart(1000000000001.25) << '\\n';\n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    int quo;\n    std::cout << \"remquo(+Inf, 1) = \" << std::remquo(INFINITY, 1, &quo) << '\\n';\n    if(fetestexcept(FE_INVALID)) std::cout << \"    FE_INVALID raised\\n\";\n}",
            "output": "cos(pi * 0.25) = 0.707107\ncos(pi * 1.25) = -0.707107\ncos(pi * 2.25) = 0.707107\ncos(pi * 0.25) = 0.707107\ncos(pi * 1.25) = -0.707107\ncos(pi * 2.25) = 0.707107\ncos(pi * 1000000000000.25) = 0.707123\ncos(pi * 1000000000001.25) = -0.707117\ncos(pi * 1000000000000.25) = 0.707107\ncos(pi * 1000000000001.25) = -0.707107 \nremquo(+Inf, 1) = -nan\n    FE_INVALID raised"
        }
    },
    "fma, std::fmaf, std::fmal": {
        "description": {
            "texte": "If successful, returns the value of (x*y) + z as if calculated to infinite precision and rounded once to fit the result type (or, alternatively, calculated as a single ternary floating-point operation).If a range error due to overflow occurs, \u00b1HUGE_VAL, \u00b1HUGE_VALF, or \u00b1HUGE_VALL is returned.If a range error due to underflow occurs, the correct value (after rounding) is returned."
        },
        "parametres": "   x, y, z   -   values of floating-point or integral types \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    // demo the difference between fma and built-in operators\n    double in = 0.1;\n    std::cout << \"0.1 double is \" << std::setprecision(23) << in\n              << \" (\" << std::hexfloat << in << std::defaultfloat << \")\\n\"\n              << \"0.1*10 is 1.0000000000000000555112 (0x8.0000000000002p-3), \"\n              << \"or 1.0 if rounded to double\\n\";\n    double expr_result = 0.1 * 10 - 1;\n    double fma_result = fma(0.1, 10, -1);\n    std::cout << \"0.1 * 10 - 1 = \" << expr_result\n              << \" : 1 subtracted after intermediate rounding\\n\"\n              << \"fma(0.1, 10, -1) = \" << std::setprecision(6) << fma_result << \" (\"\n              << std::hexfloat << fma_result << std::defaultfloat << \")\\n\\n\";\n \n    // fma is used in double-double arithmetic\n    double high = 0.1 * 10;\n    double low = fma(0.1, 10, -high);\n    std::cout << \"in double-double arithmetic, 0.1 * 10 is representable as \"\n              << high << \" + \" << low << \"\\n\\n\";\n \n    // error handling \n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"fma(+Inf, 10, -Inf) = \" << std::fma(INFINITY, 10, -INFINITY) << '\\n';\n    if(std::fetestexcept(FE_INVALID))\n        std::cout << \"    FE_INVALID raised\\n\";\n}",
            "output": "0.1 double is 0.10000000000000000555112 (0x1.999999999999ap-4)\n0.1*10 is 1.0000000000000000555112 (0x8.0000000000002p-3), or 1.0 if rounded to double\n0.1 * 10 - 1 = 0 : 1 subtracted after intermediate rounding\nfma(0.1, 10, -1) = 5.55112e-17 (0x1p-54)\n \nin double-double arithmetic, 0.1 * 10 is representable as 1 + 5.55112e-17\n \nfma(+Inf, 10, -Inf) = -nan\n    FE_INVALID raised"
        }
    },
    "fmax, std::fmaxf, std::fmaxl": {
        "description": {
            "texte": "If successful, returns the larger of two floating point values. The value returned is exact and does not depend on any rounding modes."
        },
        "parametres": "   x, y   -   values of floating-point or integral types \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n \nint main()\n{\n    std::cout << \"fmax(2,1)    = \" << std::fmax(2,1) << '\\n'\n              << \"fmax(-Inf,0) = \" << std::fmax(-INFINITY,0) << '\\n'\n              << \"fmax(NaN,-1) = \" << std::fmax(NAN,-1) << '\\n';\n}",
            "output": "fmax(2,1)    = 2\nfmax(-Inf,0) = 0\nfmax(NaN,-1) = -1"
        }
    },
    "fmin, std::fminf, std::fminl": {
        "description": {
            "texte": "If successful, returns the smaller of two floating point values. The value returned is exact and does not depend on any rounding modes."
        },
        "parametres": "   x, y   -   values of floating-point or integral types \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n \nint main()\n{\n    std::cout << \"fmin(2,1)    = \" << std::fmin(2,1) << '\\n'\n              << \"fmin(-Inf,0) = \" << std::fmin(-INFINITY,0) << '\\n'\n              << \"fmin(NaN,-1) = \" << std::fmin(NAN,-1) << '\\n';\n}",
            "output": "fmin(2,1)    = 1\nfmin(-Inf,0) = -inf\nfmin(NaN,-1) = -1"
        }
    },
    "fdim, std::fdimf, std::fdiml": {
        "description": {
            "texte": "If successful, returns the positive difference between x and y.If a range error due to overflow occurs, +HUGE_VAL, +HUGE_VALF, or +HUGE_VALL is returned.If a range error due to underflow occurs, the correct value (after rounding) is returned."
        },
        "parametres": "   x, y   -   values of floating-point or integral types \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << \"fdim(4, 1) = \" << std::fdim(4, 1)\n              << \" fdim(1, 4) = \" << std::fdim(1, 4) << '\\n'\n              << \"fdim(4,-1) = \" << std::fdim(4, -1)\n              << \" fdim(1,-4) = \" << std::fdim(1, -4) << '\\n';\n    // error handling \n    errno = 0;\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"fdim(1e308, -1e308) = \" << std::fdim(1e308, -1e308) << '\\n';\n    if (errno == ERANGE)\n        std::cout << \"    errno == ERANGE: \" << std::strerror(errno) << '\\n';\n    if (std::fetestexcept(FE_OVERFLOW))\n        std::cout << \"    FE_OVERFLOW raised\\n\";\n}",
            "output": "fdim(4, 1) = 3 fdim(1, 4) = 0\nfdim(4,-1) = 5 fdim(1,-4) = 5\nfdim(1e308, -1e308) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised"
        }
    },
    "nan, std::nanf, std::nanl": {
        "description": {
            "texte": "Converts the implementation-defined character string arg into the corresponding quiet NaN value, as if by calling std::strtod, std::strtof, or std::strtold, respectively, as follows:The call std::nan(\"n-char-sequence\"), where n-char-sequence is a sequence of digits, Latin letters, and underscores, is equivalent to the call std::strtod(\"NAN(n-char-sequence)\", (char**)nullptr);.The call std::nan(\"\") is equivalent to the call std::strtod(\"NAN()\", (char**)nullptr);.The call std::nan(\"string\"), where string is neither an n-char-sequence nor an empty string, is equivalent to the call std::strtod(\"NAN\", (char**)nullptr);."
        },
        "parametres": "   arg   -   narrow character string identifying the contents of a NaN \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cstdint>\n#include <cstring>\n \nint main()\n{\n    double f1 = std::nan(\"1\");\n    std::uint64_t f1n; std::memcpy(&f1n, &f1, sizeof f1);\n    std::cout << \"nan(\\\"1\\\") = \" << f1 << \" (\" << std::hex << f1n << \")\\n\";\n \n    double f2 = std::nan(\"2\");\n    std::uint64_t f2n; std::memcpy(&f2n, &f2, sizeof f2);\n    std::cout << \"nan(\\\"2\\\") = \" << f2 << \" (\" << std::hex << f2n << \")\\n\";\n}",
            "output": "nan(\"1\") = nan (7ff0000000000001)\nnan(\"2\") = nan (7ff0000000000002)"
        }
    },
    "exp2, std::exp2f, std::exp2l": {
        "description": {
            "texte": "If no errors occur, the base-2 exponential of n (2n) is returned.If a range error due to overflow occurs, +HUGE_VAL, +HUGE_VALF, or +HUGE_VALL is returned.If a range error occurs due to underflow, the correct result (after rounding) is returned."
        },
        "parametres": "   n   -   value of floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << \"exp2(4) = \" << std::exp2(4) << '\\n'\n              << \"exp2(0.5) = \" << std::exp2(0.5) << '\\n'\n              << \"exp2(-4) = \" << std::exp2(-4) << '\\n';\n    // special values\n    std::cout << \"exp2(-0) = \" << std::exp2(-0.0) << '\\n'\n              << \"exp2(-Inf) = \" << std::exp2(-INFINITY) << '\\n';\n    // error handling\n    errno = 0;\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"exp2(1024) = \" << std::exp2(1024) << '\\n';\n    if (errno == ERANGE)\n        std::cout << \"    errno == ERANGE: \" << std::strerror(errno) << '\\n';\n    if (std::fetestexcept(FE_OVERFLOW))\n        std::cout << \"    FE_OVERFLOW raised\\n\";\n}",
            "output": "exp2(4) = 16\nexp2(0.5) = 1.41421\nexp2(-4) = 0.0625\nexp2(-0) = 1\nexp2(-Inf) = 0\nexp2(1024) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised"
        }
    },
    "expm1, std::expm1f, std::expm1l": {
        "description": {
            "texte": "If no errors occur earg-1 is returned.If a range error due to overflow occurs, +HUGE_VAL, +HUGE_VALF, or +HUGE_VALL is returned.If a range error occurs due to underflow, the correct result (after rounding) is returned."
        },
        "parametres": "   arg   -   value of floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << \"expm1(1) = \" << std::expm1(1) << '\\n'\n              << \"Interest earned in 2 days on on $100, compounded daily at 1%\\n\"\n              << \" on a 30/360 calendar = \"\n              << 100*std::expm1(2*std::log1p(0.01/360)) << '\\n'\n              << \"exp(1e-16)-1 = \" << std::exp(1e-16)-1\n              << \", but expm1(1e-16) = \" << std::expm1(1e-16) << '\\n';\n    // special values\n    std::cout << \"expm1(-0) = \" << std::expm1(-0.0) << '\\n'\n              << \"expm1(-Inf) = \" << std::expm1(-INFINITY) << '\\n';\n    // error handling\n    errno = 0;\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"expm1(710) = \" << std::expm1(710) << '\\n';\n    if (errno == ERANGE)\n        std::cout << \"    errno == ERANGE: \" << std::strerror(errno) << '\\n';\n    if (std::fetestexcept(FE_OVERFLOW))\n        std::cout << \"    FE_OVERFLOW raised\\n\";\n}",
            "output": "expm1(1) = 1.71828\nInterest earned in 2 days on on $100, compounded daily at 1%\n on a 30/360 calendar = 0.00555563\nexp(1e-16)-1 = 0 expm1(1e-16) = 1e-16\nexpm1(-0) = -0\nexpm1(-Inf) = -1\nexpm1(710) = inf\n    errno == ERANGE: Result too large\n    FE_OVERFLOW raised"
        }
    },
    "log2, std::log2f, std::log2l": {
        "description": {
            "texte": "If no errors occur, the base-2 logarithm of arg (log2(arg) or lb(arg)) is returned.If a domain error occurs, an implementation-defined value is returned (NaN where supported).If a pole error occurs, -HUGE_VAL, -HUGE_VALF, or -HUGE_VALL is returned."
        },
        "parametres": "   arg   -   value of floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << \"log2(65536) = \" << std::log2(65536) << '\\n'\n              << \"log2(0.125) = \" << std::log2(0.125) << '\\n'\n              << \"log2(0x020f) = \" << std::log2(0x020f)\n              << \" (highest set bit is in position 9)\\n\"\n              << \"base-5 logarithm of 125 = \" << std::log2(125)/std::log2(5) << '\\n';\n    // special values\n    std::cout << \"log2(1) = \" << std::log2(1) << '\\n'\n              << \"log2(+Inf) = \" << std::log2(INFINITY) << '\\n';\n    // error handling\n    errno = 0;\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"log2(0) = \" << std::log2(0) << '\\n';\n    if (errno == ERANGE)\n        std::cout << \"    errno == ERANGE: \" << std::strerror(errno) << '\\n';\n    if (std::fetestexcept(FE_DIVBYZERO))\n        std::cout << \"    FE_DIVBYZERO raised\\n\";\n}",
            "output": "log2(65536) = 16\nlog2(0.125) = -3\nlog2(0x020f) = 9.04166 (highest set bit is in position 9)\nbase-5 logarithm of 125 = 3\nlog2(1) = 0\nlog2(+Inf) = inf\nlog2(0) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised"
        }
    },
    "log1p, std::log1pf, std::log1pl": {
        "description": {
            "texte": "If no errors occur ln(1+arg) is returned.If a domain error occurs, an implementation-defined value is returned (NaN where supported).If a pole error occurs, -HUGE_VAL, -HUGE_VALF, or -HUGE_VALL is returned.If a range error occurs due to underflow, the correct result (after rounding) is returned."
        },
        "parametres": "   arg   -   value of floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cfenv>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << \"log1p(0) = \" << log1p(0) << '\\n'\n              << \"Interest earned in 2 days on on $100, compounded daily at 1%\\n\"\n              << \" on a 30/360 calendar = \"\n              << 100*expm1(2*log1p(0.01/360)) << '\\n'\n              << \"log(1+1e-16) = \" << std::log(1+1e-16)\n              << \" log1p(1e-16) = \" << std::log1p(1e-16) << '\\n';\n    // special values\n    std::cout << \"log1p(-0) = \" << std::log1p(-0.0) << '\\n'\n              << \"log1p(+Inf) = \" << std::log1p(INFINITY) << '\\n';\n    // error handling\n    errno = 0;\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"log1p(-1) = \" << std::log1p(-1) << '\\n';\n    if (errno == ERANGE)\n        std::cout << \"    errno == ERANGE: \" << std::strerror(errno) << '\\n';\n    if (std::fetestexcept(FE_DIVBYZERO))\n        std::cout << \"    FE_DIVBYZERO raised\\n\";\n}",
            "output": "log1p(0) = 0\nInterest earned in 2 days on on $100, compounded daily at 1%\n on a 30/360 calendar = 0.00555563\nlog(1+1e-16) = 0 log1p(1e-16) = 1e-16\nlog1p(-0) = -0\nlog1p(+Inf) = inf\nlog1p(-1) = -inf\n    errno == ERANGE: Result too large\n    FE_DIVBYZERO raised"
        }
    },
    "cbrt, std::cbrtf, std::cbrtl": {
        "description": {
            "texte": "If no errors occur, the cubic root of arg (3\u221aarg), is returned.If a range error occurs due to underflow, the correct result (after rounding) is returned."
        },
        "parametres": "   arg   -   value of a floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n \nint main()\n{\n    // normal use\n    std::cout << \"cbrt(729) = \" << std::cbrt(729) << '\\n'\n              << \"cbrt(-0.125) = \" << std::cbrt(-0.125) << '\\n';\n    // special values\n    std::cout << \"cbrt(-0) = \" << std::cbrt(-0.0) << '\\n'\n              << \"cbrt(+inf) = \" << std::cbrt(INFINITY) << '\\n';\n}",
            "output": "cbrt(729) = 9\ncbrt(-0.125) = -0.5\ncbrt(-0) = -0\ncbrt(+inf) = inf"
        }
    },
    "hypot, std::hypotf, std::hypotl": {
        "description": {
            "texte": "The value computed by the two-argument version of this function is the length of the hypotenuse of a right-angled triangle with sides of length x and y, or the distance of the point (x,y) from the origin (0,0), or the magnitude of a complex number x+iy.The value computed by the three-argument version of this function is the distance of the point (x,y,z) from the origin (0,0,0)."
        },
        "parametres": "   x, y, z   -   values of floating-point or integral types \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cfenv>\n#include <cfloat>\n#include <cstring>\n \n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    // typical usage\n    std::cout << \"(1,1) cartesian is (\" << std::hypot(1,1)\n              << ',' << std::atan2(1,1) << \") polar\\n\";\n    // special values\n    std::cout << \"hypot(NAN,INFINITY) = \" << std::hypot(NAN,INFINITY) << '\\n';\n    // error handling\n    errno = 0;\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"hypot(DBL_MAX,DBL_MAX) = \" << std::hypot(DBL_MAX,DBL_MAX) << '\\n';\n    if (errno == ERANGE)\n        std::cout << \"    errno = ERANGE \" << std::strerror(errno) << '\\n';\n    if (fetestexcept(FE_OVERFLOW))\n        std::cout << \"    FE_OVERFLOW raised\\n\";\n}",
            "output": "(1,1) cartesian is (1.41421,0.785398) polar\nhypot(NAN,INFINITY) = inf\nhypot(DBL_MAX,DBL_MAX) = inf\n    errno = ERANGE Numerical result out of range\n    FE_OVERFLOW raised"
        }
    },
    "asinh, std::asinhf, std::asinhl": {
        "description": {
            "texte": "If no errors occur, the inverse hyperbolic sine of arg (sinh-1(arg), or arsinh(arg)), is returned.If a range error occurs due to underflow, the correct result (after rounding) is returned."
        },
        "parametres": "   arg   -   value of a floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n \nint main()\n{\n    std::cout << \"asinh(1) = \" << std::asinh(1) << '\\n'\n              << \"asinh(-1) = \" << std::asinh(-1) << '\\n';\n    // special values\n    std::cout << \"asinh(+0) = \" << std::asinh(+0.0) << '\\n'\n              << \"asinh(-0) = \" <<  std::asinh(-0.0) << '\\n';\n}",
            "output": "asinh(1) = 0.881374\nasinh(-1) = -0.881374\nasinh(+0) = 0\nasinh(-0) = -0"
        }
    },
    "acosh, std::acoshf, std::acoshl": {
        "description": {
            "texte": "If no errors occur, the inverse hyperbolic cosine of arg (cosh-1(arg), or arcosh(arg)) on the interval [0, +\u221e], is returned.If a domain error occurs, an implementation-defined value is returned (NaN where supported)."
        },
        "parametres": "   arg   -   value of a floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cfloat>\n#include <cerrno>\n#include <cfenv>\n#include <cstring>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << \"acosh(1) = \" << std::acosh(1) << '\\n'\n              << \"acosh(10) = \" << std::acosh(10) << '\\n'\n              << \"acosh(DBL_MAX) = \" << std::acosh(DBL_MAX) << '\\n'\n              << \"acosh(Inf) = \" <<  std::acosh(INFINITY) << '\\n';\n    // error handling\n    errno = 0;\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"acosh(0.5) = \" << std::acosh(0.5) << '\\n';\n    if (errno == EDOM)\n        std::cout << \"    errno == EDOM: \" << std::strerror(errno) << '\\n';\n    if (std::fetestexcept(FE_INVALID))\n        std::cout << \"    FE_INVALID raised\\n\";\n}",
            "output": "acosh(1) = 0\nacosh(10) = 2.99322\nacosh(DBL_MAX) = 710.476\nacosh(Inf) = inf\nacosh(0.5) = -nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised"
        }
    },
    "atanh, std::atanh, std::atanhl": {
        "description": {
            "texte": "If no errors occur, the inverse hyperbolic tangent of arg (tanh-1(arg), or artanh(arg)), is returned.If a domain error occurs, an implementation-defined value is returned (NaN where supported).If a pole error occurs, \u00b1HUGE_VAL, \u00b1HUGE_VALF, or \u00b1HUGE_VALL is returned (with the correct sign).If a range error occurs due to underflow, the correct result (after rounding) is returned."
        },
        "parametres": "   arg   -   value of a floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cfloat>\n#include <cerrno>\n#include <cfenv>\n#include <cstring>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << \"atanh(0) = \" << std::atanh(0) << '\\n'\n              << \"atanh(-0) = \" << std::atanh(-0.0) << '\\n'\n              << \"atanh(0.9) = \" << std::atanh(0.9) << '\\n';\n    // error handling \n    errno = 0;\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"atanh(-1) = \" << std::atanh(-1) << '\\n';\n    if (errno == ERANGE)\n        std::cout << \"    errno == ERANGE: \" << std::strerror(errno) << '\\n';\n    if (std::fetestexcept(FE_DIVBYZERO))\n        std::cout << \"    FE_DIVBYZERO raised\\n\";\n}",
            "output": "atanh(0) = 0\natanh(-0) = -0\natanh(0.9) = 1.47222\natanh(-1) = -inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised"
        }
    },
    "erf, std::erff, std::erfl": {
        "description": {
            "texte": "  If a range error occurs due to underflow, the correct result (after rounding), that is."
        },
        "parametres": "   arg   -   value of a floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <iomanip>\ndouble phi(double x1, double x2)\n{\n    return (std::erf(x2/std::sqrt(2)) - std::erf(x1/std::sqrt(2)))/2;\n}\nint main()\n{\n    std::cout << \"normal variate probabilities:\\n\"\n              << std::fixed << std::setprecision(2);\n    for(int n=-4; n<4; ++n)\n        std::cout << \"[\" << std::setw(2) << n << \":\" << std::setw(2) << n+1 << \"]: \"\n                  << std::setw(5) << 100*phi(n, n+1) << \"%\\n\";\n \n    std::cout << \"special values:\\n\"\n              << \"erf(-0) = \" << std::erf(-0.0) << '\\n'\n              << \"erf(Inf) = \" << std::erf(INFINITY) << '\\n';\n}",
            "output": "normal variate probabilities:\n[-4:-3]:  0.13%\n[-3:-2]:  2.14%\n[-2:-1]: 13.59%\n[-1: 0]: 34.13%\n[ 0: 1]: 34.13%\n[ 1: 2]: 13.59%\n[ 2: 3]:  2.14%\n[ 3: 4]:  0.13%\nspecial values:\nerf(-0) = -0.00\nerf(Inf) = 1.00"
        }
    },
    "erfc, std::erfcf, std::erfcl": {
        "description": {
            "texte": "If a range error occurs due to underflow, the correct result (after rounding) is returned."
        },
        "parametres": "   arg   -   value of a floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <iomanip>\ndouble normalCDF(double x) // Phi(-\u221e, x) aka N(x)\n{\n    return std::erfc(-x/std::sqrt(2))/2;\n}\nint main()\n{\n    std::cout << \"normal cumulative distribution function:\\n\"\n              << std::fixed << std::setprecision(2);\n    for(double n=0; n<1; n+=0.1)\n        std::cout << \"normalCDF(\" << n << \") \" << 100*normalCDF(n) << \"%\\n\";\n \n    std::cout << \"special values:\\n\"\n              << \"erfc(-Inf) = \" << std::erfc(-INFINITY) << '\\n'\n              << \"erfc(Inf) = \" << std::erfc(INFINITY) << '\\n';\n}",
            "output": "normal cumulative distribution function:\nnormalCDF(0.00) 50.00%\nnormalCDF(0.10) 53.98%\nnormalCDF(0.20) 57.93%\nnormalCDF(0.30) 61.79%\nnormalCDF(0.40) 65.54%\nnormalCDF(0.50) 69.15%\nnormalCDF(0.60) 72.57%\nnormalCDF(0.70) 75.80%\nnormalCDF(0.80) 78.81%\nnormalCDF(0.90) 81.59%\nnormalCDF(1.00) 84.13%\nspecial values:\nerfc(-Inf) = 2.00\nerfc(Inf) = 0.00"
        }
    },
    "tgamma, std::tgammaf, std::tgammal": {
        "description": {
            "texte": "If no errors occur, the value of the gamma function of arg, that is \\(\\mathsf{\\Gamma}(arg) = \\int_0^\\infty t^{arg-1} e^{-t} \\mathsf{d}t\\)\u222b\u221e0targ-1 e-t dt, is returned.If a domain error occurs, an implementation-defined value (NaN where supported) is returned.If a pole error occurs, \u00b1HUGE_VAL, \u00b1HUGE_VALF, or \u00b1HUGE_VALL is returned.If a range error due to overflow occurs, \u00b1HUGE_VAL, \u00b1HUGE_VALF, or \u00b1HUGE_VALL is returned.If a range error due to underflow occurs, the correct value (after rounding) is returned."
        },
        "parametres": "   arg   -   value of a floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << \"tgamma(10) = \" << std::tgamma(10)\n              << \", 9! = \" << 2*3*4*5*6*7*8*9 << '\\n'\n              << \"tgamma(0.5) = \" << std::tgamma(0.5)\n              << \", sqrt(pi) = \" << std::sqrt(std::acos(-1)) << '\\n';\n    // special values\n    std::cout << \"tgamma(1) = \" << std::tgamma(1) << '\\n'\n              << \"tgamma(+Inf) = \" << std::tgamma(INFINITY) << '\\n';\n    // error handling\n    errno=0;\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"tgamma(-1) = \" << std::tgamma(-1) << '\\n';\n    if (errno == EDOM)\n        std::cout << \"    errno == EDOM: \" << std::strerror(errno) << '\\n';\n    if (std::fetestexcept(FE_INVALID))\n        std::cout << \"    FE_INVALID raised\\n\";\n}",
            "output": "tgamma(10) = 362880, 9! = 362880\ntgamma(0.5) = 1.77245, sqrt(pi) = 1.77245\ntgamma(1) = 1\ntgamma(+Inf) = inf\ntgamma(-1) = nan\n    errno == EDOM: Numerical argument out of domain\n    FE_INVALID raised"
        }
    },
    "lgamma, std::lgammaf, std::lgammal": {
        "description": {
            "texte": "If no errors occur, the value of the logarithm of the gamma function of arg, that is loge|\u222b\u221e0targ-1 e-t dt|, is returned.If a pole error occurs, +HUGE_VAL, +HUGE_VALF, or +HUGE_VALL is returned.If a range error due to overflow occurs, \u00b1HUGE_VAL, \u00b1HUGE_VALF, or \u00b1HUGE_VALL is returned."
        },
        "parametres": "   arg   -   value of a floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nconst double pi = std::acos(-1);\nint main()\n{\n    std::cout << \"lgamma(10) = \" << std::lgamma(10)\n              << \",  log(9!) = \" << std::log(2*3*4*5*6*7*8*9) << '\\n'\n              << \"lgamma(0.5) = \" << std::lgamma(0.5)\n              << \" , log(sqrt(pi)) = \" << std::log(std::sqrt(pi)) << '\\n';\n    // special values\n    std::cout << \"lgamma(1) = \" << std::lgamma(1) << '\\n'\n              << \"lgamma(+Inf) = \" << std::lgamma(INFINITY) << '\\n';\n    // error handling\n    errno = 0;\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"lgamma(0) = \" << std::lgamma(0) << '\\n';\n    if (errno == ERANGE)\n        std::cout << \"    errno == ERANGE: \" << std::strerror(errno) << '\\n';\n    if (std::fetestexcept(FE_DIVBYZERO))\n        std::cout << \"    FE_DIVBYZERO raised\\n\";\n}",
            "output": "lgamma(10) = 12.8018,  log(9!) = 12.8018\nlgamma(0.5) = 0.572365 , log(sqrt(pi)) = 0.572365\nlgamma(1) = 0\nlgamma(+Inf) = inf\nlgamma(0) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_DIVBYZERO raised"
        }
    },
    "ceil, std::ceilf, std::ceill": {
        "description": {
            "texte": "If no errors occur, the smallest integer value not less than arg, that is \u2308arg\u2309, is returned."
        },
        "parametres": "   arg   -   floating point value \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\nint main()\n{\n    std::cout << std::fixed\n              << \"ceil(+2.4) = \" << std::ceil(+2.4) << '\\n'\n              << \"ceil(-2.4) = \" << std::ceil(-2.4) << '\\n'\n              << \"ceil(-0.0) = \" << std::ceil(-0.0) << '\\n'\n              << \"ceil(-Inf) = \" << std::ceil(-INFINITY) << '\\n';\n}",
            "output": "ceil(+2.4) = 3.000000\nceil(-2.4) = -2.000000\nceil(-0.0) = -0.000000\nceil(-Inf) = -INF"
        }
    },
    "floor, std::floorf, std::floorl": {
        "description": {
            "texte": "If no errors occur, the largest integer value not greater than arg, that is \u230aarg\u230b, is returned."
        },
        "parametres": "   arg   -   floating point value \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\nint main()\n{\n    std::cout << std::fixed\n              << \"floor(+2.7) = \" << std::floor(+2.7) << '\\n'\n              << \"floor(-2.7) = \" << std::floor(-2.7) << '\\n'\n              << \"floor(-0.0) = \" << std::floor(-0.0) << '\\n'\n              << \"floor(-Inf) = \" << std::floor(-INFINITY) << '\\n';\n}",
            "output": "floor(+2.7) = 2.000000\nfloor(-2.7) = -3.000000\nfloor(-0.0) = -0.000000\nfloor(-Inf) = -inf"
        }
    },
    "trunc, std::truncf, std::truncl": {
        "description": {
            "texte": "If no errors occur, the nearest integer value not greater in magnitude than arg (in other words, arg rounded towards zero) is returned."
        },
        "parametres": "   arg   -   floating point value \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\nint main()\n{\n    std::cout << std::fixed\n              << \"trunc(+2.7) = \" << std::trunc(+2.7) << '\\n'\n              << \"trunc(-2.9) = \" << std::trunc(-2.9) << '\\n'\n              << \"trunc(-0.0) = \" << std::trunc(-0.0) << '\\n'\n              << \"trunc(-Inf) = \" << std::trunc(-INFINITY) << '\\n';\n}",
            "output": "trunc(+2.7) = 2.000000\ntrunc(-2.9) = -2.000000\ntrunc(-0.0) = -0.000000\ntrunc(-Inf) = -inf"
        }
    },
    "round, std::roundf, std::roundl, std::lround, std::lroundf, std::lroundl, std::llround, std::llroundf": {
        "description": {
            "texte": "If no errors occur, the nearest integer value to arg, rounding halfway cases away from zero, is returned.If a domain error occurs, an implementation-defined value is returned."
        },
        "parametres": "   arg   -   floating point value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cfenv>\n#include <climits>\n \n#pragma STDC FENV_ACCESS ON\n \nint main()\n{\n    // round\n    std::cout << \"round(+2.3) = \" << std::round(2.3)\n              << \"  round(+2.5) = \" << std::round(2.5)\n              << \"  round(+2.7) = \" << std::round(2.7) << '\\n'\n              << \"round(-2.3) = \" << std::round(-2.3)\n              << \"  round(-2.5) = \" << std::round(-2.5)\n              << \"  round(-2.7) = \" << std::round(-2.7) << '\\n';\n \n    std::cout << \"round(-0.0) = \" << std::round(-0.0)  << '\\n'\n              << \"round(-Inf) = \" << std::round(-INFINITY) << '\\n';\n \n    // lround\n    std::cout << \"lround(+2.3) = \" << std::lround(2.3)\n              << \"  lround(+2.5) = \" << std::lround(2.5)\n              << \"  lround(+2.7) = \" << std::lround(2.7) << '\\n'\n              << \"lround(-2.3) = \" << std::lround(-2.3)\n              << \"  lround(-2.5) = \" << std::lround(-2.5)\n              << \"  lround(-2.7) = \" << std::lround(-2.7) << '\\n';\n \n    std::cout << \"lround(-0.0) = \" << std::lround(-0.0)  << '\\n'\n              << \"lround(-Inf) = \" << std::lround(-INFINITY) << '\\n';\n \n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"std::lround(LONG_MAX+1.5) = \"\n              << std::lround(LONG_MAX+1.5) << '\\n';\n    if (std::fetestexcept(FE_INVALID))\n              std::cout << \"    FE_INVALID was raised\\n\";\n}",
            "output": "round(+2.3) = 2  round(+2.5) = 3  round(+2.7) = 3\nround(-2.3) = -2  round(-2.5) = -3  round(-2.7) = -3\nround(-0.0) = -0\nround(-Inf) = -inf\nlround(+2.3) = 2  lround(+2.5) = 3  lround(+2.7) = 3\nlround(-2.3) = -2  lround(-2.5) = -3  lround(-2.7) = -3\nlround(-0.0) = 0\nlround(-Inf) = -9223372036854775808\nstd::lround(LONG_MAX+1.5) = -9223372036854775808\n    FE_INVALID was raised"
        }
    },
    "nearbyint, std::nearbyintf, std::nearbyintl": {
        "description": {
            "texte": "The nearest integer value to arg, according to the current rounding mode, is returned."
        },
        "parametres": "   arg   -   floating point value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cfenv>\n \nint main()\n{\n#pragma STDC FENV_ACCESS ON\n    std::fesetround(FE_TONEAREST);\n    std::cout << \"rounding to nearest: \\n\"\n              << \"nearbyint(+2.3) = \" << std::nearbyint(2.3)\n              << \"  nearbyint(+2.5) = \" << std::nearbyint(2.5)\n              << \"  nearbyint(+3.5) = \" << std::nearbyint(3.5) << '\\n'\n              << \"nearbyint(-2.3) = \" << std::nearbyint(-2.3)\n              << \"  nearbyint(-2.5) = \" << std::nearbyint(-2.5)\n              << \"  nearbyint(-3.5) = \" << std::nearbyint(-3.5) << '\\n';\n \n    std::fesetround(FE_DOWNWARD);\n    std::cout << \"rounding down:\\n\"\n              << \"nearbyint(+2.3) = \" << std::nearbyint(2.3)\n              << \"  nearbyint(+2.5) = \" << std::nearbyint(2.5)\n              << \"  nearbyint(+3.5) = \" << std::nearbyint(3.5) << '\\n'\n              << \"nearbyint(-2.3) = \" << std::nearbyint(-2.3)\n              << \"  nearbyint(-2.5) = \" << std::nearbyint(-2.5)\n              << \"  nearbyint(-3.5) = \" << std::nearbyint(-3.5) << '\\n';\n \n    std::cout << \"nearbyint(-0.0) = \" << std::nearbyint(-0.0)  << '\\n'\n              << \"nearbyint(-Inf) = \" << std::nearbyint(-INFINITY) << '\\n';\n}",
            "output": "rounding to nearest: \nnearbyint(+2.3) = 2  nearbyint(+2.5) = 2  nearbyint(+3.5) = 4\nnearbyint(-2.3) = -2  nearbyint(-2.5) = -2  nearbyint(-3.5) = -4\nrounding down:\nnearbyint(+2.3) = 2  nearbyint(+2.5) = 2  nearbyint(+3.5) = 3\nnearbyint(-2.3) = -3  nearbyint(-2.5) = -3  nearbyint(-3.5) = -4\nnearbyint(-0.0) = -0\nnearbyint(-Inf) = -inf"
        }
    },
    "rint, std::rintf, std::rintl, std::lrint, std::lrintf, std::lrintl, std::llrint, std::llrintf": {
        "description": {
            "texte": "If no errors occur, the nearest integer value to arg, according to the current rounding mode, is returned."
        },
        "parametres": "   arg   -   floating point value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cfenv>\n#include <climits>\n \nint main()\n{\n#pragma STDC FENV_ACCESS ON\n    std::fesetround(FE_TONEAREST);\n    std::cout << \"rounding to nearest (halfway cases to even):\\n\"\n              << \"rint(+2.3) = \" << std::rint(2.3)\n              << \"  rint(+2.5) = \" << std::rint(2.5)\n              << \"  rint(+3.5) = \" << std::rint(3.5) << '\\n'\n              << \"rint(-2.3) = \" << std::rint(-2.3)\n              << \"  rint(-2.5) = \" << std::rint(-2.5)\n              << \"  rint(-3.5) = \" << std::rint(-3.5) << '\\n';\n \n    std::fesetround(FE_DOWNWARD);\n    std::cout << \"rounding down:\\n\" \n              << \"rint(+2.3) = \" << std::rint(2.3)\n              << \"  rint(+2.5) = \" << std::rint(2.5)\n              << \"  rint(+3.5) = \" << std::rint(3.5) << '\\n'\n              << \"rint(-2.3) = \" << std::rint(-2.3)\n              << \"  rint(-2.5) = \" << std::rint(-2.5)\n              << \"  rint(-3.5) = \" << std::rint(-3.5) << '\\n'\n              << \"rounding down with lrint\\n\" \n              << \"lrint(+2.3) = \" << std::lrint(2.3)\n              << \"  lrint(+2.5) = \" << std::lrint(2.5)\n              << \"  lrint(+3.5) = \" << std::lrint(3.5) << '\\n'\n              << \"lrint(-2.3) = \" << std::lrint(-2.3)\n              << \"  lrint(-2.5) = \" << std::lrint(-2.5)\n              << \"  lrint(-3.5) = \" << std::lrint(-3.5) << '\\n';\n \n    std::cout << \"lrint(-0.0) = \" << std::lrint(-0.0)  << '\\n'\n              << \"lrint(-Inf) = \" << std::lrint(-INFINITY) << '\\n';\n \n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"std::rint(0.1) = \" << std::rint(.1) << '\\n';\n    if (std::fetestexcept(FE_INEXACT))\n              std::cout << \"    FE_INEXACT was raised\\n\";\n \n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"std::lrint(LONG_MIN-2048.0) = \"\n              << std::lrint(LONG_MIN-2048.0) << '\\n';\n    if (std::fetestexcept(FE_INVALID))\n              std::cout << \"    FE_INVALID was raised\\n\";\n}",
            "output": "rounding to nearest (halfway cases to even): \nrint(+2.3) = 2  rint(+2.5) = 2  rint(+3.5) = 4\nrint(-2.3) = -2  rint(-2.5) = -2  rint(-3.5) = -4\nrounding down:\nrint(+2.3) = 2  rint(+2.5) = 2  rint(+3.5) = 3\nrint(-2.3) = -3  rint(-2.5) = -3  rint(-3.5) = -4\nrounding down with lrint\nlrint(+2.3) = 2  lrint(+2.5) = 2  lrint(+3.5) = 3\nlrint(-2.3) = -3  lrint(-2.5) = -3  lrint(-3.5) = -4\nlrint(-0.0) = 0\nlrint(-Inf) = -9223372036854775808\nstd::rint(0.1) = 0\n    FE_INEXACT was raised\nstd::lrint(LONG_MIN-2048.0) = -9223372036854775808\n    FE_INVALID was raised"
        }
    },
    "frexp, std::frexpf, std::frexpl": {
        "description": {
            "texte": "If arg is zero, returns zero and stores zero in *exp.Otherwise (if arg is not zero), if no errors occur, returns the value x in the range (-1;-0.5], [0.5; 1) and stores an integer value in *exp such that x\u00d72(*exp)=arg.If the value to be stored in *exp is outside the range of int, the behavior is unspecified.If arg is not a floating-point number, the behavior is unspecified."
        },
        "parametres": "   arg   -   floating point value \n   exp   -   pointer to integer value to store the exponent to \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <limits>\n \nint main()\n{\n    double f = 123.45;\n    std::cout << \"Given the number \" << f << \" or \" << std::hexfloat\n              << f << std::defaultfloat << \" in hex,\\n\";\n \n    double f3;\n    double f2 = std::modf(f, &f3);\n    std::cout << \"modf() makes \" << f3 << \" + \" << f2 << '\\n';\n \n    int i;\n    f2 = std::frexp(f, &i);\n    std::cout << \"frexp() makes \" << f2 << \" * 2^\" << i << '\\n';\n \n    i = std::ilogb(f);\n    std::cout << \"logb()/ilogb() make \" << f/std::scalbn(1.0, i) << \" * \"\n              << std::numeric_limits<double>::radix\n              << \"^\" << std::ilogb(f) << '\\n';\n}",
            "output": "Given the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6"
        }
    },
    "ldexp, std::ldexpf, std::ldexpl": {
        "description": {
            "texte": "If no errors occur, x multiplied by 2 to the power of exp (x\u00d72exp) is returned.If a range error due to overflow occurs, \u00b1HUGE_VAL, \u00b1HUGE_VALF, or \u00b1HUGE_VALL is returned.If a range error due to underflow occurs, the correct result (after rounding) is returned."
        },
        "parametres": "   x   -   floating point value \n   exp   -   integer value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << \"ldexp(7, -4) = \" << std::ldexp(7, -4) << '\\n'\n              << \"ldexp(1, -1074) = \" << std::ldexp(1, -1074)\n              << \" (minimum positive subnormal double)\\n\"\n              << \"ldexp(nextafter(1,0), 1024) = \"\n              << std::ldexp(std::nextafter(1,0), 1024)\n              << \" (largest finite double)\\n\";\n    // special values\n    std::cout << \"ldexp(-0, 10) = \" << std::ldexp(-0.0, 10) << '\\n'\n              << \"ldexp(-Inf, -1) = \" << std::ldexp(-INFINITY, -1) << '\\n';\n    // error handling\n    errno = 0;\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"ldexp(1, 1024) = \" << std::ldexp(1, 1024) << '\\n';\n    if (errno == ERANGE)\n        std::cout << \"    errno == ERANGE: \" << std::strerror(errno) << '\\n';\n    if (std::fetestexcept(FE_OVERFLOW))\n        std::cout << \"    FE_OVERFLOW raised\\n\";\n}",
            "output": "ldexp(7, -4) = 0.4375\nldexp(1, -1074) = 4.94066e-324 (minimum positive subnormal double)\nldexp(nextafter(1,0), 1024) = 1.79769e+308 (largest finite double)\nldexp(-0, 10) = -0\nldexp(-Inf, -1) = -inf\nldexp(1, 1024) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised"
        }
    },
    "modf, std::modff, std::modfl": {
        "description": {
            "texte": "If no errors occur, returns the fractional part of x with the same sign as x. The integral part is put into the value pointed to by iptr.The sum of the returned value and the value stored in *iptr gives x (allowing for rounding)."
        },
        "parametres": "   x   -   floating point value \n   iptr   -   pointer to floating point value to store the integral part to \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <limits>\n \nint main()\n{\n    double f = 123.45;\n    std::cout << \"Given the number \" << f << \" or \" << std::hexfloat\n              << f << std::defaultfloat << \" in hex,\\n\";\n \n    double f3;\n    double f2 = std::modf(f, &f3);\n    std::cout << \"modf() makes \" << f3 << \" + \" << f2 << '\\n';\n \n    int i;\n    f2 = std::frexp(f, &i);\n    std::cout << \"frexp() makes \" << f2 << \" * 2^\" << i << '\\n';\n \n    i = std::ilogb(f);\n    std::cout << \"logb()/ilogb() make \" << f/std::scalbn(1.0, i) << \" * \"\n              << std::numeric_limits<double>::radix\n              << \"^\" << std::ilogb(f) << '\\n';\n \n    // special values\n    f2 = std::modf(-0.0, &f3);\n    std::cout << \"modf(-0) makes \" << f3 << \" + \" << f2 << '\\n';\n    f2 = std::modf(-INFINITY, &f3);\n    std::cout << \"modf(-Inf) makes \" << f3 << \" + \" << f2 << '\\n';\n \n}",
            "output": "Given the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6\nmodf(-0) makes -0 + -0\nmodf(-Inf) makes -INF + -0"
        }
    },
    "scalbn, std::scalbnf, std::scalbnl, std::scalbln, std::scalblnf, std::scalblnl": {
        "description": {
            "texte": "If no errors occur, x multiplied by FLT_RADIX to the power of arg (x\u00d7FLT_RADIXexp) is returned.If a range error due to overflow occurs, \u00b1HUGE_VAL, \u00b1HUGE_VALF, or \u00b1HUGE_VALL is returned.If a range error due to underflow occurs, the correct result (after rounding) is returned."
        },
        "parametres": "   x   -   floating point value \n   exp   -   integer value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cerrno>\n#include <cstring>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    std::cout << \"scalbn(7, -4) = \" << std::scalbn(7, -4) << '\\n'\n              << \"scalbn(1, -1074) = \" << std::scalbn(1, -1074)\n              << \" (minimum positive subnormal double)\\n\"\n              << \"scalbn(nextafter(1,0), 1024) = \"\n              << std::scalbn(std::nextafter(1,0), 1024)\n              << \" (largest finite double)\\n\";\n    // special values\n    std::cout << \"scalbn(-0, 10) = \" << std::scalbn(-0.0, 10) << '\\n'\n              << \"scalbn(-Inf, -1) = \" << std::scalbn(-INFINITY, -1) << '\\n';\n    // error handling\n    errno = 0;\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"scalbn(1, 1024) = \" << std::scalbn(1, 1024) << '\\n';\n    if (errno == ERANGE)\n        std::cout << \"    errno == ERANGE: \" << std::strerror(errno) << '\\n';\n    if (std::fetestexcept(FE_OVERFLOW))\n        std::cout << \"    FE_OVERFLOW raised\\n\";\n}",
            "output": "scalbn(7, -4) = 0.4375\nscalbn(1, -1074) = 4.94066e-324 (minimum positive subnormal double)\nscalbn(nextafter(1,0), 1024) = 1.79769e+308 (largest finite double)\nscalbn(-0, 10) = -0\nscalbn(-Inf, -1) = -inf\nscalbn(1, 1024) = inf\n    errno == ERANGE: Numerical result out of range\n    FE_OVERFLOW raised"
        }
    },
    "ilogb, std::ilogbf, std::ilogbl": {
        "description": {
            "texte": "Formally, the unbiased exponent is the integral part of logr|arg| as a signed integral value, for non-zero arg, where r is std::numeric_limits<T>::radix and T is the floating-point type of arg."
        },
        "parametres": "   arg   -   floating point value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <limits>\n#include <cfenv>\n \n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    double f = 123.45;\n    std::cout << \"Given the number \" << f << \" or \" << std::hexfloat\n              << f << std::defaultfloat << \" in hex,\\n\";\n \n    double f3;\n    double f2 = std::modf(f, &f3);\n    std::cout << \"modf() makes \" << f3 << \" + \" << f2 << '\\n';\n \n    int i;\n    f2 = std::frexp(f, &i);\n    std::cout << \"frexp() makes \" << f2 << \" * 2^\" << i << '\\n';\n \n    i = std::ilogb(f);\n    std::cout << \"logb()/ilogb() make \" << f/std::scalbn(1.0, i) << \" * \"\n              << std::numeric_limits<double>::radix\n              << \"^\" << std::ilogb(f) << '\\n';\n \n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"ilogb(0) = \" << std::ilogb(0) << '\\n';\n    if (std::fetestexcept(FE_INVALID))\n        std::cout << \"    FE_INVALID raised\\n\";\n}",
            "output": "Given the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6\nilogb(0) = -2147483648\n    FE_INVALID raised"
        }
    },
    "logb, std::logbf, std::logbl": {
        "description": {
            "texte": "Formally, the unbiased exponent is the signed integral part of logr|arg| (returned by this function as a floating-point value), for non-zero arg, where r is std::numeric_limits<T>::radix and T is the floating-point type of arg. If arg is subnormal, it is treated as though it was normalized."
        },
        "parametres": "   arg   -   floating point value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <limits>\n#include <cfenv>\n#pragma STDC FENV_ACCESS ON\nint main()\n{\n    double f = 123.45;\n    std::cout << \"Given the number \" << f << \" or \" << std::hexfloat\n              << f << std::defaultfloat << \" in hex,\\n\";\n \n    double f3;\n    double f2 = std::modf(f, &f3);\n    std::cout << \"modf() makes \" << f3 << \" + \" << f2 << '\\n';\n \n    int i;\n    f2 = std::frexp(f, &i);\n    std::cout << \"frexp() makes \" << f2 << \" * 2^\" << i << '\\n';\n \n    i = std::ilogb(f);\n    std::cout << \"logb()/ilogb() make \" << f/std::scalbn(1.0, i) << \" * \"\n              << std::numeric_limits<double>::radix\n              << \"^\" << std::ilogb(f) << '\\n';\n \n    // error handling\n    std::feclearexcept(FE_ALL_EXCEPT);\n    std::cout << \"logb(0) = \" << std::logb(0) << '\\n';\n    if (std::fetestexcept(FE_DIVBYZERO))\n        std::cout << \"    FE_DIVBYZERO raised\\n\";\n}",
            "output": "Given the number 123.45 or 0x1.edccccccccccdp+6 in hex,\nmodf() makes 123 + 0.45\nfrexp() makes 0.964453 * 2^7\nlogb()/ilogb() make 1.92891 * 2^6\nlogb(0) = -Inf\n    FE_DIVBYZERO raised"
        }
    },
    "nextafter, std::nextafterf, std::nextafterl, std::nexttoward, std::nexttowardf, std::nexttowardl": {
        "description": {
            "texte": "Returns the next representable value of from in the direction of to."
        },
        "parametres": "   from, to   -   floating point values \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <cfloat>\n#include <cfenv>\n \nint main()\n{\n    float from1 = 0, to1 = std::nextafter(from1, 1.f);\n    std::cout << \"The next representable float after \" << std::setprecision(20) << from1\n              << \" is \" << to1\n              << std::hexfloat << \" (\" << to1 << \")\\n\" << std::defaultfloat;\n \n    float from2 = 1, to2 = std::nextafter(from2, 2.f);\n    std::cout << \"The next representable float after \" << from2 << \" is \" << to2\n              << std::hexfloat << \" (\" << to2 << \")\\n\" << std::defaultfloat;\n \n    double from3 = std::nextafter(0.1, 0), to3 = 0.1;\n    std::cout << \"The number 0.1 lies between two valid doubles:\\n\"\n              << std::setprecision(56) << \"    \" << from3\n              << std::hexfloat << \" (\" << from3 << ')' << std::defaultfloat\n              << \"\\nand \" << to3 << std::hexfloat << \" (\" << to3 << \")\\n\"\n              << std::defaultfloat << std::setprecision(20);\n \n    // difference between nextafter and nexttoward:\n    long double dir = std::nextafter(from1, 1.0L); // first subnormal long double\n    float x = nextafter(from1, dir); // first converts dir to float, giving 0\n    std::cout << \"With nextafter, next float after \" << from1 << \" is \" << x << '\\n';\n    x = std::nexttoward(from1, dir);\n    std::cout << \"With nexttoward, next float after \" << from1 << \" is \" << x << '\\n';\n \n    // special values\n    {\n        #pragma STDC FENV_ACCESS ON\n        std::feclearexcept(FE_ALL_EXCEPT);\n        double from4 = DBL_MAX, to4 = std::nextafter(from4, INFINITY);\n        std::cout << \"The next representable double after \" << std::setprecision(6)\n                  << from4 << std::hexfloat << \" (\" << from4 << ')'\n                  << std::defaultfloat << \" is \" << to4\n                  << std::hexfloat << \" (\" << to4 << \")\\n\" << std::defaultfloat;\n        if(std::fetestexcept(FE_OVERFLOW)) std::cout << \"   raised FE_OVERFLOW\\n\";\n        if(std::fetestexcept(FE_INEXACT)) std::cout << \"   raised FE_INEXACT\\n\";\n    } // end FENV_ACCESS block\n \n    float from5 = 0.0, to5 = std::nextafter(from5, -0.0);\n    std::cout << \"std::nextafter(+0.0, -0.0) gives \" << std::fixed << to5 << '\\n';\n}",
            "output": "The next representable float after 0 is 1.4012984643248170709e-45 (0x1p-149)\nThe next representable float after 1 is 1.0000001192092895508 (0x1.000002p+0)\nThe number 0.1 lies between two valid doubles:\n    0.09999999999999999167332731531132594682276248931884765625 (0x1.9999999999999p-4)\nand 0.1000000000000000055511151231257827021181583404541015625 (0x1.999999999999ap-4)\nWith nextafter, next float after 0 is 0\nWith nexttoward, next float after 0 is 1.4012984643248170709e-45\nThe next representable double after 1.79769e+308 (0x1.fffffffffffffp+1023) is inf (inf)\n   raised FE_OVERFLOW\n   raised FE_INEXACT\nstd::nextafter(+0.0, -0.0) gives -0.000000"
        }
    },
    "copysign, std::copysignf, std::copysignl": {
        "description": {
            "texte": "If no errors occur, the floating point value with the magnitude of x and the sign of y is returned.If x is NaN, then NaN with the sign of y is returned.If y is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations."
        },
        "parametres": "   x, y   -   floating point values \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n \nint main(void)\n{\n    std::cout << \"copysign(1.0,+2.0) = \" << std::copysign(1.0,+2.0) << '\\n'\n              << \"copysign(1.0,-2.0) = \" << std::copysign(1.0,-2.0) << '\\n'\n              << \"copysign(inf,-2.0) = \" << std::copysign(INFINITY,-2.0) << '\\n'\n              << \"copysign(NaN,-2.0) = \" << std::copysign(NAN,-2.0) << '\\n';\n}",
            "output": "copysign(1.0,+2.0) = 1\ncopysign(1.0,-2.0) = -1\ncopysign(inf,-2.0) = -inf\ncopysign(NaN,-2.0) = -nan"
        }
    },
    "fpclassify": {
        "description": {
            "texte": "one of FP_INFINITE, FP_NAN, FP_NORMAL, FP_SUBNORMAL, FP_ZERO or implementation-defined type, specifying the category of arg."
        },
        "parametres": "   arg   -   floating point value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cfloat>\n \nconst char* show_classification(double x) {\n    switch(std::fpclassify(x)) {\n        case FP_INFINITE:  return \"Inf\";\n        case FP_NAN:       return \"NaN\";\n        case FP_NORMAL:    return \"normal\";\n        case FP_SUBNORMAL: return \"subnormal\";\n        case FP_ZERO:      return \"zero\";\n        default:           return \"unknown\";\n    }\n}\nint main()\n{\n    std::cout << \"1.0/0.0 is \" << show_classification(1/0.0) << '\\n'\n              << \"0.0/0.0 is \" << show_classification(0.0/0.0) << '\\n'\n              << \"DBL_MIN/2 is \" << show_classification(DBL_MIN/2) << '\\n'\n              << \"-0.0 is \" << show_classification(-0.0) << '\\n'\n              << \"1.0 is \" << show_classification(1.0) << '\\n';\n}",
            "output": "1.0/0.0 is Inf\n0.0/0.0 is NaN\nDBL_MIN/2 is subnormal\n-0.0 is zero\n1.0 is normal"
        }
    },
    "isfinite": {
        "description": {
            "texte": "true if arg has finite value, false otherwise."
        },
        "parametres": "   arg   -   floating point value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cfloat>\n \nint main()\n{\n    std::cout << std::boolalpha\n              << \"isfinite(NaN) = \" << std::isfinite(NAN) << '\\n'\n              << \"isfinite(Inf) = \" << std::isfinite(INFINITY) << '\\n'\n              << \"isfinite(0.0) = \" << std::isfinite(0.0) << '\\n'\n              << \"isfinite(exp(800)) = \" << std::isfinite(std::exp(800)) << '\\n'\n              << \"isfinite(DBL_MIN/2.0) = \" << std::isfinite(DBL_MIN/2.0) << '\\n';\n}",
            "output": "isfinite(NaN) = false\nisfinite(Inf) = false\nisfinite(0.0) = true\nisfinite(exp(800)) = false\nisfinite(DBL_MIN/2.0) = true"
        }
    },
    "isinf": {
        "description": {
            "texte": "true if arg is infinite, false otherwise."
        },
        "parametres": "   arg   -   floating point value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cfloat>\n \nint main()\n{\n    std::cout << std::boolalpha\n              << \"isinf(NaN) = \" << std::isinf(NAN) << '\\n'\n              << \"isinf(Inf) = \" << std::isinf(INFINITY) << '\\n'\n              << \"isinf(0.0) = \" << std::isinf(0.0) << '\\n'\n              << \"isinf(exp(800)) = \" << std::isinf(std::exp(800)) << '\\n'\n              << \"isinf(DBL_MIN/2.0) = \" << std::isinf(DBL_MIN/2.0) << '\\n';\n}",
            "output": "isinf(NaN) = false\nisinf(Inf) = true\nisinf(0.0) = false\nisinf(exp(800)) = true\nisinf(DBL_MIN/2.0) = false"
        }
    },
    "isnan": {
        "description": {
            "texte": "true if arg is a NaN, false otherwise."
        },
        "parametres": "   arg   -   floating point value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cfloat>\n \nint main()\n{\n    std::cout << std::boolalpha\n              << \"isnan(NaN) = \" << std::isnan(NAN) << '\\n'\n              << \"isnan(Inf) = \" << std::isnan(INFINITY) << '\\n'\n              << \"isnan(0.0) = \" << std::isnan(0.0) << '\\n'\n              << \"isnan(DBL_MIN/2.0) = \" << std::isnan(DBL_MIN/2.0) << '\\n'\n              << \"isnan(0.0 / 0.0)   = \" << std::isnan(0.0/0.0) << '\\n'\n              << \"isnan(Inf - Inf)   = \" << std::isnan(INFINITY - INFINITY) << '\\n';\n}",
            "output": "isnan(NaN) = true\nisnan(Inf) = false\nisnan(0.0) = false\nisnan(DBL_MIN/2.0) = false\nisnan(0.0 / 0.0)   = true\nisnan(Inf - Inf)   = true"
        }
    },
    "isnormal": {
        "description": {
            "texte": "true if arg is normal, false otherwise."
        },
        "parametres": "   arg   -   floating point value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <cfloat>\n \nint main()\n{\n    std::cout << std::boolalpha\n              << \"isnormal(NaN) = \" << std::isnormal(NAN) << '\\n'\n              << \"isnormal(Inf) = \" << std::isnormal(INFINITY) << '\\n'\n              << \"isnormal(0.0) = \" << std::isnormal(0.0) << '\\n'\n              << \"isnormal(DBL_MIN/2.0) = \" << std::isnormal(DBL_MIN/2.0) << '\\n'\n              << \"isnormal(1.0) = \" << std::isnormal(1.0) << '\\n';\n}",
            "output": "isnormal(NaN) = false\nisnormal(Inf) = false\nisnormal(0.0) = false\nisnormal(DBL_MIN/2.0) = false\nisnormal(1.0) = true"
        }
    },
    "signbit": {
        "description": {
            "texte": "true if arg is negative, false otherwise."
        },
        "parametres": "   arg   -   floating point value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n \nint main()\n{\n    std::cout << std::boolalpha\n              << \"signbit(+0.0) = \" << std::signbit(+0.0) << '\\n'\n              << \"signbit(-0.0) = \" << std::signbit(-0.0) << '\\n';\n}",
            "output": "signbit(+0.0) = false\nsignbit(-0.0) = true"
        }
    },
    "isgreater": {
        "description": {
            "texte": "true if x > y, false otherwise."
        },
        "parametres": "   x   -   floating point value \n   y   -   floating point value \n\n"
    },
    "isgreaterequal": {
        "description": {
            "texte": "true if x >= y, false otherwise."
        },
        "parametres": "   x   -   floating point value \n   y   -   floating point value \n\n"
    },
    "isless": {
        "description": {
            "texte": "true if x < y, false otherwise."
        },
        "parametres": "   x   -   floating point value \n   y   -   floating point value \n\n"
    },
    "islessequal": {
        "description": {
            "texte": "true if x <= y, false otherwise."
        },
        "parametres": "   x   -   floating point value \n   y   -   floating point value \n\n"
    },
    "islessgreater": {
        "description": {
            "texte": "true if x < y || x > y, false otherwise."
        },
        "parametres": "   x   -   floating point value \n   y   -   floating point value \n\n"
    },
    "isunordered": {
        "description": {
            "texte": "true if either x or y is NaN, false otherwise."
        },
        "parametres": "   x   -   floating point value \n   y   -   floating point value \n\n"
    },
    "assoc_laguerre, std::assoc_laguerref, std::assoc_laguerrel": {
        "description": {
            "texte": "Errors may be reported as specified in math_errhandling."
        },
        "parametres": "   n   -   the degree of the polymonial, a value of unsigned integer type \n   m   -   the order of the polynomial, a value of unsigned integer type \n   x   -   the argument, a value of a floating-point or integral type \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\ndouble L1(unsigned m, double x) { return -x + m + 1; }\ndouble L2(unsigned m, double x) { return 0.5*(x*x-2*(m+2)*x+(m+1)*(m+2)); }\nint main()\n{\n    // spot-checks\n    std::cout << std::assoc_laguerre(1, 10, 0.5) << '=' << L1(10, 0.5) << '\\n'\n              << std::assoc_laguerre(2, 10, 0.5) << '=' << L2(10, 0.5) << '\\n';\n}",
            "output": "10.5=10.5\n60.125=60.125"
        }
    },
    "assoc_legendre, std::assoc_legendref, std::assoc_legendrel": {
        "description": {
            "texte": "Note that the Condon-Shortley phase term  \\((-1)^m\\)(-1)m is omitted from this definition."
        },
        "parametres": "   n   -   the degree of the polynomial, a value of unsigned integer type \n   m   -   the order of the polynomial, a value of unsigned integer type \n   x   -   the argument, a value of a floating-point or integral type \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\ndouble P20(double x) { return 0.5*(3*x*x-1); }\ndouble P21(double x) { return 3.0*x*std::sqrt(1-x*x); }\ndouble P22(double x) { return 3*(1-x*x); }\nint main()\n{\n    // spot-checks\n    std::cout << std::assoc_legendre(2, 0, 0.5) << '=' << P20(0.5) << '\\n'\n              << std::assoc_legendre(2, 1, 0.5) << '=' << P21(0.5) << '\\n'\n              << std::assoc_legendre(2, 2, 0.5) << '=' << P22(0.5) << '\\n';\n}",
            "output": "-0.125=-0.125\n1.29904=1.29904\n2.25=2.25"
        }
    },
    "comp_ellint_1, std::comp_ellint_1f, std::comp_ellint_1l": {
        "description": {
            "texte": "If no errors occur, value of the complete elliptic integral of the first kind of k, that is ellint_1(k,\u03c0/2), is returned."
        },
        "parametres": "   k   -   elliptic modulus or eccentricity (a value of a floating-point or integral type) \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\nint main()\n{\n    double hpi = std::acos(-1)/2;\n    std::cout << \"K(0) = \" << std::comp_ellint_1(0) << '\\n'\n              << \"\u03c0/2 = \" << hpi << '\\n'\n              << \"K(0.5) = \" << std::comp_ellint_1(0.5) << '\\n'\n              << \"F(0.5, \u03c0/2) = \" << std::ellint_1(0.5, hpi) << '\\n';\n    std::cout << \"Period of a pendulum length 1 m at 90 degree initial angle is \"\n              << 4*std::sqrt(1/9.80665)*\n                 std::comp_ellint_1(std::pow(std::sin(hpi/2),2)) << \" s\\n\";\n}",
            "output": "K(0) = 1.5708\n\u03c0/2 = 1.5708\nK(0.5) = 1.68575\nF(0.5, \u03c0/2) = 1.68575\nPeriod of a pendulum length 1 m at 90 degree initial angle is 2.15324 s"
        }
    },
    "comp_ellint_2, std::comp_ellint_2f, std::comp_ellint_2l": {
        "description": {
            "texte": "If no errors occur, value of the complete elliptic integral of the second kind of k, that is ellint_2(k,\u03c0/2), is returned."
        },
        "parametres": "   k   -   elliptic modulus or eccentricity (a value of a floating-point or integral type) \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\nint main()\n{\n    double hpi = std::acos(-1)/2;\n    std::cout << \"E(0) = \" << std::comp_ellint_2(0) << '\\n'\n              << \"\u03c0/2 = \" << hpi << '\\n'\n              << \"E(1) = \" << std::comp_ellint_2(1) << '\\n'\n              << \"E(1, \u03c0/2) = \" << std::ellint_2(1, hpi) << '\\n';\n}",
            "output": "E(0) = 1.5708\n\u03c0/2 = 1.5708\nE(1) = 1\nE(1, \u03c0/2) = 1"
        }
    },
    "comp_ellint_3, std::comp_ellint_3f, std::comp_ellint_3l": {
        "description": {
            "texte": "If no errors occur, value of the complete elliptic integral of the third kind of k and \u03bd, that is std::ellint_3(k,\u03bd,\u03c0/2), is returned."
        },
        "parametres": "   k   -   elliptic modulus or eccentricity (a value of a floating-point or integral type) \n   \u03bd   -   elliptic characteristic (a value of floating-point or integral type) \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\nint main()\n{\n    double hpi = std::acos(-1)/2;\n    std::cout << \"\u03a0(0.5,0) = \" << std::comp_ellint_3(0.5, 0) << '\\n'\n              << \"K(0.5) = \" << std::comp_ellint_1(0.5) << '\\n'\n              << \"\u03a0(0,0) = \" << std::comp_ellint_3(0, 0) << '\\n'\n              << \"\u03c0/2 = \" << hpi << '\\n'\n              << \"\u03a0(0.5,1) = \" << std::comp_ellint_3(0.5, 1) << '\\n';\n}",
            "output": "\u03a0(0.5,0) = 1.68575\nK(0.5) = 1.68575\n\u03a0(0,0) = 1.5708\n\u03c0/2 = 1.5708\n\u03a0(0.5,1) = inf"
        }
    },
    "cyl_bessel_j, std::cyl_bessel_jf, std::cyl_bessel_jl": {
        "description": {
            "texte": "Errors may be reported as specified in math_errhandling."
        },
        "parametres": "   \u03bd   -   the order of the function \n   x   -   the argument of the function \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\nint main()\n{\n    // spot check for \u03bd == 0\n    double x = 1.2345;\n    std::cout << \"J_0(\" << x << \") = \" << std::cyl_bessel_j(0, x) << '\\n';\n \n    // series expansion for J_0\n    double fct = 1;\n    double sum = 0;\n    for(int k = 0; k < 6; fct*=++k) {\n        sum += std::pow(-1, k)*std::pow((x/2),2*k) / std::pow(fct,2);\n        std::cout << \"sum = \" << sum << '\\n';\n    }        \n}",
            "output": "J_0(1.2345) = 0.653792\nsum = 1\nsum = 0.619002\nsum = 0.655292\nsum = 0.653756\nsum = 0.653793\nsum = 0.653792"
        }
    },
    "cyl_bessel_k, std::cyl_bessel_kf, std::cyl_bessel_kl": {
        "description": {
            "texte": "Errors may be reported as specified in math_errhandling."
        },
        "parametres": "   \u03bd   -   the order of the function \n   x   -   the argument of the function) \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\nint main()\n{\n    double pi = std::acos(-1);\n    double x = 1.2345;\n \n    // spot check for \u03bd == 0.5\n    std::cout << \"K_.5(\" << x << \") = \" << std::cyl_bessel_k( .5, x) << '\\n'\n              << \"calculated via I = \" << \n              (pi/2)*(std::cyl_bessel_i(-.5,x)\n                     -std::cyl_bessel_i(.5,x))/std::sin(.5*pi) << '\\n';\n}",
            "output": "K_.5(1.2345) = 0.32823\ncalculated via I = 0.32823"
        }
    },
    "cyl_neumann, std::cyl_neumannf, std::cyl_neumannl": {
        "description": {
            "texte": "Errors may be reported as specified in math_errhandling."
        },
        "parametres": "   \u03bd   -   the order of the function \n   x   -   the argument of the function) \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\nint main()\n{\n    double pi = std::acos(-1);\n    double x = 1.2345;\n \n    // spot check for \u03bd == 0.5\n    std::cout << \"N_.5(\" << x << \") = \" << std::cyl_neumann(.5, x) << '\\n'\n              << \"calculated via J = \" << \n              (std::cyl_bessel_j(.5,x)*std::cos(.5*pi)\n             - std::cyl_bessel_j(-.5,x))/std::sin(.5*pi) << '\\n';\n}",
            "output": "N_.5(1.2345) = -0.236973\ncalculated via J = -0.236973"
        }
    },
    "ellint_1, std::ellint_1f, std::ellint_1l": {
        "description": {
            "texte": "Errors may be reported as specified in math_errhandling."
        },
        "parametres": "   k   -   elliptic modulus or eccentricity (a value of a floating-point or integral type) \n   \u03c6   -   Jacobi amplitude (a value of floating-point or integral type, measured in radians) \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\nint main()\n{\n    double hpi = std::acos(-1)/2;\n    std::cout << \"F(0,\u03c0/2) = \" << std::ellint_1(0, hpi) << '\\n'\n              << \"F(0,-\u03c0/2) = \" << std::ellint_1(0, -hpi) << '\\n'\n              << \"\u03c0/2 = \" << hpi << '\\n'\n              << \"F(0.7,0) = \" << std::ellint_1(0.7, 0) << '\\n';\n}",
            "output": "F(0,\u03c0/2) = 1.5708\nF(0,-\u03c0/2) = -1.5708\n\u03c0/2 = 1.5708\nF(0.7,0) = 0"
        }
    },
    "ellint_2, std::ellint_2f, std::ellint_2l": {
        "description": {
            "texte": "If no errors occur, value of the incomplete elliptic integral of the second kind of k and \u03c6, that is \u222b\u03c60\u221a1-k2sin2\u03b8d\u03b8, is returned."
        },
        "parametres": "   k   -   elliptic modulus or eccentricity (a value of a floating-point or integral type) \n   \u03c6   -   Jacobi amplitude (a value of floating-point or integral type, measured in radians) \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\nint main()\n{\n    double hpi = std::acos(-1)/2;\n    std::cout << \"E(0,\u03c0/2) = \" << std::ellint_2(0, hpi) << '\\n'\n              << \"E(0,-\u03c0/2) = \" << std::ellint_2(0, -hpi) << '\\n'\n              << \"\u03c0/2 = \" << hpi << '\\n'\n              << \"E(0.7,0) = \" << std::ellint_2(0.7, 0) << '\\n'\n              << \"E(1,\u03c0/2) = \" << std::ellint_2(1, hpi) << '\\n';\n}",
            "output": "F(0,\u03c0/2) = 1.5708\nF(0,-\u03c0/2) = -1.5708\n\u03c0/2 = 1.5708\nF(0.7,0) = 0\nE(1,\u03c0/2) = 1"
        }
    },
    "ellint_3, std::ellint_3f, std::ellint_3l": {
        "description": {
            "texte": "Errors may be reported as specified in math_errhandling."
        },
        "parametres": "   k   -   elliptic modulus or eccentricity (a value of a floating-point or integral type) \n   \u03bd   -   elliptic characteristic (a value of floating-point or integral type) \n   \u03c6   -   Jacobi amplitude (a value of floating-point or integral type, measured in radians) \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\nint main()\n{\n    double hpi = std::acos(-1)/2;\n    std::cout << \"\u03a0(0,0,\u03c0/2) = \" << std::ellint_3(0, 0, hpi) << '\\n'\n              << \"\u03c0/2 = \" << hpi << '\\n';\n}",
            "output": "\u03a0(0,0,\u03c0/2) = 1.5708\n\u03c0/2 = 1.5708"
        }
    },
    "expint, std::expintf, std::expintl": {
        "description": {
            "texte": "Errors may be reported as specified in math_errhandling."
        },
        "parametres": "   arg   -   value of a floating-point or Integral type \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\nint main()\n{\n    std::cout << \"Ei(0) = \" << std::expint(0) << '\\n'\n              << \"Ei(1) = \" << std::expint(1) << '\\n'\n              << \"Gompetz constant = \" << -std::exp(1)*std::expint(-1) << '\\n';\n}",
            "output": "Ei(0) = -inf\nEi(1) = 1.89512\nGompetz constant = 0.596347"
        }
    },
    "legendre, std::legendref, std::legendrel": {
        "description": {
            "texte": "Errors may be reported as specified in math_errhandling."
        },
        "parametres": "   n   -   the degree of the polynomial \n   x   -   the argument, a value of a floating-point or integral type \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\ndouble P3(double x) { return 0.5*(5*std::pow(x,3) - 3*x); }\ndouble P4(double x) { return 0.125*(35*std::pow(x,4)-30*x*x+3); }\nint main()\n{\n    // spot-checks\n    std::cout << std::legendre(3, 0.25) << '=' << P3(0.25) << '\\n'\n              << std::legendre(4, 0.25) << '=' << P4(0.25) << '\\n';\n}",
            "output": "-0.335938=-0.335938\n0.157715=0.157715"
        }
    },
    "laguerre, std::laguerref, std::laguerrel": {
        "description": {
            "texte": "Errors may be reported as specified in math_errhandling."
        },
        "parametres": "   n   -   the degree of the polymonial, a value of unsigned integer type \n   x   -   the argument, a value of a floating-point or integral type \n\n",
        "exemple": {
            "input": "#define __STDCPP_WANT_MATH_SPEC_FUNCS__ 1\n#include <cmath>\n#include <iostream>\ndouble L1(double x) { return -x + 1; }\ndouble L2(double x) { return 0.5*(x*x-4*x+2); }\nint main()\n{\n    // spot-checks\n    std::cout << std::laguerre(1, 0.5) << '=' << L1(0.5) << '\\n'\n              << std::laguerre(2, 0.5) << '=' << L2(0.5) << '\\n';\n}",
            "output": "0.5=0.5\n0.125=0.125"
        }
    },
    "riemann_zeta, std::riemann_zetaf, std::riemann_zetal": {
        "description": {
            "texte": "If no errors occur, value of the Riemann zeta function of arg, \u03b6(arg), defined for the entire real axis:"
        },
        "parametres": "   arg   -   value of a floating-point or integral type \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\nint main()\n{\n    // spot checks for well-known values\n    std::cout << \"\u03b6(-1) = \" << std::riemann_zeta(-1) << '\\n'\n              << \"\u03b6(0) = \" << std::riemann_zeta(0) << '\\n'\n              << \"\u03b6(1) = \" << std::riemann_zeta(1) << '\\n'\n              << \"\u03b6(0.5) = \" << std::riemann_zeta(0.5) << '\\n'\n              << \"\u03b6(2) = \" << std::riemann_zeta(2) << ' '\n              << \"(\u03c0\u00b2/6 = \" << std::pow(std::acos(-1),2)/6 << \")\\n\";\n}",
            "output": "\u03b6(-1) = -0.0833333\n\u03b6(0) = -0.5\n\u03b6(1) = inf\n\u03b6(0.5) = -1.46035\n\u03b6(2) = 1.64493 (\u03c0\u00b2/6 = 1.64493)"
        }
    },
    "sph_bessel, std::sph_besself, std::sph_bessell": {
        "description": {
            "texte": "If no errors occur, returns the value of the spherical Bessel function of the first kind of n and x, that is jn(x) = (\u03c0/2x)1/2Jn+1/2(x) where Jn(x) is std::cyl_bessel_j(n,x) and x\u22650."
        },
        "parametres": "   n   -   the order of the function \n   x   -   the argument of the function \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\nint main()\n{\n    // spot check for n == 1\n    double x = 1.2345;\n    std::cout << \"j_1(\" << x << \") = \" << std::sph_bessel(1, x) << '\\n';\n \n    // exact solution for j_1\n    std::cout << \"(sin x)/x^2 - (cos x)/x = \" << std::sin(x)/(x*x) - std::cos(x)/x << '\\n';\n}",
            "output": "j_1(1.2345) = 0.352106\n(sin x)/x^2 - (cos x)/x = 0.352106"
        }
    },
    "sph_legendre, std::sph_legendref, std::sph_legendrel": {
        "description": {
            "texte": "Note that the Condon-Shortley phase term  (-1)mis included in this definition because it is omitted from the definition of Pml in std::assoc_legendre."
        },
        "parametres": "   l   -   degree \n   m   -   order \n   \u03b8   -   polar angle, measured in radians \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\nint main()\n{\n    // spot check for l=3, m=0\n    double x = 1.2345;\n    std::cout << \"Y_3^0(\" << x << \") = \" << std::sph_legendre(3, 0, x) << '\\n';\n \n    // exact solution\n    double pi = std::acos(-1);\n    std::cout << \"exact solution = \"\n              << 0.25*std::sqrt(7/pi)*(5*std::pow(std::cos(x),3)-3*std::cos(x))\n              << '\\n';\n}",
            "output": "Y_3^0(1.2345) = -0.302387\nexact solution = -0.302387"
        }
    },
    "sph_neumann, std::sph_neumannf, std::sph_neumannl": {
        "description": {
            "texte": "If no errors occur, returns the value of the spherical Bessel function of the second kind (spherical Neumann function) of n and x, that is nn(x) = (\u03c0/2x)1/2Nn+1/2(x) where Nn(x) is std::cyl_neumann(n,x) and x\u22650."
        },
        "parametres": "   n   -   the order of the function \n   x   -   the argument of the function \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <iostream>\nint main()\n{\n    // spot check for n == 1\n    double x = 1.2345;\n    std::cout << \"n_1(\" << x << \") = \" << std::sph_neumann(1, x) << '\\n';\n \n    // exact solution for n_1\n    std::cout << \"-(cos x)/x^2 - (sin x)/x = \"\n              << -std::cos(x)/(x*x) - std::sin(x)/x << '\\n';\n}",
            "output": "n_1(1.2345) = -0.981201\n-(cos x)/x^2 - (sin x)/x = -0.981201"
        }
    },
    "is_error_code_enum\n": {
        "description": {
            "texte": "Specifies that std::future_errc is an error code enum. This enables std::error_code automatic conversions."
        }
    },
    "make_error_code(std::io_errc)\n": {
        "description": {
            "texte": "Constructs an std::error_code object from a value of type std::io_errc as if by return std::error_code(static_cast<int>(e), std::iostream_category()). This function is called by the constructor of std::error_code when given an std::io_errc argument."
        },
        "parametres": "   e   -   error code number \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <system_error>\nint main()\n{\n    std::error_code ec = std::make_error_code(std::io_errc::stream);\n    std::cout << \"Error code from io_errc::stream has category \"\n              << ec.category().name() << '\\n';\n}",
            "output": "Error code from io_errc::stream has category iostream"
        }
    },
    "make_error_condition(std::io_errc)\n": {
        "description": {
            "texte": "Constructs an std::error_condition object from a value of type std::io_errc as if by return std::error_condition(static_cast<int>(e), std::iostream_category())."
        },
        "parametres": "   e   -   error code number \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <system_error>\n#include <string>\n \nint main()\n{\n    std::error_condition ec  = std::make_error_condition(std::io_errc::stream);\n    std::cout << \"error condition for io_errc::stream has value \" << ec.value()\n              << \"\\nand message \\\"\" << ec.message() << \"\\\"\\n\";\n}",
            "output": "error condition for io_errc::stream has value 1\nand message \"unspecified iostream_category error\""
        }
    },
    "showbase, std::noshowbase": {
        "description": {
            "texte": "1) enables the showbase flag in the stream str as if by calling str.setf(std::ios_base::showbase).2) disables the showbase flag in the stream str as if by calling str.unsetf(std::ios_base::showbase).This is an I/O manipulator, it may be called with an expression such as out << std::showbase for any out of type std::basic_ostream or with an expression such as in >> std::showbase for any in of type std::basic_istream.The showbase flag affects the behavior of integer output (see std::num_put::put), monetary input (see std::money_get::get) and monetary output (see std::money_put::put)."
        },
        "parametres": "   str   -   reference to I/O stream \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <locale>\n#include <iostream>\n#include <iomanip>\nint main()\n{\n    // showbase affects the output of octals and hexadecimals\n    std::cout << std::hex\n              << \"showbase: \" << std::showbase << 42 << '\\n'\n              << \"noshowbase: \" << std::noshowbase << 42 << '\\n';\n \n    // and both input and output of monetary values\n    std::locale::global(std::locale(\"en_US.utf8\"));\n    long double val = 0;\n    std::istringstream is(\"3.14\");\n    is >> std::showbase >> std::get_money(val);\n    std::cout << \"With showbase, parsing 3.14 as money gives \" << val << '\\n';\n    is.seekg(0);\n    is >> std::noshowbase >> std::get_money(val);\n    std::cout << \"Without showbase, parsing 3.14 as money gives \" << val << '\\n';\n}",
            "output": "showbase: 0x2a\nnoshowbase: 2a\nWith showbase, parsing 3.14 as money gives 0\nWithout showbase, parsing 3.14 as money gives 314"
        }
    },
    "showpoint, std::noshowpoint": {
        "description": {
            "texte": "Enables or disables the unconditional inclusion of the decimal point character in floating-point output. Has no effect on input.This is an I/O manipulator, it may be called with an expression such as out << std::showpoint for any out of type std::basic_ostream or with an expression such as in >> std::showpoint for any in of type std::basic_istream.The character to use as decimal point character is determined by the numpunct facet of the locale imbued in the stream at the time of output, as described in std::num_put::put."
        },
        "parametres": "   str   -   reference to I/O stream \n\n",
        "exemple": {
            "input": "#include <iostream>\nint main()\n{\n    std::cout << \"1.0 with showpoint: \" << std::showpoint << 1.0 << '\\n'\n              << \"1.0 with noshowpoint: \" << std::noshowpoint << 1.0 << '\\n';\n}",
            "output": "1.0 with showpoint: 1.00000\n1.0 with noshowpoint: 1"
        }
    },
    "showpos, std::noshowpos": {
        "description": {
            "texte": "Enables or disables the display of the plus sign '+' in non-negative integer output. Has no effect on input.1) enables the showpos flag in the stream str as if by calling str.setf(std::ios_base::showpos).2) disables the showpos flag in the stream str as if by calling str.unsetf(std::ios_base::showpos).This is an I/O manipulator, it may be called with an expression such as out << std::showpos for any out of type std::basic_ostream or with an expression such as in >> std::showpos for any in of type std::basic_istream."
        },
        "parametres": "   str   -   reference to I/O stream \n\n",
        "exemple": {
            "input": "#include <iostream>\nint main()\n{\n        std::cout << \"showpos: \" << std::showpos << 42 << ' ' << 3.14 << ' ' << 0 << '\\n'\n                  << \"noshowpos: \" << std::noshowpos << 42 << ' ' << 3.14 << ' ' << 0 << '\\n';\n}",
            "output": "showpos: +42 +3.14 +0\nnoshowpos: 42 3.14 0"
        }
    },
    "skipws, std::noskipws": {
        "description": {
            "texte": "Enables or disables skipping of leading whitespace by the formatted input functions (enabled by default). Has no effect on output.1) enables the skipws flag in the stream str as if by calling str.setf(std::ios_base::skipws).2) disables the skipws flag in the stream str as if by calling str.unsetf(std::ios_base::skipws).The whitespace skipping is performed by the constructor of std::basic_istream::sentry, which reads and discards the characters classified as whitespace by the std::ctype facet of the stream's imbued locale.This is an I/O manipulator, it may be called with an expression such as out << std::noskipws for any out of type std::basic_ostream or with an expression such as in >> std::noskipws for any in of type std::basic_istream."
        },
        "parametres": "   str   -   reference to I/O stream \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\nint main()\n{\n    char c1, c2, c3;\n    std::istringstream(\"a b c\") >> c1 >> c2 >> c3;\n    std::cout << \"Default  behavior: c1 = \" << c1 << \" c2 = \" << c2 << \" c3 = \" << c3 << '\\n';\n    std::istringstream(\"a b c\") >> std::noskipws >> c1 >> c2 >> c3;\n    std::cout << \"noskipws behavior: c1 = \" << c1 << \" c2 = \" << c2 << \" c3 = \" << c3 << '\\n';\n}",
            "output": "Default  behavior: c1 = a c2 = b c3 = c\nnoskipws behavior: c1 = a c2 =   c3 = b"
        }
    },
    "uppercase, std::nouppercase": {
        "description": {
            "texte": "Enables the use of uppercase characters in floating-point and hexadecimal integer output. Has no effect on input.1) enables the uppercase flag in the stream str as if by calling str.setf(std::ios_base::uppercase).2) disables the uppercase flag in the stream str as if by calling str.unsetf(std::ios_base::uppercase).This is an I/O manipulator, it may be called with an expression such as out << std::uppercase for any out of type std::basic_ostream or with an expression such as in >> std::uppercase for any in of type std::basic_istream."
        },
        "parametres": "   str   -   reference to I/O stream \n\n",
        "exemple": {
            "input": "#include <iostream>\nint main()\n{\n    std::cout << std::hex << std::showbase\n              << \"0x2a with uppercase: \" << std::uppercase << 0x2a << '\\n'\n              << \"0x2a with nouppercase: \" << std::nouppercase << 0x2a << '\\n'\n              << \"1e-10 with uppercase: \" << std::uppercase << 1e-10 << '\\n'\n              << \"1e-10 with nouppercase: \" << std::nouppercase << 1e-10 << '\\n';\n}",
            "output": "0x2a with uppercase: 0X2A\n0x2a with nouppercase: 0x2a\n1e-10 with uppercase: 1E-10\n1e-10 with nouppercase: 1e-10"
        }
    },
    "unitbuf, std::nounitbuf": {
        "description": {
            "texte": "Enables or disables automatic flushing of the output stream after any output operation. Has no effect on input.1) enables the unitbuf flag in the stream str as if by calling str.setf(std::ios_base::unitbuf).2) disables the unitbuf flag in the stream str as if by calling str.unsetf(std::ios_base::unitbuf).This is an I/O manipulator, it may be called with an expression such as out << std::unitbuf for any out of type std::basic_ostream or with an expression such as in >> std::unitbuf for any in of type std::basic_istream."
        },
        "parametres": "   str   -   reference to I/O stream \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n \ntemplate<typename Diff>\nvoid log_progress(Diff d)\n{\n    std::cout << \"..(\"\n              << std::chrono::duration_cast<std::chrono::milliseconds>(d).count()\n              << \" ms)..\";\n}\n \nint main()\n{\n    volatile int sink = 0;\n    std::cout << std::unitbuf; // enable automatic flushing\n \n    auto t1 = std::chrono::high_resolution_clock::now();\n    for (int j = 0; j < 5; ++j)\n    {\n        for (int n = 0; n < 10000; ++n)\n            for (int m = 0; m < 20000; ++m)\n                sink += m * n; // do some work\n        auto now = std::chrono::high_resolution_clock::now();\n        log_progress(now - t1);\n    }\n    std::cout << '\\n';\n}",
            "output": "..(450 ms)....(902 ms)....(1352 ms)....(1802 ms)....(2252 ms).."
        }
    },
    "left, std::right, std::internal": {
        "description": {
            "texte": "Modifies the default positioning of the fill characters. left and right apply to any output, internal applies to integer, floating-point, and monetary output. Has no effect on input.1) sets the adjustfield of the stream str to left as if by calling str.setf(std::ios_base::left, std::ios_base::adjustfield).2) sets the adjustfield of the stream str to right as if by calling str.setf(std::ios_base::right, std::ios_base::adjustfield).3) sets the adjustfield of the stream str to internal as if by calling str.setf(std::ios_base::internal, std::ios_base::adjustfield).This is an I/O manipulator. It may be called with an expression such as out << std::left for any out of type std::basic_ostream or with an expression such as in >> std::left for any in of type std::basic_istream."
        },
        "parametres": "   str   -   reference to I/O stream \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <locale>\n \nint main()\n{\n    std::cout.imbue(std::locale(\"en_US.utf8\"));\n    std::cout << \"Left fill:\\n\" << std::left << std::setfill('*')\n              << std::setw(12) << -1.23  << '\\n'\n              << std::setw(12) << std::hex << std::showbase << 42 << '\\n'\n              << std::setw(12) << std::put_money(123, true) << \"\\n\\n\";\n \n    std::cout << \"Internal fill:\\n\" << std::internal\n              << std::setw(12) << -1.23  << '\\n'\n              << std::setw(12) << 42 << '\\n'\n              << std::setw(12) << std::put_money(123, true) << \"\\n\\n\";\n \n    std::cout << \"Right fill:\\n\" << std::right\n              << std::setw(12) << -1.23  << '\\n'\n              << std::setw(12) << 42 << '\\n'\n              << std::setw(12) << std::put_money(123, true) << '\\n';\n}",
            "output": "Left fill:\n-1.23*******\n0x2a********\nUSD *1.23***\n \nInternal fill:\n-*******1.23\n0x********2a\nUSD ****1.23\n \nRight fill:\n*******-1.23\n********0x2a\n***USD *1.23"
        }
    },
    "fixed, std::scientific, std::hexfloat, std::defaultfloat": {
        "description": {
            "texte": "Modifies the default formatting for floating-point input/output.This is an I/O manipulator, it may be called with an expression such as out << std::fixed for any out of type std::basic_ostream or with an expression such as in >> std::scientific for any in of type std::basic_istream."
        },
        "parametres": "   str   -   reference to I/O stream \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::cout << \"The number 0.01 in fixed:      \" << std::fixed << 0.01 << '\\n'\n              << \"The number 0.01 in scientific: \" << std::scientific << 0.01 << '\\n'\n              << \"The number 0.01 in hexfloat:   \" << std::hexfloat << 0.01 << '\\n'\n              << \"The number 0.01 in default:    \" << std::defaultfloat << 0.01 << '\\n';\n    double f;\n    std::istringstream(\"0x1P-1022\") >> std::hexfloat >> f;\n    std::cout << \"Parsing 0x1P-1022 as hex gives \" << f << '\\n';\n}",
            "output": "The number 0.01 in fixed:      0.010000\nThe number 0.01 in scientific: 1.000000e-02\nThe number 0.01 in hexfloat:   0x1.47ae147ae147bp-7\nThe number 0.01 in default:    0.01\nParsing 0x1P-1022 as hex gives 2.22507e-308"
        }
    },
    "ios_base::failure": {
        "description": {
            "texte": "The class std::ios_base::failure defines an exception object that is thrown on failure by the functions in the Input/Output library.std::ios_base::failure may be defined either as a member class of std::ios_base or as a synonym (typedef) for another class with equivalent functionality. (since C++17)."
        },
        "parametres": "   message   -   explanatory string \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\nint main()\n{\n    std::ifstream f(\"doesn't exist\");\n    try {\n        f.exceptions(f.failbit);\n    } catch (const std::ios_base::failure& e)\n    {\n        std::cout << \"Caught an ios_base::failure.\\n\"\n                  << \"Explanatory string: \" << e.what() << '\\n'\n                  << \"Error code: \" << e.code() << '\\n';\n    }\n}",
            "output": "Caught an ios_base::failure.\nExplanatory string: ios_base::clear: unspecified iostream_category error\nError code: iostream:1"
        }
    },
    "ios_base::Init": {
        "description": {
            "texte": "This class is used to ensure that the default C++ streams (std::cin, std::cout, etc.) are properly initialized and destructed. The class tracks how many instances of it are created and initializes the C++ streams when the first instance is constructed as well as flushes the output streams when the last instance is destructed.The header <iostream> behaves as if it defines (directly or indirectly) an instance of std::ios_base::Init with static storage duration: this makes it safe to access the standard I/O streams in the constructors and destructors of static objects with ordered initialization (as long as #include <iostream> is included in the translation unit before these objects were defined)."
        }
    },
    "resetiosflags": {
        "description": {
            "texte": "When used in an expression out << resetiosflags(mask) or in >> resetiosflags(mask), clears all format flags of the stream out or in as specified by the mask."
        },
        "parametres": "   mask   -   bitmask of the flags to clear \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <iostream>\n#include <iomanip>\nint main()\n{\n    std::istringstream in(\"10 010 10 010 10 010\");\n    int n1, n2;\n    in >> std::oct >> n1 >> n2;\n    std::cout << \"Parsing \\\"10 010\\\" with std::oct gives:  \" << n1 << ' ' << n2 << '\\n';\n    in >> std::dec >> n1 >> n2;\n    std::cout << \"Parsing \\\"10 010\\\" with std::dec gives:  \" << n1 << ' ' << n2 << '\\n';\n    in >> std::resetiosflags(std::ios_base::basefield) >> n1 >> n2;\n    std::cout << \"Parsing \\\"10 010\\\" with autodetect gives: \" << n1 << ' ' << n2 << '\\n';\n}",
            "output": "Parsing \"10 010\" with std::oct gives:  8 8\nParsing \"10 010\" with std::dec gives:  10 10\nParsing \"10 010\" with autodetect gives: 10 8"
        }
    },
    "setiosflags": {
        "description": {
            "texte": "When used in an expression out << setiosflags(mask) or in >> setiosflags(mask), sets all format flags of the stream out or in as specified by the mask."
        },
        "parametres": "   mask   -   bitmask of the flags to set \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n \nint main()\n{\n    std::cout <<  std::resetiosflags(std::ios_base::dec) \n              <<  std::setiosflags(  std::ios_base::hex\n                                   | std::ios_base::uppercase\n                                   | std::ios_base::showbase) << 42 << '\\n';\n}",
            "output": "0X2A"
        }
    },
    "setbase": {
        "description": {
            "texte": "Sets the numeric base of the stream. When used in an expression out << setbase(base) or in >> setbase(base), changes the basefield flag of the stream out or in, depending on the value of base:Values of base other than 8, 10, or 16 reset basefield to zero, which corresponds to decimal output and prefix-dependent input."
        },
        "parametres": "   base   -   new value for basefield \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n#include <iomanip>\nint main()\n{\n    std::cout << \"Parsing string \\\"10 0x10 010\\\"\\n\";\n \n    int n1, n2, n3;\n    std::istringstream s(\"10 0x10 010\");\n    s >> std::setbase(16) >> n1 >> n2 >> n3;\n    std::cout << \"hexadecimal parse: \" << n1 << ' ' << n2 << ' ' << n3 << '\\n';\n \n    s.clear();\n    s.seekg(0);\n    s >> std::setbase(0) >> n1 >> n2 >> n3;\n    std::cout << \"prefix-dependent parse: \" << n1 << ' ' << n2 << ' ' << n3 << '\\n';\n \n    std::cout << \"hex output: \" << std::setbase(16)\n              << std::showbase << n1 << ' ' << n2 << ' ' << n3 << '\\n';\n}",
            "output": "Parsing string \"10 0x10 010\"\nhexadecimal parse: 16 16 16\nprefix-dependent parse: 10 16 8\nhex output: 0xa 0x10 0x8"
        }
    },
    "setfill": {
        "description": {
            "texte": "When used in an expression out << setfill(c) sets the fill character of the stream out to c."
        },
        "parametres": "   c   -   new value for the fill character \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\nint main()\n{\n    std::cout << \"default fill: \" << std::setw(10) << 42 << '\\n'\n              << \"setfill('*'): \" << std::setfill('*')\n                                  << std::setw(10) << 42 << '\\n';\n}",
            "output": "default fill:         42\nsetfill('*'): ********42"
        }
    },
    "setprecision": {
        "description": {
            "texte": "When used in an expression out << setprecision(n) or in >> setprecision(n), sets the precision parameter of the stream out or in to exactly n."
        },
        "parametres": "   n   -   new value for precision \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <limits>\nint main()\n{\n    const long double pi = std::acos(-1.L);\n    std::cout << \"default precision (6): \" << pi << '\\n'\n              << \"std::setprecision(10): \" << std::setprecision(10) << pi << '\\n'\n              << \"max precision:         \"\n              << std::setprecision(std::numeric_limits<long double>::digits10 + 1)\n              << pi << '\\n';\n}",
            "output": "default precision (6): 3.14159\nstd::setprecision(10): 3.141592654\nmax precision:         3.141592653589793239"
        }
    },
    "setw": {
        "description": {
            "texte": "When used in an expression out << setw(n) or in >> setw(n), sets the width parameter of the stream out or in to exactly n."
        },
        "parametres": "   n   -   new value for width \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <iostream>\n#include <iomanip>\n \nint main()\n{\n    std::cout << \"no setw:\" << 42 << '\\n'\n              << \"setw(6):\" << std::setw(6) << 42 << '\\n'\n              << \"setw(6), several elements: \" << 89 << std::setw(6) << 12 << 34 << '\\n';\n    std::istringstream is(\"hello, world\");\n    char arr[10];\n    is >> std::setw(6) >> arr;\n    std::cout << \"Input from \\\"\" << is.str() << \"\\\" with setw(6) gave \\\"\"\n              << arr << \"\\\"\\n\";\n}",
            "output": "no setw:42\nsetw(6):    42\nsetw(6), several elements: 89    1234\nInput from \"hello, world\" with setw(6) gave \"hello\""
        }
    },
    "get_money": {
        "description": {
            "texte": "When used in an expression in >> get_money(mon, intl), parses the character input as a monetary value, as specified by the std::money_get facet of the locale currently imbued in in, and stores the value in mon.The extraction operation in in >> get_money(mon, intl) behaves as a FormattedInputFunction."
        },
        "parametres": "   mon   -   variable where monetary value will be written. Can be either long double or basic_string \n   intl   -   expects to find required international currency strings if true, expects optional currency symbols otherwise \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n#include <locale>\n#include <iomanip>\n \nint main()\n{\n    std::istringstream in(\"$1,234.56 2.22 USD  3.33\");\n    long double v1, v2;\n    std::string v3;\n    in.imbue(std::locale(\"en_US.UTF-8\"));\n    in >> std::get_money(v1) >> std::get_money(v2) >> std::get_money(v3, true);\n    if (in) {\n        std::cout << std::quoted(in.str()) << \" parsed as: \"\n                  << v1 << \", \" << v2 << \", \" << v3 << '\\n';\n    } else {\n        std::cout << \"Parse failed\";\n    }\n}",
            "output": "\"$1,234.56 2.22 USD  3.33\" parsed as: 123456, 222, 333"
        }
    },
    "put_money": {
        "description": {
            "texte": "When used in an expression out << put_money(mon, intl), converts the monetary value mon to its character representation as specified by the std::money_put facet of the locale currently imbued in out.The insertion operation in out << put_money(mon, intl) behaves as a FormattedOutputFunction."
        },
        "parametres": "   mon   -   a monetary value, either long double or std::basic_string \n   intl   -   use international currency strings if true, use currency symbols otherwise \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n \nint main()\n{\n    long double mon = 123.45; // or std::string mon = \"123.45\";\n \n    std::cout.imbue(std::locale(\"en_US.utf8\"));\n    std::cout << std::showbase\n              << \"en_US: \" << std::put_money(mon)\n              << \" or \" << std::put_money(mon, true) << '\\n';\n \n    std::cout.imbue(std::locale(\"ru_RU.utf8\"));\n    std::cout << \"ru_RU: \" << std::put_money(mon)\n              << \" or \" << std::put_money(mon, true) << '\\n';\n \n    std::cout.imbue(std::locale(\"ja_JP.utf8\"));\n    std::cout << \"ja_JP: \" << std::put_money(mon)\n              << \" or \" << std::put_money(mon, true) << '\\n';\n}",
            "output": "en_US: $1.23 or USD  1.23\nru_RU: 1.23 \u0440\u0443\u0431 or 1.23 RUB \nja_JP: \uffe5123 or JPY  123"
        }
    },
    "get_time": {
        "description": {
            "texte": "When used in an expression in >> get_time(tmb, fmt), parses the character input as a date/time value according to format string fmt according to the std::time_get facet of the locale currently imbued in the input stream in. The resultant value is stored in a std::tm object pointed to by tmb."
        },
        "parametres": "   tmb   -   valid pointer to the std::tm object where the result will be stored \n   fmt   -   pointer to a null-terminated CharT string specifying the conversion format The format string consists of zero or more conversion specifiers, whitespace characters, and ordinary characters (except %). Each ordinary character is expected to match one character in the input stream in case-insensitive comparison. Each whitespace character matches arbitrary whitespace in the input string. Each conversion specification begins with % character, optionally followed by E or O modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The format specifiers match the POSIX function strptime():\n   Conversion specifier   Explanation   Writes to fields \n   %   matches a literal %. The full conversion specification must be %%.   (none) \n   t   matches any whitespace.   (none) \n   n   matches any whitespace.   (none) \n   Year \n   Y   parses full year as a 4 digit decimal number, leading zeroes permitted but not required   tm_year \n   EY   parses year in the alternative representation, e.g.\u5e73\u621023\u5e74 (year Heisei 23) which writes 2011 to tm_year in ja_JP locale   tm_year \n   y   parses last 2 digits of year as a decimal number. Range [69,99] results in values 1969 to 1999, range [00,68] results in 2000-2068   tm_year \n   Oy   parses last 2 digits of year using the alternative numeric system, e.g. \u5341\u4e00 is parsed as 11 in ja_JP locale   tm_year \n   Ey   parses year as offset from locale's alternative calendar period %EC   tm_year \n   C   parses the first 2 digits of year as a decimal number (range [00,99])   tm_year \n   EC   parses the name of the base year (period) in the locale's alternative representation, e.g. \u5e73\u6210 (Heisei era) in ja_JP   tm_year \n   Month \n   b   parses the month name, either full or abbreviated, e.g. Oct   tm_mon \n   h   synonym of b   tm_mon \n   B   synonym of b   tm_mon \n   m   parses the month as a decimal number (range [01,12]), leading zeroes permitted but not required   tm_mon \n   Om   parses the month using the alternative numeric system, e.g. \u5341\u4e8c parses as 12 in ja_JP locale   tm_mon \n   Week \n   U   parses the week of the year as a decimal number (Sunday is the first day of the week) (range [00,53]), leading zeroes permitted but not required   tm_year, tm_wday, tm_yday \n   OU   parses the week of the year, as by %U, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c parses as 52 in ja_JP locale   tm_year, tm_wday, tm_yday \n   W   parses the week of the year as a decimal number (Monday is the first day of the week) (range [00,53]), leading zeroes permitted but not required   tm_year, tm_wday, tm_yday \n   OW   parses the week of the year, as by %W, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c parses as 52 in ja_JP locale   tm_year, tm_wday, tm_yday \n   Day of the year/month \n   j   parses day of the year as a decimal number (range [001,366]), leading zeroes permitted but not required   tm_yday \n   d   parses the day of the month as a decimal number (range [01,31]), leading zeroes permitted but not required   tm_mday \n   Od   parses the day of the month using the alternative numeric system, e.g \u4e8c\u5341\u4e03 parses as 27 in ja_JP locale, leading zeroes permitted but not required   tm_mday \n   e   synonym of d   tm_mday \n   Oe   synonym of Od   tm_mday \n   Day of the week \n   a   parses the name of the day of the week, either full or abbreviated, e.g. Fri   tm_wday \n   A   synonym of a   tm_wday \n   w   parses weekday as a decimal number, where Sunday is 0 (range [0-6])   tm_wday \n   Ow   parses weekday as a decimal number, where Sunday is 0, using the alternative numeric system, e.g. \u4e8c parses as 2 in ja_JP locale   tm_wday \n   Hour, minute, second \n   H   parses the hour as a decimal number, 24 hour clock (range [00-23]), leading zeroes permitted but not required   tm_hour \n   OH   parses hour from 24-hour clock using the alternative numeric system, e.g. \u5341\u516b parses as 18 in ja_JP locale   tm_hour \n   I   parses hour as a decimal number, 12 hour clock (range [01,12]), leading zeroes permitted but not required   tm_hour \n   OI   parses hour from 12-hour clock using the alternative numeric system, e.g. \u516d reads as 06 in ja_JP locale   tm_hour \n   M   parses minute as a decimal number (range [00,59]), leading zeroes permitted but not required   tm_min \n   OM   parses minute using the alternative numeric system, e.g. \u4e8c\u5341\u4e94 parses as 25 in ja_JP locale   tm_min \n   S   parses second as a decimal number (range [00,60]), leading zeroes permitted but not required   tm_sec \n   OS   parses second using the alternative numeric system, e.g. \u4e8c\u5341\u56db parses as 24 in ja_JP locale   tm_sec \n   Other \n   c   parses the locale's standard date and time string format, e.g. Sun Oct 17 04:41:13 2010 (locale dependent)   all \n   Ec   parses the locale's alternative date and time string format, e.g. expecting \u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   all \n   x   parses the locale's standard date representation   all \n   Ex   parses the locale's alternative date representation, e.g. expecting \u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   all \n   X   parses the locale's standard time representation   all \n   EX   parses the locale's alternative time representation   all \n   D   equivalent to \"%m / %d / %y \"   tm_mon, tm_mday, tm_year \n   r   parses locale's standard 12-hour clock time (in POSIX, \"%I : %M : %S %p\")   tm_hour, tm_min, tm_sec \n   R   equivalent to \"%H : %M\"   tm_hour, tm_min \n   T   equivalent to \"%H : %M : %S\"   tm_hour, tm_min, tm_sec \n   p   parses the locale's equivalent of a.m. or p.m.   tm_hour \n\n Note: tm_isdst is not written to, and needs to be set explicitly for use with functions such as mktime.\n\n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n#include <locale>\n#include <iomanip>\n \nint main()\n{\n    std::tm t = {};\n    std::istringstream ss(\"2011-Februar-18 23:12:34\");\n    ss.imbue(std::locale(\"de_DE.utf-8\"));\n    ss >> std::get_time(&t, \"%Y-%b-%d %H:%M:%S\");\n    if (ss.fail()) {\n        std::cout << \"Parse failed\\n\";\n    } else {\n        std::cout << std::put_time(&t, \"%c\") << '\\n';\n    }\n}",
            "output": "Sun Feb 18 23:12:34 2011"
        }
    },
    "put_time": {
        "description": {
            "texte": "When used in an expression out << put_time(tmb, fmt), converts the date and time information from a given calendar time tmb to a character string according to format string fmt, as if by calling std::strftime, std::wcsftime, or analog (depending on CharT), according to the std::time_put facet of the locale currently imbued in the output stream out."
        },
        "parametres": "   tmb   -   pointer to the calendar time structure as obtained from std::localtime or std::gmtime \n   fmt   -   pointer to a null-terminated CharT string specifying the format of conversion. The format string consists of zero or more conversion specifiers and ordinary characters (except %). All ordinary characters, including the terminating null character, are copied to the output string without modification. Each conversion specification begins with % character, optionally followed by E or O modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The following format specifiers are available:\n   Conversion specifier   Explanation   Used fields \n   %   writes literal %. The full conversion specification must be %%.   \n   n(C++11)   writes newline character   \n   t(C++11)   writes horizontal tab character   \n   Year \n   Y   writes year as a decimal number, e.g. 2017   tm_year \n   EY(C++11)   writes year in the alternative representation, e.g.\u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   tm_year \n   y   writes last 2 digits of year as a decimal number (range [00,99])   tm_year \n   Oy(C++11)   writes last 2 digits of year using the alternative numeric system, e.g. \u5341\u4e00 instead of 11 in ja_JP locale   tm_year \n   Ey(C++11)   writes year as offset from locale's alternative calendar period %EC (locale-dependent)   tm_year \n   C(C++11)   writes first 2 digits of year as a decimal number (range [00,99])   tm_year \n   EC(C++11)   writes name of the base year (period) in the locale's alternative representation, e.g. \u5e73\u6210 (Heisei era) in ja_JP   tm_year \n   G(C++11)   writes ISO 8601 week-based year, i.e. the year that contains the specified week. In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday \n   g(C++11)   writes last 2 digits of ISO 8601 week-based year, i.e. the year that contains the specified week (range [00,99]). In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday \n   Month \n   b   writes abbreviated month name, e.g. Oct (locale dependent)   tm_mon \n   h(C++11)   synonym of b   tm_mon \n   B   writes full month name, e.g. October (locale dependent)   tm_mon \n   m   writes month as a decimal number (range [01,12])   tm_mon \n   Om(C++11)   writes month using the alternative numeric system, e.g. \u5341\u4e8c instead of 12 in ja_JP locale   tm_mon \n   Week \n   U   writes week of the year as a decimal number (Sunday is the first day of the week) (range [00,53])   tm_year, tm_wday, tm_yday \n   OU(C++11)   writes week of the year, as by %U, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday \n   W   writes week of the year as a decimal number (Monday is the first day of the week) (range [00,53])   tm_year, tm_wday, tm_yday \n   OW(C++11)   writes week of the year, as by %W, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday \n   V(C++11)   writes ISO 8601 week of the year (range [01,53]). In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday \n   OV(C++11)   writes week of the year, as by %V, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday \n   Day of the year/month \n   j   writes day of the year as a decimal number (range [001,366])   tm_yday \n   d   writes day of the month as a decimal number (range [01,31])   tm_mday \n   Od(C++11)   writes zero-based day of the month using the alternative numeric system, e.g \u4e8c\u5341\u4e03 instead of 27 in ja_JP locale Single character is preceded by a space.\n  tm_mday \n   e(C++11)   writes day of the month as a decimal number (range [1,31]). Single digit is preceded by a space.\n  tm_mday \n   Oe(C++11)   writes one-based day of the month using the alternative numeric system, e.g. \u4e8c\u5341\u4e03 instead of 27 in ja_JP locale Single character is preceded by a space.\n  tm_mday \n   Day of the week \n   a   writes abbreviated weekday name, e.g. Fri (locale dependent)   tm_wday \n   A   writes full weekday name, e.g. Friday (locale dependent)   tm_wday \n   w   writes weekday as a decimal number, where Sunday is 0 (range [0-6])   tm_wday \n   Ow(C++11)   writes weekday, where Sunday is 0, using the alternative numeric system, e.g. \u4e8c instead of 2 in ja_JP locale   tm_wday \n   u(C++11)   writes weekday as a decimal number, where Monday is 1 (ISO 8601 format) (range [1-7])   tm_wday \n   Ou(C++11)   writes weekday, where Monday is 1, using the alternative numeric system, e.g. \u4e8c instead of 2 in ja_JP locale   tm_wday \n   Hour, minute, second \n   H   writes hour as a decimal number, 24 hour clock (range [00-23])   tm_hour \n   OH(C++11)   writes hour from 24-hour clock using the alternative numeric system, e.g. \u5341\u516b instead of 18 in ja_JP locale   tm_hour \n   I   writes hour as a decimal number, 12 hour clock (range [01,12])   tm_hour \n   OI(C++11)   writes hour from 12-hour clock using the alternative numeric system, e.g. \u516d instead of 06 in ja_JP locale   tm_hour \n   M   writes minute as a decimal number (range [00,59])   tm_min \n   OM(C++11)   writes minute using the alternative numeric system, e.g. \u4e8c\u5341\u4e94 instead of 25 in ja_JP locale   tm_min \n   S   writes second as a decimal number (range [00,60])   tm_sec \n   OS(C++11)   writes second using the alternative numeric system, e.g. \u4e8c\u5341\u56db instead of 24 in ja_JP locale   tm_sec \n   Other \n   c   writes standard date and time string, e.g. Sun Oct 17 04:41:13 2010 (locale dependent)   all \n   Ec(C++11)   writes alternative date and time string, e.g. using \u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   all \n   x   writes localized date representation (locale dependent)   all \n   Ex(C++11)   writes alternative date representation, e.g. using \u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   all \n   X   writes localized time representation (locale dependent)   all \n   EX(C++11)   writes alternative time representation (locale dependent)   all \n   D(C++11)   equivalent to \"%m/%d/%y\"   tm_mon, tm_mday, tm_year \n   F(C++11)   equivalent to \"%Y-%m-%d\" (the ISO 8601 date format)   tm_mon, tm_mday, tm_year \n   r(C++11)   writes localized 12-hour clock time (locale dependent)   tm_hour, tm_min, tm_sec \n   R(C++11)   equivalent to \"%H:%M\"   tm_hour, tm_min \n   T(C++11)   equivalent to \"%H:%M:%S\" (the ISO 8601 time format)   tm_hour, tm_min, tm_sec \n   p   writes localized a.m. or p.m. (locale dependent)   tm_hour \n   z(C++11)   writes offset from UTC in the ISO 8601 format (e.g. -0430), or no characters if the time zone information is not available   tm_isdst \n   Z   writes locale-dependent time zone name or abbreviation, or no characters if the time zone information is not available   tm_isdst \n\n \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <ctime>\n \nint main()\n{\n    std::time_t t = std::time(nullptr);\n    std::tm tm = *std::localtime(&t);\n    std::cout.imbue(std::locale(\"ru_RU.utf8\"));\n    std::cout << \"ru_RU: \" << std::put_time(&tm, \"%c %Z\") << '\\n';\n    std::cout.imbue(std::locale(\"ja_JP.utf8\"));\n    std::cout << \"ja_JP: \" << std::put_time(&tm, \"%c %Z\") << '\\n';\n}",
            "output": "ru_RU: \u0421\u0440. 28 \u0434\u0435\u043a. 2011 10:21:16 EST\nja_JP: 2011\u5e7412\u670828\u65e5 10\u664221\u520616\u79d2 EST"
        }
    },
    "quoted": {
        "description": {
            "texte": "Allows insertion and extraction of quoted strings, such as the ones found in CSV or XML.When used in an expression out << quoted(s, delim, escape), where out is an output stream with char_type equal to CharT and, for overloads 2-4, traits_type equal to Traits, behaves as a FormattedOutputFunction, which inserts into out a sequence of characters seq constructed as follows:Then, if seq.size() < out.width(), adds out.width()-seq.size() copies of the fill character out.fill() either at the end of the sequence (if ios_base::left is set in out.flags()) or at the beginning of the sequence (in all other cases).Finally, outputs each character from the resulting sequence as if by calling out.rdbuf()->sputn(seq, n), where n=std::max(out.width(), seq.size()) and out.width(0) to cancel the effects of std::setw, if any."
        },
        "parametres": "   s   -   the string to insert or extract \n   delim   -   the character to use as the delimiter, defaults to \" \n   escape   -   the character to use as the escape character, defaults to \\ \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n \nint main()\n{\n    std::stringstream ss;\n    std::string in = \"String with spaces, and embedded \\\"quotes\\\" too\";\n    std::string out;\n \n    ss << std::quoted(in);\n    std::cout << \"read in     [\" << in << \"]\\n\"\n              << \"stored as   [\" << ss.str() << \"]\\n\";\n \n    ss >> std::quoted(out);\n    std::cout << \"written out [\" << out << \"]\\n\";\n}",
            "output": "read in     [String with spaces, and embedded \"quotes\" too]\nstored as   [\"String with spaces, and embedded \\\"quotes\\\" too\"]\nwritten out [String with spaces, and embedded \"quotes\" too]"
        }
    },
    "operator>>(std::basic_istream)": {
        "description": {
            "texte": " 1-2) Performs character input operations.1) Behaves as an FormattedInputFunction. After constructing and checking the sentry object, which may skip leading whitespace, extracts a character and stores it to ch. If no character is available, sets failbit (in addition to eofbit that is set as required of a FormattedInputFunction).2) Behaves as an FormattedInputFunction. After constructing and checking the sentry object, which may skip leading whitespace, extracts successive characters and stores them at successive locations of a character array whose first element is pointed to by (until C++20) s. The extraction stops if one of the following conditions are met:In either case, an additional null character value CharT() is stored at the end of the output. If no characters were extracted, sets failbit (the null character is still written, to the first position in the output). Finally, calls st.width(0) to cancel the effects of std::setw, if any.  3)."
        },
        "parametres": "   st   -   input stream to extract the data from \n   ch   -   reference to a character to store the extracted character to \n   s   -   pointer to (until C++20) a character array to store the extracted characters to \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n \nint main()\n{\n    std::string input = \"n greetings\";\n    std::istringstream stream(input);\n    char c;\n    const int MAX = 6;\n    char cstr[MAX];\n \n    stream >> c >> std::setw(MAX) >> cstr;\n    std::cout << \"c = \" << c << '\\n'\n              << \"cstr = \" << cstr << '\\n';\n \n    double f;\n    std::istringstream(\"1.23\") >> f; // rvalue stream extraction\n    std::cout << \"f = \" << f << '\\n';\n}",
            "output": "c = n\ncstr = greet\nf = 1.23"
        }
    },
    "ws": {
        "description": {
            "texte": "Discards leading whitespace from an input stream.Behaves as an UnformattedInputFunction, except that is.gcount() is not modified. After constructing and checking the sentry object, extracts characters from the stream and discards them until any one of the following conditions occurs:This is an input-only I/O manipulator, it may be called with an expression such as in >> std::ws for any in of type std::basic_istream."
        },
        "parametres": "   is   -   reference to input stream \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <istream>\n#include <sstream>\n#include <string>\n \nint main()\n{\n    std::istringstream s(\"     this is a test\");\n    std::string line;\n    std::getline(s >> std::ws, line);\n    std::cout << \"ws + getline returns: \\\"\" << line << \"\\\"\\n\";\n}",
            "output": "ws + getline returns: \"this is a test\""
        }
    },
    "operator<<(std::basic_ostream)": {
        "description": {
            "texte": "Inserts a character or a character string.Before insertion, first, all characters are widened using os.widen(), then padding is determined as follows: if the number of characters to insert is less than os.width(), then enough copies of os.fill() are added to the character sequence to make its length equal os.width(). If (out.flags()&std::ios_base::adjustfield) == std::ios_base::left, the fill characters are added at the end of the output sequence, otherwise they are added before the output sequence. After insertion, width(0) is called to cancel the effects of std::setw, if any.  The behavior is undefined if s is a null pointer."
        },
        "parametres": "   os   -   output stream to insert data to \n   ch   -   reference to a character to insert \n   s   -   pointer to a character string to insert \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n \nint main()\n{\n    std::cout << \"Hello, world\" // the const char* overload\n              << '\\n';          // the char overload\n    std::ofstream(\"test.txt\") << 1.2; // rvalue overload\n}",
            "output": "Hello, world"
        }
    },
    "ends": {
        "description": {
            "texte": "Inserts a null character into the output sequence os as if by calling os.put(CharT()).This is an output-only I/O manipulator, it may be called with an expression such as out << std::ends for any out of type std::basic_ostream."
        },
        "parametres": "   os   -   reference to output stream \n\n",
        "exemple": {
            "input": "#include <cstdio>\n#include <strstream>\nint main()\n{\n    std::ostrstream oss;\n    oss << \"Sample text: \" << 42 << std::ends;\n    std::printf(\"%s\\n\", oss.str());\n    oss.freeze(false); // enable memory deallocation\n}",
            "output": "Sample text: 42"
        }
    },
    "flush": {
        "description": {
            "texte": "Flushes the output sequence os as if by calling os.flush().This is an output-only I/O manipulator, it may be called with an expression such as out << std::flush for any out of type std::basic_ostream."
        },
        "parametres": "   os   -   reference to output stream \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\ntemplate<typename Diff>\nvoid log_progress(Diff d)\n{\n    std::cout << \"..(\"\n              << std::chrono::duration_cast<std::chrono::milliseconds>(d).count()\n              << \" ms)..\" << std::flush;\n}\nint main()\n{\n    volatile int sink=0;\n \n    auto t1 = std::chrono::high_resolution_clock::now();\n    for(int j=0; j<5; ++j)\n    {\n        for(int n=0; n<10000; ++n)\n            for(int m=0; m<20000; ++m)\n                sink += m*n; // do some work\n        auto now = std::chrono::high_resolution_clock::now();\n        log_progress(now - t1);\n    }\n    std::cout << '\\n';\n}",
            "output": "..(450 ms)....(901 ms)....(1350 ms)....(1800 ms)....(2250 ms).."
        }
    },
    "endl": {
        "description": {
            "texte": "Inserts a newline character into the output sequence os and flushes it as if by calling os.put(os.widen('\\n')) followed by os.flush().This is an output-only I/O manipulator, it may be called with an expression such as out << std::endl for any out of type std::basic_ostream."
        },
        "parametres": "   os   -   reference to output stream \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n \ntemplate<typename Diff>\nvoid log_progress(Diff d)\n{\n    std::cout << std::chrono::duration_cast<std::chrono::milliseconds>(d).count()\n              << \" ms passed\" << std::endl;\n}\n \nint main()\n{\n    std::cout.sync_with_stdio(false); // on some platforms, stdout flushes on \\n\n    volatile int sink = 0;\n \n    auto t1 = std::chrono::high_resolution_clock::now();\n    for (int j=0; j<5; ++j)\n    {\n        for (int n=0; n<10000; ++n)\n            for (int m=0; m<20000; ++m)\n                sink += m*n; // do some work\n        auto now = std::chrono::high_resolution_clock::now();\n        log_progress(now - t1);\n    }\n}",
            "output": "487 ms passed\n974 ms passed\n1470 ms passed\n1965 ms passed\n2455 ms passed"
        }
    },
    "swap(std::basic_stringbuf)\n": {
        "description": {
            "texte": "Overloads the std::swap algorithm for std::basic_stringbuf. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   std::basic_stringbuf objects whose states to swap \n\n"
    },
    "swap(std::basic_istringstream)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::basic_istringstream. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   streams whose state to swap \n\n"
    },
    "swap(std::basic_filebuf)\n": {
        "description": {
            "texte": "Overloads the std::swap algorithm for std::basic_filebuf. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   std::basic_filebuf objects whose states to swap \n\n"
    },
    "swap(std::basic_ifstream)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::basic_ifstream. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   streams whose state to swap \n\n"
    },
    "swap(std::basic_ofstream)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::basic_ofstream. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   streams whose state to swap \n\n"
    },
    "swap(std::basic_fstream)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::basic_fstream. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   streams whose state to swap \n\n"
    },
    "swap(std::basic_syncbuf)\n": {
        "description": {
            "texte": "Overloads the std::swap algorithm for std::basic_syncbuf. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   std::basic_syncbuf objects whose states to swap \n\n"
    },
    "setbuf": {
        "description": {
            "texte": "Sets the internal buffer to use for I/O operations performed on the C stream stream.If buffer is not null, equivalent to std::setvbuf(stream, buffer, _IOFBF, BUFSIZ).If buffer is null, equivalent to std::setvbuf(stream, NULL, _IONBF, 0), which turns off buffering."
        },
        "parametres": "   stream   -   the file stream to set the buffer to. \n   buffer   -   pointer to a buffer for the stream to use. If NULL is supplied, the buffering is turned off. If not null, must be able to hold at least BUFSIZ characters \n\n",
        "exemple": {
            "input": "#include <cstdio>\n#include <thread>\n#include <chrono>\n \nint main()\n{\n    using namespace std::chrono_literals;\n \n    std::setbuf(stdout, NULL); // unbuffered stdout\n    std::putchar('a'); // appears immediately on unbuffered stream\n    std::this_thread::sleep_for(1s);\n    std::putchar('b');\n}",
            "output": "ab"
        }
    },
    "fseek": {
        "description": {
            "texte": "Sets the file position indicator for the file stream stream.If the stream is open in binary mode, the new position is exactly offset bytes measured from the beginning of the file if origin is SEEK_SET, from the current file position if origin is SEEK_CUR, and from the end of the file if origin is SEEK_END. Binary streams are not required to support SEEK_END, in particular if additional null bytes are output.If the stream is open in text mode, the only supported values for offset are zero (which works with any origin) and a value returned by an earlier call to std::ftell on a stream associated with the same file (which only works with origin of SEEK_SET).If the stream is wide-oriented, the restrictions of both text and binary streams apply (result of std::ftell is allowed with SEEK_SET and zero offset is allowed from SEEK_SET and SEEK_CUR, but not SEEK_END).In addition to changing the file position indicator, fseek undoes the effects of std::ungetc and clears the end-of-file status, if applicable.If a read or write error occurs, the error indicator for the stream (std::ferror) is set and the file position is unaffected."
        },
        "parametres": "   stream   -   file stream to modify \n   offset   -   number of characters to shift the position relative to origin \n   origin   -   position to which offset is added. It can have one of the following values: SEEK_SET, SEEK_CUR, SEEK_END \n\n",
        "exemple": {
            "input": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <fstream>\n#include <cassert>\n \nint main()\n{\n    std::ofstream(\"dummy.nfo\") << \"sample data\\n\";\n \n \n    std::FILE* fp = std::fopen(\"dummy.nfo\", \"rb\");\n    assert(fp);\n \n    std::fseek(fp, 0, SEEK_END); // seek to end\n    std::size_t filesize = std::ftell(fp);\n \n    std::fseek(fp, 0, SEEK_SET); // seek to start\n    std::vector<uint8_t> buffer(filesize);\n    std::fread(buffer.data(), sizeof(uint8_t), buffer.size(), fp);\n \n    std::fclose(fp);\n    std::printf(\"i've read %zi bytes\\n\", filesize);\n}",
            "output": "i've read 12 bytes"
        }
    },
    "tmpnam": {
        "description": {
            "texte": "Creates a unique filename that does not name a currently existing file, and stores it in the character string pointed to by filename. The function is capable of generating up to TMP_MAX of unique filenames, but some or all of them may already be in use, and thus not suitable return values.std::tmpnam modifies static state and is not required to be thread-safe."
        },
        "parametres": "   filename   -   pointer to the character array capable of holding at least L_tmpnam bytes, to be used as a result buffer. If a null pointer is passed, a pointer to an internal static buffer is returned. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstdio>\n#include <string>\n \nint main()\n{\n    std::string name1 = std::tmpnam(nullptr);\n    std::cout << \"temporary file name: \" << name1 << '\\n';\n \n    char name2[L_tmpnam];\n    if (std::tmpnam(name2)) {\n        std::cout << \"temporary file name: \" << name2 << '\\n';\n    }\n}",
            "output": "temporary file name: /tmp/fileDjwifs\ntemporary file name: /tmp/fileEv2bfW"
        }
    },
    "freopen": {
        "description": {
            "texte": "First, attempts to close the file associated with stream, ignoring any errors. Then, if filename is not null, attempts to open the file specified by filename using mode as if by fopen, and associates that file with the file stream pointed to by stream. If filename is a null pointer, then the function attempts to reopen the file that is already associated with stream (it is implementation defined which mode changes are allowed in this case)."
        },
        "parametres": "   filename   -   file name to associate the file stream to \n   mode   -   null-terminated character string determining new file access mode    File access mode string   Meaning   Explanation   Action if file  already exists   Action if file  does not exist \n   \"r\"   read   Open a file for reading   read from start   failure to open \n   \"w\"   write   Create a file for writing   destroy contents   create new \n   \"a\"   append   Append to a file   write to end   create new \n   \"r+\"   read extended   Open a file for read/write   read from start   error \n   \"w+\"   write extended   Create a file for read/write   destroy contents   create new \n   \"a+\"   append extended   Open a file for read/write   write to end   create new \n   File access mode flag \"b\" can optionally be specified to open a file in binary mode. This flag has no effect on POSIX systems, but on Windows, for example, it disables special handling of '\\n' and '\\x1A'.  On the append file access modes, data is written to the end of the file regardless of the current position of the file position indicator. \n   File access mode flag \"x\" can optionally be appended to \"w\" or \"w+\" specifiers. This flag forces the function to fail if the file exists, instead of overwriting it. (C++17) \n   The behavior is undefined if the mode is not one of the strings listed above. Some implementations define additional supported modes (e.g. Windows). \n\n \n   stream   -   the file stream to modify \n\n",
        "exemple": {
            "input": "#include <cstdio>\n \nint main()\n{\n    std::printf(\"stdout is printed to console\\n\");\n    if(std::freopen(\"redir.txt\", \"w\", stdout)) {\n        std::printf(\"stdout is redirected to a file\\n\"); // this is written to redir.txt\n        std::fclose(stdout);\n    }\n}",
            "output": "stdout is printed to console"
        }
    },
    "fclose": {
        "description": {
            "texte": "Closes the given file stream. Any unwritten buffered data are flushed to the OS. Any unread buffered data are discarded.Whether or not the operation succeeds, the stream is no longer associated with a file, and the buffer allocated by std::setbuf or std::setvbuf, if any, is also disassociated and deallocated if automatic allocation was used.The behavior is undefined if the value of the pointer stream is used after fclose returns."
        },
        "parametres": "   stream   -   the file stream to close \n\n",
        "exemple": {
            "input": "#include <cstdio>\n#include <cstdlib>\n \nint main()\n{\n    FILE* fp = std::fopen(\"test.txt\", \"r\");\n    if(!fp) {\n        std::perror(\"File opening failed\");\n        return EXIT_FAILURE;\n    }\n \n    int c; // note: int, not char, required to handle EOF\n    while ((c = std::fgetc(fp)) != EOF) { // standard C I/O file reading loop\n       std::putchar(c);\n    }\n \n    if (std::ferror(fp))\n        std::puts(\"I/O error when reading\");\n    else if (std::feof(fp))\n        std::puts(\"End of file reached successfully\");\n \n    std::fclose(fp);\n}"
        }
    },
    "fflush": {
        "description": {
            "texte": "For output streams (and for update streams on which the last operation was output), writes any unwritten data from the stream's buffer to the associated output device.For input streams (and for update streams on which the last operation was input), the behavior is undefined.If stream is a null pointer, all open output streams are flushed, including the ones manipulated within library packages or otherwise not directly accessible to the program."
        },
        "parametres": "   stream   -   the file stream to write out \n\n"
    },
    "setvbuf": {
        "description": {
            "texte": "Changes the the buffering mode of the given file stream stream as indicated by the argument mode. In addition,"
        },
        "parametres": "   stream   -   the file stream to set the buffer to \n   buffer   -   pointer to a buffer for the stream to use or null pointer to change size and mode only \n   mode   -   buffering mode to use. It can be one of the following values:    _IOFBF   full buffering \n   _IOLBF   line buffering \n   _IONBF   no buffering \n\n \n   size   -   size of the buffer \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstdio>\n#include <stdlib.h>\n#include <sys/stat.h>\n \nint main()\n{\n    std::FILE* fp = std::fopen(\"test.txt\", \"r\");\n    if(!fp) {\n       std::perror(\"fopen\"); return 1;\n    }\n \n    struct stat stats;\n    if(fstat(fileno(fp), &stats) == -1) { // POSIX only\n        std::perror(\"fstat\"); return 1;\n    }\n \n    std::cout << \"BUFSIZ is \" << BUFSIZ << \", but optimal block size is \"\n              << stats.st_blksize << '\\n';\n    if(std::setvbuf(fp, NULL, _IOFBF, stats.st_blksize) != 0) {\n       perror(\"setvbuf failed\"); // POSIX version sets errno\n       return 1;\n    }\n \n    int ch;\n    while((ch=std::fgetc(fp)) != EOF); // read entire file: use truss/strace to\n                                       // observe the read(2) syscalls used\n    std::fclose(fp);\n}",
            "output": "BUFSIZ is 8192, but optimal block size is 65536"
        }
    },
    "fread": {
        "description": {
            "texte": "Reads up to count objects into the array buffer from the given input stream stream as if by calling std::fgetc size times for each object, and storing the results, in the order obtained, into the successive positions of buffer, which is reinterpreted as an array of unsigned char. The file position indicator for the stream is advanced by the number of characters read.If the objects are not TriviallyCopyable, the behavior is undefined.If an error occurs, the resulting value of the file position indicator for the stream is indeterminate. If a partial element is read, its value is indeterminate."
        },
        "parametres": "   buffer   -   pointer to the first object in the array to be read \n   size   -   size of each object in bytes \n   count   -   the number of the objects to be read \n   stream   -   input file stream to read from \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstdio>\n#include <fstream>\n#include <vector>\nint main()\n{\n    // prepare file\n    std::ofstream(\"test.txt\") << 1 << ' ' << 2 << '\\n';\n    std::FILE* f = std::fopen(\"test.txt\", \"r\");\n \n    std::vector<char> buf(4); // char is trivally copyable\n    std::fread(&buf[0], sizeof buf[0], buf.size(), f);\n \n    for(char n : buf)\n        std::cout << n;\n \n    std::vector<std::string> buf2; // string is not trivially copyable\n// this would result in undefined behavior\n//    std::fread(&buf2[0], sizeof buf2[0], buf2.size(), f);\n}",
            "output": "1 2"
        }
    },
    "fwrite": {
        "description": {
            "texte": "Writes up to count binary objects from the given array buffer to the output stream stream. The objects are written as if by reinterpreting each object as an array of unsigned char and calling std::fputc size times for each object to write those unsigned chars into stream, in order. The file position indicator for the stream is advanced by the number of characters written.If the objects are not TriviallyCopyable, the behavior is undefined.If an error occurs, the resulting value of the file position indicator for the stream is indeterminate."
        },
        "parametres": "   buffer   -   pointer to the first object object in the array to be written \n   size   -   size of each object \n   count   -   the number of the objects to be written \n   stream   -   output file stream to write to \n\n",
        "exemple": {
            "input": "#include <cstdio>\n#include <vector>\n#include <array>\n \nint main ()\n{\n    // write buffer to file\n    if(std::FILE* f1 = std::fopen(\"file.bin\", \"wb\")) {\n        std::array<int, 3> v = {42, -1, 7}; // underlying storage of std::array is an array\n        std::fwrite(v.data(), sizeof v[0], v.size(), f1);\n        std::fclose(f1);\n    }\n \n    // read the same data and print it to the standard output\n    if(std::FILE *f2 = std::fopen(\"file.bin\", \"rb\")) {\n        std::vector<int> rbuf(10); // underlying storage of std::vector is also an array\n        std::size_t sz = std::fread(rbuf.data(), sizeof rbuf[0], rbuf.size(), f2);\n        std::fclose(f2);\n        for(std::size_t n = 0; n < sz; ++n) {\n            std::printf(\"%d\\n\", rbuf[n]);\n        }\n    }\n}",
            "output": "42\n-1\n7"
        }
    },
    "fgets": {
        "description": {
            "texte": "Reads at most count - 1 characters from the given file stream and stores them in the character array pointed to by str. Reading stops if end-of-file occurs or a newline character is found, in which case str will contain that newline character. If no errors occur, writes a null character at the position immediately after the last character written to str."
        },
        "parametres": "   str   -   pointer to an element of a char array \n   count   -   maximum number of characters to write (typically the length of str) \n   stream   -   file stream to read the data from \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n \nint main()\n{\n    std::FILE* tmpf = std::tmpfile();\n    std::fputs(\"Alan Turing\\n\", tmpf);\n    std::fputs(\"John von Neumann\\n\", tmpf);\n    std::fputs(\"Alonzo Church\\n\", tmpf);\n \n    std::rewind(tmpf);\n    char buf[8];\n    while (std::fgets(buf, sizeof buf, tmpf) != NULL) {\n        std::cout << '\"' << buf << '\"' << '\\n';\n    }\n}",
            "output": "\"Alan Tu\"\n\"ring\n\"\n\"John vo\"\n\"n Neuma\"\n\"nn\n\"\n\"Alonzo \"\n\"Church\n\""
        }
    },
    "fputc, std::putc": {
        "description": {
            "texte": "Writes a character ch to the given output stream stream.Internally, the character is converted to unsigned char just before being written.In C, putc() may be implemented as a macro, which is disallowed in C++. Therefore calls to std::fputc() and std::putc() always have the same effect."
        },
        "parametres": "   ch   -   character to be written \n   stream   -   output stream \n\n",
        "exemple": {
            "input": "#include <cstdio>\n \nint main()\n{\n    for (char c = 'a'; c != 'z'; c++)\n        std::putc(c, stdout);\n    std::putc('\\n', stdout);\n \n    // putchar return value is not equal to the argument\n    int r = 0x1070;\n    std::printf(\"\\n0x%x\\n\", r);\n    r = std::putchar(r);\n    std::printf(\"\\n0x%x\\n\", r);\n}",
            "output": "abcdefghijklmnopqrstuvwxy\n0x1070\np\n0x70"
        }
    },
    "fputs": {
        "description": {
            "texte": "Writes every character from the null-terminated string str to the output stream stream, as if by repeatedly executing std::fputc.The terminating null character from str is not written."
        },
        "parametres": "   str   -   null-terminated character string to be written \n   stream   -   output stream \n\n",
        "exemple": {
            "input": "#include <cstdio>\n \nint main(void)\n{\n    int rc = std::fputs(\"Hello World\", stdout);\n \n    if (rc == EOF)\n       std::perror(\"fputs()\"); // POSIX requires that errno is set\n}",
            "output": "Hello World"
        }
    },
    "getchar": {
        "description": {
            "texte": "Reads the next character from stdin.Equivalent to std::getc(stdin)."
        }
    },
    "gets": {
        "description": {
            "texte": "Reads stdin into given character string until a newline character is found or end-of-file occurs."
        },
        "parametres": "   str   -   character string to be written \n\n"
    },
    "putchar": {
        "description": {
            "texte": "Writes a character ch to stdout. Internally, the character is converted to unsigned char just before being written.Equivalent to putc(ch, stdout)."
        },
        "parametres": "   ch   -   character to be written \n\n",
        "exemple": {
            "input": "#include <cstdio>\n \nint main()\n{\n    for (char c = 'a'; c != 'z'; c++)\n        std::putchar(c);\n    std::putchar('\\n');\n \n    // putchar return value is not equal to the argument\n    int r = 0x1070;\n    std::printf(\"\\n0x%x\\n\", r);\n    r = std::putchar(r);\n    std::printf(\"\\n0x%x\\n\", r);\n}",
            "output": "abcdefghijklmnopqrstuvwxy\n0x1070\np\n0x70"
        }
    },
    "puts": {
        "description": {
            "texte": "Writes every character from the null-terminated string str and one additional newline character '\\n' to the output stream stdout, as if by repeatedly executing std::fputc.The terminating null character from str is not written."
        },
        "parametres": "   str   -   character string to be written \n\n",
        "exemple": {
            "input": "#include <cstdio>\n \nint main()\n{\n    int rc = std::puts(\"Hello World\");\n \n    if (rc == EOF)\n       std::perror(\"puts()\"); // POSIX requires that errno is set\n}",
            "output": "Hello World"
        }
    },
    "ungetc": {
        "description": {
            "texte": "If ch does not equal EOF, pushes the character ch (reinterpreted as unsigned char) into the input buffer associated with the stream stream in such a manner than subsequent read operation from stream will retrieve that character. The external device associated with the stream is not modified.Stream repositioning operations std::fseek, std::fsetpos, and std::rewind discard the effects of ungetc.If ungetc is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful ungetc were performed, read operations retrieve the pushed-back characters in reverse order of ungetc.If ch equals EOF, the operation fails and the stream is not affected.A successful call to ungetc clears the end of file status flag std::feof.A successful call to ungetc on a binary stream decrements the stream position indicator by one (the behavior is indeterminate if the stream position indicator was zero).A successful call to ungetc on a text stream modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back characters are retrieved with a read operation, the stream position indicator is equal to its value before ungetc."
        },
        "parametres": "   ch   -   character to be pushed into the input stream buffer \n   stream   -   file stream to put the character back to \n\n",
        "exemple": {
            "input": "#include <cctype>\n#include <cstdio>\n \nvoid demo_scanf(const char* fmt, std::FILE* s) {\n    if(*fmt == '%') {\n        switch(*++fmt) {\n            case 'u': {\n                int c;\n                while(std::isspace(c=std::getc(s))) {} // skip leading white space\n                unsigned int num = 0;\n                while(std::isdigit(c)) {\n                    num = num*10 + c-'0';\n                    c = std::getc(s);\n                }\n                std::printf(\"%%u scanned %u\\n\", num);\n                std::ungetc(c, s); // reprocess the non-digit\n            }\n            case 'c': {\n                int c = std::getc(s);\n                std::printf(\"%%c scanned '%c'\\n\", c);\n            }\n        }\n    }\n}\n \nint main()\n{\n    std::FILE* f = std::fopen(\"input.txt\", \"w+\");\n    std::fputs(\"123x\", f);\n    std::rewind(f);\n    demo_scanf(\"%u%c\", f);\n    std::fclose(f);\n}",
            "output": "%u scanned 123\n%c scanned 'x'"
        }
    },
    "scanf, std::fscanf, std::sscanf": {
        "description": {
            "texte": "Reads data from the a variety of sources, interprets it according to format and stores the results into given locations."
        },
        "parametres": "   stream   -   input file stream to read from \n   buffer   -   pointer to a null-terminated character string to read from \n   format   -   pointer to a null-terminated character string specifying how to read the input. The format string consists of.\n\n non-whitespace multibyte characters except %: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal. \n whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling isspace in a loop). Note that there is no difference between \"\\n\", \" \", \"\\t\\t\", or other whitespace in the format string. \n conversion specifications. Each conversion specification has the following format: \n\n introductory % character \n (optional) assignment-suppressing character *. If this option is present, the function does not assign the result of the conversion to any receiving argument. \n (optional) integer number (greater than zero) that specifies maximum field width, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that %s and %[ may lead to buffer overflow if the width is not provided. \n (optional) length modifier that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below). \n conversion format specifier \n\n      The following format specifiers are available:\n   Conversion specifier   Explanation   Argument type \n   length modifier   hh (C++11).\n  h   (none)   l   ll (C++11).\n  j (C++11).\n  z (C++11).\n  t (C++11).\n  L \n   %   matches literal %   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A \n   c    matches a character or a sequence of characters  If a width specifier is used, matches exactly width characters (the argument must be a pointer to an array with sufficient room). Unlike %s and %[, does not append the null character to the array.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A \n   s    matches a sequence of non-whitespace characters (a string)  If width specifier is used, matches up to width or until the first whitespace character, whichever appears first. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\n\n   [set]   matches a non-empty sequence of character from set of characters.  If the first character of the set is ^, then all characters not in the set are matched. If the set begins with ] or ^] then the ] character is also included into the set. It is implementation-defined whether the character - in the non-initial position in the scanset may be indicating a range, as in [0-9]. If width specifier is used, matches only up to width. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\n\n   d   matches a decimal integer.  The format of the number is the same as expected by strtol() with the value 10 for the base argument.\n  \nsigned char* or unsigned char*\n   \nsigned short* or unsigned short*\n   \nsigned int* or unsigned int*\n   \nsigned long* or unsigned long*\n   \nsigned long long* or unsigned long long*\n   \nintmax_t* or uintmax_t*\n   size_t*   ptrdiff_t*   N/A \n   i   matches an integer.  The format of the number is the same as expected by strtol() with the value \u200b0\u200b for the base argument (base is determined by the first characters parsed).\n\n   u   matches an unsigned decimal integer.  The format of the number is the same as expected by strtoul() with the value 10 for the base argument.\n\n   o   matches an unsigned octal integer.  The format of the number is the same as expected by strtoul() with the value 8 for the base argument.\n\n   x, X   matches an unsigned hexadecimal integer.  The format of the number is the same as expected by strtoul() with the value 16 for the base argument.\n\n   n   returns the number of characters read so far.  No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined.\n\n   a, A(C++11) e, E f, F g, G   matches a floating-point number.  The format of the number is the same as expected by strtof().\n  N/A   N/A   float*   double*   N/A   N/A   N/A   N/A   long double* \n   p   matches implementation defined character sequence defining a pointer.  printf family of functions should produce the same sequence using %p format specifier.\n  N/A   N/A   void**   N/A   N/A   N/A   N/A   N/A   N/A \n\n For every conversion specifier other than n, the longest sequence of input characters which does not exceed any speci\ufb01ed \ufb01eld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The \ufb01rst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-\ufb01le, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\nAll conversion specifiers other than [, c, and n consume and discard all leading whitespace characters (determined as if by calling isspace) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\nThe conversion specifiers lc, ls, and l[ perform multibyte-to-wide character conversion as if by calling mbrtowc() with an mbstate_t object initialized to zero before the first character is converted.\nThe conversion specifiers s and [ always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of %s or %[, without specifying the destination array size, is as unsafe as std::gets.\nThe correct conversion specifications for the fixed-width integer types (int8_t, etc) are defined in the header <cinttypes> (although SCNdMAX, SCNuMAX, etc is synonymous with %jd, %ju, etc).\nThere is a sequence point after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing \"100er\" with the conversion specifier %f, the sequence \"100e\" (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with \"r\" remaining. Some existing implementations do not follow this rule and roll back to consume only \"100\", leaving \"er\", e.g. glibc bug 1765.\n\n   ...   -   receiving arguments \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <clocale>\n#include <cstdio>\n \nint main()\n{\n    int i, j;\n    float x, y;\n    char str1[10], str2[4];\n    wchar_t warr[2];\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n \n    char input[] = u8\"25 54.32E-1 Thompson 56789 0123 56\u00df\u6c34\";\n    // parse as follows:\n    // %d: an integer \n    // %f: a floating-point value\n    // %9s: a string of at most 9 non-whitespace characters\n    // %2d: two-digit integer (digits 5 and 6)\n    // %f: a floating-point value (digits 7, 8, 9)\n    // %*d an integer which isn't stored anywhere\n    // ' ': all consecutive whitespace\n    // %3[0-9]: a string of at most 3 digits (digits 5 and 6)\n    // %2lc: two wide characters, using multibyte to wide conversion\n    int ret = std::sscanf(input, \"%d%f%9s%2d%f%*d %3[0-9]%2lc\",\n                     &i, &x, str1, &j, &y, str2, warr);\n \n    std::cout << \"Converted \" << ret << \" fields:\\n\"\n              << \"i = \" << i << \"\\nx = \" << x << '\\n'\n              << \"str1 = \" << str1 << \"\\nj = \" << j << '\\n'\n              << \"y = \" << y << \"\\nstr2 = \" << str2 << '\\n'\n              << std::hex << \"warr[0] = U+\" << warr[0]\n              << \" warr[1] = U+\" << warr[1] << '\\n';\n}",
            "output": "Converted 7 fields:\ni = 25\nx = 5.432\nstr1 = Thompson\nj = 56\ny = 789\nstr2 = 56\nwarr[0] = U+df warr[1] = U+6c34"
        }
    },
    "vscanf, std::vfscanf, std::vsscanf": {
        "description": {
            "texte": "Reads data from the a variety of sources, interprets it according to format and stores the results into locations defined by vlist."
        },
        "parametres": "   stream   -   input file stream to read from \n   buffer   -   pointer to a null-terminated character string to read from \n   format   -   pointer to a null-terminated character string specifying how to read the input. The format string consists of.\n\n non-whitespace multibyte characters except %: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal. \n whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling isspace in a loop). Note that there is no difference between \"\\n\", \" \", \"\\t\\t\", or other whitespace in the format string. \n conversion specifications. Each conversion specification has the following format: \n\n introductory % character \n (optional) assignment-suppressing character *. If this option is present, the function does not assign the result of the conversion to any receiving argument. \n (optional) integer number (greater than zero) that specifies maximum field width, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that %s and %[ may lead to buffer overflow if the width is not provided. \n (optional) length modifier that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below). \n conversion format specifier \n\n      The following format specifiers are available:\n   Conversion specifier   Explanation   Argument type \n   length modifier   hh (C++11).\n  h   (none)   l   ll (C++11).\n  j (C++11).\n  z (C++11).\n  t (C++11).\n  L \n   %   matches literal %   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A \n   c    matches a character or a sequence of characters  If a width specifier is used, matches exactly width characters (the argument must be a pointer to an array with sufficient room). Unlike %s and %[, does not append the null character to the array.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A \n   s    matches a sequence of non-whitespace characters (a string)  If width specifier is used, matches up to width or until the first whitespace character, whichever appears first. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\n\n   [set]   matches a non-empty sequence of character from set of characters.  If the first character of the set is ^, then all characters not in the set are matched. If the set begins with ] or ^] then the ] character is also included into the set. It is implementation-defined whether the character - in the non-initial position in the scanset may be indicating a range, as in [0-9]. If width specifier is used, matches only up to width. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\n\n   d   matches a decimal integer.  The format of the number is the same as expected by strtol() with the value 10 for the base argument.\n  \nsigned char* or unsigned char*\n   \nsigned short* or unsigned short*\n   \nsigned int* or unsigned int*\n   \nsigned long* or unsigned long*\n   \nsigned long long* or unsigned long long*\n   \nintmax_t* or uintmax_t*\n   size_t*   ptrdiff_t*   N/A \n   i   matches an integer.  The format of the number is the same as expected by strtol() with the value \u200b0\u200b for the base argument (base is determined by the first characters parsed).\n\n   u   matches an unsigned decimal integer.  The format of the number is the same as expected by strtoul() with the value 10 for the base argument.\n\n   o   matches an unsigned octal integer.  The format of the number is the same as expected by strtoul() with the value 8 for the base argument.\n\n   x, X   matches an unsigned hexadecimal integer.  The format of the number is the same as expected by strtoul() with the value 16 for the base argument.\n\n   n   returns the number of characters read so far.  No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined.\n\n   a, A(C++11) e, E f, F g, G   matches a floating-point number.  The format of the number is the same as expected by strtof().\n  N/A   N/A   float*   double*   N/A   N/A   N/A   N/A   long double* \n   p   matches implementation defined character sequence defining a pointer.  printf family of functions should produce the same sequence using %p format specifier.\n  N/A   N/A   void**   N/A   N/A   N/A   N/A   N/A   N/A \n\n For every conversion specifier other than n, the longest sequence of input characters which does not exceed any speci\ufb01ed \ufb01eld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The \ufb01rst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-\ufb01le, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\nAll conversion specifiers other than [, c, and n consume and discard all leading whitespace characters (determined as if by calling isspace) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\nThe conversion specifiers lc, ls, and l[ perform multibyte-to-wide character conversion as if by calling mbrtowc() with an mbstate_t object initialized to zero before the first character is converted.\nThe conversion specifiers s and [ always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of %s or %[, without specifying the destination array size, is as unsafe as std::gets.\nThe correct conversion specifications for the fixed-width integer types (int8_t, etc) are defined in the header <cinttypes> (although SCNdMAX, SCNuMAX, etc is synonymous with %jd, %ju, etc).\nThere is a sequence point after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing \"100er\" with the conversion specifier %f, the sequence \"100e\" (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with \"r\" remaining. Some existing implementations do not follow this rule and roll back to consume only \"100\", leaving \"er\", e.g. glibc bug 1765.\n\n   vlist   -   variable argument list containing the receiving arguments \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstdio>\n#include <cstdarg>\n#include <stdexcept>\n \nvoid checked_sscanf(int count, const char* buf, const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    if(std::vsscanf(buf, fmt, ap) != count)\n        throw std::runtime_error(\"parsing error\");\n    va_end(ap);\n}\n \nint main()\n{\n    try {\n        int n, m;\n        std::cout << \"Parsing '1 2'...\";\n        checked_sscanf(2, \"1 2\", \"%d %d\", &n, &m);\n        std::cout << \"success\\n\";\n        std::cout << \"Parsing '1 a'...\";\n        checked_sscanf(2, \"1 a\", \"%d %d\", &n, &m);\n        std::cout << \"success\\n\";\n    } catch(const std::exception& e)\n    {\n        std::cout << e.what() << '\\n';\n    }\n}",
            "output": "Parsing '1 2'...success\nParsing '1 a'...parsing error"
        }
    },
    "printf, std::fprintf, std::sprintf, std::snprintf": {
        "description": {
            "texte": "Loads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks.If a call to sprintf or snprintf causes copying to take place between objects that overlap, the behavior is undefined (e.g. sprintf(buf, \"%s text\", buf);)."
        },
        "parametres": "   stream   -   output file stream to write to \n   buffer   -   pointer to a character string to write to \n   buf_size   -   up to buf_size - 1 characters may be written, plus the null terminator \n   format   -   pointer to a null-terminated multibyte string specifying how to interpret the data. The format string consists of ordinary multibyte characters (except %), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n introductory % character \n (optional) one or more flags that modify the behavior of the conversion: \n\n -: the result of the conversion is left-justified within the field (by default it is right-justified) \n +: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative) \n space: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if + flag is present. \n # : alternative form of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined. \n 0 : for integer and floating point number conversions, leading zeros are used to pad the field instead of space characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if - flag is present. \n\n (optional) integer value or * that specifies minimum field width. The result is padded with space characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when * is used, the width is specified by an additional argument of type int. If the value of the argument is negative, it results with the - flag specified and positive field width. (Note: This is the minimum width: The value is never truncated.) \n\n (optional) . followed by integer number or *, or neither that specifies precision of the conversion. In the case when * is used, the precision is specified by an additional argument of type int. If the value of this argument is negative, it is ignored. If neither a number nor * is used, the precision is taken as zero. See the table below for exact effects of precision. \n (optional) length modifier that specifies the size of the argument \n conversion format specifier \n\n        The following format specifiers are available:\n   Conversion specifier   Explanation   Argument type \n   length modifier   hh (C++11).\n  h   (none)   l   ll (C++11).\n  j (C++11).\n  z (C++11).\n  t (C++11).\n  L \n   %   writes literal %. The full conversion specification must be %%.   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A \n   c    writes a single character.  The argument is first converted to unsigned char. If the l modifier is used, the argument is first converted to a character string as if by %ls with a wchar_t[2] argument.\n  N/A   N/A   int   wint_t   N/A   N/A   N/A   N/A   N/A \n   s    writes a character string  The argument must be a pointer to the initial element of an array of characters. Precision specifies the maximum number of bytes to be written. If Precision is not specified, writes every byte up to and not including the first null terminator. If the l specifier is used, the argument must be a pointer to the initial element of an array of wchar_t, which is converted to char array as if by a call to wcrtomb with zero-initialized conversion state.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A \n   d i   converts a signed integer into decimal representation [-]dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  signed char   short   int   long   long long   intmax_t   signed size_t\n   ptrdiff_t   N/A \n   o   converts a unsigned integer into octal representation oooo.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation precision is increased if necessary, to write one leading zero. In that case if both the converted value and the precision are \u200b0\u200b, single \u200b0\u200b is written.\n  unsigned char   unsigned short   unsigned int   unsigned long   unsigned long long   uintmax_t   size_t   unsigned version of ptrdiff_t\n   N/A \n   x X   converts an unsigned integer into hexadecimal representation hhhh.  For the x conversion letters abcdef are used. For the X conversion letters ABCDEF are used. Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation 0x or 0X is prefixed to results if the converted value is nonzero.\n  N/A \n   u   converts an unsigned integer into decimal representation dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  N/A \n   f F   converts floating-point number to the decimal notation in the style [-]ddd.ddd.  Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   double   \ndouble (C++11)\n   N/A   N/A   N/A   N/A   long double \n   e E   converts floating-point number to the decimal exponent notation.  For the e conversion style [-]d.ddde\u00b1dd is used. For the E conversion style [-]d.dddE\u00b1dd is used. The exponent contains at least two digits, more digits are used only if necessary. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   a A (C++11).\n  converts floating-point number to the hexadecimal exponent notation.  For the a conversion style [-]0xh.hhhp\u00b1d is used. For the A conversion style [-]0Xh.hhhP\u00b1d is used. The first hexadecimal digit is not 0 if the argument is a normalized floating point value. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is sufficient for exact representation of the value. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   g G   converts floating-point number to decimal or decimal exponent notation depending on the value and the precision.  For the g conversion style conversion with style e or f will be performed. For the G conversion style conversion with style E or F will be performed. Let P equal the precision if nonzero, 6 if the precision is not specified, or 1 if the precision is \u200b0\u200b. Then, if a conversion with style E would have an exponent of X:\n\n if P > X \u2265 \u22124, the conversion is with style f or F and precision P \u2212 1 \u2212 X. \n otherwise, the conversion is with style e or E and precision P \u2212 1. \n Unless alternative representation is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   n   returns the number of characters written so far by this call to the function.  The result is written to the value pointed to by the argument. The specification may not contain any flag, field width, or precision.\n  signed char*   short*   int*   long*   long long*   intmax_t*   signed size_t*\n   ptrdiff_t*   N/A \n   p   writes an implementation defined character sequence defining a pointer.   N/A   N/A   void*   N/A   N/A   N/A   N/A   N/A   N/A \n\n The floating point conversion functions convert infinity to inf or infinity. Which one is used is implementation defined.\nNot-a-number is converted to nan or nan(char_sequence). Which one is used is implementation defined.\nThe conversions F, E, G, A output INF, INFINITY, NAN instead.\nEven though %c expects int argument, it is safe to pass a char because of the integer promotion that takes place when a variadic function is called.\nThe correct conversion specifications for the fixed-width character types (int8_t, etc) are defined in the header <cinttypes> (although PRIdMAX, PRIuMAX, etc is synonymous with %jd, %ju, etc).\nThe memory-writing conversion specifier %n is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked printf_s family of functions.\nThere is a sequence point after the action of each conversion specifier; this permits storing multiple %n results in the same variable or, as an edge case, printing a string modified by an earlier %n within the same call.\nIf a conversion specification is invalid, the behavior is undefined.\n\n   ...   -   arguments specifying data to print. If any argument after default conversions is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by format, the behavior is undefined. If there are more arguments than required by format, the extraneous arguments are evaluated and ignored \n\n",
        "exemple": {
            "input": "#include <cstdio>\n#include <limits>\n#include <cstdint>\n#include <cinttypes>\n \nint main()\n{\n    std::printf(\"Strings:\\n\");\n \n    const char* s = \"Hello\";\n    std::printf(\"\\t[%10s]\\n\\t[%-10s]\\n\\t[%*s]\\n\\t[%-10.*s]\\n\\t[%-*.*s]\\n\",\n        s, s, 10, s, 4, s, 10, 4, s);\n \n    std::printf(\"Characters:\\t%c %%\\n\", 65);\n \n    std::printf(\"Integers\\n\");\n    std::printf(\"Decimal:\\t%i %d %.6i %i %.0i %+i %i\\n\", 1, 2, 3, 0, 0, 4, -4);\n    std::printf(\"Hexadecimal:\\t%x %x %X %#x\\n\", 5, 10, 10, 6);\n    std::printf(\"Octal:\\t%o %#o %#o\\n\", 10, 10, 4);\n \n    std::printf(\"Floating point\\n\");\n    std::printf(\"Rounding:\\t%f %.0f %.32f\\n\", 1.5, 1.5, 1.3);\n    std::printf(\"Padding:\\t%05.2f %.2f %5.2f\\n\", 1.5, 1.5, 1.5);\n    std::printf(\"Scientific:\\t%E %e\\n\", 1.5, 1.5);\n    std::printf(\"Hexadecimal:\\t%a %A\\n\", 1.5, 1.5);\n    std::printf(\"Special values:\\t0/0=%g 1/0=%g\\n\", 0.0/0.0, 1.0/0.0);\n \n    std::printf(\"Variable width control:\\n\");\n    std::printf(\"right-justified variable width: '%*c'\\n\", 5, 'x');\n    int r = std::printf(\"left-justified variable width : '%*c'\\n\", -5, 'x');\n    std::printf(\"(the last printf printed %d characters)\\n\", r);\n \n    // fixed-width types\n    std::uint32_t val = std::numeric_limits<std::uint32_t>::max();\n    std::printf(\"Largest 32-bit value is %\" PRIu32 \" or %#\" PRIx32 \"\\n\", val, val);\n}",
            "output": "Strings:\n        [     Hello]\n        [Hello     ]\n        [     Hello]\n        [Hell      ]\n        [Hell      ]\nCharacters:     A %\nIntegers\nDecimal:        1 2 000003 0  +4 -4\nHexadecimal:    5 a A 0x6\nOctal:  12 012 04\nFloating point\nRounding:       1.500000 2 1.30000000000000004440892098500626\nPadding:        01.50 1.50  1.50\nScientific:     1.500000E+00 1.500000e+00\nHexadecimal:    0x1.8p+0 0X1.8P+0\nSpecial values: 0/0=nan 1/0=inf\nVariable width control:\nright-justified variable width: '    x'\nleft-justified variable width : 'x    '\n(the last printf printed 40 characters)\nLargest 32-bit value is 4294967295 or 0xffffffff"
        }
    },
    "vprintf, std::vfprintf, std::vsprintf, std::vsnprintf": {
        "description": {
            "texte": "Loads the data from the locations, defined by vlist, converts them to character string equivalents and writes the results to a variety of sinks."
        },
        "parametres": "   stream   -   output file stream to write to \n   buffer   -   pointer to a character string to write to \n   buf_size   -   maximum number of characters to write \n   format   -   pointer to a null-terminated character string specifying how to interpret the data. The format string consists of ordinary multibyte characters (except %), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n introductory % character \n (optional) one or more flags that modify the behavior of the conversion: \n\n -: the result of the conversion is left-justified within the field (by default it is right-justified) \n +: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative) \n space: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if + flag is present. \n # : alternative form of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined. \n 0 : for integer and floating point number conversions, leading zeros are used to pad the field instead of space characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if - flag is present. \n\n (optional) integer value or * that specifies minimum field width. The result is padded with space characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when * is used, the width is specified by an additional argument of type int. If the value of the argument is negative, it results with the - flag specified and positive field width. (Note: This is the minimum width: The value is never truncated.) \n\n (optional) . followed by integer number or *, or neither that specifies precision of the conversion. In the case when * is used, the precision is specified by an additional argument of type int. If the value of this argument is negative, it is ignored. If neither a number nor * is used, the precision is taken as zero. See the table below for exact effects of precision. \n (optional) length modifier that specifies the size of the argument \n conversion format specifier \n\n        The following format specifiers are available:\n   Conversion specifier   Explanation   Argument type \n   length modifier   hh (C++11).\n  h   (none)   l   ll (C++11).\n  j (C++11).\n  z (C++11).\n  t (C++11).\n  L \n   %   writes literal %. The full conversion specification must be %%.   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A \n   c    writes a single character.  The argument is first converted to unsigned char. If the l modifier is used, the argument is first converted to a character string as if by %ls with a wchar_t[2] argument.\n  N/A   N/A   int   wint_t   N/A   N/A   N/A   N/A   N/A \n   s    writes a character string  The argument must be a pointer to the initial element of an array of characters. Precision specifies the maximum number of bytes to be written. If Precision is not specified, writes every byte up to and not including the first null terminator. If the l specifier is used, the argument must be a pointer to the initial element of an array of wchar_t, which is converted to char array as if by a call to wcrtomb with zero-initialized conversion state.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A \n   d i   converts a signed integer into decimal representation [-]dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  signed char   short   int   long   long long   intmax_t   signed size_t\n   ptrdiff_t   N/A \n   o   converts a unsigned integer into octal representation oooo.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation precision is increased if necessary, to write one leading zero. In that case if both the converted value and the precision are \u200b0\u200b, single \u200b0\u200b is written.\n  unsigned char   unsigned short   unsigned int   unsigned long   unsigned long long   uintmax_t   size_t   unsigned version of ptrdiff_t\n   N/A \n   x X   converts an unsigned integer into hexadecimal representation hhhh.  For the x conversion letters abcdef are used. For the X conversion letters ABCDEF are used. Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation 0x or 0X is prefixed to results if the converted value is nonzero.\n  N/A \n   u   converts an unsigned integer into decimal representation dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  N/A \n   f F   converts floating-point number to the decimal notation in the style [-]ddd.ddd.  Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   double   \ndouble (C++11)\n   N/A   N/A   N/A   N/A   long double \n   e E   converts floating-point number to the decimal exponent notation.  For the e conversion style [-]d.ddde\u00b1dd is used. For the E conversion style [-]d.dddE\u00b1dd is used. The exponent contains at least two digits, more digits are used only if necessary. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   a A (C++11).\n  converts floating-point number to the hexadecimal exponent notation.  For the a conversion style [-]0xh.hhhp\u00b1d is used. For the A conversion style [-]0Xh.hhhP\u00b1d is used. The first hexadecimal digit is not 0 if the argument is a normalized floating point value. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is sufficient for exact representation of the value. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   g G   converts floating-point number to decimal or decimal exponent notation depending on the value and the precision.  For the g conversion style conversion with style e or f will be performed. For the G conversion style conversion with style E or F will be performed. Let P equal the precision if nonzero, 6 if the precision is not specified, or 1 if the precision is \u200b0\u200b. Then, if a conversion with style E would have an exponent of X:\n\n if P > X \u2265 \u22124, the conversion is with style f or F and precision P \u2212 1 \u2212 X. \n otherwise, the conversion is with style e or E and precision P \u2212 1. \n Unless alternative representation is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   n   returns the number of characters written so far by this call to the function.  The result is written to the value pointed to by the argument. The specification may not contain any flag, field width, or precision.\n  signed char*   short*   int*   long*   long long*   intmax_t*   signed size_t*\n   ptrdiff_t*   N/A \n   p   writes an implementation defined character sequence defining a pointer.   N/A   N/A   void*   N/A   N/A   N/A   N/A   N/A   N/A \n\n The floating point conversion functions convert infinity to inf or infinity. Which one is used is implementation defined.\nNot-a-number is converted to nan or nan(char_sequence). Which one is used is implementation defined.\nThe conversions F, E, G, A output INF, INFINITY, NAN instead.\nEven though %c expects int argument, it is safe to pass a char because of the integer promotion that takes place when a variadic function is called.\nThe correct conversion specifications for the fixed-width character types (int8_t, etc) are defined in the header <cinttypes> (although PRIdMAX, PRIuMAX, etc is synonymous with %jd, %ju, etc).\nThe memory-writing conversion specifier %n is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked printf_s family of functions.\nThere is a sequence point after the action of each conversion specifier; this permits storing multiple %n results in the same variable or, as an edge case, printing a string modified by an earlier %n within the same call.\nIf a conversion specification is invalid, the behavior is undefined.\n\n   vlist   -   variable argument list containing the data to print \n\n",
        "exemple": {
            "input": "#include <vector>\n#include <cstdio>\n#include <cstdarg>\n#include <ctime>\n \nvoid debug_log(const char *fmt, ...)\n{\n    std::time_t t = std::time(nullptr);\n    char time_buf[100];\n    std::strftime(time_buf, sizeof time_buf, \"%D %T\", std::gmtime(&t));\n    va_list args1;\n    va_start(args1, fmt);\n    va_list args2;\n    va_copy(args2, args1);\n    std::vector<char> buf(1+std::vsnprintf(nullptr, 0, fmt, args1));\n    va_end(args1);\n    std::vsnprintf(buf.data(), buf.size(), fmt, args2);\n    va_end(args2);\n    std::printf(\"%s [debug]: %s\\n\", time_buf, buf.data());\n}\n \nint main()\n{\n    debug_log(\"Logging, %d, %d, %d\", 1, 2, 3);\n}",
            "output": "04/13/15 15:09:18 [debug]: Logging, 1, 2, 3"
        }
    },
    "ftell": {
        "description": {
            "texte": "Returns the current value of the file position indicator for the file stream stream.If the stream is open in binary mode, the value obtained by this function is the number of bytes from the beginning of the file.If the stream is open in text mode, the value returned by this function is unspecified and is only meaningful as the input to std::fseek."
        },
        "parametres": "   stream   -   file stream to examine \n\n"
    },
    "fgetpos": {
        "description": {
            "texte": "Obtains the file position indicator and the current parse state (if any) for the file stream stream and stores them in the object pointed to by pos. The value stored is only meaningful as the input to std::fsetpos."
        },
        "parametres": "   stream   -   file stream to examine \n   pos   -   pointer to a fpos_t object to store the file position indicator to \n\n"
    },
    "fsetpos": {
        "description": {
            "texte": "Sets the file position indicator and the multibyte parsing state (if any) for the C file stream stream according to the value pointed to by pos.Besides establishing new parse state and position, a call to this function undoes the effects of std::ungetc and clears the end-of-file state, if it is set.If a read or write error occurs, the error indicator (std::ferror)for the stream is set."
        },
        "parametres": "   stream   -   file stream to modify \n   pos   -   pointer to a fpos_t object obtained from std::fgetpos called on a stream associated with the same file \n\n"
    },
    "rewind": {
        "description": {
            "texte": "Moves the file position indicator to the beginning of the given file stream.The function is equivalent to std::fseek(stream, 0, SEEK_SET);, except that end-of-file and error indicators are cleared.The function drops any effects from previous calls to ungetc."
        },
        "parametres": "   stream   -   file stream to modify \n\n",
        "exemple": {
            "input": "#include <cstdio>\n \nint main()\n{\n    std::FILE *f;\n    char ch;\n    char str[20];\n \n    f = std::fopen(\"file.txt\", \"w\");\n    for (ch = '0'; ch <= '9'; ch++) {\n        std::fputc(ch, f);\n    }\n    std::fclose(f);\n \n \n    std::FILE* f2 = std::fopen(\"file.txt\", \"r\");\n    unsigned int size = std::fread(str, 1, 10, f2);\n    std::puts(str);\n    std::printf(\"\\n%u\\n\",size);\n \n    std::rewind(f2);\n    unsigned int size2 = std::fread(str, 1, 10, f2);\n    std::puts(str);\n    std::printf(\"\\n%u\",size2);\n    std::fclose(f2);\n}"
        }
    },
    "clearerr": {
        "description": {
            "texte": "Resets the error flags and the EOF indicator for the given file stream."
        },
        "parametres": "   stream   -   the file to reset the error flags for \n\n"
    },
    "feof": {
        "description": {
            "texte": "Checks if the end of the given file stream has been reached."
        },
        "parametres": "   stream   -   the file stream to check \n\n",
        "exemple": {
            "input": "#include <cstdio>\n#include <cstdlib>\n \nint main()\n{\n    FILE* fp = std::fopen(\"test.txt\", \"r\");\n    if(!fp) {\n        std::perror(\"File opening failed\");\n        return EXIT_FAILURE;\n    }\n \n    int c; // note: int, not char, required to handle EOF\n    while ((c = std::fgetc(fp)) != EOF) { // standard C I/O file reading loop\n       std::putchar(c);\n    }\n \n    if (std::ferror(fp))\n        std::puts(\"I/O error when reading\");\n    else if (std::feof(fp))\n        std::puts(\"End of file reached successfully\");\n \n    std::fclose(fp);\n}"
        }
    },
    "ferror": {
        "description": {
            "texte": "Checks the given stream for errors."
        },
        "parametres": "   stream   -   the file stream to check \n\n",
        "exemple": {
            "input": "#include <cstdio>\n#include <cstdlib>\n#include <clocale>\n#include <cwchar>\n \nint main(void)\n{\n    const char *fname = std::tmpnam(nullptr);\n    std::FILE* f = std::fopen(fname, \"wb\");\n    std::fputs(\"\\xff\\xff\\n\", f); // not a valid UTF-8 character sequence\n    std::fclose(f);\n \n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    f = std::fopen(fname, \"rb\");\n    std::wint_t ch;\n    while ((ch=std::fgetwc(f)) != WEOF) // attempt to read as UTF-8\n          std::printf(\"%#x \", ch);\n \n    if (std::feof(f))\n        puts(\"EOF indicator set\");\n    if (std::ferror(f))\n        puts(\"Error indicator set\");\n}",
            "output": "Error indicator set"
        }
    },
    "perror": {
        "description": {
            "texte": "Prints a textual description of the error code currently stored in the system variable errno to stderr.The description is formed by concatenating the following components:"
        },
        "parametres": "   s   -   pointer to a null-terminated string with explanatory message \n\n",
        "exemple": {
            "input": "#include <cmath>\n#include <cerrno>\n#include <cstdio>\n \nint main()\n{\n    double not_a_number = std::log(-1.0);\n    if (errno == EDOM) {\n        std::perror(\"log(-1) failed\");\n    }\n}",
            "output": "log(-1) failed: Numerical argument out of domain"
        }
    },
    "remove": {
        "description": {
            "texte": "Deletes the file identified by character string pointed to by fname.If the file is currently open by the current or another process, the behavior of this function is implementation-defined (in particular, POSIX systems unlink the file name, although the file system space is not reclaimed even if this was the last hardlink to the file until the last running process closes the file, Windows does not allow the file to be deleted)."
        },
        "parametres": "   fname   -   pointer to a null-terminated string containing the path identifying the file to delete \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <cstdio>\nint main()\n{\n    bool ok = static_cast<bool>(std::ofstream(\"file1.txt\").put('a')); // create file\n    if(!ok) { std::perror(\"Error creating file1.txt\"); return 1; }\n    std::cout << std::ifstream(\"file1.txt\").rdbuf() << '\\n'; // print file\n \n    std::remove(\"file1.txt\"); // delete file\n \n    bool failed = !std::ifstream(\"file1.txt\");\n    if(failed) { std::perror(\"Error opening deleted file\"); return 1; }\n}",
            "output": "a\nError opening deleted file: No such file or directory"
        }
    },
    "rename": {
        "description": {
            "texte": "Changes the filename of a file. The file is identified by character string pointed to by old_filename. The new filename is identified by character string pointed to by new_filename.If new_filename exists, the behavior is implementation-defined."
        },
        "parametres": "   old_filename   -   pointer to a null-terminated string containing the path identifying the file to rename \n   new_filename   -   pointer to a null-terminated string containing the new path of the file \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <cstdio>\nint main()\n{\n    bool ok{std::ofstream(\"from.txt\").put('a')}; // create and write to file\n    if (!ok) {\n        std::perror(\"Error creating from.txt\");\n        return 1;\n    }\n \n    if (std::rename(\"from.txt\", \"to.txt\")) {\n        std::perror(\"Error renaming\");\n        return 1;\n    }\n \n    std::cout << std::ifstream(\"to.txt\").rdbuf() << '\\n'; // print file\n}",
            "output": "a"
        }
    },
    "tmpfile": {
        "description": {
            "texte": "Creates and opens a temporary file with a unique auto-generated filename.The file is opened as a binary file for update (as by std::fopen with access mode \"wb+\"). At least TMP_MAX files may be opened during the lifetime of a program (this limit may be shared with std::tmpnam and may be further limited by FOPEN_MAX).If the program closes the file, e.g. by executing std::fclose, the file is automatically deleted.If the program terminates normally (by calling std::exit, returning from main, etc), all files that were opened by calling std::tmpfile are also automatically deleted.If the program terminates abnormally, it is implementation-defined if these temporary files are deleted."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    std::FILE* tmpf = std::tmpfile();\n    std::fputs(\"Hello, world\", tmpf);\n    std::rewind(tmpf);\n    char buf[6];\n    std::fgets(buf, sizeof buf, tmpf);\n    std::cout << buf << '\\n';\n \n    // Linux-specific method to display the tmpfile name\n    std::cout << fs::read_symlink(\n                     fs::path(\"/proc/self/fd\") / std::to_string(fileno(tmpf))\n                 ) << '\\n';\n}",
            "output": "Hello\n\"/tmp/tmpfBlY1lI (deleted)\""
        }
    },
    "strtoimax, std::strtoumax": {
        "description": {
            "texte": "Interprets an integer value in a byte string pointed to by nptr.Discards any whitespace characters (as identified by calling isspace()) until the first non-whitespace character is found, then takes as many characters as possible to form a valid base-n (where n=base) integer number representation and converts them to an integer value. The valid integer value consists of the following parts:The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is {0,1}, for base-3 integers is {0,1,2}, and so on. For bases larger than 10, valid digits include alphabetic characters, starting from Aa for base-11 integer, to Zz for base-36 integer. The case of the characters is ignored.Additional numeric formats may be accepted by the currently installed C locale.If the value of base is \u200b0\u200b, the numeric base is auto-detected: if the prefix is 0, the base is octal, if the prefix is 0x or 0X, the base is hexadecimal, otherwise the base is decimal.If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type.The functions sets the pointer pointed to by endptr to point to the character past the last character interpreted. If endptr is NULL, it is ignored.If the nptr is empty or does not have the expected form, no conversion is performed, and (if enptr is not NULL) the value of nptr is stored in the object pointed to by endptr."
        },
        "parametres": "   nptr   -   pointer to the null-terminated byte string to be interpreted \n   endptr   -   pointer to a pointer to character. \n   base   -   base of the interpreted integer value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <cinttypes>\n \nint main()\n{\n    std::string str = \"helloworld\";\n    std::intmax_t val = std::strtoimax(str.c_str(), nullptr, 36);\n    std::cout << str << \" in base 36 is \" << val << \" in base 10\\n\";\n \n    char* nptr;\n    val = std::strtoimax(str.c_str(), &nptr, 30);\n    if(nptr != &str[0] + str.size())\n        std::cout << str << \" in base 30 is invalid.\"\n                  << \" The first invalid digit is \" << *nptr << '\\n';\n}",
            "output": "helloworld in base 36 is 1767707668033969 in base 10\nhelloworld in base 30 is invalid. The first invalid digit is w"
        }
    },
    "wcstoimax, std::wcstoumax": {
        "description": {
            "texte": "Interprets an unsigned integer value in a wide string pointed to by nptr.Discards any whitespace characters (as identified by calling isspace()) until the first non-whitespace character is found, then takes as many characters as possible to form a valid base-n (where n=base) unsigned integer number representation and converts them to an integer value. The valid unsigned integer value consists of the following parts:The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is {0,1}, for base-3 integers is {0,1,2}, and so on. For bases larger than 10, valid digits include alphabetic characters, starting from Aa for base-11 integer, to Zz for base-36 integer. The case of the characters is ignored.Additional numeric formats may be accepted by the currently installed C locale.If the value of base is \u200b0\u200b, the numeric base is auto-detected: if the prefix is 0, the base is octal, if the prefix is 0x or 0X, the base is hexadecimal, otherwise the base is decimal.If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type, which applies unsigned integer wraparound rules.The functions sets the pointer pointed to by endptr to point to the wide character past the last character interpreted. If endptr is NULL, it is ignored."
        },
        "parametres": "   nptr   -   pointer to the null-terminated wide string to be interpreted \n   endptr   -   pointer to a pointer to a wide character. \n   base   -   base of the interpreted integer value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <cinttypes>\n \nint main()\n{\n    std::wstring str = L\"helloworld\";\n    std::intmax_t val = std::wcstoimax(str.c_str(), nullptr, 36);\n    std::wcout << str << \" in base 36 is \" << val << \" in base 10\\n\";\n \n    wchar_t* nptr;\n    val = std::wcstoimax(str.c_str(), &nptr, 30);\n    if(nptr != &str[0] + str.size())\n        std::wcout << str << \" in base 30 is invalid.\"\n                  << \" The first invalid digit is \" << *nptr << '\\n';\n}",
            "output": "helloworld in base 36 is 1767707668033969 in base 10\nhelloworld in base 30 is invalid. The first invalid digit is w"
        }
    },
    "swap(std::basic_regex)\n": {
        "description": {
            "texte": "Overloads the std::swap algorithm for std::basic_regex. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   regular expressions to swap \n\n"
    },
    "operator==,!=,,>=(std::sub_match)\n": {
        "description": {
            "texte": "Compares a sub_match to another sub_match, a string, a null-terminated character sequence or a character."
        },
        "parametres": "   lhs, rhs   -   a sub_match, basic_string, pointer to a null-terminated string or a character to compare \n\n"
    },
    "operator<<(std::sub_match)": {
        "description": {
            "texte": "Writes the representation of the matched subsequence m to the output stream os.Equivalent to os << m.str()."
        },
        "parametres": "   os   -   output stream to write the representation to \n   m   -   a sub-match object to output \n\n"
    },
    "operator==,!=(std::match_results)": {
        "description": {
            "texte": "Compares two match_results objects.Two match_results are equal if the following conditions are met:"
        },
        "parametres": "   lhs, rhs   -   match results to compare \n   Type requirements \n   -BidirIt must meet the requirements of LegacyBidirectionalIterator. \n   -Alloc must meet the requirements of Allocator. \n\n"
    },
    "swap(std::match_results)": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::match_results. Exchanges the contents of x1 with those of x2. Effectively calls x1.swap(x2)."
        },
        "parametres": "   x1, x2   -   the match_results objects whose contents will be swapped \n   Type requirements \n   -BidirIt must meet the requirements of LegacyBidirectionalIterator. \n   -Alloc must meet the requirements of Allocator. \n\n"
    },
    "filesystem::u8path": {
        "description": {
            "texte": "Constructs a path p from a UTF-8 encoded sequence of chars, supplied either as an std::string, or as std::string_view, or as a null-terminated multibyte string, or as a [first, last) iterator pair."
        },
        "parametres": "   source   -   a UTF-8 encoded std::string, std::string_view, a pointer to a null-terminated multibyte string, or an input iterator with char value type that points to a null-terminated multibyte string \n   first, last   -   pair of LegacyInputIterators that specify a UTF-8 encoded character sequence \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -The value type of InputIt must be char \n\n",
        "exemple": {
            "input": "#include <cstdio>\n#ifdef _MSC_VER\n#include <io.h>\n#include <fcntl.h>\n#else\n#include <locale>\n#include <clocale>\n#endif\n#include <fstream>\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n#ifdef _MSC_VER\n    _setmode(_fileno(stderr), _O_WTEXT);\n#else\n    std::setlocale(LC_ALL, \"\");\n    std::locale::global(std::locale(\"\"));\n    std::cout.imbue(std::locale());\n    std::wcerr.imbue(std::locale());\n#endif\n \n    fs::path p = fs::u8path(u8\"\u8981\u3089\u306a\u3044.txt\");\n    std::ofstream(p) << \"File contents\"; // Prior to LWG2676 uses operator string_type()\n                                         // on MSVC, where string_type is wstring, only\n                                         // works due to non-standard extension.\n                                         // Post-LWG2676 uses new fstream constructors\n \n    // native string representation can be used with OS APIs\n    if (std::FILE* f =\n#ifdef _MSC_VER\n                _wfopen(p.c_str(), L\"r\")\n#else\n                std::fopen(p.c_str(), \"r\")\n#endif\n        )\n    {\n        int ch;\n        while((ch=fgetc(f))!= EOF) putchar(ch);\n        std::fclose(f);\n    }\n \n    // multibyte and wide representation can be used for output\n    std::cout << \"\\nFile name in narrow multibyte encoding: \" << p.string() << '\\n';\n    std::wcerr << \"File name in wide encoding: \" << p.wstring() << '\\n';\n \n    fs::remove(p);\n}",
            "output": "File contents\nFile name in narrow multibyte encoding: \u8981\u3089\u306a\u3044.txt\nFile name in wide encoding: \u8981\u3089\u306a\u3044.txt"
        }
    },
    "swap(std::thread)": {
        "description": {
            "texte": "Overloads the std::swap algorithm for std::thread. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   threads whose states to swap \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <thread>\n#include <chrono>\n \nvoid foo()\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nvoid bar()\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nint main()\n{\n    std::thread t1(foo);\n    std::thread t2(bar);\n \n    std::cout << \"thread 1 id: \" << t1.get_id() << std::endl;\n    std::cout << \"thread 2 id: \" << t2.get_id() << std::endl;\n \n    std::swap(t1, t2);\n \n    std::cout << \"after std::swap(t1, t2):\" << std::endl;\n    std::cout << \"thread 1 id: \" << t1.get_id() << std::endl;\n    std::cout << \"thread 2 id: \" << t2.get_id() << std::endl;\n \n    t1.swap(t2);\n \n    std::cout << \"after t1.swap(t2):\" << std::endl;\n    std::cout << \"thread 1 id: \" << t1.get_id() << std::endl;\n    std::cout << \"thread 2 id: \" << t2.get_id() << std::endl;\n \n    t1.join();\n    t2.join();\n}",
            "output": "thread 1 id: 1892\nthread 2 id: 2584\nafter std::swap(t1, t2):\nthread 1 id: 2584\nthread 2 id: 1892\nafter t1.swap(t2):\nthread 1 id: 1892\nthread 2 id: 2584"
        }
    },
    "operator==,!=,,>=(std::thread::id)": {
        "description": {
            "texte": "Compares two thread identifiers."
        },
        "parametres": "   lhs, rhs   -   thread identifiers to compare \n\n"
    },
    "operator<<(std::thread::id)": {
        "description": {
            "texte": "Writes a textual representation of a thread identifier id to the output stream ost.If two thread identifiers compare equal, they have identical textual representations; if they do not compare equal, their representations are distinct."
        },
        "parametres": "   ost   -   output stream to insert the data into \n   id   -   thread identifier \n\n"
    },
    "hash": {
        "description": {
            "texte": "The template specialization of std::hash for the std::thread::id class allows users to obtain hashes of the identifiers of threads."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <thread>\n#include <chrono>\n#include <vector>\nusing namespace std::chrono_literals;\nvoid foo()\n{\n    std::this_thread::sleep_for(10ms);\n}\n \nint main()\n{\n    std::vector<std::thread> v;\n    for(int n = 0; n < 4; ++n)\n        v.emplace_back(foo);\n \n    std::hash<std::thread::id> hasher;\n    for(auto& t : v) {\n        std::cout << \"thread \" << t.get_id() << \" hashes to \" << hasher(t.get_id()) << '\\n';\n        t.join();\n    }\n}",
            "output": "thread 139786440144640 hashes to 8905351942358389397\nthread 139786431751936 hashes to 9222844670065909738\nthread 139786423359232 hashes to 18199000599186780501\nthread 139786414966528 hashes to 15386662774029264672"
        }
    },
    "swap(std::unique_lock)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::unique_lock. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   lock wrappers whose states to swap \n\n"
    },
    "swap(std::shared_lock)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::shared_lock. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   lock wrappers whose states to swap \n\n"
    },
    "swap(std::promise)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::promise. Exchanges the shared state of lhs with that of rhs. Effectively calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   promises whose states to swap \n\n"
    },
    "swap(std::packaged_task)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::packaged_task. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   packaged tasks whose states to swap \n\n"
    },
    "uses_allocator_construction_args": {
        "description": {
            "texte": "Prepares the argument list needed to create an object of the given type T by means of uses-allocator construction."
        },
        "parametres": "   alloc   -   the allocator to use. \n   args   -   the arguments to pass to T's constructor \n   x   -   tuple of arguments to pass to the constructors of T's .first \n   y   -   tuple of arguments to pass to the constructors of T's .second \n   u   -   single argument to pass to the constructor of T's .first \n   v   -   single argument to pass to the constructor of T's .second \n   pr   -   a pair whose .first will be passed to the constructor of T's .first and .second will be passed to the constructor of T's .second \n\n"
    },
    "make_obj_using_allocator": {
        "description": {
            "texte": "Creates an object of the given type T by means of uses-allocator construction.Equivalent to.",
            "code": "return std::make_from_tuple<T>(\n    std::uses_allocator_construction_args<T>(alloc, std::forward<Args>(args)...)\n);"
        },
        "parametres": "   alloc   -   the allocator to use. \n   args   -   the arguments to pass to T's constructor \n\n"
    },
    "uninitialized_construct_using_allocator": {
        "description": {
            "texte": "Creates an object of the given type T by means of uses-allocator construction at the uninitialized memory location indicated by p.Equivalent to.",
            "code": "return ::new(static_cast<void*>(p)) T(\n    std::make_obj_using_allocator<T>(alloc, std::forward<Args>(args)...)\n);"
        },
        "parametres": "   p   -   the memory location where the object will be placed. \n   alloc   -   the allocator to use. \n   args   -   the arguments to pass to T's constructor \n\n"
    },
    "common_reference": {
        "description": {
            "texte": "Determines the common reference type of the types T..., that is, the type to which all the types in T... can be converted or bound. If such a type exists (as determined according to the rules below), the member type names that type. Otherwise, there is no member type. The behavior is undefined if any of the types in T... is an incomplete type other than (possibly cv-qualified) void.When given reference types, common_reference attempts to find a reference type to which the supplied reference types can all be bound, but may return a non-reference type if it cannot find such a reference type.The simple common reference type of two reference types T1 and T2 is defined as follows:"
        }
    },
    "type_identity": {
        "description": {
            "texte": "Provides the member typedef type that names T (i.e., the identity transformation)."
        }
    },
    "bitset::reference": {
        "description": {
            "texte": "The std::bitset class includes std::bitset::reference as a publicly-accessible nested class. This class is used as a proxy object to allow users to interact with individual bits of a bitset, since standard C++ types (like references and pointers) are not built with enough precision to specify individual bits.The primary use of std::bitset::reference is to provide an l-value that can be returned from operator[].Any reads or writes to a bitset that happen via a std::bitset::reference potentially read or write to the entire underlying bitset."
        },
        "parametres": "   x   -   value to assign \n\n"
    },
    "bitset::bitset": {
        "description": {
            "texte": "Constructs a new bitset from one of several optional data sources:"
        },
        "parametres": "   val   -   number used to initialize the bitset \n   str   -   string used to initialize the bitset \n   pos   -   a starting offset into str \n   n   -   number of characters to use from str \n   one   -   alternate character for set bits in str \n   zero   -   alternate character for unset bits in str \n\n",
        "exemple": {
            "input": "#include <bitset>\n#include <string>\n#include <iostream>\n#include <climits>\n \nint main() \n{\n    // empty constructor\n    std::bitset<8> b1; // [0,0,0,0,0,0,0,0]\n \n    // unsigned long long constructor\n    std::bitset<8> b2(42);          // [0,0,1,0,1,0,1,0]\n    std::bitset<70> bl(ULLONG_MAX); // [0,0,0,0,0,0,1,1,1,...,1,1,1] in C++11\n    std::bitset<8> bs(0xfff0);      // [1,1,1,1,0,0,0,0]\n \n    // string constructor\n    std::string bit_string = \"110010\";\n    std::bitset<8> b3(bit_string);       // [0,0,1,1,0,0,1,0]\n    std::bitset<8> b4(bit_string, 2);    // [0,0,0,0,0,0,1,0]\n    std::bitset<8> b5(bit_string, 2, 3); // [0,0,0,0,0,0,0,1]\n \n    // string constructor using custom zero/one digits\n    std::string alpha_bit_string = \"aBaaBBaB\";\n    std::bitset<8> b6(alpha_bit_string, 0, alpha_bit_string.size(),\n                      'a', 'B');         // [0,1,0,0,1,1,0,1]\n \n    // char* constructor using custom digits\n    std::bitset<8> b7(\"XXXXYYYY\", 8, 'X', 'Y'); // [0,0,0,0,1,1,1,1]\n \n    std::cout << b1 << '\\n' << b2 << '\\n' << bl << '\\n' << bs << '\\n'\n              << b3 << '\\n' << b4 << '\\n' << b5 << '\\n' << b6 << '\\n'\n              << b7 << '\\n';\n}",
            "output": "00000000\n00101010\n0000001111111111111111111111111111111111111111111111111111111111111111\n11110000\n00110010\n00000010\n00000001\n01001101\n00001111"
        }
    },
    "operator==,!=(std::bitset)": {
        "description": {
            "texte": "1) Returns true if all of the bits in *this and rhs are equal.2) Returns true if any of the bits in *this and rhs are not equal."
        },
        "parametres": "   rhs   -   bitset to compare \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <bitset>\n \nint main()\n{\n    std::bitset<4> b1(3); // [0,0,1,1]\n    std::bitset<4> b2(b1);\n    std::bitset<4> b3(4); // [0,1,0,0]\n \n    std::cout << \"b1 == b2: \" << (b1 == b2) << '\\n';\n    std::cout << \"b1 == b3: \" << (b1 == b3) << '\\n';\n    std::cout << \"b1 != b3: \" << (b1 != b3) << '\\n';\n}",
            "output": "b1 == b2: 1\nb1 == b3: 0\nb1 != b3: 1"
        }
    },
    "bitset::operator[]": {
        "description": {
            "texte": "Accesses the bit at position pos. The first version returns the value of the bit, the second version returns an object of type std::bitset::reference that allows modification of the value.Unlike test(), does not throw exceptions: the behavior is undefined if pos is out of bounds."
        },
        "parametres": "   pos   -   position of the bit to return \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <bitset>\n \nint main()\n{\n    std::bitset<8> b1(42);\n    for (std::size_t i = 0; i < b1.size(); ++i) {\n        std::cout << \"b1[\" << i << \"]: \" << b1[i] << '\\n';\n    }\n    b1[0] = true; // modifies the first bit through bitset::reference\n    std::cout << \"After setting bit 0, the bitset holds \" << b1 << '\\n';\n}",
            "output": "b1[0]: 0\nb1[1]: 1\nb1[2]: 0\nb1[3]: 1\nb1[4]: 0\nb1[5]: 1\nb1[6]: 0\nb1[7]: 0\nAfter setting bit 0, the bitset holds 00101011"
        }
    },
    "bitset::test": {
        "description": {
            "texte": "Returns the value of the bit at the position pos.Unlike operator[], performs a bounds check and throws std::out_of_range if pos does not correspond to a valid position in the bitset."
        },
        "parametres": "   pos   -   position of the bit to return \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <bitset>\n \nint main() \n{\n    std::bitset<10> b1(\"1111010000\");\n \n    size_t idx = 0;\n    while (idx < b1.size() && !b1.test(idx)) {\n      ++idx;\n    }\n \n    if (idx < b1.size()) {\n        std::cout << \"first set bit at index \" << idx << '\\n';\n    } else {\n        std::cout << \"no set bits\\n\";\n    }\n}",
            "output": "first set bit at index 4"
        }
    },
    "bitset::all, std::bitset::any, std::bitset::none": {
        "description": {
            "texte": "Checks if all, any or none of the bits are set to true."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <bitset>\n \nint main()\n{\n    std::bitset<4> b1(\"0000\");\n    std::bitset<4> b2(\"0101\");\n    std::bitset<4> b3(\"1111\");\n \n    std::cout << \"bitset\\t\" << \"all\\t\" << \"any\\t\" << \"none\\n\";\n    std::cout << b1 << '\\t' << b1.all() << '\\t' << b1.any() << '\\t' << b1.none() << '\\n';\n    std::cout << b2 << '\\t' << b2.all() << '\\t' << b2.any() << '\\t' << b2.none() << '\\n';\n    std::cout << b3 << '\\t' << b3.all() << '\\t' << b3.any() << '\\t' << b3.none() << '\\n';\n}",
            "output": "bitset  all     any     none\n0000    0       0       1\n0101    0       1       0\n1111    1       1       0"
        }
    },
    "bitset::count": {
        "description": {
            "texte": "Returns the number of bits that are set to true."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <bitset>\n \nint main()\n{\n    std::bitset<8> b(\"00010010\");\n    std::cout << \"initial value: \" << b << '\\n';\n \n    // find the first unset bit\n    std::size_t idx = 0;\n    while (idx < b.size() && b.test(idx)) ++idx;\n \n    // continue setting bits until half the bitset is filled\n    while (idx < b.size() && b.count() < b.size()/2) {\n        b.set(idx);\n        std::cout << \"setting bit \" << idx << \": \" << b << '\\n';\n        while (idx < b.size() && b.test(idx)) ++idx;\n    }\n \n}",
            "output": "initial value: 00010010\nsetting bit 0: 00010011\nsetting bit 2: 00010111"
        }
    },
    "bitset::size": {
        "description": {
            "texte": "Returns the number of bits that the bitset can hold."
        }
    },
    "bitset::operator&=,|=,^=,~": {
        "description": {
            "texte": "Performs binary AND, OR, XOR and NOT.Note that &=, |=, and ^= are only defined for bitsets of the same size N."
        },
        "parametres": "   other   -   another bitset \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <bitset>\n \nint main()\n{\n    std::bitset<16> dest;\n    std::string pattern_str = \"1001\";\n    std::bitset<16> pattern(pattern_str);\n \n    for (size_t i = 0, ie = dest.size()/pattern_str.size(); i != ie; ++i) {\n        dest <<= pattern_str.size();\n        dest |= pattern;\n    }\n    std::cout << dest << '\\n';\n}",
            "output": "1001100110011001"
        }
    },
    "bitset::operator>,>>=": {
        "description": {
            "texte": "Performs binary shift left and binary shift right. Zeroes are shifted in."
        },
        "parametres": "   pos   -   number of positions to shift the bits \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <bitset>\n \nint main()\n{\n    std::bitset<8> b(\"01110010\");\n    std::cout << \"initial value: \" << b << '\\n';\n \n    while (b.any()) {\n        while (!b.test(0)) {\n            b >>= 1;\n        }\n        std::cout << b << '\\n';\n        b >>= 1;\n    }\n}",
            "output": "initial value: 01110010\n00111001\n00000111\n00000011\n00000001"
        }
    },
    "bitset::set": {
        "description": {
            "texte": "Sets all bits to true or to specified value."
        },
        "parametres": "   pos   -   the position of the bit to set (least significant to most significant) \n   value   -   the value to set the bit to \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <bitset>\n \nint main()\n{\n    std::bitset<8> b;\n    for (size_t i = 1; i < b.size(); i += 2) {\n        b.set(i);\n    }\n    std::cout << b << '\\n';\n}",
            "output": "10101010"
        }
    },
    "bitset::reset": {
        "description": {
            "texte": "Sets bits to false."
        },
        "parametres": "   pos   -   the position of the bit to set \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <bitset>\n \nint main()\n{\n    std::bitset<8> b(42);\n    std::cout << \"Bitset is         \" << b << '\\n';\n    b.reset(1);\n    std::cout << \"After b.reset(1): \" << b << '\\n';\n    b.reset();\n    std::cout << \"After b.reset():  \" << b << '\\n';\n}",
            "output": "Bitset is         00101010\nAfter b.reset(1): 00101000\nAfter b.reset():  00000000"
        }
    },
    "bitset::flip": {
        "description": {
            "texte": "Flips bits, i.e. changes true values to false and false values to true. Equivalent to a logical NOT operation on part or all of the bitset."
        },
        "parametres": "   pos   -   the position of the bit to flip \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <bitset>\n \nint main()\n{\n    std::bitset<4> b;\n \n    std::cout << b << \"\\n\";\n    std::cout << b.flip(0) << '\\n';\n    std::cout << b.flip(2) << '\\n';\n    std::cout << b.flip() << '\\n';\n}",
            "output": "0000\n0001\n0101\n1010"
        }
    },
    "bitset::to_string": {
        "description": {
            "texte": "Converts the contents of the bitset to a string. Uses zero to represent bits with value of false and one to represent bits with value of true.The resulting string contains N characters with the first character corresponds to the last (N-1th) bit and the last character corresponding to the first bit."
        },
        "parametres": "   zero   -   character to use to represent false \n   one   -   character to use to represent true \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <bitset>\nint main()\n{\n    std::bitset<8> b(42);\n    std::cout << b.to_string() << '\\n'\n              << b.to_string('*') << '\\n'\n              << b.to_string('O', 'X') << '\\n';\n}",
            "output": "00101010\n**1*1*1*\nOOXOXOXO"
        }
    },
    "bitset::to_ulong": {
        "description": {
            "texte": "Converts the contents of the bitset to an unsigned long integer.The first bit of the bitset corresponds to the least significant digit of the number and the last bit corresponds to the most significant digit."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <bitset>\n \nint main()\n{\n    for (unsigned long i = 0; i < 10; ++i) {\n        std::bitset<5> b(i);\n        std::bitset<5> b_inverted = ~b;\n        std::cout << i << '\\t';\n        std::cout << b << '\\t';\n        std::cout << b_inverted << '\\t';\n        std::cout << b_inverted.to_ulong() << '\\n'; \n    }\n}",
            "output": "0        00000        11111        31\n1        00001        11110        30\n2        00010        11101        29\n3        00011        11100        28\n4        00100        11011        27\n5        00101        11010        26\n6        00110        11001        25\n7        00111        11000        24\n8        01000        10111        23\n9        01001        10110        22"
        }
    },
    "bitset::to_ullong": {
        "description": {
            "texte": "Converts the contents of the bitset to an unsigned long long integer.The first bit of the bitset corresponds to the least significant digit of the number and the last bit corresponds to the most significant digit."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <bitset>\n#include <limits>\n \nint main()\n{\n    std::bitset<std::numeric_limits<unsigned long long>::digits> b(\n        0x123456789abcdef0LL\n    );\n \n    std::cout << b << \"  \" << std::hex << b.to_ullong() << '\\n';\n    b.flip();\n    std::cout << b << \"  \" << b.to_ullong() << '\\n';\n}",
            "output": "0001001000110100010101100111100010011010101111001101111011110000  123456789abcdef0\n1110110111001011101010011000011101100101010000110010000100001111  edcba9876543210f"
        }
    },
    "bind_front": {
        "description": {
            "texte": "The function template bind_front generates a forwarding call wrapper for f. Calling this wrapper is equivalent to invoking f with its first sizeof...(Args) parameters bound to args.In other words, std::bind_front(f, bound_args...)(call_args...) is equivalent to std::invoke(f, bound_args..., call_args....).The program is ill-formed if any of the following is not true:"
        },
        "parametres": "   f   -   Callable object (function object, pointer to function, reference to function, pointer to member function, or pointer to data member) that will be bound to some arguments \n   args   -   list of the arguments to bind to the first sizeof...(Args) parameters of f \n   Type requirements \n   -std::decay_t<F> and each type in std::decay_t<Args>... must meet the requirements of MoveConstructible. \n\n"
    },
    "identity": {
        "description": {
            "texte": "std::identity is a function object type whose operator() returns its argument unchanged."
        },
        "parametres": "   t   -   argument to return \n\n"
    },
    "ranges::not_equal_to": {
        "description": {
            "texte": "Function object for performing comparisons. Deduces the parameter types of the function call operator from the arguments (but not the return type)."
        }
    },
    "ranges::greater": {
        "description": {
            "texte": "Function object for performing comparisons. Deduces the parameter types of the function call operator from the arguments (but not the return type)."
        }
    },
    "ranges::greater_equal": {
        "description": {
            "texte": "Function object for performing comparisons. Deduces the parameter types of the function call operator from the arguments (but not the return type)."
        }
    },
    "ranges::less_equal": {
        "description": {
            "texte": "Function object for performing comparisons. Deduces the parameter types of the function call operator from the arguments (but not the return type)."
        }
    },
    "chrono::time_of_day": {
        "description": {
            "texte": "The class template time_of_day splits a std::chrono::duration representing time since midnight into a \"broken down\" time such as hours:minutes:seconds, with the precision of the split determined by the Duration template parameter. It also tracks whether it should be output in a 12-hour time format or a 24-hour time format. It is primarily a formatting tool.The primary template (1) is not defined; four specializations are provided to handle four different levels of precision.Each specialization of time_of_day is a TriviallyCopyable StandardLayoutType.The partial specialization (5) only exists if std::chrono::treat_as_floating_point_v<Rep> is false and std::chrono::duration<Rep, Period> is not convertible to std::chrono::seconds."
        }
    },
    "chrono::clock_time_conversion": {
        "description": {
            "texte": "std::chrono::clock_time_conversion is a trait that specifies how to convert a std::chrono::time_point of the Source clock to that of the Dest clock. It does so by providing an const-callable operator() that accepts an argument of type std::chrono::time_point<Source, Duration> and returns a std::chrono::time_point<Dest, OtherDuration> that represents an equivalent point in time. The duration of the returned time point is computed from the source duration in a manner that varies for each specialization. clock_time_conversion is normally only used indirectly, via std::chrono::clock_cast.A program may specialize clock_time_conversion if at least one of the template parameters is a user-defined clock type.The primary template is an empty struct. The standard defines the following specializations:"
        },
        "parametres": "   t   -   time point to convert \n\n"
    },
    "chrono::clock_cast": {
        "description": {
            "texte": "Converts the time point t of a clock Source to an equivalent time point of the clock Dest, using std::chrono::system_clock and/or std::chrono::utc_clock as intermediaries if necessary."
        }
    },
    "chrono::is_clock": {
        "description": {
            "texte": "If T satisfies the Clock requirements, provides the member constant value equal true. For any other type, value is false.For the purpose of this trait, the extent to which an implementation determines that a type cannot meet the Clock requirements is unspecified, except that a minimum T shall not qualify as a Clock unless it meets all of the following conditions:The behavior of a program that adds specializations for is_clock is undefined."
        }
    },
    "chrono::utc_clock": {
        "description": {
            "texte": "The clock std::chrono::utc_clock is a Clock that represents Coordinated Universal Time (UTC). It measures time since 00:00:00 UTC, Thursday, 1 January 1970, including leap seconds.utc_clock meets the Clock requirements. It does not meet the TrivialClock requirements unless the implementation can guarantee that now() does not throw an exception."
        }
    },
    "chrono::tai_clock": {
        "description": {
            "texte": "The clock std::chrono::tai_clock is a Clock that represents International Atomic Time (TAI). It measures time since 00:00:00, 1 January 1958, and is offset 10 seconds ahead of UTC at that date (i.e., its epoch, 1958-01-01 00:00:00 TAI, is 1957-12-31 23:59:50 UTC).Leap seconds are not inserted into TAI. Thus, every time a leap second is inserted into UTC, UTC falls another second behind TAI. As of December 2017, UTC is 37 seconds behind TAI, reflecting the 10-second initial offset and the 27 leap seconds inserted between 1958 and 2017. Thus, 2018-01-01 00:00:00 UTC is equivalent to 2018-01-01 00:00:37 TAI.tai_clock meets the Clock requirements. It does not meet the TrivialClock requirements unless the implementation can guarantee that now() does not throw an exception."
        }
    },
    "chrono::gps_clock": {
        "description": {
            "texte": "The clock std::chrono::gps_clock is a Clock that represents Global Positioning System (GPS) time. It measures time since 00:00:00, 6 January 1980 UTC.Leap seconds are not inserted into GPS. Thus, every time a leap second is inserted into UTC, UTC falls another second behind GPS. As of December 2017, UTC is 18 seconds behind GPS, reflecting the 18 leap seconds inserted between 1980 and 2017. Thus, 2018-01-01 00:00:00 UTC is equivalent to 2018-01-01 00:00:18 GPS. GPS is a constant 19 seconds behind TAI.gps_clock meets the Clock requirements. It does not meet the TrivialClock requirements unless the implementation can guarantee that now() does not throw an exception."
        }
    },
    "chrono::file_clock": {
        "description": {
            "texte": "std::chrono::file_clock is an alias for the clock used for std::filesystem::file_time_type. Its epoch is unspecified.file_clock meets the TrivialClock requirements."
        }
    },
    "chrono::local_t": {
        "description": {
            "texte": "The class local_t is a pseudo-clock that is used as the first template argument to std::chrono::time_point to indicate that the time point represents local time with respect of a not-yet-specified time zone. local_time supports streaming and the full set of time point arithmetic."
        }
    },
    "chrono::day": {
        "description": {
            "texte": "The class day represents a day in a month. Its normal range is [1, 31], but it may hold any number in [0, 255].day is a TriviallyCopyable StandardLayoutType."
        }
    },
    "chrono::month": {
        "description": {
            "texte": "The class month represents a month in a year. Its normal range is [1, 12], but it may hold any number in [0, 255]. Twelve named constants are predefined in the std::chrono namespace for the twelve months of the year.month is a TriviallyCopyable StandardLayoutType."
        }
    },
    "chrono::year": {
        "description": {
            "texte": "The class year represents a year in the proleptic Gregorian calendar. Its range is [-32767, 32767].year is a TriviallyCopyable StandardLayoutType."
        }
    },
    "chrono::weekday": {
        "description": {
            "texte": "The class weekday represent a day of the week in the Gregorian calendar. Its normal range is [0, 6], for Sunday through Saturday, but it can hold any value in the range [0, 255]. Seven named constants are predefined in the std::chrono namespace for the seven days of the week.weekday is a TriviallyCopyable StandardLayoutType."
        }
    },
    "chrono::operator/ (calendar)": {
        "description": {
            "texte": "These operator/ overloads provide a conventional syntax for the creation of Gregorian calendar dates.For creation of a full date, any of the following three orders are accepted:In each case day can replaced with one of:A plain integer is accepted if its meaning is unambiguous from the types of other operands: 2005y/4/5 is allowed, but 5/April/2005 is not.Partial-date types (year_month, month_day, etc.) can be created by not applying the second operator/ in any of the three orders."
        }
    },
    "chrono::year_month_day": {
        "description": {
            "texte": "The class year_month_day represents a specific year, month, and day. It is a field-based time point, with a resolution of std::chrono::days. std::chrono::years- and std::chrono::months-oriented arithmetic are supported directly. An implicit conversion to and from std::chrono::sys_days allows std::chrono::days-oriented arithmetic to be performed efficiently.year_month_day is a TriviallyCopyable StandardLayoutType."
        }
    },
    "chrono::year_month_day_last": {
        "description": {
            "texte": "The class year_month_day_last represents the last day of a specific year and month. It is a field-based time point, with a resolution of std::chrono::days, subject to the limit that it can only represent the last day of a month.std::chrono::years- and std::chrono::months-oriented arithmetic are supported directly. An implicit conversion to std::chrono::sys_days allows std::chrono::days-oriented arithmetic to be performed efficiently.year_month_day_last is a TriviallyCopyable StandardLayoutType."
        }
    },
    "chrono::year_month_weekday": {
        "description": {
            "texte": "The class year_month_weekday represents the n-th weekday of a specific year and month. It is a field-based time point, with a resolution of std::chrono::days. std::chrono::years- and std::chrono::months-oriented arithmetic are supported directly. An implicit conversion to and from std::chrono::sys_days allows std::chrono::days-oriented arithmetic to be performed efficiently.year_month_weekday is a TriviallyCopyable StandardLayoutType."
        }
    },
    "chrono::year_month_weekday_last": {
        "description": {
            "texte": "The class year_month_weekday_last represents the last weekday of a specific year and month. It is a field-based time point, with a resolution of std::chrono::days, except that it is limited to pointing to the last weekday of a year and month. std::chrono::years- and std::chrono::months-oriented arithmetic are supported directly. An implicit conversion to std::chrono::sys_days allows std::chrono::days-oriented arithmetic to be performed efficiently.year_month_weekday_last is a TriviallyCopyable StandardLayoutType."
        }
    },
    "chrono::weekday_last": {
        "description": {
            "texte": "The class weekday_last represents the last weekday of some month.weekday_last is a TriviallyCopyable StandardLayoutType."
        }
    },
    "chrono::month_day": {
        "description": {
            "texte": "The class month_day represents a specific day of a specific month, of some yet to be specified year.month_day is a TriviallyCopyable StandardLayoutType."
        }
    },
    "chrono::month_day_last": {
        "description": {
            "texte": "The class month_day_last represents the last day of a specific month, of some yet to be specified year.month_day_last is a TriviallyCopyable StandardLayoutType."
        }
    },
    "chrono::month_weekday": {
        "description": {
            "texte": "The class month_weekday represents the n-th weekday of a specific month, of some yet to be specified year.month_weekday is a TriviallyCopyable StandardLayoutType."
        }
    },
    "chrono::month_weekday_last": {
        "description": {
            "texte": "The class month_weekday_last represents the last weekday of a specific month, of some yet to be specified year.month_weekday_last is a TriviallyCopyable StandardLayoutType."
        }
    },
    "chrono::year_month": {
        "description": {
            "texte": "The class year_month represents a specific month of a specific year, but with an unspecified day. It is a field-based time point, with a resolution of std::chrono::months.year_month is a TriviallyCopyable StandardLayoutType."
        }
    },
    "chrono::tzdb": {
        "description": {
            "texte": "The class tzdb represents a copy of the IANA time zone database. Users cannot construct a tzdb and can only obtain read-only access to one via the free functions std::chrono::get_tzdb_list and std::chrono::get_tzdb."
        }
    },
    "chrono::tzdb_list": {
        "description": {
            "texte": "tzdb_list is a singleton list of std::chrono::tzdbs, each of which represents a copy of the IANA time zone database. Users cannot construct a tzdb_list and can only obtain access to one via the std::chrono::get_tzdb_list free function."
        }
    },
    "chrono::get_tzdb_list, std::chrono::get_tzdb, std::chrono::remote_version, std::chrono::reload_tzdb": {
        "description": {
            "texte": "These functions provide access to the program-wide time zone database."
        }
    },
    "chrono::time_zone": {
        "description": {
            "texte": "The class time_zone represents all time zone transitions for a specific geographic area.Users cannot construct time_zone objects. The library implementation creates time_zone objects when it initializes the time zone database and provides const access to these objects.time_zone is not copyable but does have a defaulted move constructor and a defaulted move assignment operator. However, as users have only const access to time_zone objects, these functions cannot be called in user code without invoking undefined behavior."
        }
    },
    "chrono::locate_zone": {
        "description": {
            "texte": "Convenience function for locating a time zone in the time zone database. Equivalent to std::chrono::get_tzdb().locate_zone(tz_name)."
        }
    },
    "chrono::current_zone": {
        "description": {
            "texte": "Convenience function for obtaining local time zone from the time zone database. Equivalent to std::chrono::get_tzdb().current_zone()."
        }
    },
    "chrono::zoned_time": {
        "description": {
            "texte": "The class zoned_time represents a logical pairing of a time zone and a std::chrono::time_point whose resolution is Duration.An invariant of zoned_time is that it always refers to a valid time zone and represents an existing and unambiguous time point in that time zone. Consistent with this invariant, zoned_time has no move constructor or move assignment operator; attempts to move a zoned_time will perform a copy.The program is ill-formed if Duration is not a specialization of std::chrono::duration.The template parameter TimeZonePtr allows users to supply their own time zone pointer types and further customize the behavior of zoned_time via std::chrono::zoned_traits. Custom time zone types need not support all the operations supported by std::chrono::time_zone, only those used by the functions actually called on the zoned_time.TimeZonePtr must be MoveConstructible. Move-only TimeZonePtrs are allowed but difficult to use, as the zoned_time will be immovable and it is not possible to access the stored TimeZonePtr."
        }
    },
    "chrono::link": {
        "description": {
            "texte": "The class link represents an alternative name for a time zone.Users cannot construct link objects. The library implementation creates link objects when it initializes the time zone database and provides const access to these objects.link is not copyable but does have a defaulted move constructor and a defaulted move assignment operator. However, as users have only const access to link objects, these functions cannot be called in user code without invoking undefined behavior."
        }
    },
    "chrono::leap": {
        "description": {
            "texte": "The class leap represents the date and time of a leap second insertion.Users cannot construct leap objects except by copying from existing leap objects. The library implementation creates leap objects when it initializes the time zone database and provides const access to these objects.leap has a defaulted copy constructor and a defaulted copy assignment operator."
        }
    },
    "chrono::sys_info": {
        "description": {
            "texte": "The class sys_info describes time zone information associated with a time zone at a particular point in time (represented as either a std::chrono::sys_time or a std::chrono::local_time). This is a low-level data structure typically not used directly by user code."
        }
    },
    "chrono::local_info": {
        "description": {
            "texte": "The class local_info describes the result of converting a std::chrono::local_time to a std::chrono::sys_time.This is a low-level data structure; typical conversions from local_time to sys_time will use it implicitly rather than explicitly."
        }
    },
    "chrono::zoned_traits": {
        "description": {
            "texte": "The class zoned_traits provides a way to customize the behavior of the constructors of std::chrono::zoned_time with custom time zone pointer types. In particular, it allows such types to specify the default time zone to use and the mapping of a time zone's name to the corresponding time zone pointer. It is acceptable for custom time zone pointer types to not support either operation, in which case the corresponding constructors of zoned_time will not participate in overload resolution.The primary template is empty. A specialization is provided for const std::chrono::time_zone*, the default time zone pointer type."
        }
    },
    "chrono::nonexistent_local_time": {
        "description": {
            "texte": "Defines a type of object to be thrown as exception to report that an attempt was made to convert a nonexistent std::chrono::local_time to a std::chrono::sys_time without specifying a std::chrono::choose (such as choose::earliest or choose::latest).This exception is thrown by std::chrono::time_zone::to_sys and functions that call it (such as the constructors of std::chrono::zoned_time that takes a std::chrono::local_time)."
        },
        "parametres": "   tp   -   the time point for which conversion was attempted \n   i   -   a std::chrono::local_info describing the result of the conversion attempt \n\n"
    },
    "chrono::ambiguous_local_time": {
        "description": {
            "texte": "Defines a type of object to be thrown as exception to report that an attempt was made to convert a ambiguous std::chrono::local_time to a std::chrono::sys_time without specifying a std::chrono::choose (such as choose::earliest or choose::latest).This exception is thrown by std::chrono::time_zone::to_sys and functions that call it (such as the constructors of std::chrono::zoned_time that takes a std::chrono::local_time)."
        },
        "parametres": "   tp   -   the time point for which conversion was attempted \n   i   -   a std::chrono::local_info describing the result of the conversion attempt \n\n"
    },
    "chrono::format": {
        "description": {
            "texte": "Formats the streamable object s using the format string fmt and the locale loc (if provided).These function templates behave as if they."
        }
    },
    "chrono::parse": {
        "description": {
            "texte": "Returns an object manip of unspecified type such that, given a std::basic_istream<CharT, Traits> object is, the expression is >> manip calls from_stream (unqualified, to enable argument-dependent lookup) as follows:The expression is >> manip is an lvalue of type std::basic_istream<CharT, Traits> with the value is.These overloads only participate in overload resolution if the corresponding from_stream expression is well-formed."
        }
    },
    "initializer_list::initializer_list": {
        "description": {
            "texte": "Constructs an empty initializer list."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <initializer_list>\n \nint main() \n{\n    std::initializer_list<int> empty_list;\n    std::cout << \"empty_list.size(): \" << empty_list.size() << '\\n';\n \n    // create initializer lists using list-initialization\n    std::initializer_list<int> digits {1, 2, 3, 4, 5};\n    std::cout << \"digits.size(): \" << digits.size() << '\\n';\n \n    // special rule for auto means 'fractions' has the\n    // type std::initializer_list<double>\n    auto fractions = {3.14159, 2.71828};\n    std::cout << \"fractions.size(): \" << fractions.size() << '\\n';\n}",
            "output": "empty_list.size(): 0\ndigits.size(): 5\nfractions.size(): 2"
        }
    },
    "initializer_list::size": {
        "description": {
            "texte": "Returns the number of elements in the initializer list, i.e. std::distance(begin(), end())."
        }
    },
    "initializer_list::begin": {
        "description": {
            "texte": "Returns a pointer to the first element in the initializer list.If the initializer list is empty, the values of begin() and end() are unspecified, but will be identical."
        }
    },
    "initializer_list::end": {
        "description": {
            "texte": "Returns a pointer to one past the last element in the initializer list, i.e. begin() + size().If the initializer list is empty, the values of begin() and end() are unspecified, but will be identical."
        }
    },
    "rbegin(std::initializer_list)\n": {
        "description": {
            "texte": "The overload of std::rbegin for initializer_list returns an std::reverse_iterator pointing at the last element of il."
        },
        "parametres": "   il   -   an initializer_list \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n \nint main() \n{\n    auto il = { 3, 1, 4 };\n    for (auto it = std::rbegin(il); it != std::rend(il); ++it)\n        std::cout << *it << '\\n'; \n}",
            "output": "4\n1\n3"
        }
    },
    "rend(std::initializer_list)\n": {
        "description": {
            "texte": "The overload of std::rend for initializer_list returns an std::reverse_iterator pointing at the first element of il."
        },
        "parametres": "   il   -   an initializer_list \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n \nint main() \n{\n    auto il = { 3, 1, 4 };\n    for (auto it = std::rbegin(il); it != std::rend(il); ++it)\n        std::cout << *it << '\\n'; \n}",
            "output": "4\n1\n3"
        }
    },
    "tuple::tuple": {
        "description": {
            "texte": "Constructs a new tuple."
        },
        "parametres": "   args   -   values used to initialize each element of the tuple \n   other   -   a tuple of values used to initialize each element of the tuple \n   p   -   pair of values used to initialize both elements of this 2-tuple \n   a   -   allocator to use in uses-allocator construction \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <memory>\n \n// helper function to print a tuple of any size\ntemplate<class Tuple, std::size_t N>\nstruct TuplePrinter {\n    static void print(const Tuple& t) \n    {\n        TuplePrinter<Tuple, N-1>::print(t);\n        std::cout << \", \" << std::get<N-1>(t);\n    }\n};\n \ntemplate<class Tuple>\nstruct TuplePrinter<Tuple, 1>{\n    static void print(const Tuple& t) \n    {\n        std::cout << std::get<0>(t);\n    }\n};\n \ntemplate<class... Args>\nvoid print(const std::tuple<Args...>& t) \n{\n    std::cout << \"(\";\n    TuplePrinter<decltype(t), sizeof...(Args)>::print(t);\n    std::cout << \")\\n\";\n}\n// end helper function\n \nint main()\n{\n    std::tuple<int, std::string, double> t1;\n    std::cout << \"Value-initialized: \"; print(t1);\n    std::tuple<int, std::string, double> t2(42, \"Test\", -3.14);\n    std::cout << \"Initialized with values: \"; print(t2);\n    std::tuple<char, std::string, int> t3(t2);\n    std::cout << \"Implicitly converted: \"; print(t3);\n    std::tuple<int, double> t4(std::make_pair(42, 3.14));\n    std::cout << \"Constructed from a pair\"; print(t4);\n \n    // given Allocator my_alloc with a single-argument constructor my_alloc(int)\n    // use my_alloc(1) to allocate 10 ints in a vector\n    std::vector<int, my_alloc> v(10, 1, my_alloc(1));\n    // use my_alloc(2) to allocate 10 ints in a vector in a tuple\n    std::tuple<int, std::vector<int, my_alloc>, double> t5(std::allocator_arg,\n                                                           my_alloc(2), 42, v,  -3.14);\n}",
            "output": "Value-initialized: (0, , 0)\nInitialized with values: (42, Test, -3.14)\nImplicitly converted: (*, Test, -3)\nConstructed from a pair(42, 3.14)"
        }
    },
    "tuple::operator=": {
        "description": {
            "texte": "Replaces the contents of the tuple with the contents of another tuple or a pair.1) Copy assignment operator. Assigns each element of other to the corresponding element of *this.2) Move assignment operator. For all i, assigns std::forward<Ti>(get<i>(other)) to get<i>(*this).3) For all i, assigns std::get<i>(other) to std::get<i>(*this).4) For all i, assigns std::forward<Ui>(std::get<i>(other)) to std::get<i>(*this).5) Assigns p.first to the first element of *this and p.second to the second element of *this.6) Assigns std::forward<U1>(p.first) to the first element of *this and std::forward<U2>(p.second) to the second element of *this."
        },
        "parametres": "   other   -   tuple to replace the contents of this tuple \n   p   -   pair to replace the contents of this 2-tuple \n\n"
    },
    "tuple::swap": {
        "description": {
            "texte": "Calls swap (which might be std::swap, or might be found via ADL) for each element in *this and its corresponding element in other."
        },
        "parametres": "   other   -   tuple of values to swap \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <tuple>\n#include <string>\n \nint main()\n{\n    std::tuple<int, std::string, float> p1, p2;\n    p1 = std::make_tuple(10, \"test\", 3.14);\n    p2.swap(p1);\n    std::cout << \"(\"  << std::get<0>(p2)\n              << \", \" << std::get<1>(p2)\n              << \", \" << std::get<2>(p2) << \")\\n\";\n}",
            "output": "(10, test, 3.14)"
        }
    },
    "deduction guides for std::tuple\n": {
        "description": {
            "texte": "These deduction guides are provided for std::tuple to account for the edge cases missed by the implicit deduction guides, in particular, non-copyable arguments and array to pointer conversion."
        },
        "exemple": {
            "input": "#include <tuple>\nint main()\n{\n    int a[2], b[3], c[4];\n    std::tuple t1{a, b, c}; // explicit deduction guide is used in this case\n}"
        }
    },
    "any::any": {
        "description": {
            "texte": "Constructs a new any object."
        },
        "parametres": "   other   -   another any object to copy or move from \n   value   -   value to initialize the contained value with \n   il, args   -   arguments to be passed to the constructor of the contained object \n\n"
    },
    "any::~any": {
        "description": {
            "texte": "Destroys the contained object, if any, as if by a call to reset()."
        }
    },
    "any::operator=": {
        "description": {
            "texte": "Assigns contents to the contained value."
        },
        "parametres": "   rhs   -   object whose contained value to assign \n\n"
    },
    "any::emplace": {
        "description": {
            "texte": "Changes the contained object to one of type std::decay_t<ValueType> constructed from the arguments.First destroys the current contained object (if any) by reset(), then:"
        }
    },
    "any::reset": {
        "description": {
            "texte": "If not empty, destroys the contained object."
        }
    },
    "any::swap": {
        "description": {
            "texte": "Swaps the content of two any objects."
        },
        "parametres": "   other   -   object to swap with \n\n"
    },
    "any::has_value": {
        "description": {
            "texte": "Checks whether the object contains a value."
        }
    },
    "any::type": {
        "description": {
            "texte": "Queries the contained type."
        }
    },
    "make_any": {
        "description": {
            "texte": "Constructs an any object containing an object of type T, passing the provided arguments to T's constructor."
        }
    },
    "optional::optional": {
        "description": {
            "texte": "Constructs a new optional object."
        },
        "parametres": "   other   -   another optional object whose contained value is copied \n   value   -   value with which to initialize the contained value \n   args...   -   arguments with which to initialize the contained value \n   ilist   -   initializer list with which to initialize the contained value \n\n",
        "exemple": {
            "input": "#include <optional>\n#include <iostream>\n#include <string>\nint main()\n{\n    std::optional<int> o1, // empty\n                       o2 = 1, // init from rvalue\n                       o3 = o2; // copy-constructor\n \n    // calls std::string( initializer_list<CharT> ) constructor\n    std::optional<std::string> o4(std::in_place, {'a', 'b', 'c'});\n \n    // calls std::string( size_type count, CharT ch ) constructor\n    std::optional<std::string> o5(std::in_place, 3, 'A');\n \n    // Move-constructed from std::string using deduction guide to pick the type\n \n    std::optional o6(std::string{\"deduction\"});\n \n    std::cout << *o2 << ' ' << *o3 << ' ' << *o4 << ' ' << *o5  << ' ' << *o6 << '\\n';\n}",
            "output": "1 1 abc AAA deduction"
        }
    },
    "optional::~optional": {
        "description": {
            "texte": "If the object contains a value and the type T is not trivially destructible (see std::is_trivially_destructible), destroys the contained value by calling its destructor, as if by value().T::~T().Otherwise, does nothing."
        }
    },
    "optional::operator=": {
        "description": {
            "texte": "Replaces contents of *this with the contents of other."
        },
        "parametres": "   other   -   another optional object whose contained value to assign \n   value   -   value to assign to the contained value \n\n",
        "exemple": {
            "input": "#include <optional>\n#include <iostream>\nint main()\n{\n    std::optional<const char*> s1 = \"abc\", s2; // constructor\n    s2 = s1; // assignment\n    s1 = \"def\"; // decaying assignment (U = char[4], T = const char*)\n    std::cout << *s2 << ' ' << *s1 << '\\n';\n}",
            "output": "abc def"
        }
    },
    "optional::operator->, std::optional::operator*": {
        "description": {
            "texte": "Accesses the contained value.The behavior is undefined if *this does not contain a value."
        },
        "exemple": {
            "input": "#include <optional>\n#include <iostream>\n#include <string>\n \nint main()\n{\n    using namespace std::string_literals;\n \n    std::optional<int> opt1 = 1;\n    std::cout<< \"opt1: \"  << *opt1 << '\\n';\n \n    *opt1 = 2;\n    std::cout<< \"opt1: \"  << *opt1 << '\\n';\n \n    std::optional<std::string> opt2 = \"abc\"s;\n    std::cout<< \"opt2: \" << *opt2 << \" size: \" << opt2->size() << '\\n';\n \n    // You can \"take\" the contained value by calling operator* on a rvalue to optional\n \n    auto taken = *std::move(opt2);\n    std::cout << \"taken: \" << taken << \" opt2: \" << *opt2 << \"size: \" << opt2->size()  << '\\n';\n}",
            "output": "opt1: 1\nopt1: 2\nopt2: abc size: 3\ntaken: abc opt2: size: 0"
        }
    },
    "optional::operator bool, std::optional::has_value": {
        "description": {
            "texte": "Checks whether *this contains a value."
        }
    },
    "optional::value": {
        "description": {
            "texte": "If *this contains a value, returns a reference to the contained value.Otherwise, throws a std::bad_optional_access exception."
        },
        "exemple": {
            "input": "#include <optional>\n#include <iostream>\nint main()\n{\n    std::optional<int> opt = {};\n \n    try {\n        int n = opt.value();\n    } catch(const std::bad_optional_access& e) {\n        std::cout << e.what() << '\\n';\n    }\n}",
            "output": "bad optional access"
        }
    },
    "optional::value_or": {
        "description": {
            "texte": "Returns the contained value if *this has a value, otherwise returns default_value."
        },
        "parametres": "   default_value   -   the value to use in case *this is empty \n   Type requirements \n   -T must meet the requirements of CopyConstructible in order to use overload (1). \n   -T must meet the requirements of MoveConstructible in order to use overload (2). \n   -U&& must be convertible to T \n\n",
        "exemple": {
            "input": "#include <optional>\n#include <iostream>\n#include <cstdlib>\n \nstd::optional<const char*> maybe_getenv(const char* n)\n{\n    if(const char* x = std::getenv(n))\n       return x;\n    else\n       return {};\n}\nint main()\n{\n     std::cout << maybe_getenv(\"MYPWD\").value_or(\"(none)\") << '\\n';\n}",
            "output": "(none)"
        }
    },
    "optional::emplace": {
        "description": {
            "texte": "Constructs the contained value in-place. If *this already contains a value before the call, the contained value is destroyed by calling its destructor."
        },
        "parametres": "   args...   -   the arguments to pass to the constructor \n   ilist   -   the initializer list to pass to the constructor \n   Type requirements \n   -T must be constructible from Args... for overload (1) \n   -T must be constructible from std::initializer_list and Args... for overload (2) \n\n"
    },
    "optional::swap": {
        "description": {
            "texte": "Swaps the contents with those of other."
        },
        "parametres": "   other   -   the optional object to exchange the contents with \n\n"
    },
    "optional::reset": {
        "description": {
            "texte": "If *this contains a value, destroy that value as if by value().T::~T(). Otherwise, there are no effects.*this does not contain a value after this call."
        }
    },
    "deduction guides for std::optional\n": {
        "description": {
            "texte": "One deduction guide is provided for std::optional to account for the edge cases missed by the implicit deduction guides, in particular, non-copyable arguments and array to pointer conversion."
        },
        "exemple": {
            "input": "#include <optional>\n \nint main()\n{\n    int a[2];\n    std::optional oa{a}; // explicit deduction guide is used in this case\n}"
        }
    },
    "variant::variant": {
        "description": {
            "texte": " Constructs a new variant object."
        },
        "parametres": "   other   -   another variant object whose contained value to copy/move \n   t   -   value to initialize the contained value with \n   args...   -   arguments to initialize the contained value with \n   il   -   initializer list to initialize the contained value with \n\n"
    },
    "variant::valueless_by_exception": {
        "description": {
            "texte": "Returns false if and only if the variant holds a value."
        }
    },
    "variant::emplace": {
        "description": {
            "texte": "Creates a new value in-place, in an existing variant object."
        },
        "parametres": "   args   -   constructor arguments to use when constructing the new value \n   il   -   initializer_list argument to use when constructing the new value \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <variant>\n \nint main()\n{\n  std::variant<std::string> v1;\n  v1.emplace<0>(\"abc\"); // OK\n  std::cout << std::get<0>(v1) << '\\n';\n  v1.emplace<std::string>(\"def\"); // OK\n  std::cout << std::get<0>(v1) << '\\n';\n \n  std::variant<std::string, std::string> v2;\n  v2.emplace<1>(\"ghi\"); // OK\n  std::cout << std::get<1>(v2) << '\\n';\n  // v2.emplace<std::string>(\"abc\"); -> Error\n}",
            "output": "abc\ndef\nghi"
        }
    },
    "variant::swap": {
        "description": {
            "texte": "Swaps two variant objects.The behavior is undefined unless lvalues of type T_i are Swappable and std::is_move_constructible_v<T_i> is true for all T_i in Types...."
        },
        "parametres": "   rhs   -   a variant object to swap with \n\n",
        "exemple": {
            "input": "#include <variant>\n#include <string>\n#include <iostream>\n \nint main()\n{\n    std::variant<int, std::string> v1{2}, v2{\"abc\"}; \n    std::visit([] (auto&& x) { std::cout << x << ' '; }, v1);\n    std::visit([] (auto&& x) { std::cout << x << '\\n'; }, v2);\n    v1.swap(v2);\n    std::visit([] (auto&& x) { std::cout << x << ' '; }, v1);\n    std::visit([] (auto&& x) { std::cout << x << '\\n'; }, v2);\n}",
            "output": "2 abc\nabc 2"
        }
    },
    "type_info::operator==, std::type_info::operator!=": {
        "description": {
            "texte": "Checks if the objects refer to the same types."
        },
        "parametres": "   rhs   -   another type information object to compare to \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <typeinfo>\n#include <string>\n#include <utility>\n \nclass person\n{\n  public:\n \n   person(std::string&& n) : _name(n) {}\n   virtual const std::string& name() const{ return _name; }\n \n  private:\n \n    std::string _name;\n};\n \nclass employee : public person\n{\n   public:\n \n     employee(std::string&& n, std::string&& p) :\n         person(std::move(n)), _profession(std::move(p)) {}\n \n     const std::string& profession() const { return _profession; }\n \n   private:\n \n     std::string _profession;\n};\n \nvoid somefunc(const person& p)\n{\n   if(typeid(employee) == typeid(p))\n   {\n      std::cout << p.name() << \" is an employee \";\n      auto& emp = dynamic_cast<const employee&>(p);\n      std::cout << \"who works in \" << emp.profession() << '\\n';\n   }\n}\n \nint main()\n{\n   employee paul(\"Paul\",\"Economics\");\n   somefunc(paul);\n}",
            "output": "Paul is an employee who works in Economics"
        }
    },
    "operator==,!=(std::allocator)": {
        "description": {
            "texte": "Compares two default allocators. Since default allocators are stateless, two default allocators are always equal."
        },
        "parametres": "   lhs, rhs   -   default allocators to compare \n\n"
    },
    "operator==,!=(std::function)\n": {
        "description": {
            "texte": "Compares a std::function with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal."
        },
        "parametres": "   f   -   std::function to compare \n\n",
        "exemple": {
            "input": "#include <functional>\n#include <iostream>\n \nusing SomeVoidFunc = std::function<void(int)>;\n \nclass C {\npublic:\n    C(SomeVoidFunc void_func = nullptr) : \n        void_func_(void_func)\n    {\n        if (void_func_ == nullptr) { // specialized compare with nullptr\n            void_func_ = std::bind(&C::default_func, this, std::placeholders::_1);\n        }\n        void_func_(7);\n    }\n \n    void default_func(int i) { std::cout << i << '\\n'; };\n \nprivate:\n    SomeVoidFunc void_func_;\n};\n \nvoid user_func(int i)\n{\n    std::cout << (i + 1) << '\\n';\n}\n \nint main()\n{\n    C c1;\n    C c2(user_func);\n}",
            "output": "7\n8"
        }
    },
    "locale::operator==, operator!=": {
        "description": {
            "texte": "Tests two locales for equality. Named locales are considered equal if their names are equal. Unnamed locales are considered equal if they are copies of each other."
        },
        "parametres": "   other   -   a std::locale object to compare \n\n"
    },
    "operator==,!=(std::linear_congruential_engine)\n": {
        "description": {
            "texte": "Compares two pseudo-random number engines. Two engines are equal, if their internal states are equivalent, that is, if they would generate equivalent values for any number of calls of operator()."
        },
        "parametres": "   lhs, rhs   -   engines to compare \n\n"
    },
    "operator==,!=(std::poisson_distribution)\n": {
        "description": {
            "texte": "Compares two distribution objects. Two distribution objects are equal when parameter values and internal state is the same.1) Compares two distribution objects for equality.2) Compares two distribution objects for inequality."
        },
        "parametres": "   lhs, rhs   -   distribution objects to compare \n\n"
    },
    "regex_iterator::operator==,operator!=": {
        "description": {
            "texte": "Compares two regex_iterators.For the sake of exposition, assume that regex_iterator contains the following members:"
        },
        "parametres": "   rhs   -   a regex_iterator to compare to \n\n"
    },
    "scoped_allocator_adaptor::scoped_allocator_adaptor": {
        "description": {
            "texte": "1) Default constructor: value-initializes the OuterAlloc base class and the inner allocator member object, if used by the implementation.2) Constructs the base class OuterAlloc from std::forward<OuterA2>(outerAlloc), and the inner allocators with innerAllocs.... This overload only participates in overload resolution if std::is_constructible<OuterAlloc, OuterA2>::value is true.3) Copy-constructor: initializes each allocator from the corresponding allocator of other.4) Move-constructor: moves each allocator from the corresponding allocator of other into *this.5) Initializes each allocator from the corresponding allocator of other. This overload only participates in overload resolution if std::is_constructible<OuterAlloc, const OuterA2&>::value is true.6) Initializes each allocator from the corresponding allocator of other, using move semantics. This overload only participates in overload resolution if std::is_constructible<OuterAlloc, OuterA2>::value is true."
        },
        "parametres": "   outerAlloc   -   constructor argument for the outer allocator \n   innerAllocs...   -   constructor arguments for the inner allocators \n   other   -   another std::scoped_allocator_adaptor \n\n"
    },
    "scoped_allocator_adaptor::operator=": {
        "description": {
            "texte": "1) Explicitly defaulted copy assignment operator that copy assigns the base class (OuterAlloc, the outer allocator) and all inner allocators.2) Explicitly defaulted move assignment operator that move assigns the base class (OuterAlloc, the outer allocator) and all inner allocators."
        },
        "parametres": "   other   -   another std::scoped_allocator_adaptor \n\n"
    },
    "scoped_allocator_adaptor::inner_allocator": {
        "description": {
            "texte": "Obtains a reference to the inner allocator used to declare this scoped_allocator_adaptor.If sizeof...(InnerAllocs) == 0, that is, no inner allocators were declared, returns *this. Otherwise returns a reference to std::scoped_allocator_adaptor<InnerAllocs...>, that is, a scoped allocator composed of all inner allocators of *this, with the first inner allocator becoming the outer allocator."
        }
    },
    "scoped_allocator_adaptor::outer_allocator": {
        "description": {
            "texte": "Obtains a reference to the outer allocator used to declare this class.1) returns static_cast<OuterAlloc&>(*this).2) returns static_cast<const OuterAlloc&>(*this)."
        }
    },
    "scoped_allocator_adaptor::allocate": {
        "description": {
            "texte": "Uses the outer allocator to allocate uninitialized storage."
        },
        "parametres": "   n   -   the number of objects to allocate storage for \n   hint   -   pointer to a nearby memory location \n\n"
    },
    "scoped_allocator_adaptor::deallocate": {
        "description": {
            "texte": "Uses the outer allocator to deallocate the storage referenced by p, by calling std::allocator_traits<OuterAlloc>::deallocate(outer_allocator(), p, n)."
        },
        "parametres": "   p   -   pointer to the previously allocated memory \n   n   -   the number of objects for which the memory was allocated \n\n"
    },
    "scoped_allocator_adaptor::max_size": {
        "description": {
            "texte": "Reports the maximum allocation size supported by the outer allocator, by calling std::allocator_traits<OuterAlloc>::max_size(outer_allocator())."
        }
    },
    "scoped_allocator_adaptor::construct": {
        "description": {
            "texte": "Constructs an object in allocated, but not initialized storage pointed to by p using OuterAllocator and the provided constructor arguments. If the object is of type that itself uses allocators, or if it is std::pair, passes InnerAllocator down to the constructed object.First, retrieve the outermost allocator OUTERMOST by calling this->outer_allocator(), and then calling the outer_allocator() member function recursively on the result of this call until reaching an allocator that has no such member function.Define OUTERMOST_ALLOC_TRAITS(x) as std::allocator_traits<std::remove_reference_t<decltype(OUTERMOST(x))>>"
        },
        "parametres": "   p   -   pointer to allocated, but not initialized storage \n   args...   -   the constructor arguments to pass to the constructor of T \n   x   -   the constructor arguments to pass to the constructor of T1 \n   y   -   the constructor arguments to pass to the constructor of T2 \n   xy   -   the pair whose two members are the constructor arguments for T1 and T2 \n\n"
    },
    "scoped_allocator_adaptor::destroy": {
        "description": {
            "texte": "Uses the outer allocator to call the destructor of the object pointed to by p, by calling.std::allocator_traits<OUTERMOST>::destroy(OUTERMOST(*this), p).where OUTERMOST is the type that would be returned by calling this->outer_allocator(), and then calling the outer_allocator() member function recursively on the result of this call until reaching the type that has no such member function."
        },
        "parametres": "   p   -   pointer to the object that is going to be destroyed \n\n"
    },
    "scoped_allocator_adaptor::select_on_container_copy_construction": {
        "description": {
            "texte": "Creates a new instance of std::scoped_allocator_adaptor, where the outer allocator base class and each inner allocator subobject are obtained by calling std::allocator_traits<A>::select_on_container_copy_construction()."
        }
    },
    "deduction guides for std::scoped_allocator_adaptor\n": {
        "description": {
            "texte": "One deduction guide is provided for std::scoped_allocator_adaptor to make it possible to deduce its outer allocator."
        }
    },
    "pmr::memory_resource::allocate": {
        "description": {
            "texte": "Allocates storage with a size of at least bytes bytes. The returned storage is aligned to the specified alignment if such alignment is supported, and to alignof(std::max_align_t) otherwise.Equivalent to return do_allocate(bytes, alignment);."
        }
    },
    "pmr::memory_resource::deallocate": {
        "description": {
            "texte": "Deallocates the storage pointed to by p. p shall have been returned by a prior call to allocate(bytes, alignment) on a memory_resource that compares equal to *this, and the storage it points to shall not yet have been deallocated.Equivalent to do_deallocate(p, bytes, alignment);."
        }
    },
    "pmr::memory_resource::is_equal": {
        "description": {
            "texte": "Compares *this for equality with other. Two memory_resources compare equal if and only if memory allocated from one memory_resource can be deallocated from the other and vice versa.Equivalent to return do_is_equal(other);."
        }
    },
    "pmr::memory_resource::do_allocate": {
        "description": {
            "texte": "Allocates storage with a size of at least bytes bytes, aligned to the specified alignment.alignment shall be a power of two."
        }
    },
    "pmr::memory_resource::do_deallocate": {
        "description": {
            "texte": "Deallocates the storage pointed to by p.p must have been returned by a prior call to allocate(bytes, alignment) on a memory_resource that compares equal to *this, and the storage it points to must not yet have been deallocated, otherwise the behavior is undefined."
        }
    },
    "pmr::memory_resource::do_is_equal": {
        "description": {
            "texte": "Compares *this for equality with other.Two memory_resources compare equal if and only if memory allocated from one memory_resource can be deallocated from the other and vice versa."
        }
    },
    "pmr::operator==, std::pmr::operator!=": {
        "description": {
            "texte": "Compares two polymorphic allocators. Two polymorphic allocators compare equal if their underlying memory resource compares equal."
        },
        "parametres": "   lhs, rhs   -   polymorphic allocators to compare \n\n"
    },
    "numeric_limits::is_specialized": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::is_specialized is true for all T for which there exists a specialization of std::numeric_limits."
        }
    },
    "numeric_limits::is_signed": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::is_signed is true for all signed arithmetic types T and false for the unsigned types. This constant is meaningful for all specializations."
        }
    },
    "numeric_limits::is_integer": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::is_integer is true for all integer arithmetic types T and false otherwise. This constant is meaningful for all specializations."
        }
    },
    "numeric_limits::is_exact": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::is_exact is true for all arithmetic types T that use exact representation."
        }
    },
    "numeric_limits::has_infinity": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::has_infinity is true for all types T capable of representing the positive infinity as a distinct special value. This constant is meaningful for all floating-point types and is guaranteed to be true if std::numeric_limits<T>::is_iec559 == true."
        }
    },
    "numeric_limits::has_quiet_NaN": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::has_quiet_NaN is true for all types T capable of representing the special value \"Quiet Not-A-Number\". This constant is meaningful for all floating-point types and is guaranteed to be true if std::numeric_limits<T>::is_iec559 == true."
        }
    },
    "numeric_limits::has_signaling_NaN": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::has_signaling_NaN is true for all types T capable of representing the special value \"Signaling Not-A-Number\". This constant is meaningful for all floating-point types and is guaranteed to be true if std::numeric_limits<T>::is_iec559 == true."
        }
    },
    "numeric_limits::has_denorm": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::has_denorm identifies the floating-point types that support subnormal values."
        }
    },
    "numeric_limits::has_denorm_loss": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::has_denorm_loss is true for all floating-point types T that detect loss of precision when creating a subnormal number as denormalization loss rather than as inexact result (see below)."
        }
    },
    "numeric_limits::round_style": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::round_style identifies the rounding style used by the floating-point type T whenever a value that is not one of the exactly repesentable values of T is stored in an object of that type."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <limits>\nint main()\n{\n    std::cout << std::hexfloat << \"The decimal 0.1 is stored in a double as \"\n              << 0.1 << '\\n'\n              << \"The decimal 0.3 is stored in a double as \"\n              << 0.3 << '\\n'\n              << \"The rounding style is \" << std::numeric_limits<double>::round_style << '\\n';\n}",
            "output": "The decimal 0.1 is stored in a double as 0x1.999999999999ap-4\nThe decimal 0.3 is stored in a double as 0x1.3333333333333p-2\nThe rounding style is 1"
        }
    },
    "numeric_limits::is_iec559": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::is_iec559 is true for all floating-point types T which fulfill the requirements of IEC 559 (IEEE 754) standard. If std::numeric_limits<T>::is_iec559 is true, then std::numeric_limits<T>::has_infinity, std::numeric_limits<T>::has_quiet_NaN, and std::numeric_limits<T>::has_signaling_NaN are also true."
        }
    },
    "numeric_limits::is_bounded": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::is_bounded is true for all arithmetic types T that represent a finite set of values. While all fundamental types are bounded, this constant would be false in a specialization of std::numeric_limits for a library-provided arbitrary precision arithmetic type."
        }
    },
    "numeric_limits::is_modulo": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::is_modulo is true for all arithmetic types T that are possible to  (until C++11)handle overflows with modulo arithmetic, that is, if the result of addition, subtraction, multiplication, or division of this type would fall outside the range [min(), max()], the value returned by such operation differs from the expected value by a multiple of max()-min()+1."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <type_traits>\n#include <limits>\n \ntemplate<class T>\ntypename std::enable_if<std::numeric_limits<T>::is_modulo>::type\n    check_overflow()\n{\n    std::cout << \"\\nmax value is \" << std::numeric_limits<T>::max() << '\\n'\n              << \"min value is \" << std::numeric_limits<T>::min() << '\\n'\n              << \"max value + 1 is \" << std::numeric_limits<T>::max()+1 << '\\n';\n}\n \nint main()\n{\n    check_overflow<int>();\n    check_overflow<unsigned long>();\n    // check_overflow<float>(); // compile-time error, not a modulo type\n}",
            "output": "max value is 2147483647\nmin value is -2147483648\nmax value + 1 is -2147483648\n \nmax value is 18446744073709551615\nmin value is 0\nmax value + 1 is 0"
        }
    },
    "numeric_limits::digits": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::digits is the number of digits in base-radix that can be represented by the type T without change. For integer types, this is the number of bits not counting the sign bit and the padding bits (if any). For floating-point types, this is the number of digits in the mantissa."
        }
    },
    "numeric_limits::radix": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::radix is the base of the number system used in the representation of the type. It is 2 for all binary numeric types, but it may be, for example, 10 for IEEE 754 decimal floating-point types or for third-party binary-coded decimal integers. This constant is meaningful for all specializations."
        }
    },
    "numeric_limits::min_exponent": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::min_exponent is the lowest negative number n such that rn-1, where r is std::numeric_limits<T>::radix, is a valid normalized value of the floating-point type T."
        },
        "exemple": {
            "input": "#include <iostream>\nint main()\n{\n    std::cout << \"min() = \" << std::numeric_limits<float>::min() << '\\n'\n              << \"min_exponent10 = \" << std::numeric_limits<float>::min_exponent10 << '\\n'\n              << std::hexfloat\n              << \"min() = \" << std::numeric_limits<float>::min() << '\\n'\n              << \"min_exponent = \" << std::numeric_limits<float>::min_exponent << '\\n';\n}",
            "output": "min() = 1.17549e-38\nmin_exponent10 = -37\nmin() = 0x1p-126\nmin_exponent = -125"
        }
    },
    "numeric_limits::min_exponent10": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::min_exponent10 is the lowest negative number n such that 10n is a valid normalized value of the floating-point type T."
        },
        "exemple": {
            "input": "#include <iostream>\nint main()\n{\n    std::cout << \"min() = \" << std::numeric_limits<float>::min() << '\\n'\n              << \"min_exponent10 = \" << std::numeric_limits<float>::min_exponent10 << '\\n'\n              << std::hexfloat\n              << \"min() = \" << std::numeric_limits<float>::min() << '\\n'\n              << \"min_exponent = \" << std::numeric_limits<float>::min_exponent << '\\n';\n}",
            "output": "min() = 1.17549e-38\nmin_exponent10 = -37\nmin() = 0x1p-126\nmin_exponent = -125"
        }
    },
    "numeric_limits::max_exponent": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::max_exponent is the largest positive number n such that rn-1, where r is std::numeric_limits<T>::radix, is a representable finite value of the floating-point type T."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <limits>\nint main()\n{\n    std::cout << \"max() = \" << std::numeric_limits<float>::max() << '\\n'\n              << \"max_exponent10 = \" << std::numeric_limits<float>::max_exponent10 << '\\n'\n              << std::hexfloat\n              << \"max() = \" << std::numeric_limits<float>::max() << '\\n'\n              << \"max_exponent = \" << std::numeric_limits<float>::max_exponent << '\\n';\n}",
            "output": "max() = 3.40282e+38\nmax_exponent10 = 38\nmax() = 0x1.fffffep+127\nmax_exponent = 128"
        }
    },
    "numeric_limits::max_exponent10": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::max_exponent10 is the largest positive number n such that 10n is a representable finite value of the floating-point type T."
        },
        "exemple": {
            "input": "#include <iostream>\nint main()\n{\n    std::cout << \"max() = \" << std::numeric_limits<float>::max() << '\\n'\n              << \"max_exponent10 = \" << std::numeric_limits<float>::max_exponent10 << '\\n'\n              << std::hexfloat\n              << \"max() = \" << std::numeric_limits<float>::max() << '\\n'\n              << \"max_exponent = \" << std::numeric_limits<float>::max_exponent << '\\n';\n}",
            "output": "max() = 3.40282e+38\nmax_exponent10 = 38\nmax() = 0x1.fffffep+127\nmax_exponent = 128"
        }
    },
    "numeric_limits::traps": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::traps is true for all arithmetic types T that have at least one value that, if used as an argument to an arithmetic operation, will generate a trap."
        }
    },
    "numeric_limits::tinyness_before": {
        "description": {
            "texte": "The value of std::numeric_limits<T>::tinyness_before is true for all floating-point types T that test results of floating-point expressions for underflow before rounding."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <limits>\n#include <cmath>\n#include <cfenv>\nint main()\n{\n    std::cout << \"Tinyness before: \" << std::boolalpha\n              << std::numeric_limits<double>::tinyness_before << '\\n';\n \n    double denorm_max = std::nextafter(std::numeric_limits<double>::min(), 0);\n    double multiplier = 1 + std::numeric_limits<double>::epsilon();\n \n    std::feclearexcept(FE_ALL_EXCEPT);\n \n    double result = denorm_max*multiplier; // Underflow only if tinyness_before\n \n    if(std::fetestexcept(FE_UNDERFLOW))\n        std::cout << \"Underflow detected\\n\";\n \n    std::cout << std::hexfloat << denorm_max << \" x \" << multiplier  <<  \" = \"\n              << result << '\\n';\n}",
            "output": "Tinyness before: true\nUnderflow detected\n0xf.ffffffffffffp-1030 x 0x1.0000000000001p+0 = 0x1p-1022"
        }
    },
    "numeric_limits::min": {
        "description": {
            "texte": "Returns the minimum finite value representable by the numeric type T.For floating-point types with denormalization, min returns the minimum positive normalized value. Note that this behavior may be unexpected, especially when compared to the behavior of min for integral types. To find the value that has no values less than it, use numeric_limits::lowest.min is only meaningful for bounded types and for unbounded unsigned types, that is, types that represent an infinite set of negative values have no meaningful minimum."
        },
        "exemple": {
            "input": "#include <limits>\n#include <cstddef>\n#include <iostream>\n \nint main()\n{\n    std::cout \n        << \"short: \" << std::dec << std::numeric_limits<short>::min()\n        << \" or \" << std::hex << std::showbase \n        << std::numeric_limits<short>::min() << '\\n'\n \n        << \"int: \" << std::dec << std::numeric_limits<int>::min() << std::showbase\n        << \" or \" << std::hex << std::numeric_limits<int>::min() << '\\n' << std::dec \n \n        << \"ptrdiff_t: \" << std::numeric_limits<std::ptrdiff_t>::min() << std::showbase\n        << \" or \" << std::hex << std::numeric_limits<std::ptrdiff_t>::min() << '\\n'\n \n        << \"float: \" << std::numeric_limits<float>::min()\n        << \" or \" << std::hexfloat << std::numeric_limits<float>::min() << '\\n'\n \n        << \"double: \" << std::defaultfloat << std::numeric_limits<double>::min()\n        << \" or \" << std::hexfloat << std::numeric_limits<double>::min() << '\\n';\n}",
            "output": "short: -32768 or 0x8000\nint: -2147483648 or 0x80000000\nptrdiff_t: -9223372036854775808 or 0x8000000000000000\nfloat: 1.17549e-38 or 0x1p-126\ndouble: 2.22507e-308 or 0x1p-1022"
        }
    },
    "numeric_limits::lowest": {
        "description": {
            "texte": "Returns the lowest finite value representable by the numeric type T, that is, a finite value x such that there is no other finite value y where y < x. This is different from std::numeric_limits<T>::min() for floating-point types. Only meaningful for bounded types."
        },
        "exemple": {
            "input": "#include <limits>\n#include <iostream>\nint main()\n{\n \n    std::cout << \"std::numeric_limits<T>::min():\\n\"\n              << \"\\tfloat: \" << std::numeric_limits<float>::min()\n              << \" or \" << std::hexfloat << std::numeric_limits<float>::min() << '\\n'\n              << \"\\tdouble: \" << std::defaultfloat << std::numeric_limits<double>::min()\n              << \" or \" << std::hexfloat << std::numeric_limits<double>::min() << '\\n';\n    std::cout << \"std::numeric_limits<T>::lowest():\\n\"\n              << \"\\tfloat: \" << std::defaultfloat << std::numeric_limits<float>::lowest()\n              << \" or \" << std::hexfloat << std::numeric_limits<float>::lowest() << '\\n'\n              << \"\\tdouble: \" << std::defaultfloat << std::numeric_limits<double>::lowest()\n              << \" or \" << std::hexfloat << std::numeric_limits<double>::lowest() << '\\n';\n    std::cout << \"std::numeric_limits<T>::max():\\n\"\n              << \"\\tfloat: \" << std::defaultfloat << std::numeric_limits<float>::max()\n              << \" or \" << std::hexfloat << std::numeric_limits<float>::max() << '\\n'\n              << \"\\tdouble: \" << std::defaultfloat << std::numeric_limits<double>::max()\n              << \" or \" << std::hexfloat << std::numeric_limits<double>::max() << '\\n';\n}",
            "output": "std::numeric_limits<T>::min():\n        float: 1.17549e-38 or 0x1p-126\n        double: 2.22507e-308 or 0x1p-1022\nstd::numeric_limits<T>::lowest():\n        float: -3.40282e+38 or -0x1.fffffep+127\n        double: -1.79769e+308 or -0x1.fffffffffffffp+1023\nstd::numeric_limits<T>::max():\n        float: 3.40282e+38 or 0x1.fffffep+127\n        double: 1.79769e+308 or 0x1.fffffffffffffp+1023"
        }
    },
    "numeric_limits::max": {
        "description": {
            "texte": "Returns the maximum finite value representable by the numeric type T. Meaningful for all bounded types."
        },
        "exemple": {
            "input": "#include <limits>\n#include <cstddef>\n#include <iostream>\nint main()\n{\n    std::cout << \"short: \" << std::dec << std::numeric_limits<short>::max()\n              << \" or \" << std::hex << std::showbase << std::numeric_limits<short>::max() << '\\n'\n              << \"int: \" << std::dec << std::numeric_limits<int>::max()\n              << \" or \" << std::hex << std::numeric_limits<int>::max() << '\\n' << std::dec\n              << \"streamsize: \" << std::dec << std::numeric_limits<std::streamsize>::max()\n              << \" or \" << std::hex << std::numeric_limits<std::streamsize>::max() << '\\n'\n              << \"size_t: \" << std::dec << std::numeric_limits<std::size_t>::max()\n              << \" or \" << std::hex << std::numeric_limits<std::size_t>::max() << '\\n'\n              << \"float: \" << std::numeric_limits<float>::max()\n              << \" or \" << std::hexfloat << std::numeric_limits<float>::max() << '\\n'\n              << \"double: \" << std::defaultfloat << std::numeric_limits<double>::max()\n              << \" or \" << std::hexfloat << std::numeric_limits<double>::max() << '\\n';\n}",
            "output": "short: 32767 or 0x7fff\nint: 2147483647 or 0x7fffffff\nsize_t: 18446744073709551615 or 0xffffffffffffffff\nstreamsize: 9223372036854775807 or 0x7fffffffffffffff\nfloat: 3.40282e+38 or 0x1.fffffep+127\ndouble: 1.79769e+308 or 0x1.fffffffffffffp+1023"
        }
    },
    "numeric_limits::epsilon": {
        "description": {
            "texte": "Returns the machine epsilon, that is, the difference between 1.0 and the next value representable by the floating-point type T. It is only meaningful if std::numeric_limits<T>::is_integer == false."
        },
        "exemple": {
            "input": "#include <cmath>\n#include <limits>\n#include <iomanip>\n#include <iostream>\n#include <type_traits>\n#include <algorithm>\n \ntemplate<class T>\ntypename std::enable_if<!std::numeric_limits<T>::is_integer, bool>::type\n    almost_equal(T x, T y, int ulp)\n{\n    // the machine epsilon has to be scaled to the magnitude of the values used\n    // and multiplied by the desired precision in ULPs (units in the last place)\n    return std::abs(x-y) <= std::numeric_limits<T>::epsilon() * std::abs(x+y) * ulp\n        // unless the result is subnormal\n        || std::abs(x-y) < std::numeric_limits<T>::min();\n}\n \nint main()\n{\n    double d1 = 0.2;\n    double d2 = 1 / std::sqrt(5) / std::sqrt(5);\n    std::cout << std::fixed << std::setprecision(20) \n        << \"d1=\" << d1 << \"\\nd2=\" << d2 << '\\n';\n \n    if(d1 == d2)\n        std::cout << \"d1 == d2\\n\";\n    else\n        std::cout << \"d1 != d2\\n\";\n \n    if(almost_equal(d1, d2, 2))\n        std::cout << \"d1 almost equals d2\\n\";\n    else\n        std::cout << \"d1 does not almost equal d2\\n\";\n}",
            "output": "d1=0.20000000000000001110\nd2=0.19999999999999998335\nd1 != d2\nd1 almost equals d2"
        }
    },
    "numeric_limits::round_error": {
        "description": {
            "texte": "Returns the largest possible rounding error in ULPs (units in the last place) as defined by ISO 10967, which can vary from 0.5 (rounding to the nearest digit) to 1.0 (rounding to zero or to infinity). It is only meaningful if std::numeric_limits<T>::is_integer == false."
        }
    },
    "numeric_limits::infinity": {
        "description": {
            "texte": "Returns the special value \"positive infinity\", as represented by the floating-point type T. Only meaningful if std::numeric_limits<T>::has_infinity == true. In IEEE 754, the most common binary representation of floating-point numbers, the positive infinity is the value with all bits of the exponent set and all bits of the fraction cleared."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <limits>\nint main()\n{\n    double max = std::numeric_limits<double>::max();\n    double inf = std::numeric_limits<double>::infinity();\n \n    if(inf > max)\n        std::cout << inf << \" is greater than \" << max << '\\n';\n}",
            "output": "inf is greater than 1.79769e+308"
        }
    },
    "numeric_limits::quiet_NaN": {
        "description": {
            "texte": "Returns the special value \"quiet not-a-number\", as represented by the floating-point type T. Only meaningful if std::numeric_limits<T>::has_quiet_NaN == true. In IEEE 754, the most common binary representation of floating-point numbers, any value with all bits of the exponent set and at least one bit of the fraction set represents a NaN. It is implementation-defined which values of the fraction represent quiet or signaling NaNs, and whether the sign bit is meaningful."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <limits>\n#include <cmath>\n \nint main()\n{\n    std::cout << std::numeric_limits<double>::quiet_NaN() << ' '\n              << std::numeric_limits<double>::signaling_NaN() << ' '\n              << std::acos(2) << ' '\n              << std::tgamma(-1) << ' '\n              << std::log(-1) << ' '\n              << std::sqrt(-1) << ' '\n              << 0 / 0.0 << '\\n';\n \n    std::cout << \"NaN == NaN? \" << std::boolalpha\n              << ( std::numeric_limits<double>::quiet_NaN()\n                   == std::numeric_limits<double>::quiet_NaN() ) << '\\n';\n}",
            "output": "nan nan nan nan nan -nan -nan\nNaN == NaN? false"
        }
    },
    "numeric_limits::signaling_NaN": {
        "description": {
            "texte": "Returns the special value \"signaling not-a-number\", as represented by the floating-point type T. Only meaningful if std::numeric_limits<T>::has_signaling_NaN == true. In IEEE 754, the most common binary representation of floating-point numbers, any value with all bits of the exponent set and at least one bit of the fraction set represents a NaN. It is implementation-defined which values of the fraction represent quiet or signaling NaNs, and whether the sign bit is meaningful."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <limits>\n#include <cfenv>\n#pragma STDC_FENV_ACCESS on\nvoid show_fe_exceptions()\n{\n    int n = std::fetestexcept(FE_ALL_EXCEPT);\n    if(n & FE_INVALID) std::cout << \"FE_INVALID is raised\\n\";\n    else if(n == 0)    std::cout << \"no exceptions are raised\\n\";\n    std::feclearexcept(FE_ALL_EXCEPT);\n}\nint main()\n{\n    double snan = std::numeric_limits<double>::signaling_NaN();\n    std::cout << \"After sNaN was obtained \";\n    show_fe_exceptions();\n    double qnan = snan * 2.0;\n    std::cout << \"After sNaN was multiplied by 2 \";\n    show_fe_exceptions();\n    double qnan2 = qnan * 2.0;\n    std::cout << \"After the quieted NaN was multiplied by 2 \";\n    show_fe_exceptions();\n    std::cout << \"The result is \" << qnan2 << '\\n';\n}",
            "output": "After sNaN was obtained no exceptions are raised\nAfter sNaN was multiplied by 2 FE_INVALID is raised\nAfter the quieted NaN was multiplied by 2 no exceptions are raised\nThe result is nan"
        }
    },
    "numeric_limits::denorm_min": {
        "description": {
            "texte": "Returns the minimum positive subnormal value of the type T, if std::numeric_limits<T>::has_denorm != std::denorm_absent, otherwise returns std::numeric_limits<T>::min(). Only meaningful for floating-point types."
        },
        "exemple": {
            "input": "#include <cassert>\n#include <cstdint>\n#include <cstring>\n#include <iostream>\n#include <limits>\n \nint main()\n{\n    // the smallest subnormal value has sign bit = 0, exponent = 0\n    // and only the least significant bit of the fraction is 1\n    std::uint32_t denorm_bits = 0x0001;\n    float denorm_float;\n    std::memcpy(&denorm_float, &denorm_bits, sizeof(float));\n \n    assert(denorm_float == std::numeric_limits<float>::denorm_min());\n \n    std::cout << \"float\\tmin()\\t\\tdenorm_min()\\n\";\n    std::cout << \"\\t\" << std::numeric_limits<float>::min() << '\\t';\n    std::cout <<         std::numeric_limits<float>::denorm_min() << '\\n';\n \n    std::cout << \"double\\tmin()\\t\\tdenorm_min()\\n\";\n    std::cout << \"\\t\" << std::numeric_limits<double>::min() << '\\t';\n    std::cout <<         std::numeric_limits<double>::denorm_min() << '\\n';\n}",
            "output": "float        min()                denorm_min()\n        1.17549e-38        1.4013e-45\ndouble        min()                denorm_min()\n        2.22507e-308        4.94066e-324"
        }
    },
    "error_code::error_code": {
        "description": {
            "texte": "Constructs new error code."
        },
        "parametres": "   ec   -   platform dependent error code to construct with \n   ecat   -   error category corresponding to ec \n   e   -   error code enum to construct with \n\n"
    },
    "error_code::operator=": {
        "description": {
            "texte": "Replaces the error code and corresponding category with those representing error code enum e.Equivalent to *this = std::make_error_code(e). The overload participates in overload resolutions only if std::is_error_code_enum<ErrorCodeEnum>::value == true."
        },
        "parametres": "   e   -   error code enum to construct \n\n"
    },
    "error_code::assign": {
        "description": {
            "texte": "Replaces the contents with error code ec and corresponding category ecat."
        },
        "parametres": "   ec   -   platform-dependent error code enum to assign \n   ecat   -   error category corresponding to ec \n\n"
    },
    "error_code::clear": {
        "description": {
            "texte": "Replaces the error code and error category with default values.Equivalent to *this = error_code(0, std::system_category())."
        }
    },
    "error_code::value": {
        "description": {
            "texte": "Returns the platform dependent error value."
        }
    },
    "error_code::category": {
        "description": {
            "texte": "Returns the error category of the error value."
        }
    },
    "error_code::default_error_condition": {
        "description": {
            "texte": "Returns the default error condition for the current error value.Equivalent to category().default_error_condition(value())."
        }
    },
    "error_code::message": {
        "description": {
            "texte": "Returns the message corresponding to the current error value and category.Equivalent to category().message(value())."
        }
    },
    "error_code::operator bool": {
        "description": {
            "texte": "Checks if the error value is valid, i.e. non-zero."
        }
    },
    "basic_string::basic_string": {
        "description": {
            "texte": "Constructs new string from a variety of data sources and optionally using user supplied allocator alloc."
        },
        "parametres": "   alloc   -   allocator to use for all memory allocations of this string \n   count   -   size of the resulting string \n   ch   -   value to initialize the string with \n   pos   -   position of the first character to include \n   first, last   -   range to copy the characters from \n   s   -   pointer to an array of characters to use as source to initialize the string with \n   other   -   another string to use as source to initialize the string with \n   ilist   -   std::initializer_list to initialize the string with \n   t   -   object (convertible to std::basic_string_view) to initialize the string with \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cassert>\n#include <iterator>\n#include <string>\n#include <cctype>\n \nint main()\n{\n  {\n    // string::string()\n    std::string s;\n    assert(s.empty() && (s.length() == 0) && (s.size() == 0));\n  }\n \n  {\n    // string::string(size_type count, charT ch)\n    std::string s(4, '=');\n    std::cout << s << '\\n'; // \"====\"\n  }\n \n  {\n    std::string const other(\"Exemplary\");\n    // string::string(string const& other, size_type pos, size_type count)\n    std::string s(other, 0, other.length()-1);\n    std::cout << s << '\\n'; // \"Exemplar\"\n  }\n \n  {\n    // string::string(charT const* s, size_type count)\n    std::string s(\"C-style string\", 7);\n    std::cout << s << '\\n'; // \"C-style\"\n  }\n \n  {\n    // string::string(charT const* s)\n    std::string s(\"C-style\\0string\");\n    std::cout << s << '\\n'; // \"C-style\"\n  }\n \n  {\n    char mutable_c_str[] = \"another C-style string\";\n    // string::string(InputIt first, InputIt last)\n    std::string s(std::begin(mutable_c_str)+8, std::end(mutable_c_str)-1);\n    std::cout << s << '\\n'; // \"C-style string\"\n  }\n \n  {\n    std::string const other(\"Exemplar\");\n    std::string s(other);\n    std::cout << s << '\\n'; // \"Exemplar\"\n  }\n \n  {\n    // string::string(string&& str)\n    std::string s(std::string(\"C++ by \") + std::string(\"example\"));\n    std::cout << s << '\\n'; // \"C++ by example\"\n  }\n \n  {\n    // string(std::initializer_list<charT> ilist)\n    std::string s({ 'C', '-', 's', 't', 'y', 'l', 'e' });\n    std::cout << s << '\\n'; // \"C-style\"\n  }\n \n  {\n    // overload resolution selects string(InputIt first, InputIt last) [with InputIt = int]\n    // which behaves as if string(size_type count, charT ch) is called\n    std::string s(3, std::toupper('a'));\n    std::cout << s << '\\n'; // \"AAA\"\n  }\n}",
            "output": "====\nExemplar\nC-style\nC-style\nC-style string\nExemplar\nC++ by example\nC-style\nAAA"
        }
    },
    "basic_string::operator=": {
        "description": {
            "texte": "Replaces the contents of the string."
        },
        "parametres": "   ch   -   value to initialize characters of the string with \n   str   -   string to be used as source to initialize the string with \n   s   -   pointer to a null-terminated character string to use as source to initialize the string with \n   ilist   -   std::initializer_list to initialize the string with \n   t   -   object convertible to std::basic_string_view to initialize the string with \n\n"
    },
    "basic_string::assign": {
        "description": {
            "texte": "Replaces the contents of the string."
        },
        "parametres": "   count   -   size of the resulting string \n   pos   -   index of the first character to take \n   ch   -   value to initialize characters of the string with \n   first, last   -   range to copy the characters from \n   str   -   string to be used as source to initialize the characters with \n   s   -   pointer to a character string to use as source to initialize the string with \n   ilist   -   std::initializer_list to initialize the characters of the string with \n   t   -   object (convertible to std::basic_string_view) to initialize the characters of the string with \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n#include <string>\n \nint main()\n{\n  std::string s;\n  // assign(size_type count, CharT ch)\n  s.assign(4, '=');\n  std::cout << s << '\\n'; // \"====\"\n \n  std::string const c(\"Exemplary\");\n  // assign(basic_string const& str)\n  s.assign(c);\n  std::cout << c << \"==\" << s <<'\\n'; // \"Exemplary == Exemplary\"\n \n  // assign(basic_string const& str, size_type pos, size_type count)\n  s.assign(c, 0, c.length()-1);\n  std::cout << s << '\\n'; // \"Exemplar\";\n \n  // assign(basic_string&& str)\n  s.assign(std::string(\"C++ by \") + \"example\");\n  std::cout << s << '\\n'; // \"C++ by example\"\n \n  // assign(charT const* s, size_type count)\n  s.assign(\"C-style string\", 7);\n  std::cout << s << '\\n'; // \"C-style\"\n \n  // assign(charT const* s)\n  s.assign(\"C-style\\0string\");\n  std::cout << s << '\\n'; // \"C-style\"\n \n  char mutable_c_str[] = \"C-style string\";\n  // assign(InputIt first, InputIt last)\n  s.assign(std::begin(mutable_c_str), std::end(mutable_c_str)-1);\n  std::cout << s << '\\n'; // \"C-style string\"\n \n  // assign(std::initializer_list<charT> ilist)\n  s.assign({ 'C', '-', 's', 't', 'y', 'l', 'e' });\n  std::cout << s << '\\n'; // \"C-style\"\n}",
            "output": "====\nExemplary==Exemplary\nExemplar\nC++ by example\nC-style\nC-style\nC-style string\nC-style"
        }
    },
    "basic_string::get_allocator": {
        "description": {
            "texte": "Returns the allocator associated with the string."
        }
    },
    "basic_string::at": {
        "description": {
            "texte": "Returns a reference to the character at specified location pos. Bounds checking is performed, exception of type std::out_of_range will be thrown on invalid access."
        },
        "parametres": "   pos   -   position of the character to return \n\n",
        "exemple": {
            "input": "#include <stdexcept>\n#include <iostream>\n#include <string>\n \nint main()\n{\n    std::string s(\"message\"); // for capacity\n \n    s = \"abc\";\n    s.at(2) = 'x'; // ok\n    std::cout << s << '\\n';\n \n    std::cout << \"string size = \" << s.size() << '\\n';\n    std::cout << \"string capacity = \" << s.capacity() << '\\n';\n \n    try {\n        // throw, even if capacity allowed to access element\n        s.at(3) = 'x';\n    }\n    catch (std::out_of_range const& exc) {\n        std::cout << exc.what() << '\\n';\n    }\n}",
            "output": "abx\nstring size = 3\nstring capacity = 7\nbasic_string::at"
        }
    },
    "basic_string::operator[]": {
        "description": {
            "texte": "Returns a reference to the character at specified location pos. No bounds checking is performed. If pos > size(), the behavior is undefined."
        },
        "parametres": "   pos   -   position of the character to return \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n \nint main()\n{\n    std::string const e(\"Exemplar\");\n    for (unsigned i = e.length() - 1; i != 0; i /= 2)\n        std::cout << e[i];\n    std::cout << '\\n';\n \n    const char* c = &e[0];\n    std::cout << c << '\\n'; // print as a C string\n \n    //Change the last character of s into a 'y'\n    std::string s(\"Exemplar \");\n    s[s.size()-1] = 'y';\n    std::cout << s << '\\n';\n}",
            "output": "rmx\nExemplar\nExemplary"
        }
    },
    "basic_string::front": {
        "description": {
            "texte": "Returns reference to the first character in the string. The behavior is undefined if empty() == true."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n \nint main()\n{\n  {\n    std::string s(\"Exemplary\");\n    char& f = s.front();\n    f = 'e';\n    std::cout << s << '\\n'; // \"exemplary\"\n  }\n \n  {\n    std::string const c(\"Exemplary\");\n    char const& f = c.front();\n    std::cout << &f << '\\n'; // \"Exemplary\"\n  }\n}",
            "output": "exemplary\nExemplary"
        }
    },
    "basic_string::back": {
        "description": {
            "texte": "Returns reference to the last character in the string. The behavior is undefined if empty() == true."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n \nint main()\n{\n  {\n    std::string s(\"Exemplary\");\n    char& back = s.back();\n    back = 's';\n    std::cout << s << '\\n'; // \"Exemplars\"\n  }\n \n  {\n    std::string const c(\"Exemplary\");\n    char const& back = c.back();\n    std::cout << back << '\\n'; // 'y'\n  }\n}",
            "output": "Exemplars\ny"
        }
    },
    "basic_string::data": {
        "description": {
            "texte": "Returns a pointer to the underlying array serving as character storage. The pointer is such that the range [data(); data() + size()) is valid and the values in it correspond to the values stored in the string.The pointer obtained from data() may be invalidated by:"
        },
        "exemple": {
            "input": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <string>\n \nint main()\n{\n  std::string const s(\"Emplary\");\n  assert(s.size() == std::strlen(s.data()));\n  assert(std::equal(s.begin(), s.end(), s.data()));\n  assert(std::equal(s.data(), s.data() + s.size(), s.begin()));\n  assert(0 == *(s.data() + s.size()));\n}"
        }
    },
    "basic_string::c_str": {
        "description": {
            "texte": "Returns a pointer to a null-terminated character array with data equivalent to those stored in the string.The pointer is such that the range [c_str(); c_str() + size()] is valid and the values in it correspond to the values stored in the string with an additional null character after the last position.The pointer obtained from c_str() may be invalidated by:Writing to the character array accessed through c_str() is undefined behavior."
        },
        "exemple": {
            "input": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <string>\n \nint main()\n{\n  std::string const s(\"Emplary\");\n  assert(s.size() == std::strlen(s.c_str()));\n  assert(std::equal(s.begin(), s.end(), s.c_str()));\n  assert(std::equal(s.c_str(), s.c_str() + s.size(), s.begin()));\n  assert(0 == *(s.c_str() + s.size()));\n}"
        }
    },
    "basic_string::operator basic_string_view": {
        "description": {
            "texte": "Returns a std::basic_string_view, constructed as if by std::basic_string_view<CharT, Traits>(data(), size())."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <string_view>\n \nvoid show_wstring_size(std::wstring_view wcstr_v)\n{\n  std::cout << wcstr_v.size() << \" code points\\n\";\n}\n \nint main()\n{\n  std::string cppstr = \"\u30e9\u30fc\u30e1\u30f3\";   // narrow string\n  std::wstring wcstr = L\"\u30e9\u30fc\u30e1\u30f3\";  // wide string\n \n  // Implicit conversion from string to string_view\n  // via std::string::operator string_view:\n  std::string_view cppstr_v = cppstr;\n \n  std::cout << cppstr_v << '\\n'\n            << cppstr_v.size() << \" code units\\n\";\n \n  // Implicit conversion from wstring to wstring_view\n  // via std::wstring::operator wstring_view:\n  show_wstring_size(wcstr);\n \n  // Warning:\n  // It is the programmer's responsibility to ensure that std::string_view \n  // does not outlive the pointed-to string! \n \n  std::string_view BAD(std::string(\"a temporary string\")); // holds a dangling pointer!\n}",
            "output": "\u30e9\u30fc\u30e1\u30f3\n12 code units\n4 code points"
        }
    },
    "basic_string::begin, std::basic_string::cbegin": {
        "description": {
            "texte": "Returns an iterator to the first character of the string.begin() returns a mutable or constant iterator, depending on the constness of *this.cbegin() always returns a constant iterator. It is equivalent to const_cast<const basic_string&>(*this).begin()."
        },
        "exemple": {
            "input": "#include <string>\n#include <iostream>\n \nint main()\n{\n    std::string s(\"Exemplar\");\n    *s.begin() = 'e';\n    std::cout << s <<'\\n';\n \n    auto i = s.cbegin();\n    std::cout << *i << '\\n';\n//  *i = 'E'; // error: i is a constant iterator\n}",
            "output": "exemplar\ne"
        }
    },
    "basic_string::end, std::basic_string::cend": {
        "description": {
            "texte": "Returns an iterator to the character following the last character of the string. This character acts as a placeholder, attempting to access it results in undefined behavior."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <string>\n \nint main()\n{\n    std::string s(\"Exemparl\");\n    std::next_permutation(s.begin(), s.end());\n \n    std::string c;\n    std::copy(s.cbegin(), s.cend(), std::back_inserter(c));\n    std::cout << c <<'\\n'; // \"Exemplar\"\n}",
            "output": "Exemplar"
        }
    },
    "basic_string::rbegin, std::basic_string::crbegin": {
        "description": {
            "texte": "Returns a reverse iterator to the first character of the reversed string. It corresponds to the last character of the non-reversed string."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <string>\n \nint main()\n{\n    std::string s(\"Exemplar!\");\n    *s.rbegin() = 'y';\n    std::cout << s << '\\n'; // \"Exemplary\"\n \n    std::string c;\n    std::copy(s.crbegin(), s.crend(), std::back_inserter(c));\n    std::cout << c << '\\n'; // \"yralpmexE\"\n}",
            "output": "Exemplary\nyralpmexE"
        }
    },
    "basic_string::rend, std::basic_string::crend": {
        "description": {
            "texte": "Returns a reverse iterator to the character following the last character of the reversed string. It corresponds to the character preceding the first character of the non-reversed string. This character acts as a placeholder, attempting to access it results in undefined behavior."
        },
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <string>\n \nint main()\n{\n  std::string s(\"A man, a plan, a canal: Panama\");\n  {\n    std::string c;\n    std::copy(s.rbegin(), s.rend(), std::back_inserter(c));\n    std::cout << c <<'\\n'; // \"amanaP :lanac a ,nalp a ,nam A\"\n  }\n \n  {\n    std::string c;\n    std::copy(s.crbegin(), s.crend(), std::back_inserter(c));\n    std::cout << c <<'\\n'; // \"amanaP :lanac a ,nalp a ,nam A\"\n  }\n}",
            "output": "amanaP :lanac a ,nalp a ,nam A\namanaP :lanac a ,nalp a ,nam A"
        }
    },
    "basic_string::empty": {
        "description": {
            "texte": "Checks if the string has no characters, i.e. whether begin() == end()."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n \nint main()\n{\n    std::string s;\n    std::boolalpha(std::cout);\n    std::cout << \"s.empty():\" << s.empty() << \"\\t s:'\" << s << \"'\\n\";\n \n    s = \"Exemplar\";\n    std::cout << \"s.empty():\" << s.empty() << \"\\t s:'\" << s << \"'\\n\";\n \n    s = \"\";\n    std::cout << \"s.empty():\" << s.empty() << \"\\t s:'\" << s << \"'\\n\";\n}",
            "output": "s.empty():true         s:''\ns.empty():false         s:'Exemplar'\ns.empty():true         s:''"
        }
    },
    "basic_string::size, std::basic_string::length": {
        "description": {
            "texte": "Returns the number of CharT elements in the string, i.e. std::distance(begin(), end())."
        },
        "exemple": {
            "input": "#include <cassert>\n#include <iterator>\n#include <string>\n \nint main()\n{\n    std::string s(\"Exemplar\");\n    assert(8 == s.size());\n    assert(s.size() == s.length());\n    assert(s.size() == static_cast<std::string::size_type>(\n        std::distance(s.begin(), s.end())));\n \n    std::u32string a(U\"\u30cf\u30ed\u30fc\u30fb\u30ef\u30fc\u30eb\u30c9\"); // 8 code points\n    assert(8 == a.size()); // 8 code units in UTF-32\n \n    std::u16string b(u\"\u30cf\u30ed\u30fc\u30fb\u30ef\u30fc\u30eb\u30c9\"); // 8 code points\n    assert(8 == b.size()); // 8 code units in UTF-16\n \n    std::string c(u8\"\u30cf\u30ed\u30fc\u30fb\u30ef\u30fc\u30eb\u30c9\"); // 8 code points\n    assert(24 == c.size()); // 24 code units in UTF-8\n}"
        }
    },
    "basic_string::max_size": {
        "description": {
            "texte": "Returns the maximum number of elements the string is able to hold due to system or library implementation limitations, i.e. \u200bstd::distance(begin(), end())\u200b for the largest string."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n \nint main()\n{\n    std::string s;\n    std::cout << \"Maximum size of a string is \" << s.max_size() << \"\\n\";\n}",
            "output": "Maximum size of a string is 4294967294"
        }
    },
    "basic_string::reserve": {
        "description": {
            "texte": "(none)."
        },
        "parametres": "   new_cap   -   new capacity of the string \n\n",
        "exemple": {
            "input": "#include <cassert>\n#include <string>\n \nint main()\n{\n    std::string s;\n    std::string::size_type new_capacity{ 100u };\n    assert(new_capacity > s.capacity());\n \n    s.reserve(new_capacity);\n    assert(new_capacity <= s.capacity());\n}"
        }
    },
    "basic_string::capacity": {
        "description": {
            "texte": "Returns the number of characters that the string has currently allocated space for."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n \nvoid show_capacity(std::string const& s)\n{\n    std::cout << \"'\" << s << \"' has capacity \" << s.capacity() << \".\\n\";\n}\n \nint main()\n{\n    std::string s{\"Exemplar\"};\n    show_capacity(s);\n \n    s += \" is an example string.\";\n    show_capacity(s);\n}",
            "output": "'Exemplar' has capacity 15.\n'Exemplar is an example string.' has capacity 30."
        }
    },
    "basic_string::shrink_to_fit": {
        "description": {
            "texte": "Requests the removal of unused capacity.It is a non-binding request to reduce capacity() to size(). It depends on the implementation if the request is fulfilled.If (and only if) reallocation takes place, all pointers, references, and iterators are invalidated."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n \nint main()\n{\n    std::string s;\n    std::cout << \"Default-constructed capacity is \" << s.capacity() << '\\n';\n    s.resize(100);\n    std::cout << \"Capacity of a 100-element string is \" << s.capacity() << '\\n';\n    s.clear();\n    std::cout << \"Capacity after clear() is \" << s.capacity() << '\\n';\n    s.shrink_to_fit();\n    std::cout << \"Capacity after shrink_to_fit() is \" << s.capacity() << '\\n';\n}",
            "output": "Default-constructed capacity is 0\nCapacity of a 100-element string is 100\nCapacity after clear() is 100\nCapacity after shrink_to_fit() is 0"
        }
    },
    "basic_string::clear": {
        "description": {
            "texte": "Removes all characters from the string as if by executing erase(begin(), end()).All pointers, references, and iterators are invalidated."
        },
        "exemple": {
            "input": "#include <cassert>\n#include <string>\n \nint main()\n{\n    std::string s{ \"Exemplar\" };\n    std::string::size_type const capacity = s.capacity();\n \n    s.clear();\n    assert(s.capacity() == capacity);\n    assert(s.empty());\n    assert(s.size() == 0);\n}"
        }
    },
    "basic_string::insert": {
        "description": {
            "texte": "Inserts characters into the string."
        },
        "parametres": "   index   -   position at which the content will be inserted \n   pos   -   iterator before which the characters will be inserted \n   ch   -   character to insert \n   count   -   number of characters to insert \n   s   -   pointer to the character string to insert \n   str   -   string to insert \n   first, last   -   range defining characters to insert \n   index_str   -   position of the first character in the string str to insert \n   ilist   -   std::initializer_list to insert the characters from \n   t   -   object (convertible to std::basic_string_view) to insert the characters from \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n",
        "exemple": {
            "input": "#include <cassert>\n#include <iterator>\n#include <string>\nusing namespace std::string_literals;\nint main()\n{\n    std::string s = \"xmplr\";\n \n    // insert(size_type index, size_type count, char ch)\n    s.insert(0, 1, 'E');\n    assert(\"Exmplr\" == s);\n \n    // insert(size_type index, const char* s)\n    s.insert(2, \"e\");\n    assert(\"Exemplr\" == s);\n \n    // insert(size_type index, string const& str)\n    s.insert(6, \"a\"s);\n    assert(\"Exemplar\" == s);\n \n    // insert(size_type index, string const& str,\n    //     size_type index_str, size_type count)\n    s.insert(8, \" is an example string.\"s, 0, 14);\n    assert(\"Exemplar is an example\" == s);\n \n    // insert(const_iterator pos, char ch)\n    s.insert(s.cbegin() + s.find_first_of('n') + 1, ':');\n    assert(\"Exemplar is an: example\" == s);\n \n    // insert(const_iterator pos, size_type count, char ch)\n    s.insert(s.cbegin() + s.find_first_of(':') + 1, 2, '=');\n    assert(\"Exemplar is an:== example\" == s);\n \n    // insert(const_iterator pos, InputIt first, InputIt last)\n    {\n        std::string seq = \" string\";\n        s.insert(s.begin() + s.find_last_of('e') + 1,\n            std::begin(seq), std::end(seq));\n        assert(\"Exemplar is an:== example string\" == s);\n    }\n \n    // insert(const_iterator pos, std::initializer_list<char>)\n    s.insert(s.cbegin() + s.find_first_of('g') + 1, { '.' });\n    assert(\"Exemplar is an:== example string.\" == s);\n}"
        }
    },
    "basic_string::erase": {
        "description": {
            "texte": "Removes specified characters from the string."
        },
        "parametres": "   index   -   first character to remove \n   count   -   number of characters to remove \n   position   -   iterator to the character to remove \n   first, last   -   range of the characters to remove \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <algorithm>\n#include <string>\n \nint main()\n{\n    std::string s = \"This is an example\";\n    std::cout << s << '\\n';\n \n    s.erase(0, 5); // Erase \"This \"\n    std::cout << s << '\\n';\n \n    s.erase(std::find(s.begin(), s.end(), ' ')); // Erase ' '\n    std::cout << s << '\\n';\n \n    s.erase(s.find(' ')); // Trim from ' ' to the end of the string\n    std::cout << s << '\\n';\n}",
            "output": "This is an example\nis an example\nisan example\nisan"
        }
    },
    "basic_string::push_back": {
        "description": {
            "texte": "Appends the given character ch to the end of the string."
        },
        "parametres": "   ch   -   the character to append \n\n"
    },
    "basic_string::pop_back": {
        "description": {
            "texte": "Removes the last character from the string.Equivalent to erase(end()-1). The behavior is undefined if the string is empty."
        }
    },
    "basic_string::append": {
        "description": {
            "texte": "Appends additional characters to the string."
        },
        "parametres": "   count   -   number of characters to append \n   pos   -   the index of the first character to append \n   ch   -   character value to append \n   first, last   -   range of characters to append \n   str   -   string to append \n   s   -   pointer to the character string to append \n   ilist   -   initializer list with the characters to append \n   t   -   object convertible to std::basic_string_view with the characters to append \n\n",
        "exemple": {
            "input": "#include <string>\n#include <iostream>\n \nint main() {\n    std::basic_string<char> str = \"string\";\n    const char* cptr = \"C-string\";\n    const char carr[] = \"Two and one\";\n \n    std::string output;\n \n    // 1) Append a char 3 times. \n    // Notice, this is the only overload accepting chars.\n    output.append(3, '*');\n    std::cout << \"1) \" << output << \"\\n\";\n \n    //  2) Append a whole string\n    output.append(str);\n    std::cout << \"2) \" << output << \"\\n\";\n \n    // 3) Append part of a string (last 3 letters, in this case)\n    output.append(str, 3, 3);\n    std::cout << \"3) \" << output << \"\\n\";\n \n    // 4) Append part of a C-string\n    // Notice, because `append` returns *this, we can chain calls together\n    output.append(1, ' ').append(carr, 4);\n    std::cout << \"4) \" << output << \"\\n\";\n \n    // 5) Append a whole C-string\n    output.append(cptr);\n    std::cout << \"5) \" << output << \"\\n\";\n \n    // 6) Append range\n    output.append(&carr[3], std::end(carr));\n    std::cout << \"6) \" << output << \"\\n\";\n \n    // 7) Append initializer list\n    output.append({ ' ', 'l', 'i', 's', 't' });\n    std::cout << \"7) \" << output << \"\\n\";\n}",
            "output": "1) ***\n2) ***string\n3) ***stringing\n4) ***stringing Two \n5) ***stringing Two C-string\n6) ***stringing Two C-string and one\n7) ***stringing Two C-string and one list"
        }
    },
    "basic_string::compare": {
        "description": {
            "texte": "Compares two character sequences.A character sequence consisting of count1 characters starting at data1 is compared to a character sequence consisting of count2 characters starting at data2 as follows. First, calculate the number of characters to compare, as if by size_type rlen = std::min(count1, count2). Then compare the sequences by calling Traits::compare(data1, data2, rlen). For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows:"
        },
        "parametres": "   str   -   other string to compare to \n   s   -   pointer to the character string to compare to \n   count1   -   number of characters of this string to compare \n   pos1   -   position of the first character in this string to compare \n   count2   -   number of characters of the given string to compare \n   pos2   -   position of the first character of the given string to compare \n   t   -   object (convertible to std::basic_string_view) to compare to \n\n",
        "exemple": {
            "input": "#include <cassert>\n#include <string>\n#include <iostream>\n \nint main() \n{\n    // 1) Compare with other string\n    {\n        int compare_value{\n            std::string{\"Batman\"}.compare(std::string{\"Superman\"})\n        };\n        std::cout << (\n            compare_value < 0 ? \"Batman comes before Superman\\n\" :\n            compare_value > 0 ? \"Superman comes before Batman\\n\" :\n            \"Superman and Batman are the same.\\n\"\n        );\n    }\n \n    // 2) Compare substring with other string\n    {\n        int compare_value{\n            std::string{\"Batman\"}.compare(3, 3, std::string{\"Superman\"})\n        };\n        std::cout << (\n            compare_value < 0 ? \"man comes before Superman\\n\" :\n            compare_value > 0 ? \"Superman comes before man\\n\" :\n            \"man and Superman are the same.\\n\"\n        );\n    }\n \n    // 3) Compare substring with other substring\n    {\n        std::string a{\"Batman\"};\n        std::string b{\"Superman\"};\n \n        int compare_value{a.compare(3, 3, b, 5, 3)};\n \n        std::cout << (\n            compare_value < 0 ? \"man comes before man\\n\" :\n            compare_value > 0 ? \"man comes before man\\n\" :\n            \"man and man are the same.\\n\"\n        );\n        // Compare substring with other substring\n        // defaulting to end of other string\n        assert(compare_value == a.compare(3, 3, b, 5));\n    }\n \n    // 4) Compare with char pointer\n    {\n        int compare_value{std::string{\"Batman\"}.compare(\"Superman\")};\n \n        std::cout << (\n            compare_value < 0 ? \"Batman comes before Superman\\n\" :\n            compare_value > 0 ? \"Superman comes before Batman\\n\" :\n            \"Superman and Batman are the same.\\n\"\n        );\n    }\n \n    // 5) Compare substring with char pointer\n    {\n        int compare_value{std::string{\"Batman\"}.compare(3, 3, \"Superman\")};\n \n        std::cout << (\n            compare_value < 0 ? \"man comes before Superman\\n\" :\n            compare_value > 0 ? \"Superman comes before man\\n\" :\n            \"man and Superman are the same.\\n\"\n        );\n    }\n \n    // 6) Compare substring with char pointer substring\n    {\n        int compare_value{std::string{\"Batman\"}.compare(0, 3, \"Superman\", 5)};\n \n        std::cout << (\n            compare_value < 0 ? \"Bat comes before Super\\n\" :\n            compare_value > 0 ? \"Super comes before Bat\\n\" :\n            \"Super and Bat are the same.\\n\"\n        );\n    }\n}",
            "output": "Batman comes before Superman\nSuperman comes before man\nman and man are the same.\nBatman comes before Superman\nSuperman comes before man\nBat comes before Super"
        }
    },
    "basic_string::starts_with": {
        "description": {
            "texte": "Checks if the string begins with the given prefix, where.All three overloads effectively return std::basic_string_view<CharT, Traits>(data(), size()).starts_with(x);"
        },
        "parametres": "   x   -   a character sequence or a single character to compare to the start of the string \n\n"
    },
    "basic_string::ends_with": {
        "description": {
            "texte": "Checks if the string ends with the given suffix, where.All three overloads effectively return std::basic_string_view<CharT, Traits>(data(), size()).ends_with(x);"
        },
        "parametres": "   x   -   a character sequence or a single character to compare to the end of the string \n\n"
    },
    "basic_string::replace": {
        "description": {
            "texte": "Replaces the part of the string indicated by either [pos, pos + count) or [first, last) with a new string.The new string can be one of:"
        },
        "parametres": "   pos   -   start of the substring that is going to be replaced \n   count   -   length of the substring that is going to be replaced \n   first, last   -   range of characters that is going to be replaced \n   str   -   string to use for replacement \n   pos2   -   start of the substring to replace with \n   count2   -   number of characters to replace with \n   cstr   -   pointer to the character string to use for replacement \n   ch   -   character value to use for replacement \n   first2, last2   -   range of characters to use for replacement \n   ilist   -   initializer list with the characters to use for replacement \n   t   -   object (convertible to std::basic_string_view) with the characters to use for replacement \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n \nint main()\n{\n    std::string str(\"The quick brown fox jumps over the lazy dog.\");\n \n    str.replace(10, 5, \"red\"); // (5)\n \n    str.replace(str.begin(), str.begin() + 3, 1, 'A'); // (6)\n \n    std::cout << str << '\\n';\n}",
            "output": "A quick red fox jumps over the lazy dog."
        }
    },
    "basic_string::substr": {
        "description": {
            "texte": "Returns a substring [pos, pos+count). If the requested substring extends past the end of the string, or if count == npos, the returned substring is [pos, size())."
        },
        "parametres": "   pos   -   position of the first character to include \n   count   -   length of the substring \n\n",
        "exemple": {
            "input": "#include <string>\n#include <iostream>\n \nint main()\n{\n    std::string a = \"0123456789abcdefghij\";\n \n    // count is npos, returns [pos, size())\n    std::string sub1 = a.substr(10);\n    std::cout << sub1 << '\\n';\n \n    // both pos and pos+count are within bounds, returns [pos, pos+count)\n    std::string sub2 = a.substr(5, 3);\n    std::cout << sub2 << '\\n';\n \n    // pos is within bounds, pos+count is not, returns [pos, size()) \n    std::string sub4 = a.substr(a.size()-3, 50);\n    std::cout << sub4 << '\\n';\n \n    try {\n        // pos is out of bounds, throws\n        std::string sub5 = a.substr(a.size()+3, 50);\n        std::cout << sub5 << '\\n';\n    } catch(const std::out_of_range& e) {\n        std::cout << \"pos exceeds string size\\n\";\n    }\n}",
            "output": "abcdefghij\n567\nhij\npos exceeds string size"
        }
    },
    "basic_string::copy": {
        "description": {
            "texte": "Copies a substring [pos, pos+count) to character string pointed to by dest. If the requested substring lasts past the end of the string, or if count == npos, the copied substring is [pos, size()). The resulting character string is not null-terminated.If pos > size(), std::out_of_range is thrown."
        },
        "parametres": "   dest   -   pointer to the destination character string \n   pos   -   position of the first character to include \n   count   -   length of the substring \n\n",
        "exemple": {
            "input": "#include <string>\n#include <iostream>\n \nint main()\n{\n  std::string foo(\"quuuux\");\n  char bar[7]{};\n  foo.copy(bar, sizeof bar);\n  std::cout << bar << '\\n';\n}",
            "output": "quuuux"
        }
    },
    "basic_string::resize": {
        "description": {
            "texte": "Resizes the string to contain count characters.If the current size is less than count, additional characters are appended.If the current size is greater than count, the string is reduced to its first count elements.The first version initializes new characters to CharT(), the second version initializes new characters to ch."
        },
        "parametres": "   count   -   new size of the string \n   ch   -   character to initialize the new characters with \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <stdexcept>\n \nint main()\n{\n    std::cout << \"Basic functionality:\\n\";\n    const unsigned  desired_length(8);\n    std::string     long_string( \"Where is the end?\" );\n    std::string     short_string( \"Ha\" );\n \n    // Shorten\n    std::cout << \"Before: \\\"\" << long_string << \"\\\"\\n\";\n    long_string.resize( desired_length );\n    std::cout << \"After: \\\"\" << long_string <<  \"\\\"\\n\";\n \n    // Lengthen\n    std::cout << \"Before: \\\"\" << short_string <<  \"\\\"\\n\";\n    short_string.resize( desired_length, 'a' );\n    std::cout << \"After: \\\"\" << short_string <<  \"\\\"\\n\";\n \n    std::cout  << \"\\nErrors:\\n\";\n    {\n        std::string s;    \n \n        try {\n            // size is OK, no length_error\n            // (may throw bad_alloc)\n            s.resize(s.max_size() - 1, 'x');\n        } catch (const std::bad_alloc&) {\n            std::cout << \"1. bad alloc\\n\";\n        }\n \n        try {\n            // size is OK, no length_error\n            // (may throw bad_alloc)\n            s.resize(s.max_size(), 'x');\n        } catch (const std::bad_alloc& exc) {\n            std::cout << \"2. bad alloc\\n\";\n        }\n \n        try {\n            // size is BAD, throw length_error\n            s.resize(s.max_size() + 1, 'x');\n        } catch (const std::length_error&) {\n            std::cout << \"3. length error\\n\";\n        }\n     }\n}",
            "output": "Basic functionality:\nBefore: \"Where is the end?\"\nAfter: \"Where is\"\nBefore: \"Ha\"\nAfter: \"Haaaaaaa\"\n \nErrors:\n1. bad alloc\n2. bad alloc\n3. length error"
        }
    },
    "basic_string::swap": {
        "description": {
            "texte": "Exchanges the contents of the string with those of other. All iterators and references may be invalidated."
        },
        "parametres": "   other   -   string to exchange the contents with \n\n",
        "exemple": {
            "input": "#include <string>\n#include <iostream>\n \nint main() \n{\n    std::string a = \"AAA\";\n    std::string b = \"BBB\";\n \n    std::cout << \"before swap\" << '\\n';\n    std::cout << \"a: \" << a << '\\n';\n    std::cout << \"b: \" << b << '\\n';\n \n    a.swap(b);\n \n    std::cout << \"after swap\" << '\\n';\n    std::cout << \"a: \" << a << '\\n';\n    std::cout << \"b: \" << b << '\\n';\n}",
            "output": "before swap\na: AAA\nb: BBB\nafter swap\na: BBB\nb: AAA"
        }
    },
    "basic_string::find": {
        "description": {
            "texte": "Finds the first substring equal to the given character sequence. Search begins at pos, i.e. the found substring must not begin in a position preceding pos.Formally, a substring str is said to be found at position xpos if all of the following is true:In particular, this implies that."
        },
        "parametres": "   str   -   string to search for \n   pos   -   position at which to start the search \n   count   -   length of substring to search for \n   s   -   pointer to a character string to search for \n   ch   -   character to search for \n   t   -   object (convertible to std::basic_string_view) to search for \n\n",
        "exemple": {
            "input": "#include <string>\n#include <iostream>\n \nvoid print(std::string::size_type n, std::string const &s)\n{\n    if (n == std::string::npos) {\n        std::cout << \"not found\\n\";\n    } else {\n        std::cout << \"found: \" << s.substr(n) << '\\n';\n    }\n}\n \nint main()\n{\n    std::string::size_type n;\n    std::string const s = \"This is a string\";\n \n    // search from beginning of string\n    n = s.find(\"is\");\n    print(n, s);\n \n    // search from position 5\n    n = s.find(\"is\", 5);\n    print(n, s);\n \n    // find a single character\n    n = s.find('a');\n    print(n, s);\n \n    // find a single character\n    n = s.find('q');\n    print(n, s);\n}",
            "output": "found: is is a string\nfound: is a string\nfound: a string\nnot found"
        }
    },
    "basic_string::rfind": {
        "description": {
            "texte": "Finds the last substring equal to the given character sequence. Search begins at pos, i.e. the found substring must not begin in a position following pos. If npos or any value not smaller than size()-1 is passed as pos, whole string will be searched.In all cases, equality is checked by calling Traits::eq."
        },
        "parametres": "   str   -   string to search for \n   pos   -   position at which to begin searching \n   count   -   length of substring to search for \n   s   -   pointer to a character string to search for \n   ch   -   character to search for \n   t   -   object (convertible to std::basic_string_view) to search for \n\n",
        "exemple": {
            "input": "#include <string>\n#include <iostream>\n \nvoid print(std::string::size_type n, std::string const &s)\n{\n    if (n == std::string::npos) {\n        std::cout << \"not found\\n\";\n    } else {\n        std::cout << \"found: \\\"\" << s.substr(n) << \"\\\" at \" << n << '\\n';\n    }\n}\n \nint main()\n{\n    std::string::size_type n;\n    std::string const s = \"This is a string\";\n \n    // search backwards from end of string\n    n = s.rfind(\"is\");\n    print(n, s);\n    // search backwards from position 4\n    n = s.rfind(\"is\", 4);\n    print(n, s);\n    // find a single character\n    n = s.rfind('s');\n    print(n, s);\n    // find a single character\n    n = s.rfind('q');\n    print(n, s);\n}",
            "output": "found: \"is a string\" at 5\nfound: \"is is a string\" at 2\nfound: \"string\" at 10\nnot found"
        }
    },
    "basic_string::find_first_of": {
        "description": {
            "texte": "Finds the first character equal to one of the characters in the given character sequence. The search considers only the interval [pos, size()). If the character is not present in the interval, npos will be returned."
        },
        "parametres": "   str   -   string identifying characters to search for \n   pos   -   position at which to begin searching \n   count   -   length of character string identifying characters to search for \n   s   -   pointer to a character string identifying characters to search for \n   ch   -   character to search for \n   t   -   object (convertible to std::basic_string_view) identifying characters to search for \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n \nint main()\n{\n    // the test string\n    std::string str = std::string(\"Hello World!\");\n \n    // strings and chars to search for\n    std::string search_str = std::string(\"o\");\n    const char* search_cstr = \"Good Bye!\";\n \n    std::cout << str.find_first_of(search_str) << '\\n';\n    std::cout << str.find_first_of(search_str, 5) << '\\n';\n    std::cout << str.find_first_of(search_cstr) << '\\n';\n    std::cout << str.find_first_of(search_cstr, 0, 4) << '\\n';\n    // 'x' is not in \"Hello World', thus it will return std::string::npos\n    std::cout << str.find_first_of('x') << '\\n';\n}",
            "output": "4\n7\n1\n4\n18446744073709551615"
        }
    },
    "basic_string::find_first_not_of": {
        "description": {
            "texte": "Finds the first character equal to none of the characters in the given character sequence. The search considers only the interval [pos, size()). If the character is not present in the interval, npos will be returned.In all cases, equality is checked by calling Traits::eq."
        },
        "parametres": "   str   -   string identifying characters to search for \n   pos   -   position for the seach to start from \n   count   -   length of character string identifying characters to search for \n   s   -   pointer to a character string identifying characters to search for \n   ch   -   character identifying characters to search for \n   t   -   object (convertible to std::basic_string_view) identifying characters to search for \n\n",
        "exemple": {
            "input": "#include <string>\n#include <iostream>\n \nint main() {\n    std::string to_search = \"Some data with %MACROS to substitute\";\n \n    std::cout << \"Before: \" << to_search << '\\n';\n \n    auto pos = std::string::npos;\n    while ((pos = to_search.find('%')) != std::string::npos) {\n        // Permit uppercase letters, lowercase letters and numbers in macro names\n        const auto after = to_search.find_first_not_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", pos + 1);\n \n        // Now to_search[pos] == '%' and to_search[after] == ' ' (after the 'S')\n \n        if(after != std::string::npos)\n            to_search.replace(pos, after - pos, \"some very nice macros\");\n    }\n \n    std::cout << \"After: \" << to_search << '\\n';\n}",
            "output": "Before: Some data with %MACROS to substitute\nAfter: Some data with some very nice macros to substitute"
        }
    },
    "basic_string::find_last_of": {
        "description": {
            "texte": "Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the interval [0, pos]. If the character is not present in the interval, npos will be returned.In all cases, equality is checked by calling Traits::eq."
        },
        "parametres": "   str   -   string identifying characters to search for \n   pos   -   position at which the search is to finish \n   count   -   length of character string identifying characters to search for \n   s   -   pointer to a character string identifying characters to search for \n   ch   -   character to search for \n   t   -   object (convertible to std::basic_string_view) identifying characters to search for \n\n",
        "exemple": {
            "input": "#include<string>\n#include<iostream>\nint main()\n{\n    const std::string path=\"/root/config\";\n    auto const pos=path.find_last_of('/');\n    const auto leaf=path.substr(pos+1);\n \n    std::cout << leaf << '\\n';\n}",
            "output": "config"
        }
    },
    "basic_string::find_last_not_of": {
        "description": {
            "texte": "Finds the last character equal to none of the characters in the given character sequence. The search considers only the interval [0, pos]. If the character is not present in the interval, npos will be returned.In all cases, equality is checked by calling Traits::eq."
        },
        "parametres": "   str   -   string identifying characters to search for \n   pos   -   position at which to begin searching \n   count   -   length of character string identifying characters to search for \n   s   -   pointer to a character string identifying characters to search for \n   ch   -   character identifying characters to search for \n   t   -   object (convertible to std::basic_string_view) identifying characters to search for \n\n"
    },
    "basic_string::npos": {
        "description": {
            "texte": "This is a special value equal to the maximum value representable by the type size_type. The exact meaning depends on context, but it is generally used either as end of string indicator by the functions that expect a string index or as the error indicator by the functions that return a string index."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <bitset>\n#include <string>\n \nint main()\n{\n    // string search functions return npos if nothing is found\n    std::string s = \"test\";\n    if(s.find('a') == std::string::npos)\n        std::cout << \"no 'a' in 'test'\\n\";\n \n    // functions that take string subsets as arguments \n    // use npos as the \"all the way to the end\" indicator\n    std::string s2(s, 2, std::string::npos);\n    std::cout << s2 << '\\n';\n \n    std::bitset<5> b(\"aaabb\", std::string::npos, 'a', 'b');\n    std::cout << b << '\\n';\n}",
            "output": "no 'a' in 'test'\nst\n00011"
        }
    },
    "hash (std::string, std::wstring, std::u16string, std::u32string, std::pmr::string, std::pmr::wstring, std::pmr::u16string, std::pmr::u32string)\n": {
        "description": {
            "texte": "The template specializations of std::hash for the various string classes allow users to obtain hashes of strings."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <functional>\n \nint main()\n{\n    std::string s = \"Stand back! I've got jimmies!\";\n    std::hash<std::string> hash_fn;\n \n    size_t hash = hash_fn(s);\n \n    std::cout << hash << '\\n';\n}",
            "output": "325378910"
        }
    },
    "deduction guides for std::basic_string\n": {
        "description": {
            "texte": "Note: the extent to which the library determines that a type does not satisfy LegacyInputIterator is unspecified, except that as a minimum integral types do not qualify as input iterators. Likewise, the extent to which it determines that a type does not satisfy Allocator is unspecified, except that as a minimum the member type Alloc::value_type must exist and the expression std::declval<Alloc&>().allocate(std::size_t{}) must be well-formed when treated as an unevaluated operand."
        },
        "exemple": {
            "input": "#include <string>\n#include <vector>\nint main() {\n   std::vector<char> v = {'a', 'b', 'c'};\n   std::basic_string s(v.begin(), v.end()); // uses explicit deduction guide\n}"
        }
    },
    "basic_string_view::operator=": {
        "description": {
            "texte": "Replaces the view with that of view."
        },
        "parametres": "   view   -   view to copy \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string_view>\nint main()\n{\n    std::string_view v = \"Hello, world\";\n    v = v.substr(7);\n    std::cout << v << '\\n';\n}",
            "output": "world"
        }
    },
    "basic_string_view::begin, std::basic_string_view::cbegin": {
        "description": {
            "texte": "Returns an iterator to the first character of the view."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string_view>\n \nint main()\n{\n    std::string_view str_view(\"abcd\");\n \n    auto begin = str_view.begin();\n    auto cbegin = str_view.cbegin();\n \n    std::cout << *begin << '\\n';\n    std::cout << *cbegin << '\\n';\n \n    std::cout << std::boolalpha << (begin == cbegin) << '\\n';\n    std::cout << std::boolalpha << (*begin == *cbegin) << '\\n';\n}",
            "output": "a\na\ntrue\ntrue"
        }
    },
    "basic_string_view::end, std::basic_string_view::cend": {
        "description": {
            "texte": "Returns an iterator to the character following the last character of the view. This character acts as a placeholder, attempting to access it results in undefined behavior."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n#include <string_view>\n \nint main()\n{\n    std::string_view str_view(\"abcd\");\n \n    auto end = str_view.end();\n    auto cend = str_view.cend();\n \n    std::cout << *std::prev(end) << '\\n';\n    std::cout << *std::prev(cend) << '\\n';\n \n    std::cout << std::boolalpha << (end == cend) << '\\n';\n}",
            "output": "d\nd\ntrue"
        }
    },
    "basic_string_view::rbegin, std::basic_string_view::crbegin": {
        "description": {
            "texte": "Returns a reverse iterator to the first character of the reversed view. It corresponds to the last character of the non-reversed view."
        },
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <string_view>\n \nint main()\n{\n    std::ostream_iterator<char> out_it(std::cout);\n    std::string_view str_view(\"abcdef\");\n \n    std::copy(str_view.rbegin(), std::next(str_view.rbegin(), 3), out_it);\n    *out_it = '\\n';\n \n    std::copy(str_view.crbegin(), std::next(str_view.crbegin(), 3), out_it);\n    *out_it = '\\n';\n}",
            "output": "fed\nfed"
        }
    },
    "basic_string_view::rend, std::basic_string_view::crend": {
        "description": {
            "texte": "Returns a reverse iterator to the character following the last character of the reversed view. It corresponds to the character preceding the first character of the non-reversed view. This character acts as a placeholder, attempting to access it results in undefined behavior."
        },
        "exemple": {
            "input": "#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <string_view>\n \nint main()\n{\n    std::ostream_iterator<char> out_it(std::cout);\n    std::string_view str_view(\"abcdef\");\n \n    std::copy(str_view.rbegin(), str_view.rend(), out_it);\n    *out_it = '\\n';\n \n    std::copy(str_view.crbegin(), str_view.crend(), out_it);\n    *out_it = '\\n';\n}",
            "output": "fedcba\nfedcba"
        }
    },
    "basic_string_view::at": {
        "description": {
            "texte": "Returns a reference to the character at specified location pos. Bounds checking is performed, exception of type std::out_of_range will be thrown on invalid access."
        },
        "parametres": "   pos   -   position of the character to return \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <stdexcept>\n#include <string_view>\n \nint main()\n{\n    std::string_view str_view(\"abcdef\");\n \n    try {\n        for (std::size_t i = 0; true; ++i)\n            std::cout << i << \": \" << str_view.at(i) << '\\n';\n    }\n    catch (const std::out_of_range& e) {\n        std::cout << \"Whooops. Index is out of range.\\n\";\n        std::cout << e.what() << '\\n';\n    }\n}",
            "output": "0: a\n1: b\n2: c\n3: d\n4: e\n5: f\n6: Whooops. Index is out of range.\nbasic_string_view::at: __pos (which is 6) >= this->size() (which is 6)"
        }
    },
    "basic_string_view::operator[]": {
        "description": {
            "texte": "Returns a const reference to the character at specified location pos.No bounds checking is performed: the behavior is undefined if pos >= size()."
        },
        "parametres": "   pos   -   position of the character to return \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string_view>\nint main()\n{\n    std::string str = \"Exemplar\";\n    std::string_view v = str;\n    std::cout << v[2] << '\\n';\n//  v[2] = 'y'; // Error: cannot modify through a string view\n    str[2] = 'y';\n    std::cout << v[2] << '\\n';\n}",
            "output": "e\ny"
        }
    },
    "basic_string_view::front": {
        "description": {
            "texte": "Returns reference to the first character in the view. The behavior is undefined if empty() == true."
        }
    },
    "basic_string_view::back": {
        "description": {
            "texte": "Returns reference to the last character in the view. The behavior is undefined if empty() == true."
        }
    },
    "basic_string_view::data": {
        "description": {
            "texte": "Returns a pointer to the underlying character array. The pointer is such that the range [data(); data() + size()) is valid and the values in it correspond to the values of the view."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <cstring>\n#include <cwchar>\n#include <string>\n#include <string_view>\nint main()\n{\n    std::wstring_view wcstr_v = L\"xyzzy\";\n    std::cout << std::wcslen(wcstr_v.data()) << '\\n';\n    // OK: the underlying character array is null-terminated\n \n    char array[3] = {'B', 'a', 'r'};\n    std::string_view array_v(array, sizeof array);\n    // std::cout << std::strlen(array_v.data()) << '\\n';\n    // error: the underlying character array is not null-terminated\n \n    std::string str(array_v.data(), array_v.size()); // OK\n    std::cout << std::strlen(str.data()) << '\\n';\n    // OK: the underlying character array of a std::string is always null-terminated\n}",
            "output": "5\n3"
        }
    },
    "basic_string_view::size, std::basic_string_view::length": {
        "description": {
            "texte": "Returns the number of CharT elements in the view, i.e. std::distance(begin(), end())."
        },
        "exemple": {
            "input": "#include <string_view>\n#include <iostream>\n \nvoid check_string(std::string_view ref)\n{\n        // Print a string surrounded by single quotes, its length\n        // and whether it is considered empty.\n        std::cout << std::boolalpha\n                  << \"'\" << ref << \"' has \" << ref.size()\n                  << \" character(s); emptiness: \" << ref.empty() << '\\n';\n}\n \nint main(int argc, char **argv)\n{\n        // An empty string\n        check_string(\"\");\n \n        // Almost always not empty: argv[0]\n        if (argc > 0)\n                check_string(argv[0]);\n}",
            "output": "'' has 0 character(s); emptiness: true\n'./a.out' has 7 character(s); emptiness: false"
        }
    },
    "basic_string_view::max_size": {
        "description": {
            "texte": "The largest possible number of char-like objects that can be referred to by a basic_string_view."
        }
    },
    "basic_string_view::empty": {
        "description": {
            "texte": "Checks if the view has no characters, i.e. whether size() == 0."
        },
        "exemple": {
            "input": "#include <string_view>\n#include <iostream>\n \nvoid check_string(std::string_view ref)\n{\n        // Print a string surrounded by single quotes, its length\n        // and whether it is considered empty.\n        std::cout << std::boolalpha\n                  << \"'\" << ref << \"' has \" << ref.size()\n                  << \" character(s); emptiness: \" << ref.empty() << '\\n';\n}\n \nint main(int argc, char **argv)\n{\n        // An empty string\n        check_string(\"\");\n \n        // Almost always not empty: argv[0]\n        if (argc > 0)\n                check_string(argv[0]);\n}",
            "output": "'' has 0 character(s); emptiness: true\n'./a.out' has 7 character(s); emptiness: false"
        }
    },
    "basic_string_view::remove_prefix": {
        "description": {
            "texte": "Moves the start of the view forward by n characters.The behavior is undefined if n > size()."
        },
        "parametres": "   n   -   number of characters to remove from the start of the view \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <algorithm>\n#include <string_view>\nint main()\n{\n    std::string str = \"   trim me\";\n    std::string_view v = str;\n    v.remove_prefix(std::min(v.find_first_not_of(\" \"), v.size()));\n    std::cout << \"String: '\" << str << \"'\\n\"\n              << \"View  : '\" << v << \"'\\n\";\n}",
            "output": "String: '   trim me'\nView  : 'trim me'"
        }
    },
    "basic_string_view::remove_suffix": {
        "description": {
            "texte": "Moves the end of the view back by n characters.The behavior is undefined if n > size()."
        },
        "parametres": "   n   -   number of characters to remove from the end of the view \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string_view>\nint main()\n{\n    char arr[] = {'a', 'b', 'c', 'd', '\\0', '\\0', '\\0'};\n    std::string_view v(arr, sizeof arr);\n    auto trim_pos = v.find('\\0');\n    if(trim_pos != v.npos)\n        v.remove_suffix(v.size() - trim_pos);\n    std::cout << \"Array: '\" << arr << \"', size=\" << sizeof arr << '\\n'\n              << \"View : '\" << v << \"', size=\" << v.size() << '\\n';\n}",
            "output": "Array: 'abcd', size=7\nView : 'abcd', size=4"
        }
    },
    "basic_string_view::swap": {
        "description": {
            "texte": "Exchanges the view with that of v."
        },
        "parametres": "   v   -   view to swap with \n\n"
    },
    "basic_string_view::copy": {
        "description": {
            "texte": "Copies the substring [pos, pos + rcount) to the character array pointed to by dest, where rcount is the smaller of count and size() - pos.Equivalent to Traits::copy(dest, data() + pos, rcount)."
        },
        "parametres": "   dest   -   pointer to the destination character string \n   pos   -   position of the first character \n   count   -   requested substring length \n\n"
    },
    "basic_string_view::substr": {
        "description": {
            "texte": "Returns a view of the substring [pos, pos + rcount), where rcount is the smaller of count and size() - pos."
        },
        "parametres": "   pos   -   position of the first character \n   count   -   requested length \n\n"
    },
    "basic_string_view::compare": {
        "description": {
            "texte": "Compares two character sequences."
        },
        "parametres": "   v   -   view to compare \n   s   -   pointer to the character string to compare to \n   count1   -   number of characters of this view to compare \n   pos1   -   position of the first character in this view to compare \n   count2   -   number of characters of the given view to compare \n   pos2   -   position of the first character of the given view to compare \n\n"
    },
    "basic_string_view::starts_with": {
        "description": {
            "texte": "Checks if the string view begins with the given prefix, where."
        },
        "parametres": "   x   -   a character sequence or a single character to compare to the start of the string view \n\n"
    },
    "basic_string_view::ends_with": {
        "description": {
            "texte": "Checks if the string view ends with the given suffix, where."
        },
        "parametres": "   x   -   a character sequence or a single character to compare to the end of the string view \n\n"
    },
    "basic_string_view::find": {
        "description": {
            "texte": "Finds the first substring equal to the given character sequence."
        },
        "parametres": "   v   -   view to search for \n   pos   -   position at which to start the search \n   count   -   length of substring to search for \n   s   -   pointer to a character string to search for \n   ch   -   character to search for \n\n"
    },
    "basic_string_view::rfind": {
        "description": {
            "texte": "Finds the last substring equal to the given character sequence."
        },
        "parametres": "   v   -   view to search for \n   pos   -   position at which to start the search \n   count   -   length of substring to search for \n   s   -   pointer to a character string to search for \n   ch   -   character to search for \n\n"
    },
    "basic_string_view::find_first_of": {
        "description": {
            "texte": "Finds the first character equal to any of the characters in the given character sequence."
        },
        "parametres": "   v   -   view to search for \n   pos   -   position at which to start the search \n   count   -   length of the string of characters to search for \n   s   -   pointer to a string of characters to search for \n   ch   -   character to search for \n\n"
    },
    "basic_string_view::find_last_of": {
        "description": {
            "texte": "Finds the last character equal to one of characters in the given character sequence. Exact search algorithm is not specified. The search considers only the interval [0; pos]. If the character is not present in the interval, npos will be returned."
        },
        "parametres": "   v   -   view to search for \n   pos   -   position at which the search is to finish \n   count   -   length of the string of characters to search for \n   s   -   pointer to a string of characters to search for \n   ch   -   character to search for \n\n"
    },
    "basic_string_view::find_first_not_of": {
        "description": {
            "texte": "Finds the first character not equal to any of the characters in the given character sequence."
        },
        "parametres": "   v   -   view to search for \n   pos   -   position at which to start the search \n   count   -   length of the string of characters to compare \n   s   -   pointer to a string of characters to compare \n   ch   -   character to compare \n\n"
    },
    "basic_string_view::find_last_not_of": {
        "description": {
            "texte": "Finds the last character not equal to any of the characters in the given character sequence."
        },
        "parametres": "   v   -   view to search for \n   pos   -   position at which to start the search \n   count   -   length of the string of characters to compare \n   s   -   pointer to a string of characters to compare \n   ch   -   character to compare \n\n"
    },
    "literals::string_view_literals::operator\"\"sv": {
        "description": {
            "texte": "Forms a string view of a character literal."
        },
        "parametres": "   str   -   pointer to the beginning of the raw character array literal \n   len   -   length of the raw character array literal \n\n",
        "exemple": {
            "input": "#include <string_view>\n#include <iostream>\n \nint main()\n{\n    using namespace std::literals;\n \n    std::string_view s1 = \"abc\\0\\0def\";\n    std::string_view s2 = \"abc\\0\\0def\"sv;\n    std::cout << \"s1: \" << s1.size() << \" \\\"\" << s1 << \"\\\"\\n\";\n    std::cout << \"s2: \" << s2.size() << \" \\\"\" << s2 << \"\\\"\\n\";\n}",
            "output": "s1: 3 \"abc\"\ns2: 8 \"abc^@^@def\""
        }
    },
    "begin,end(std::basic_string_view)\n": {
        "description": {
            "texte": "These functions are not visible to ordinary unqualified or qualified lookup, and can only be found by argument-dependent lookup when std::basic_string_view<CharT, Traits> is an associated class of the arguments."
        },
        "parametres": "   sv   -   a string_view \n\n"
    },
    "array::fill": {
        "description": {
            "texte": "Assigns the given value value to all elements in the container."
        },
        "parametres": "   value   -   the value to assign to the elements \n\n"
    },
    "deduction guides for std::array\n": {
        "description": {
            "texte": "One deduction guide is provided for std::array to provide an equivalent of std::experimental::make_array for construction of std::array from a variadic parameter pack.The program is ill-formed if (std::is_same_v<T, U> && ...) is not true."
        },
        "exemple": {
            "input": "#include <array>\nint main()\n{\n    int const x = 10;\n    std::array a{1, 2, 3, 5, x}; // OK, creates std::array<int, 5>\n \n//  std::array b{1, 2u}; // Error, all arguments must have same type\n}"
        }
    },
    "deduction guides for std::vector\n": {
        "description": {
            "texte": "This deduction guide is provided for vector to allow deduction from an iterator range. This overload only participates in overload resolution if InputIt satisfies LegacyInputIterator and Alloc satisfies Allocator.Note: the extent to which the library determines that a type does not satisfy LegacyInputIterator is unspecified, except that as a minimum integral types do not qualify as input iterators. Likewise, the extent to which it determines that a type does not satisfy Allocator is unspecified, except that as a minimum the member type Alloc::value_type must exist and the expression std::declval<Alloc&>().allocate(std::size_t{}) must be well-formed when treated as an unevaluated operand."
        },
        "exemple": {
            "input": "#include <vector>\n \nint main() {\n   std::vector<int> v = {1, 2, 3, 4};\n \n   // uses explicit deduction guide to deduce std::vector<int>\n   std::vector x(v.begin(), v.end()); \n \n   // deduces std::vector<std::vector<int>::iterator>\n   // first phase of overload resolution for list-initialization selects the candidate\n   // synthesized from the initializer-list constructor; second phase is not performed and\n   // deduction guide has no effect\n   std::vector y{v.begin(), v.end()}; \n}"
        }
    },
    "deduction guides for std::deque\n": {
        "description": {
            "texte": "This deduction guide is provided for deque to allow deduction from an iterator range. This overload only participates in overload resolution if InputIt satisfies LegacyInputIterator and Alloc satisfies Allocator.Note: the extent to which the library determines that a type does not satisfy LegacyInputIterator is unspecified, except that as a minimum integral types do not qualify as input iterators. Likewise, the extent to which it determines that a type does not satisfy Allocator is unspecified, except that as a minimum the member type Alloc::value_type must exist and the expression std::declval<Alloc&>().allocate(std::size_t{}) must be well-formed when treated as an unevaluated operand."
        },
        "exemple": {
            "input": "#include <deque>\n#include <vector>\nint main() {\n   std::vector<int> v = {1, 2, 3, 4};\n \n   // uses explicit deduction guide to deduce std::deque<int>\n   std::deque x(v.begin(), v.end()); \n \n   // deduces std::deque<std::vector<int>::iterator>\n   // first phase of overload resolution for list-initialization selects the candidate\n   // synthesized from the initializer-list constructor; second phase is not performed and\n   // deduction guide has no effect\n   std::deque y{v.begin(), v.end()}; \n}"
        }
    },
    "deduction guides for std::list\n": {
        "description": {
            "texte": "This deduction guide is provided for list to allow deduction from an iterator range. This overload only participates in overload resolution if InputIt satisfies LegacyInputIterator and Alloc satisfies Allocator.Note: the extent to which the library determines that a type does not satisfy LegacyInputIterator is unspecified, except that as a minimum integral types do not qualify as input iterators. Likewise, the extent to which it determines that a type does not satisfy Allocator is unspecified, except that as a minimum the member type Alloc::value_type must exist and the expression std::declval<Alloc&>().allocate(std::size_t{}) must be well-formed when treated as an unevaluated operand."
        },
        "exemple": {
            "input": "#include <list>\n#include <vector>\nint main() {\n   std::vector<int> v = {1, 2, 3, 4};\n \n   // uses explicit deduction guide to deduce std::list<int>\n   std::list x(v.begin(), v.end()); \n \n   // deduces std::list<std::vector<int>::iterator>\n   // first phase of overload resolution for list-initialization selects the candidate\n   // synthesized from the initializer-list constructor; second phase is not performed and\n   // deduction guide has no effect\n   std::list y{v.begin(), v.end()}; \n}"
        }
    },
    "forward_list::before_begin, cbefore_begin": {
        "description": {
            "texte": "Returns an iterator to the element before the first element of the container. This element acts as a placeholder, attempting to access it results in undefined behavior. The only usage cases are in functions insert_after(), emplace_after(), erase_after(), splice_after() and the increment operator: incrementing the before-begin iterator gives exactly the same iterator as obtained from begin()/cbegin()."
        }
    },
    "deduction guides for std::forward_list\n": {
        "description": {
            "texte": "This deduction guide is provided for forward_list to allow deduction from an iterator range. This overload only participates in overload resolution if InputIt satisfies LegacyInputIterator and Alloc satisfies Allocator.Note: the extent to which the library determines that a type does not satisfy LegacyInputIterator is unspecified, except that as a minimum integral types do not qualify as input iterators. Likewise, the extent to which it determines that a type does not satisfy Allocator is unspecified, except that as a minimum the member type Alloc::value_type must exist and the expression std::declval<Alloc&>().allocate(std::size_t{}) must be well-formed when treated as an unevaluated operand."
        },
        "exemple": {
            "input": "#include <forward_list>\n#include <vector>\nint main() {\n   std::vector<int> v = {1, 2, 3, 4};\n \n   // uses explicit deduction guide to deduce std::forward_list<int>\n   std::forward_list x(v.begin(), v.end()); \n \n   // deduces std::forward_list<std::vector<int>::iterator>\n   // first phase of overload resolution for list-initialization selects the candidate\n   // synthesized from the initializer-list constructor; second phase is not performed and\n   // deduction guide has no effect\n   std::forward_list y{v.begin(), v.end()}; \n}"
        }
    },
    "deduction guides for std::set\n": {
        "description": {
            "texte": "These deduction guides are provided for set to allow deduction from an iterator range (overloads (1,3)) and std::initializer_list (overloads (2,4)). These overloads only participate in overload resolution if InputIt satisfies LegacyInputIterator, Alloc satisfies Allocator, and Comp does not satisfy Allocator.Note: the extent to which the library determines that a type does not satisfy LegacyInputIterator is unspecified, except that as a minimum integral types do not qualify as input iterators. Likewise, the extent to which it determines that a type does not satisfy Allocator is unspecified, except that as a minimum the member type Alloc::value_type must exist and the expression std::declval<Alloc&>().allocate(std::size_t{}) must be well-formed when treated as an unevaluated operand."
        },
        "exemple": {
            "input": "#include <set>\nint main() {\n   std::set s = {1,2,3,4}; // guide #2 deduces std::set<int>\n   std::set s2(s.begin(), s.end()); // guide #1 deduces std::set<int>\n}"
        }
    },
    "erase_if (std::set)\n": {
        "description": {
            "texte": "Erases all elements that satisfy the predicate pred from the container. Equivalent to.",
            "code": "for (auto i = c.begin(), last = c.end(); i != last; ) {\n  if (pred(*i)) {\n    i = c.erase(i);\n  } else {\n    ++i;\n  }\n}"
        },
        "parametres": "   c   -   container from which to erase \n   pred   -   predicate that returns true if the element should be erased \n\n"
    },
    "deduction guides for std::multiset\n": {
        "description": {
            "texte": "These deduction guides are provided for multiset to allow deduction from an iterator range (overloads (1,3)) and std::initializer_list (overloads (2,4)). These overloads only participate in overload resolution if InputIt satisfies LegacyInputIterator, Alloc satisfies Allocator, and Comp does not satisfy Allocator.Note: the extent to which the library determines that a type does not satisfy LegacyInputIterator is unspecified, except that as a minimum integral types do not qualify as input iterators. Likewise, the extent to which it determines that a type does not satisfy Allocator is unspecified, except that as a minimum the member type Alloc::value_type must exist and the expression std::declval<Alloc&>().allocate(std::size_t{}) must be well-formed when treated as an unevaluated operand."
        },
        "exemple": {
            "input": "#include <set>\nint main() {\n   std::multiset s = {1,2,3,4}; // guide #2 deduces std::multiset<int>\n   std::multiset s2(s.begin(), s.end()); // guide #1 deduces std::multiset<int>\n}"
        }
    },
    "erase_if (std::multiset)\n": {
        "description": {
            "texte": "Erases all elements that satisfy the predicate pred from the container. Equivalent to.",
            "code": "for (auto i = c.begin(), last = c.end(); i != last; ) {\n  if (pred(*i)) {\n    i = c.erase(i);\n  } else {\n    ++i;\n  }\n}"
        },
        "parametres": "   c   -   container from which to erase \n   pred   -   predicate that returns true if the element should be erased \n\n"
    },
    "deduction guides for std::map\n": {
        "description": {
            "texte": "where the type aliases iter_key_t, iter_val_t, iter_to_alloc_t are defined as if as follows.This deduction guide is provided for map to allow deduction from an iterator range (overloads (1,3)) and std::initializer_list (overloads (2,4)). These overloads only participate in overload resolution if InputIt satisfies LegacyInputIterator, Alloc satisfies Allocator, and Comp does not satisfy Allocator.Note: the extent to which the library determines that a type does not satisfy LegacyInputIterator is unspecified, except that as a minimum integral types do not qualify as input iterators. Likewise, the extent to which it determines that a type does not satisfy Allocator is unspecified, except that as a minimum the member type Alloc::value_type must exist and the expression std::declval<Alloc&>().allocate(std::size_t{}) must be well-formed when treated as an unevaluated operand."
        },
        "exemple": {
            "input": "#include <map>\nint main() {\n// std::map m1 = {{\"foo\", 1}, {\"bar\", 2}}; // Error: braced-init-list has no type;\n                                           // cannot deduce pair<Key, T> from\n                                           // {\"foo\", 1} or {\"bar\", 2}\n \n   std::map m1 = {std::pair{\"foo\", 2}, {\"bar\", 3}}; // guide #2\n   std::map m2(m1.begin(), m1.end()); // guide #1\n}"
        }
    },
    "map::value_compare": {
        "description": {
            "texte": "std::map::value_compare is a function object that compares objects of type std::map::value_type (key-value pairs) by comparing of the first components of the pairs."
        },
        "parametres": "   c   -   comparator to assign \n\n"
    },
    "erase_if (std::map)\n": {
        "description": {
            "texte": "Erases all elements that satisfy the predicate pred from the container. Equivalent to.",
            "code": "for (auto i = c.begin(), last = c.end(); i != last; ) {\n  if (pred(*i)) {\n    i = c.erase(i);\n  } else {\n    ++i;\n  }\n}"
        },
        "parametres": "   c   -   container from which to erase \n   pred   -   predicate that returns true if the element should be erased \n\n"
    },
    "deduction guides for std::multimap\n": {
        "description": {
            "texte": "where the type aliases iter_key_t, iter_val_t, iter_to_alloc_t are defined as if as follows.This deduction guide is provided for multimap to allow deduction from an iterator range (overloads (1,3)) and std::initializer_list (overloads (2,4)). These overloads only participate in overload resolution if InputIt satisfies LegacyInputIterator, Alloc satisfies Allocator, and Comp does not satisfy Allocator.Note: the extent to which the library determines that a type does not satisfy LegacyInputIterator is unspecified, except that as a minimum integral types do not qualify as input iterators. Likewise, the extent to which it determines that a type does not satisfy Allocator is unspecified, except that as a minimum the member type Alloc::value_type must exist and the expression std::declval<Alloc&>().allocate(std::size_t{}) must be well-formed when treated as an unevaluated operand."
        },
        "exemple": {
            "input": "#include <map>\nint main() {\n// std::multimap m1 = {{\"foo\", 1}, {\"bar\", 2}}; // Error: braced-init-list has no type;\n                                                // cannot deduce pair<Key, T> from\n                                                // {\"foo\", 1} or {\"bar\", 2}\n \n   std::multimap m1 = {std::pair{\"foo\", 2}, {\"bar\", 3}}; // guide #2\n   std::multimap m2(m1.begin(), m1.end()); // guide #1\n}"
        }
    },
    "multimap::value_compare": {
        "description": {
            "texte": "std::multimap::value_compare is a function object that compares objects of type std::multimap::value_type (key-value pairs) by comparing of the first components of the pairs."
        },
        "parametres": "   c   -   comparator to assign \n\n"
    },
    "erase_if (std::multimap)\n": {
        "description": {
            "texte": "Erases all elements that satisfy the predicate pred from the container. Equivalent to.",
            "code": "for (auto i = c.begin(), last = c.end(); i != last; ) {\n  if (pred(*i)) {\n    i = c.erase(i);\n  } else {\n    ++i;\n  }\n}"
        },
        "parametres": "   c   -   container from which to erase \n   pred   -   predicate that returns true if the element should be erased \n\n"
    },
    "unordered_set::begin(size_type), std::unordered_set::cbegin(size_type)": {
        "description": {
            "texte": "Returns an iterator to the first element of the bucket with index n."
        },
        "parametres": "   n   -   the index of the bucket to access \n\n"
    },
    "unordered_set::end(size_type), std::unordered_set::cend(size_type)": {
        "description": {
            "texte": "Returns an iterator to the element following the last element of the bucket with index n. . This element acts as a placeholder, attempting to access it results in undefined behavior."
        },
        "parametres": "   n   -   the index of the bucket to access \n\n"
    },
    "unordered_set::max_bucket_count": {
        "description": {
            "texte": "Returns the maximum number of buckets the container is able to hold due to system or library implementation limitations."
        }
    },
    "unordered_set::bucket_size": {
        "description": {
            "texte": "Returns the number of elements in the bucket with index n."
        },
        "parametres": "   n   -   the index of the bucket to examine \n\n"
    },
    "unordered_set::bucket": {
        "description": {
            "texte": "Returns the index of the bucket for key key. Elements (if any) with keys equivalent to key are always found in this bucket. The returned value is valid only for instances of the container for which bucket_count() returns the same value.The behavior is undefined if bucket_count() is zero."
        },
        "parametres": "   key   -   the value of the key to examine \n\n"
    },
    "unordered_set::load_factor": {
        "description": {
            "texte": "Returns the average number of elements per bucket, that is, size() divided by bucket_count()."
        }
    },
    "unordered_set::max_load_factor": {
        "description": {
            "texte": "Manages the maximum load factor (number of elements per bucket). The container automatically increases the number of buckets if the load factor exceeds this threshold.1) Returns current maximum load factor.2) Sets the maximum load factor to ml."
        },
        "parametres": "   ml   -   new maximum load factor setting \n\n"
    },
    "unordered_set::rehash": {
        "description": {
            "texte": "Sets the number of buckets to count and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. If the new number of buckets makes load factor more than maximum load factor (count < size() / max_load_factor()), then the new number of buckets is at least size() / max_load_factor()."
        },
        "parametres": "   count   -   new number of buckets \n\n"
    },
    "deduction guides for std::unordered_set\n": {
        "description": {
            "texte": "These deduction guides are provided for unordered_set to allow deduction from an iterator range (overloads (1,3,4)) and std::initializer_list (overloads (2,5.6)). This overload only participates in overload resolution if InputIt satisfies LegacyInputIterator, Alloc satisfies Allocator, neither Hash nor Pred satisfy Allocator, Hash is not an integral type.Note: the extent to which the library determines that a type does not satisfy LegacyInputIterator is unspecified, except that as a minimum integral types do not qualify as input iterators. Likewise, the extent to which it determines that a type does not satisfy Allocator is unspecified, except that as a minimum the member type Alloc::value_type must exist and the expression std::declval<Alloc&>().allocate(std::size_t{}) must be well-formed when treated as an unevaluated operand.The size_type parameter type in these guides refers to the size_type member type of the type deduced by the deduction guide."
        },
        "exemple": {
            "input": "#include <unordered_set>\nint main() {\n   std::unordered_set s = {1,2,3,4};            // guide #2 deduces std::unordered_set<int>\n   std::unordered_set s2(s.begin(), s.end());   // guide #1 deduces std::unordered_set<int>\n}"
        }
    },
    "erase_if (std::unordered_set)\n": {
        "description": {
            "texte": "Erases all elements that satisfy the predicate pred from the container. Equivalent to.",
            "code": "for (auto i = c.begin(), last = c.end(); i != last; ) {\n  if (pred(*i)) {\n    i = c.erase(i);\n  } else {\n    ++i;\n  }\n}"
        },
        "parametres": "   c   -   container from which to erase \n   pred   -   predicate that returns true if the element should be erased \n\n"
    },
    "unordered_multiset::begin(size_type), std::unordered_multiset::cbegin(size_type)": {
        "description": {
            "texte": "Returns an iterator to the first element of the bucket with index n."
        },
        "parametres": "   n   -   the index of the bucket to access \n\n"
    },
    "unordered_multiset::end(size_type), std::unordered_multiset::cend(size_type)": {
        "description": {
            "texte": "Returns an iterator to the element following the last element of the bucket with index n. . This element acts as a placeholder, attempting to access it results in undefined behavior."
        },
        "parametres": "   n   -   the index of the bucket to access \n\n"
    },
    "unordered_multiset::max_bucket_count": {
        "description": {
            "texte": "Returns the maximum number of buckets the container is able to hold due to system or library implementation limitations."
        }
    },
    "unordered_multiset::bucket_size": {
        "description": {
            "texte": "Returns the number of elements in the bucket with index n."
        },
        "parametres": "   n   -   the index of the bucket to examine \n\n"
    },
    "unordered_multiset::bucket": {
        "description": {
            "texte": "Returns the index of the bucket for key key. Elements (if any) with keys equivalent to key are always found in this bucket. The returned value is valid only for instances of the container for which bucket_count() returns the same value.The behavior is undefined if bucket_count() is zero."
        },
        "parametres": "   key   -   the value of the key to examine \n\n"
    },
    "unordered_multiset::load_factor": {
        "description": {
            "texte": "Returns the average number of elements per bucket, that is, size() divided by bucket_count()."
        }
    },
    "unordered_multiset::max_load_factor": {
        "description": {
            "texte": "Manages the maximum load factor (number of elements per bucket). The container automatically increases the number of buckets if the load factor exceeds this threshold.1) Returns current maximum load factor.2) Sets the maximum load factor to ml."
        },
        "parametres": "   ml   -   new maximum load factor setting \n\n"
    },
    "unordered_multiset::rehash": {
        "description": {
            "texte": "Sets the number of buckets to count and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. If the new number of buckets makes load factor more than maximum load factor (count < size() / max_load_factor()), then the new number of buckets is at least size() / max_load_factor()."
        },
        "parametres": "   count   -   new number of buckets \n\n"
    },
    "deduction guides for std::unordered_multiset\n": {
        "description": {
            "texte": "These deduction guides are provided for unordered_multiset to allow deduction from an iterator range (overloads (1,3,4)) and std::initializer_list (overloads (2,5.6)). This overload only participates in overload resolution if InputIt satisfies LegacyInputIterator, Alloc satisfies Allocator, neither Hash nor Pred satisfy Allocator, Hash is not an integral type.Note: the extent to which the library determines that a type does not satisfy LegacyInputIterator is unspecified, except that as a minimum integral types do not qualify as input iterators. Likewise, the extent to which it determines that a type does not satisfy Allocator is unspecified, except that as a minimum the member type Alloc::value_type must exist and the expression std::declval<Alloc&>().allocate(std::size_t{}) must be well-formed when treated as an unevaluated operand.The size_type parameter type in these guides refers to the size_type member type of the type deduced by the deduction guide."
        },
        "exemple": {
            "input": "#include <unordered_set>\nint main() {\n   std::unordered_multiset s = {1,2,3,4};            // guide #2 deduces std::unordered_multiset<int>\n   std::unordered_multiset s2(s.begin(), s.end());   // guide #1 deduces std::unordered_multiset<int>\n}"
        }
    },
    "erase_if (std::unordered_multiset)\n": {
        "description": {
            "texte": "Erases all elements that satisfy the predicate pred from the container. Equivalent to.",
            "code": "for (auto i = c.begin(), last = c.end(); i != last; ) {\n  if (pred(*i)) {\n    i = c.erase(i);\n  } else {\n    ++i;\n  }\n}"
        },
        "parametres": "   c   -   container from which to erase \n   pred   -   predicate that returns true if the element should be erased \n\n"
    },
    "unordered_map::begin(size_type), std::unordered_map::cbegin(size_type)": {
        "description": {
            "texte": "Returns an iterator to the first element of the bucket with index n."
        },
        "parametres": "   n   -   the index of the bucket to access \n\n"
    },
    "unordered_map::end(size_type), std::unordered_map::cend(size_type)": {
        "description": {
            "texte": "Returns an iterator to the element following the last element of the bucket with index n. . This element acts as a placeholder, attempting to access it results in undefined behavior."
        },
        "parametres": "   n   -   the index of the bucket to access \n\n"
    },
    "unordered_map::max_bucket_count": {
        "description": {
            "texte": "Returns the maximum number of buckets the container is able to hold due to system or library implementation limitations."
        }
    },
    "unordered_map::bucket_size": {
        "description": {
            "texte": "Returns the number of elements in the bucket with index n."
        },
        "parametres": "   n   -   the index of the bucket to examine \n\n"
    },
    "unordered_map::bucket": {
        "description": {
            "texte": "Returns the index of the bucket for key key. Elements (if any) with keys equivalent to key are always found in this bucket. The returned value is valid only for instances of the container for which bucket_count() returns the same value.The behavior is undefined if bucket_count() is zero."
        },
        "parametres": "   key   -   the value of the key to examine \n\n"
    },
    "unordered_map::load_factor": {
        "description": {
            "texte": "Returns the average number of elements per bucket, that is, size() divided by bucket_count()."
        }
    },
    "unordered_map::max_load_factor": {
        "description": {
            "texte": "Manages the maximum load factor (number of elements per bucket). The container automatically increases the number of buckets if the load factor exceeds this threshold.1) Returns current maximum load factor.2) Sets the maximum load factor to ml."
        },
        "parametres": "   ml   -   new maximum load factor setting \n\n"
    },
    "unordered_map::rehash": {
        "description": {
            "texte": "Sets the number of buckets to count and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. If the new number of buckets makes load factor more than maximum load factor (count < size() / max_load_factor()), then the new number of buckets is at least size() / max_load_factor()."
        },
        "parametres": "   count   -   new number of buckets \n\n"
    },
    "deduction guides for std::unordered_map\n": {
        "description": {
            "texte": "where the type aliases iter_key_t, iter_val_t, iter_to_alloc_t are defined as if as follows.These deduction guide are provided for unordered_map to allow deduction from an iterator range (overloads (1,3-5)) and std::initializer_list (overloads (2,6-8)). These overloads only participate in overload resolution if InputIt satisfies LegacyInputIterator, Alloc satisfies Allocator, neither Hash nor Pred satisfy Allocator, and Hash is not an integral type.Note: the extent to which the library determines that a type does not satisfy LegacyInputIterator is unspecified, except that as a minimum integral types do not qualify as input iterators. Likewise, the extent to which it determines that a type does not satisfy Allocator is unspecified, except that as a minimum the member type Alloc::value_type must exist and the expression std::declval<Alloc&>().allocate(std::size_t{}) must be well-formed when treated as an unevaluated operand.The size_type parameter type in these guides in an refers to the size_type member type of the type deduced by the deduction guide."
        },
        "exemple": {
            "input": "#include <unordered_map>\nint main() {\n// std::unordered_map m1 = {{\"foo\", 1}, {\"bar\", 2}}; // Error: braced-init-list has no type\n                                                     // cannot deduce pair<Key, T> from\n                                                     // {\"foo\", 1} or {\"bar\", 2}\n   std::unordered_map m1 = {std::pair{\"foo\", 2}, {\"bar\", 3}}; // guide #2\n   std::unordered_map m2(m1.begin(), m1.end()); // guide #1\n}"
        }
    },
    "erase_if (std::unordered_map)\n": {
        "description": {
            "texte": "Erases all elements that satisfy the predicate pred from the container. Equivalent to.",
            "code": "for (auto i = c.begin(), last = c.end(); i != last; ) {\n  if (pred(*i)) {\n    i = c.erase(i);\n  } else {\n    ++i;\n  }\n}"
        },
        "parametres": "   c   -   container from which to erase \n   pred   -   predicate that returns true if the element should be erased \n\n"
    },
    "unordered_multimap::begin(size_type), std::unordered_multimap::cbegin(size_type)": {
        "description": {
            "texte": "Returns an iterator to the first element of the bucket with index n."
        },
        "parametres": "   n   -   the index of the bucket to access \n\n"
    },
    "unordered_multimap::end(size_type), std::unordered_multimap::cend(size_type)": {
        "description": {
            "texte": "Returns an iterator to the element following the last element of the bucket with index n. . This element acts as a placeholder, attempting to access it results in undefined behavior."
        },
        "parametres": "   n   -   the index of the bucket to access \n\n"
    },
    "unordered_multimap::max_bucket_count": {
        "description": {
            "texte": "Returns the maximum number of buckets the container is able to hold due to system or library implementation limitations."
        }
    },
    "unordered_multimap::bucket_size": {
        "description": {
            "texte": "Returns the number of elements in the bucket with index n."
        },
        "parametres": "   n   -   the index of the bucket to examine \n\n"
    },
    "unordered_multimap::bucket": {
        "description": {
            "texte": "Returns the index of the bucket for key key. Elements (if any) with keys equivalent to key are always found in this bucket. The returned value is valid only for instances of the container for which bucket_count() returns the same value.The behavior is undefined if bucket_count() is zero."
        },
        "parametres": "   key   -   the value of the key to examine \n\n"
    },
    "unordered_multimap::load_factor": {
        "description": {
            "texte": "Returns the average number of elements per bucket, that is, size() divided by bucket_count()."
        }
    },
    "unordered_multimap::max_load_factor": {
        "description": {
            "texte": "Manages the maximum load factor (number of elements per bucket). The container automatically increases the number of buckets if the load factor exceeds this threshold.1) Returns current maximum load factor.2) Sets the maximum load factor to ml."
        },
        "parametres": "   ml   -   new maximum load factor setting \n\n"
    },
    "unordered_multimap::rehash": {
        "description": {
            "texte": "Sets the number of buckets to count and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. If the new number of buckets makes load factor more than maximum load factor (count < size() / max_load_factor()), then the new number of buckets is at least size() / max_load_factor()."
        },
        "parametres": "   count   -   new number of buckets \n\n"
    },
    "deduction guides for std::unordered_multimap\n": {
        "description": {
            "texte": "where the type aliases iter_key_t, iter_val_t, iter_to_alloc_t are defined as if as follows.These deduction guide are provided for unordered_multimap to allow deduction from an iterator range (overloads (1,3-5)) and std::initializer_list (overloads (2,6-8)). These overloads only participate in overload resolution if InputIt satisfies LegacyInputIterator, Alloc satisfies Allocator, neither Hash nor Pred satisfy Allocator, and Hash is not an integral type.Note: the extent to which the library determines that a type does not satisfy LegacyInputIterator is unspecified, except that as a minimum integral types do not qualify as input iterators. Likewise, the extent to which it determines that a type does not satisfy Allocator is unspecified, except that as a minimum the member type Alloc::value_type must exist and the expression std::declval<Alloc&>().allocate(std::size_t{}) must be well-formed when treated as an unevaluated operand.The size_type parameter type in these guides in an refers to the size_type member type of the type deduced by the deduction guide."
        },
        "exemple": {
            "input": "#include <unordered_map>\nint main() {\n// std::unordered_multimap m1 = {{\"foo\", 1}, {\"bar\", 2}}; // Error: braced-init-list has no type\n                                                          // cannot deduce pair<Key, T> from\n                                                          // {\"foo\", 1} or {\"bar\", 2}\n   std::unordered_multimap m1 = {std::pair{\"foo\", 2}, {\"bar\", 3}}; // guide #2\n   std::unordered_multimap m2(m1.begin(), m1.end()); // guide #1\n}"
        }
    },
    "erase_if (std::unordered_multimap)\n": {
        "description": {
            "texte": "Erases all elements that satisfy the predicate pred from the container. Equivalent to.",
            "code": "for (auto i = c.begin(), last = c.end(); i != last; ) {\n  if (pred(*i)) {\n    i = c.erase(i);\n  } else {\n    ++i;\n  }\n}"
        },
        "parametres": "   c   -   container from which to erase \n   pred   -   predicate that returns true if the element should be erased \n\n"
    },
    "deduction guides for std::stack\n": {
        "description": {
            "texte": "These deduction guides are provided for stack to allow deduction from underlying container type. This overload only participates in overload resolution if Alloc satisfies Allocator, and Container does not satisfy Allocator and, for overload (2), if std::uses_allocator_v<Container, Allocator> is true.Note: the extent to which the library determines that a type does not satisfy LegacyInputIterator is unspecified, except that as a minimum integral types do not qualify as input iterators. Likewise, the extent to which it determines that a type does not satisfy Allocator is unspecified, except that as a minimum the member type Alloc::value_type must exist and the expression std::declval<Alloc&>().allocate(std::size_t{}) must be well-formed when treated as an unevaluated operand."
        },
        "exemple": {
            "input": "#include <vector>\n#include <stack>\nint main() {\n   std::vector<int> v = {1,2,3,4};\n   std::stack s{v};    // guide #1 deduces std::stack<int, vector<int>>\n}"
        }
    },
    "deduction guides for std::queue\n": {
        "description": {
            "texte": "These deduction guides are provided for queue to allow deduction from underlying container type. This overload only participates in overload resolution if Alloc satisfies Allocator, and Container does not satisfy Allocator and, for overload (2), if std::uses_allocator_v<Container, Allocator> is true.Note: the extent to which the library determines that a type does not satisfy LegacyInputIterator is unspecified, except that as a minimum integral types do not qualify as input iterators. Likewise, the extent to which it determines that a type does not satisfy Allocator is unspecified, except that as a minimum the member type Alloc::value_type must exist and the expression std::declval<Alloc&>().allocate(std::size_t{}) must be well-formed when treated as an unevaluated operand."
        },
        "exemple": {
            "input": "#include <vector>\n#include <queue>\nint main() {\n   std::vector<int> v = {1,2,3,4};\n   std::queue s{v};    // guide #1 deduces std::queue<int, vector<int>>\n}"
        }
    },
    "deduction guides for std::priority_queue\n": {
        "description": {
            "texte": "These deduction guides are provided for std::priority_queue to allow deduction from underlying container type (overloads (1,3)) and from an iterator range (overload (2)) This overload only participates in overload resolution if InputIt satisfies LegacyInputIterator, Alloc satisfies Allocator, Comp does not satisfy Allocator, Container does not satisfy Allocator and, for overload (3), if std::uses_allocator_v<Container, Alloc> is true.Note: the extent to which the library determines that a type does not satisfy LegacyInputIterator is unspecified, except that as a minimum integral types do not qualify as input iterators. Likewise, the extent to which it determines that a type does not satisfy Allocator is unspecified, except that as a minimum the member type Alloc::value_type must exist and the expression std::declval<Alloc&>().allocate(std::size_t{}) must be well-formed when treated as an unevaluated operand."
        },
        "exemple": {
            "input": "#include <vector>\n#include <queue>\nint main() {\n   std::vector<int> v = {1,2,3,4};\n   std::priority_queue pq1{v};                  // deduces std::priority_queue<int>\n   std::priority_queue pq2{v.begin(), v.end()}; // deduces std::priority_queue<int>\n}"
        }
    },
    "complex::complex": {
        "description": {
            "texte": "Constructs the std::complex object."
        },
        "parametres": "   re   -   the real part \n   im   -   the imaginary part \n   other   -   another complex to use as source \n\n"
    },
    "complex::operator=": {
        "description": {
            "texte": "Assigns new values to the contents."
        },
        "parametres": "   x   -   value to assign \n   cx   -   complex value to assign \n\n"
    },
    "complex::real": {
        "description": {
            "texte": "Accesses the real part of the complex number."
        },
        "parametres": "   value   -   the value to set the real part to \n\n"
    },
    "complex::imag": {
        "description": {
            "texte": "Accesses the imaginary part of the complex number."
        },
        "parametres": "   value   -   the value to set the imaginary part to \n\n"
    },
    "complex::operator+=,-=,*=,/=": {
        "description": {
            "texte": "Implements the compound assignment operators for complex arithmetic and for mixed complex/scalar arithmetic. Scalar arguments are treated as complex numbers with the real part equal to the argument and the imaginary part set to zero."
        },
        "parametres": "   other   -   a complex or scalar value of matching type (float, double, long double) \n\n"
    },
    "valarray::valarray": {
        "description": {
            "texte": "Constructs new numeric array from various sources."
        },
        "parametres": "   count   -   the number of elements to construct \n   val   -   the value to initialize the elements with \n   vals   -   pointer to a C array to use as source to initialize the contents \n   other   -   another numeric array to use as source to initialize the contents  \n   il   -   initializer list to initialize the elements with \n\n"
    },
    "valarray::~valarray": {
        "description": {
            "texte": "Destructs the numeric array. The destructors of the elements are called and the used storage is deallocated."
        }
    },
    "valarray::operator=": {
        "description": {
            "texte": "Replaces the contents of the numeric array."
        },
        "parametres": "   other   -   another numeric array (or a mask) to assign \n   val   -   the value to initialize each element with \n   il   -   initializer list to assign \n\n",
        "exemple": {
            "input": "#include <valarray>\n#include <iostream>\n \nint main()\n{\n    std::valarray<int> v1(3);\n    v1 = -1; // from a scalar \n    std::cout << \"assigned from scalar: \";\n    for(int n: v1) std::cout << n << ' '; std::cout << '\\n';\n \n    v1 = {1, 2, 3, 4, 5, 6}; // from initializer list of different size\n    std::cout << \"assigned from initializer_list:      \";\n    for(int n: v1) std::cout << n << ' '; std::cout << '\\n';\n \n    std::valarray<int> v2(3);\n    v2 = v1[std::slice(0,3,2)]; // from slice array\n    std::cout << \"every 2nd element starting at pos 0: \";\n    for(int n: v2) std::cout << n << ' '; std::cout << '\\n';\n \n    v2 = v1[v1 % 2 == 0]; // from mask array\n    std::cout << \"values that are even          :      \";\n    for(int n: v2) std::cout << n << ' '; std::cout << '\\n';\n \n    std::valarray<std::size_t> idx = {0,1,2,4}; // index array\n    v2.resize(4); // sizes must match when assigning from gen subscript\n    v2 = v1[idx]; // from indirect array\n    std::cout << \"values at positions 0,1,2,4:         \";\n    for(int n: v2) std::cout << n << ' '; std::cout << '\\n';\n}",
            "output": "assigned from scalar: -1 -1 -1 \nassigned from initializer_list:      1 2 3 4 5 6 \nevery 2nd element starting at pos 0: 1 3 5 \nvalues that are even          :      2 4 6 \nvalues at positions 0,1,2,4:         1 2 3 5"
        }
    },
    "valarray::operator[]": {
        "description": {
            "texte": "Retrieve single elements or portions of the array.The const overloads that return element sequences create a new std::valarray object. The non-const overloads return classes holding references to the array elements."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <valarray>\n \nint main() \n{\n    std::valarray<int> data = {0,1,2,3,4,5,6,7,8,9};\n \n    std::cout << \"Initial valarray: \";\n    for(int n: data) std::cout << n << ' ';\n    std::cout << '\\n';\n \n    data[data > 5] = -1; // valarray<bool> overload of operator[]\n    // the type of data>5 is std::valarray<bool>\n    // the type of data[data>5] is std::mask_array<int>\n \n    std::cout << \"After v[v>5]=-1:  \";\n    for(std::size_t n = 0; n < data.size(); ++n) \n      std::cout << data[n] << ' ';  // regular operator[]\n    std::cout << '\\n';\n}",
            "output": "Initial valarray: 0 1 2 3 4 5 6 7 8 9 \nAfter v[v>5]=-1:  0 1 2 3 4 5 -1 -1 -1 -1"
        }
    },
    "valarray::swap": {
        "description": {
            "texte": "Swaps the contents with those of other."
        },
        "parametres": "   other   -   another valarray to swap the contents with \n\n"
    },
    "valarray::size": {
        "description": {
            "texte": "Returns the number of elements in the valarray."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <valarray>\n \nint main()\n{\n    std::valarray<double> a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    std::cout << \"Average: \" << a.sum()/a.size() << '\\n';\n}",
            "output": "Average: 5.5"
        }
    },
    "valarray::resize": {
        "description": {
            "texte": "Resizes the valarray to contain count elements and assigns value to each element.This functions invalidates all pointers and references to elements in the array."
        },
        "parametres": "   count   -   new size of the container \n   value   -   the value to initialize the new elements with \n\n",
        "exemple": {
            "input": "#include <valarray>\n#include <iostream>\nint main()\n{\n    std::valarray<int> v{1,2,3};\n    v.resize(10);\n    for(int n: v) std::cout << n << ' ';\n    std::cout << '\\n';\n}",
            "output": "0 0 0 0 0 0 0 0 0 0"
        }
    },
    "valarray::sum": {
        "description": {
            "texte": "Computes the sum of the elements.The function can be used only if operator+= is defined for type T. If the std::valarray is empty, the behavior is undefined. The order in which the elements are processed by this function is unspecified."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <valarray>\n \nint main()\n{\n    std::valarray<int> a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    std::cout << a.sum() << '\\n';\n}",
            "output": "55"
        }
    },
    "valarray::min": {
        "description": {
            "texte": "Computes the minimum value of the elements.If there are no elements, the behavior is undefined.The function can be used only if operator< is defined for type T."
        },
        "exemple": {
            "input": "#include <valarray>\n#include <iostream>\n \nint main()\n{\n    std::valarray<double> a{1, 2, 3, 4, 5, 6, 7, 8};\n    std::cout << \"Minimum value : \" << a.min() << \"\\n\";\n}",
            "output": "Minimum value : 1"
        }
    },
    "valarray::max": {
        "description": {
            "texte": "Computes the maximum value of the elements.If there are no elements, the behavior is undefined.The function can be used only if operator< is defined for type T."
        },
        "exemple": {
            "input": "#include <valarray>\n#include <iostream>\n \nint main()\n{\n    std::valarray<double> a{1, 2, 3, 4, 5, 6, 7, 8};\n    std::cout << \"Maximum value : \" << a.max() << \"\\n\";\n}",
            "output": "Maximum value : 8"
        }
    },
    "valarray::shift": {
        "description": {
            "texte": "Returns a new valarray of the same size with elements whose positions are shifted by count elements. The new position of each element is i\u2212count where i is the previous position. The value of shifted in elements is T()."
        },
        "parametres": "   count   -   number of positions to shift the elements by \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <valarray>\n \n \nint main() {\n    std::valarray<int> v{1, 2, 3, 4, 5, 6, 7, 8};\n \n    for (auto const& val : v) {\n        std::cout << val << \" \";\n    }\n    std::cout << \"\\n\";\n \n    std::valarray<int> v2 = v.shift(2);\n \n    for (auto const& val : v2) {\n        std::cout << val << \" \";\n    }\n    std::cout << \"\\n\";\n}",
            "output": "1 2 3 4 5 6 7 8 \n3 4 5 6 7 8 0 0"
        }
    },
    "valarray::cshift": {
        "description": {
            "texte": "Returns a new valarray of the same size with elements whose positions are shifted circularly by count elements. The new position of each element is (i\u2212count) mod s where i is the previous position and s is size()."
        },
        "parametres": "   count   -   number of positions to shift the elements by \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <valarray>\n \n \nint main() {\n    std::valarray<int> v{1, 2, 3, 4, 5, 6, 7, 8};\n \n    for (auto const& val : v) {\n        std::cout << val << \" \";\n    }\n    std::cout << \"\\n\";\n \n    std::valarray<int> v2 = v.cshift(2);\n \n    for (auto const& val : v2) {\n        std::cout << val << \" \";\n    }\n    std::cout << \"\\n\";\n}",
            "output": "1 2 3 4 5 6 7 8 \n3 4 5 6 7 8 1 2"
        }
    },
    "valarray::apply": {
        "description": {
            "texte": "Returns a new valarray of the same size with values which are acquired by applying function func to the previous values of the elements."
        },
        "parametres": "   func   -   function to apply to the values \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <valarray>\n#include <cmath>\n \nint main()\n{\n    std::valarray<int> v = {1,2,3,4,5,6,7,8,9,10};\n    v = v.apply([](int n)->int {\n                    return std::round(std::tgamma(n+1));\n                });\n    for(auto n : v) {\n        std::cout << n << ' ';\n    }\n    std::cout << '\\n';\n}",
            "output": "1 2 6 24 120 720 5040 40320 362880 3628800"
        }
    },
    "valarray::operator+,-,~,!": {
        "description": {
            "texte": "Applies unary operators to each element in the numeric array."
        }
    },
    "valarray::operator+=,-=,*=,/=,%=,&=,|=,>=": {
        "description": {
            "texte": "Applies compound assignment operators to each element in the numeric array.The behavior is undefined if size() != v.size().The behavior is undefined if any of the values in v is computed during the assignment and depends on any of the values in *this, that is, the expression on the right side of the assignment refers to a variable in the left side of the assignment."
        },
        "parametres": "   v   -   another numeric array \n   val   -   a value \n\n"
    },
    "deduction guides for std::valarray\n": {
        "description": {
            "texte": "This deduction guide is provided for std::valarray to allow deduction from array and size (note that deduction from pointer and size is covered by the implicit guides)."
        },
        "exemple": {
            "input": "#include <valarray>\nint main() {\n  int a[] = {1, 2, 3};\n  std::valarray va(a, 3); // uses explicit deduction guide\n}"
        }
    },
    "ios_base::ios_base": {
        "description": {
            "texte": "1) The copy constructor is deleted: streams are not copyable.2) The default constructor is protected: only derived classes may construct std::ios_base. The internal state is undefined after the construction. The derived class must call basic_ios::init() to complete initialization before first use or before destructor; otherwise the behavior is undefined."
        }
    },
    "ios_base::flags": {
        "description": {
            "texte": "Manages format flags.1) returns current formatting setting.2) replaces current settings with given ones."
        },
        "parametres": "   flags   -   new formatting setting. It can be a combination of the following constants:    Constant   Explanation \n   dec   use decimal base for integer I/O: see std::dec \n   oct   use octal base for integer I/O: see std::oct \n   hex   use hexadecimal base for integer I/O: see std::hex \n   basefield   dec|oct|hex. Useful for masking operations \n   left   left adjustment (adds fill characters to the right): see std::left \n   right   right adjustment (adds fill characters to the left): see std::right \n   internal   internal adjustment (adds fill characters to the internal designated point): see std::internal \n   adjustfield   left|right|internal. Useful for masking operations \n   scientific   generate floating point types using scientific notation, or hex notation if combined with fixed: see std::scientific \n   fixed   generate floating point types using fixed notation, or hex notation if combined with scientific: see std::fixed \n   floatfield   scientific|fixed. Useful for masking operations \n   boolalpha   insert and extract bool type in alphanumeric format: see std::boolalpha \n   showbase   generate a prefix indicating the numeric base for integer output, require the currency indicator in monetary I/O: see std::showbase \n   showpoint   generate a decimal-point character unconditionally for floating-point number output: see std::showpoint \n   showpos   generate a + character for non-negative numeric output: see std::showpos \n   skipws   skip leading whitespace before certain input operations: see std::skipws \n   unitbuf   flush the output after each output operation: see std::unitbuf \n   uppercase   replace certain lowercase letters with their uppercaseequivalents in certain output operations: see std::uppercase \n  \n\n"
    },
    "ios_base::setf": {
        "description": {
            "texte": "Sets the formatting flags to specified settings."
        },
        "parametres": "   flags, mask   -   new formatting setting. mask defines which flags can be altered, flags defines which flags of those to be altered should be set (others will be cleared). Both parameters can be a combination of the following constants:    Constant   Explanation \n   dec   use decimal base for integer I/O: see std::dec \n   oct   use octal base for integer I/O: see std::oct \n   hex   use hexadecimal base for integer I/O: see std::hex \n   basefield   dec|oct|hex. Useful for masking operations \n   left   left adjustment (adds fill characters to the right): see std::left \n   right   right adjustment (adds fill characters to the left): see std::right \n   internal   internal adjustment (adds fill characters to the internal designated point): see std::internal \n   adjustfield   left|right|internal. Useful for masking operations \n   scientific   generate floating point types using scientific notation, or hex notation if combined with fixed: see std::scientific \n   fixed   generate floating point types using fixed notation, or hex notation if combined with scientific: see std::fixed \n   floatfield   scientific|fixed. Useful for masking operations \n   boolalpha   insert and extract bool type in alphanumeric format: see std::boolalpha \n   showbase   generate a prefix indicating the numeric base for integer output, require the currency indicator in monetary I/O: see std::showbase \n   showpoint   generate a decimal-point character unconditionally for floating-point number output: see std::showpoint \n   showpos   generate a + character for non-negative numeric output: see std::showpos \n   skipws   skip leading whitespace before certain input operations: see std::skipws \n   unitbuf   flush the output after each output operation: see std::unitbuf \n   uppercase   replace certain lowercase letters with their uppercaseequivalents in certain output operations: see std::uppercase \n  \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n \nconst double PI = 3.1415926535;\n \nint main() \n{\n    const int WIDTH = 15;\n \n    std::cout.setf(std::ios::right);  //equivalent: cout << right;\n    std::cout << std::setw(WIDTH/2) << \"radius\"\n              << std::setw(WIDTH) << \"circumference\" << '\\n';\n \n    std::cout.setf(std::ios::fixed);\n    for (double radius = 1; radius <= 6; radius += 0.5) {\n        std::cout << std::setprecision(1) << std::setw(WIDTH/2) \n                  << radius\n                  << std::setprecision(2) << std::setw(WIDTH) \n                  << (2 * PI * radius) << '\\n';\n    }\n}",
            "output": "radius  circumference\n    1.0           6.28\n    1.5           9.42\n    2.0          12.57\n    2.5          15.71\n    3.0          18.85\n    3.5          21.99\n    4.0          25.13\n    4.5          28.27\n    5.0          31.42\n    5.5          34.56\n    6.0          37.70"
        }
    },
    "ios_base::unsetf": {
        "description": {
            "texte": "Unsets the formatting flags identified by flags."
        },
        "parametres": "   flags   -   formatting flags to unset. It can be a combination of the following constants:    Constant   Explanation \n   dec   use decimal base for integer I/O: see std::dec \n   oct   use octal base for integer I/O: see std::oct \n   hex   use hexadecimal base for integer I/O: see std::hex \n   basefield   dec|oct|hex. Useful for masking operations \n   left   left adjustment (adds fill characters to the right): see std::left \n   right   right adjustment (adds fill characters to the left): see std::right \n   internal   internal adjustment (adds fill characters to the internal designated point): see std::internal \n   adjustfield   left|right|internal. Useful for masking operations \n   scientific   generate floating point types using scientific notation, or hex notation if combined with fixed: see std::scientific \n   fixed   generate floating point types using fixed notation, or hex notation if combined with scientific: see std::fixed \n   floatfield   scientific|fixed. Useful for masking operations \n   boolalpha   insert and extract bool type in alphanumeric format: see std::boolalpha \n   showbase   generate a prefix indicating the numeric base for integer output, require the currency indicator in monetary I/O: see std::showbase \n   showpoint   generate a decimal-point character unconditionally for floating-point number output: see std::showpoint \n   showpos   generate a + character for non-negative numeric output: see std::showpos \n   skipws   skip leading whitespace before certain input operations: see std::skipws \n   unitbuf   flush the output after each output operation: see std::unitbuf \n   uppercase   replace certain lowercase letters with their uppercaseequivalents in certain output operations: see std::uppercase \n  \n\n"
    },
    "ios_base::precision": {
        "description": {
            "texte": "Manages the precision (i.e. how many digits are generated) of floating point output performed by std::num_put::do_put.The default precision, as established by std::basic_ios::init, is 6."
        },
        "parametres": "   new_precision   -   new precision setting \n\n",
        "exemple": {
            "input": "#include <iostream>\nint main()\n{\n    const double d = 1.2345678901234;\n    std::cout << \"The  default precision is \" << std::cout.precision() << \"\\n\\n\";\n    std::cout << \"With default precision d is \" << d << '\\n';\n    std::cout.precision(12);\n    std::cout << \"With high    precision d is \" << d << '\\n';\n}",
            "output": "The  default precision is 6\n \nWith default precision d is 1.23457\nWith high    precision d is 1.23456789012"
        }
    },
    "ios_base::width": {
        "description": {
            "texte": "Manages the minimum number of characters to generate on certain output operations and the maximum number of characters to generate on certain input operations."
        },
        "parametres": "   new_width   -   new field width setting \n\n",
        "exemple": {
            "input": "#include <array>\n#include <tuple>\n#include <ctime>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n \nint main()\n{\n    auto str_time = [](int year, int mon, int day)\n    {\n        constexpr std::array<const char*, 7> week_day{ {\n            \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"\n        } };\n \n        std::tm tm{};\n        tm.tm_year = year - 1900;\n        tm.tm_mon  = mon - 1;\n        tm.tm_mday = day;\n \n        day += mon < 3 ? year-- : year - 2;\n        tm.tm_wday = (23 * mon / 9 + day + 4 + year / 4 - year / 100 + year / 400) % 7;\n \n        std::ostringstream out;\n        out << week_day[tm.tm_wday] << \", \" << std::put_time(&tm, \"%B %d, %Y\");\n        return out.str();\n    };\n \n    constexpr int column_size = 4;\n    using table_t = std::array<std::string, column_size>;\n \n    table_t headers{ { \"Name\", \"Birthdate\", \"Death date\", \"Language Created\" } };\n \n    std::array<table_t, 5> data{ {\n        { { \"Dennis MacAlistair Ritchie\", str_time(1941, 9, 9), str_time(2011, 10, 12), \"C\" } },\n        { { \"Bjarne Stroustrup\", str_time(1950, 12, 30), \"\", \"C++\" } },\n        { { \"Anders Hejlsberg\", str_time(1960, 12, 2), \"\", \"C#\" } },\n        { { \"Guido van Rossum\", str_time(1956, 1, 31), \"\", \"Python\" } },\n        { { \"Brendan Eich\", str_time(1961, 7, 4), \"\", \"Javascript\" } }\n    } };\n \n    constexpr int name_wid  = 30;\n    constexpr int birth_wid = 30;\n    constexpr int death_wid = 30;\n    constexpr int lang_wid  = 18;\n \n    auto print_line = [](table_t const &tbl)\n    {\n \n        auto const &[Name, Birthdate, DeathDate, LanguageCreated] = tbl;\n \n        std::cout.width(name_wid);\n        std::cout << (\"| \" + Name) << '|';\n \n        std::cout.width(birth_wid);\n        std::cout << (' ' + Birthdate) << '|';\n \n        std::cout.width(death_wid);\n        std::cout << (' ' + DeathDate) << '|';\n \n        std::cout.width(lang_wid);\n        std::cout << (' ' + LanguageCreated) << '|';\n \n        std::cout << '\\n';\n    };\n \n    constexpr int total_wid = name_wid + birth_wid + death_wid + lang_wid + column_size;\n \n    auto print_break = []\n    {\n        std::cout.width(total_wid);\n        std::cout.fill('-');\n        std::cout << '-' << std::endl;\n        std::cout.fill(' ');\n    };\n \n    std::cout.setf(std::ios::left, std::ios::adjustfield);\n    print_break();\n    print_line(headers);\n    print_break();\n    for (auto const &entry : data)\n        print_line(entry);\n    print_break();\n}",
            "output": "----------------------------------------------------------------------------------------------------------------\n| Name                        | Birthdate                    | Death date                   | Language Created |\n----------------------------------------------------------------------------------------------------------------\n| Dennis MacAlistair Ritchie  | Tuesday, September 09, 1941  | Wednesday, October 12, 2011  | C                |\n| Bjarne Stroustrup           | Saturday, December 30, 1950  |                              | C++              |\n| Anders Hejlsberg            | Friday, December 02, 1960    |                              | C#               |\n| Guido van Rossum            | Tuesday, January 31, 1956    |                              | Python           |\n| Brendan Eich                | Tuesday, July 04, 1961       |                              | Javascript       |\n----------------------------------------------------------------------------------------------------------------"
        }
    },
    "ios_base::imbue": {
        "description": {
            "texte": "Sets the associated locale of the stream to the given one. Before returning, each function, registered by register_callback() is called with imbue_event as a parameter."
        },
        "parametres": "   loc   -   new locale to associate the stream to \n\n"
    },
    "ios_base::getloc": {
        "description": {
            "texte": "Returns the current locale associated with the stream."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <ctime>\n#include <iomanip>\n#include <codecvt>\n \nint main()\n{\n    std::wbuffer_convert<std::codecvt_utf8<wchar_t>> conv(std::cout.rdbuf());\n    std::wostream out(&conv);\n \n    out.imbue(std::locale(out.getloc(),\n                          new std::time_put_byname<wchar_t>(\"ja_JP\")));\n \n    std::time_t t = std::time(NULL);\n    out << std::put_time(std::localtime(&t), L\"%A %c\") << '\\n';\n}",
            "output": "\u571f\u66dc\u65e5 2013\u5e7409\u670814\u65e5 11\u664231\u520615\u79d2"
        }
    },
    "ios_base::xalloc": {
        "description": {
            "texte": "Returns a unique (program-wide) index value that can be used to access one long and one void* elements in the private storage of std::ios_base by calling iword() and pword(). The call to xalloc does not allocate memory. This function is thread-safe; concurrent access by multiple threads does not result in a data race. (since C++14).Effectively increments a private static data member of std::ios_base, as if by executing return index++;, if index is the name of that static member (which may be std::atomic to support concurrent access by multiple threads, or otherwise synchronized) (since C++14)."
        },
        "exemple": {
            "input": "#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << \"[special handling for mystream]\";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << \"cout, narrow-character test \" << mymanip << '\\n';\n \n    mystream<char> myout(std::cout);\n    myout << \"myout, narrow-character test \" << mymanip << '\\n';\n \n    std::wcout << \"wcout, wide-character test \" << mymanip << '\\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << \"mywout, wide-character test \" << mymanip << '\\n';\n}",
            "output": "cout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]"
        }
    },
    "ios_base::iword": {
        "description": {
            "texte": "First, allocates or resizes the private storage (dynamic array of long or another indexable data structure) sufficiently to make index a valid index, then returns a reference to the long element of the private storage with the index index.The reference may be invalidated by any operation on this ios_base object, including another call to iword(), but the stored values are retained, so that reading from iword(index) with the same index later will produce the same value (until the next call to std::basic_ios::copyfmt()). The value can be used for any purpose. The index of the element must be obtained by a previous call to xalloc(), otherwise the behavior is undefined. New elements are initialized to \u200b0\u200b.If allocation fails, calls std::basic_ios<>::setstate(badbit) which may throw std::ios_base::failure."
        },
        "parametres": "   index   -   index value of the element \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n \nstruct Foo {\n    static int foo_xalloc;\n    std::string data; \n    Foo(const std::string& s) : data(s) {}\n};\n \n// allocates the iword storage for use with Foo objects\nint Foo::foo_xalloc = std::ios_base::xalloc();\n \n// This user-defined operator<< prints the string in reverse if the iword holds 1\nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    if(os.iword(Foo::foo_xalloc) == 1)\n        return os << std::string(f.data.rbegin(), f.data.rend());\n    else\n        return os << f.data;\n}\n \n// This I/O manipulator flips the number stored in iword between 0 and 1\nstd::ios_base& rev(std::ios_base& os)\n{\n    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);\n    return os;\n}\n \nint main()\n{\n    Foo f(\"example\");\n    std::cout << f << '\\n' << rev << f << '\\n' << rev << f << '\\n';\n}",
            "output": "example\nelpmaxe\nexample"
        }
    },
    "ios_base::pword": {
        "description": {
            "texte": "First, allocates or resizes the private storage (dynamic array of void* or another indexable data structure) sufficiently to make index a valid index, then returns a reference to the void* element of the private storage with the index index.The reference may be invalidated by any operation on this ios_base object, including another call to pword(), but the stored values are retained, so that reading from pword(index) with the same index later will produce the same value (until the next call to copyfmt()). The value can be used for any purpose. The index of the element must be obtained by xalloc(), otherwise the behavior is undefined. New elements are initialized to NULL.If allocation fails, calls std::basic_ios<>::setstate(badbit) which may throw std::ios_base::failure."
        },
        "parametres": "   index   -   index value of the element \n\n",
        "exemple": {
            "input": "#include <iostream>\n \ntemplate<class charT, class traits = std::char_traits<charT> >\nclass mystream : public std::basic_ostream<charT, traits>\n{\n public:\n    static const int xindex;\n    mystream(std::basic_ostream<charT, traits>& ostr) :\n        std::basic_ostream<charT, traits>(ostr.rdbuf())\n    {\n         this->pword(xindex) = this;\n    }\n \n    void myfn()\n    {\n        *this << \"[special handling for mystream]\";\n    }\n};\n \n// each specialization of mystream obtains a unique index from xalloc()\ntemplate<class charT, class traits>\nconst int mystream<charT, traits>::xindex = std::ios_base::xalloc();\n \n// This I/O manipulator will be able to recognize ostreams that are mystreams\n// by looking up the pointer stored in pword\ntemplate<class charT, class traits>\nstd::basic_ostream<charT,traits>& mymanip(std::basic_ostream<charT,traits>& os)\n{\n if (os.pword(mystream<charT,traits>::xindex) == &os) \n    static_cast<mystream<charT,traits>&>(os).myfn();\n return os;\n}\n \nint main()\n{\n    std::cout << \"cout, narrow-character test \" << mymanip << '\\n';\n \n    mystream<char> myout(std::cout);\n    myout << \"myout, narrow-character test \" << mymanip << '\\n';\n \n    std::wcout << \"wcout, wide-character test \" << mymanip << '\\n';\n \n    mystream<wchar_t> mywout(std::wcout);\n    mywout << \"mywout, wide-character test \" << mymanip << '\\n';\n}",
            "output": "cout, narrow-character test \nmyout, narrow-character test [special handling for mystream]\nwcout, wide-character test \nmywout, wide-character test [special handling for mystream]"
        }
    },
    "ios_base::register_callback": {
        "description": {
            "texte": "Registers a user-defined function which will be called by imbue(), std::basic_ios::copyfmt() and ~ios_base(). Every registered callback is called every time: the event type (a value of type event) is passed as its first argument, and may be used to distinguish between the callers.The callbacks are called in the reverse order of registration (in other words, register_callback() pushes a callback pair on the callback stack). If register_callback() is called from within a callback function to add a new callback, the new callback is only called on the next event.The user-defined callback function is not allowed to throw exceptions."
        },
        "parametres": "   function   -   the function which will be called on event, supplied as a function pointer of type event_callback \n   index   -   custom parameter which will be passed to the function \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n#include <functional>\n \n// cached locale-specific message and its hash\ntypedef std::pair<std::string, std::size_t> cache_t;\n \n// populate the cached message and its hash from the locale\nvoid update_cache(cache_t& cache, std::locale loc)\n{\n    auto& fct = std::use_facet< std::messages<char> >(loc);\n    std::messages_base::catalog cat = fct.open(\"sed\", loc);\n    cache.first = cat < 0 ? \"\" : fct.get(cat, 0, 0, \"Memory exhausted\");\n    cache.second = std::hash<std::string>()(cache.first);\n}\n \n// update the cache if the locale changed\nvoid true_callback(std::ios_base::event evt, std::ios_base& str, int idx)\n{\n    if (evt == std::ios_base::imbue_event) \n    {\n        cache_t* ptr = static_cast<cache_t*>(str.pword(idx));\n        update_cache(*ptr, str.getloc());\n    }\n}\n \n// registers the cache in pword() and sets up the callback\nstruct CacheSetup\n{\n    CacheSetup(std::ostream& os, std::ios_base::event_callback f, cache_t* cache)\n    {\n        int index = std::ostream::xalloc();\n        os.pword(index) = cache; // store pointer to cache in the stream\n        os.register_callback(f, index); // store callback and the index to the pointer\n        update_cache(*cache, os.getloc()); // initialize cache\n    };\n};\n \n// some custom class \nstruct S { };\n// some custom class's operator<< that needs fast access to hashed message\nstd::ostream& operator<<(std::ostream& os, const S&)\n{\n   static cache_t cache;\n   static CacheSetup setup(os, true_callback, &cache);\n   return os << cache.first << \" : \" << cache.second;\n}\n \nint main()\n{\n    std::locale loc(\"en_US.utf8\");\n \n    S s;\n    std::cout.imbue(loc);\n    std::cout << s << '\\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>(\"de_DE.utf8\")));\n    std::cout << s << '\\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>(\"ja_JP.utf8\")));\n    std::cout << s << '\\n';\n \n    std::cout.imbue(std::locale(loc, new std::messages_byname<char>(\"ru_RU.utf8\")));\n    std::cout << s << '\\n';\n}",
            "output": "Memory exhausted : 2,295,079,096\nSpeicher ersch\u00f6pft : 3,139,423,551\n\u30e1\u30e2\u30ea\u30fc\u304c\u8db3\u308a\u307e\u305b\u3093 : 3,837,351,114\n\u041f\u0430\u043c\u044f\u0442\u044c \u0438\u0441\u0447\u0435\u0440\u043f\u0430\u043d\u0430 : 3,742,732,851"
        }
    },
    "ios_base::sync_with_stdio": {
        "description": {
            "texte": "Sets whether the standard C++ streams are synchronized to the standard C streams after each input/output operation.The standard C++ streams are the following: std::cin, std::cout, std::cerr, std::clog, std::wcin, std::wcout, std::wcerr and std::wclog.The standard C streams are the following: stdin, stdout and stderr.For a standard stream str, synchronized with the C stream f, the following pairs of functions have identical effect:In practice, this means that the synchronized C++ streams are unbuffered, and each I/O operation on a C++ stream is immediately applied to the corresponding C stream's buffer. This makes it possible to freely mix C++ and C I/O.In addition, synchronized C++ streams are guaranteed to be thread-safe (individual characters output from multiple threads may interleave, but no data races occur).If the synchronization is turned off, the C++ standard streams are allowed to buffer their I/O independently, which may be considerably faster in some cases.By default, all eight standard C++ streams are synchronized with their respective C streams.If this function is called after I/O has occurred on the standard stream, the behavior is implementation-defined: implementations range from no effect to destroying the read buffer."
        },
        "parametres": "   sync   -   the new synchronization setting \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <cstdio>\n \nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cout << \"a\\n\";\n    std::printf(\"b\\n\");\n    std::cout << \"c\\n\";\n}",
            "output": "b\na\nc"
        }
    },
    "ios_base::openmode": {
        "description": {
            "texte": "Specifies available file open flags. It is a BitmaskType, the following constants are defined:"
        }
    },
    "ios_base::fmtflags": {
        "description": {
            "texte": "Specifies available formatting flags. It is a BitmaskType. The following constants are defined:"
        },
        "exemple": {
            "input": "#include <iostream>\n \nint main() \n{\n    int num = 150;\n \n    // using fmtflags as class member constants:\n    std::cout.setf(std::ios_base::hex, std::ios_base::basefield);\n    std::cout.setf(std::ios_base::showbase);\n    std::cout << num << '\\n';\n \n    // using fmtflags as inherited class member constants:\n    std::cout.setf (std::ios::hex , std::ios::basefield);\n    std::cout.setf (std::ios::showbase);\n    std::cout << num << '\\n';\n \n    // using fmtflags as object member constants:\n    std::cout.setf(std::cout.hex, std::cout.basefield);\n    std::cout.setf(std::cout.showbase);\n    std::cout << num << '\\n';\n \n    // using fmtflags as a type:\n    std::ios_base::fmtflags ff;\n    ff = std::cout.flags();\n    ff &= ~std::cout.basefield;   // unset basefield bits\n    ff |= std::cout.hex;          // set hex\n    ff |= std::cout.showbase;     // set showbase\n    std::cout.flags(ff);\n    std::cout << num << '\\n';\n \n    // not using fmtflags, but using manipulators:\n    std::cout << std::hex << std::showbase << num << '\\n';\n}",
            "output": "0x96\n0x96\n0x96\n0x96\n0x96"
        }
    },
    "ios_base::iostate": {
        "description": {
            "texte": "Specifies stream state flags. It is a BitmaskType, the following constants are defined:The eofbit is set by the following standard library functions:The following functions clear eofbit as a side-effect:Note that in nearly all situations, if eofbit is set, the failbit is set as well.The failbit is set by the following standard library functions:The badbit is set by the following standard library functions:rdbuf()->sputbackc() or rdbuf()->sungetc() return traits::eof()."
        }
    },
    "ios_base::seekdir": {
        "description": {
            "texte": "Specifies file seeking direction type. The following constants are defined:"
        }
    },
    "ios_base::event": {
        "description": {
            "texte": "Specifies the event type which is passed to functions registered by register_callback() on specific events. The following constants are defined:"
        }
    },
    "ios_base::event_callback": {
        "description": {
            "texte": "The type of function callbacks that can be registered using register_callback() to be called on specific events.type is a value of type ios_base::event which indicates the type of the event that will invoke this callback.ios refers to the stream object for which the callback is invoked: *this is passed as the argument when callbacks are invoked by std::ios_base and std::basic_ios member functions.index is the user-provided value passed to register_callback() when registering the function."
        }
    },
    "basic_ios::basic_ios": {
        "description": {
            "texte": "Constructs new basic_ios object."
        },
        "parametres": "   sb   -   stream buffer to associate to \n\n"
    },
    "basic_ios::~basic_ios": {
        "description": {
            "texte": "Destroys the basic_ios object. No operations on rdbuf are performed, it is not destroyed."
        }
    },
    "basic_ios::good": {
        "description": {
            "texte": "Returns true if the the most recent I/O operation on the stream completed successfully. Specifically, returns result of rdstate() == 0.See ios_base::iostate for the list of conditions that set the stream status bits."
        }
    },
    "basic_ios::eof": {
        "description": {
            "texte": "Returns true if the associated stream has reached end-of-file. Specifically, returns true if eofbit is set in rdstate().See ios_base::iostate for the list of conditions that set eofbit."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file(\"test.txt\");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << \"File opening failed\\n\";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\\n';\n \n    if (file.bad())\n        std::cout << \"I/O error while reading\\n\";\n    else if (file.eof())\n        std::cout << \"End of file reached successfully\\n\";\n    else if (file.fail())\n        std::cout << \"Non-integer data encountered\\n\";\n}"
        }
    },
    "basic_ios::fail": {
        "description": {
            "texte": "Returns true if an error has occurred on the associated stream. Specifically, returns true if badbit or failbit is set in rdstate().See ios_base::iostate for the list of conditions that set failbit or badbit."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file(\"test.txt\");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << \"File opening failed\\n\";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\\n';\n \n    if (file.bad())\n        std::cout << \"I/O error while reading\\n\";\n    else if (file.eof())\n        std::cout << \"End of file reached successfully\\n\";\n    else if (file.fail())\n        std::cout << \"Non-integer data encountered\\n\";\n}"
        }
    },
    "basic_ios::bad": {
        "description": {
            "texte": "Returns true if non-recoverable error has occurred on the associated stream. Specifically, returns true if badbit is set in rdstate().See ios_base::iostate for the list of conditions that set badbit."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file(\"test.txt\");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << \"File opening failed\\n\";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\\n';\n \n    if (file.bad())\n        std::cout << \"I/O error while reading\\n\";\n    else if (file.eof())\n        std::cout << \"End of file reached successfully\\n\";\n    else if (file.fail())\n        std::cout << \"Non-integer data encountered\\n\";\n}"
        }
    },
    "basic_ios::operator!": {
        "description": {
            "texte": "Returns true if an error has occurred on the associated stream. Specifically, returns true if badbit or failbit is set in rdstate()."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <cstdlib>\nint main()\n{\n    std::ifstream file(\"test.txt\");\n    if(!file)  // operator! is used here\n    {  \n        std::cout << \"File opening failed\\n\";\n        return EXIT_FAILURE;\n    }\n \n    // typical C++ I/O loop uses the return value of the I/O function\n    // as the loop controlling condition, operator bool() is used here\n    for(int n; file >> n; ) {\n       std::cout << n << ' ';\n    }\n    std::cout << '\\n';\n \n    if (file.bad())\n        std::cout << \"I/O error while reading\\n\";\n    else if (file.eof())\n        std::cout << \"End of file reached successfully\\n\";\n    else if (file.fail())\n        std::cout << \"Non-integer data encountered\\n\";\n}"
        }
    },
    "basic_ios::operator bool": {
        "description": {
            "texte": "Checks whether the stream has no errors.This operator makes it possible to use streams and functions that return references to streams as loop conditions, resulting in the idiomatic C++ input loops such as while(stream >> value) {...} or while(getline(stream, string)){...}. Such loops execute the loop's body only if the input operation succeeded."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::istringstream s(\"1 2 3 error\");\n    int n;\n    std::cout << std::boolalpha << \"s is \" << static_cast<bool>(s) << '\\n';\n    while (s >> n) {\n        std::cout << n << '\\n';\n    }\n    std::cout << \"s is \" << static_cast<bool>(s) << '\\n';\n}",
            "output": "s is true\n1\n2\n3\ns is false"
        }
    },
    "basic_ios::rdstate": {
        "description": {
            "texte": "Returns the current stream error state."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n \nint main()\n{\n  std::ostringstream stream;\n \n  if (stream.rdstate() == std::ios_base::goodbit) {\n    std::cout << \"stream state is goodbit\\n\";\n  }\n \n  stream.setstate(std::ios_base::eofbit);\n \n  // check state is exactly eofbit (no failbit and no badbit)\n  if (stream.rdstate() == std::ios_base::eofbit) {\n    std::cout << \"stream state is eofbit\\n\";\n  }\n}",
            "output": "stream state is goodbit\nstream state is eofbit"
        }
    },
    "basic_ios::setstate": {
        "description": {
            "texte": "Sets the stream error flags state in addition to currently set flags. Essentially calls clear(rdstate() | state). May throw an exception."
        },
        "parametres": "   state   -   stream error state flags to set. It can be a combination of the following constants:    Constant   Explanation \n   goodbit   no error \n   badbit   irrecoverable stream error \n   failbit   input/output operation failed (formatting or extraction error) \n   eofbit   associated input sequence has reached end-of-file \n  \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream stream;\n \n    if (!stream.fail()) {\n        std::cout << \"stream is not fail\\n\";\n    }\n \n    stream.setstate(std::ios_base::failbit);\n \n    if (stream.fail()) {\n        std::cout << \"now stream is fail\\n\";\n    }\n \n    if (!stream.good()) {\n        std::cout << \"and stream is not good\\n\";\n    }\n}",
            "output": "stream is not fail\nnow stream is fail\nand stream is not good"
        }
    },
    "basic_ios::clear": {
        "description": {
            "texte": "Sets the stream error state flags by assigning them the value of state. By default, assigns std::ios_base::goodbit which has the effect of clearing all error state flags.If rdbuf() is a null pointer (i.e. there is no associated stream buffer), then state | badbit is assigned. May throw an exception."
        },
        "parametres": "   state   -   new error state flags setting. It can be a combination of the following constants:    Constant   Explanation \n   goodbit   no error \n   badbit   irrecoverable stream error \n   failbit   input/output operation failed (formatting or extraction error) \n   eofbit   associated input sequence has reached end-of-file \n  \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n \nint main()\n{\n    double n;\n    while( std::cout << \"Please, enter a number\\n\"\n           && ! (std::cin >> n) )\n    {\n        std::cin.clear();\n        std::string line;\n        std::getline(std::cin, line);\n        std::cout << \"I am sorry, but '\" << line << \"' is not a number\\n\";\n    }\n    std::cout << \"Thank you for entering the number \" << n << '\\n';\n}"
        }
    },
    "basic_ios::copyfmt": {
        "description": {
            "texte": "If other refers to the same object as *this, has no effects. Otherwise, copies the state of the stream other into *this. This is done in the following sequence:"
        },
        "parametres": "   other   -   another stream to use as source \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n \nint main()\n{\n    std::ofstream out;\n \n    out.copyfmt(std::cout); // copy everything except rdstate and rdbuf\n    out.clear(std::cout.rdstate()); // copy rdstate\n    out.basic_ios<char>::rdbuf(std::cout.rdbuf()); // share the buffer\n \n    out << \"Hello, world\\n\";\n}",
            "output": "Hello, world"
        }
    },
    "basic_ios::fill": {
        "description": {
            "texte": "Manages the fill character used to pad the output conversions to the specified field width."
        },
        "parametres": "   ch   -   the character to use as fill character \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n \nint main ()\n{\n  std::cout << \"With default setting : \" << std::setw(10) << 40 << '\\n';\n  char prev = std::cout.fill('x');\n  std::cout << \"Replaced '\" << prev << \"' with '\"\n            << std::cout.fill() << \"': \" << std::setw(10) << 40 << '\\n';\n}",
            "output": "With default setting :         40\nReplaced ' ' with 'x': xxxxxxxx40"
        }
    },
    "basic_ios::exceptions": {
        "description": {
            "texte": "Gets and sets the exception mask of the stream. The exception mask determines the error states on occurrence of which the stream throws exception of type failure."
        },
        "parametres": "   except   -   exception mask \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n \nint main() \n{\n    int ivalue;\n    try {\n        std::ifstream in(\"in.txt\");\n        in.exceptions(std::ifstream::failbit);\n        in >> ivalue;\n    } catch (std::ios_base::failure& fail) {\n        // handle exception here\n    }\n}"
        }
    },
    "basic_ios::imbue": {
        "description": {
            "texte": "Replaces the current locale. Effectively calls ios_base::imbue(loc) and if there is an associated stream buffer (rdbuf() != 0), then calls rdbuf()->pubimbue(loc)."
        },
        "parametres": "   loc   -   the new locale \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n#include <locale>\n \nint main()\n{\n    std::istringstream iss;\n    iss.imbue(std::locale(\"en_US.UTF8\"));\n \n    std::cout << \"Current locale: \" << iss.getloc().name() << '\\n';\n \n    iss.imbue(std::locale());\n    std::cout << \"Global locale : \" << iss.getloc().name() << '\\n';\n}",
            "output": "Current locale: en_US.UTF8\nGlobal locale : C"
        }
    },
    "basic_ios::rdbuf": {
        "description": {
            "texte": "Manages the associated stream buffer."
        },
        "parametres": "   sb   -   stream buffer to associate to \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream local;\n    auto cout_buff = std::cout.rdbuf(); // save pointer to std::cout buffer\n \n    std::cout.rdbuf(local.rdbuf()); // substitute internal std::cout buffer with\n        // buffer of 'local' object\n \n    // now std::cout work with 'local' buffer\n    // you don't see this message\n    std::cout << \"some message\";\n \n    // go back to old buffer\n    std::cout.rdbuf(cout_buff);\n \n    // you will see this message\n    std::cout << \"back to default buffer\\n\";\n \n    // print 'local' content\n    std::cout << \"local content: \" << local.str() << \"\\n\";\n}",
            "output": "back to default buffer\nlocal content: some message"
        }
    },
    "basic_ios::tie": {
        "description": {
            "texte": "Manages the tied stream. A tied stream is an output stream which is synchronized with the sequence controlled by the stream buffer (rdbuf()), that is, flush() is called on the tied stream before any input/output operation on *this."
        },
        "parametres": "   str   -   an output stream to set as the tied stream \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <string>\n \nint main()\n{\n    std::ofstream os(\"test.txt\");\n    std::ifstream is(\"test.txt\");\n    std::string value(\"0\");\n \n    os << \"Hello\";\n    is >> value;\n \n    std::cout << \"Result before tie(): \\\"\" << value << \"\\\"\\n\";\n    is.clear();\n    is.tie(&os);\n \n    is >> value;\n \n    std::cout << \"Result after tie(): \\\"\" << value << \"\\\"\\n\";\n}",
            "output": "Result before tie(): \"0\"\nResult after tie(): \"Hello\""
        }
    },
    "basic_ios::narrow": {
        "description": {
            "texte": "Converts a current locale-specific character c to its standard equivalent. The result is converted from char_type to char if needed. If no conversion can be performed, the function returns dfault.Effectively calls std::use_facet< std::ctype<char_type> >(getloc()).narrow(c, dfault);."
        },
        "parametres": "   c   -   character to convert \n   dfault   -   character to return if the conversion was unsuccessful \n\n"
    },
    "basic_ios::widen": {
        "description": {
            "texte": "Converts a character c to its equivalent in the current locale. The result is converted from char to character type used within the stream if needed.Effectively calls std::use_facet< std::ctype<char_type> >(getloc()).widen(c)."
        },
        "parametres": "   c   -   character to convert \n\n"
    },
    "basic_ios::init": {
        "description": {
            "texte": "Sets the associated stream buffer to sb and initializes the internal state.The postconditions are as follows:This member function is protected: it is called by the constructors of the derived stream classes std::basic_istream and std::basic_ostream once the associated stream buffer is known. Until this function is called, every member function (including the destructor) of the default-constructed std::basic_ios invokes undefined behavior. Note that basic_ios is a virtual base class, and therefore its constructor is not called by the constructors of those directly derived classes, which is why two-stage initialization is necessary."
        },
        "parametres": "   sb   -   stream buffer to associate to \n\n"
    },
    "basic_ios::move": {
        "description": {
            "texte": "Replaces the current state with that of other, except for the associated rdbuf. other is in valid, but unspecified state after the call. After the call to this function, rdbuf() returns NULL, other.rdbuf() returns the same value as before the call, and other.tie() returns 0.This member function is protected: it is called by the protected move constructors of the derived stream classes std::basic_ostream and std::basic_istream, which, in turn, are called by the public move constructors of the further derived stream classes such as std::basic_ofstream, which know how to correctly move the associated streambuffer."
        },
        "parametres": "   other   -   the basic_ios object to transfer the state from \n\n"
    },
    "basic_ios::swap": {
        "description": {
            "texte": "Exchanges the states of *this and other, except for the associated rdbuf objects. rdbuf() and other.rdbuf() returns the same values as before the call.This swap function is protected: it is called by the swap member functions of the derived stream classes such as std::basic_ofstream or std::basic_istringstream, which know how to correctly swap the associated streambuffers."
        },
        "parametres": "   other   -   the basic_ios object to exchange the state with \n\n"
    },
    "basic_ios::set_rdbuf": {
        "description": {
            "texte": "Sets the associated stream buffer to sb without clearing the error state.This member function is protected: it is called by the move constructors of the derived streams such as std::basic_ofstream or std::basic_istringstream, as the final step after constructing the base class and after moving the stream buffer: only the most derived stream class knows how to correctly move the stream buffer, but std::basic_ios needs to be made aware of the stream's new location so that its public member functions can access it."
        },
        "parametres": "   sb   -   stream buffer to associate to \n\n"
    },
    "basic_istream::basic_istream": {
        "description": {
            "texte": "1) Constructs the basic_istream object, assigning initial values to the base class by calling basic_ios::init(sb). The value of gcount() is initialized to zero.2) The copy constructor is protected, and is deleted. Input streams are not copyable.3) The move constructor copies the value of gcount() from rhs, sets the gcount() value of rhs to zero, and uses basic_ios<CharT, Traits>::move(rhs) to move all basic_ios members, except for the rdbuf(), from rhs into *this. This move constructor is protected: it is called by the move constructors of movable input stream classes std::basic_ifstream and std::basic_istringstream, which know how to correctly move the associated stream buffer."
        },
        "parametres": "   sb   -   streambuffer to use as underlying device \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::istringstream s1(\"hello\");\n    std::istream s2(s1.rdbuf());                        // OK: s2 shares the buffer with s1\n \n//    std::istream s3(std::istringstream(\"test\"));      // ERROR: move constructor is protected\n//    std::istream s4(s2);                              // ERROR: copy constructor is deleted\n    std::istringstream s5(std::istringstream(\"world\")); // OK: move ctor called by derived class\n \n    std::cout << s2.rdbuf() << ' ' << s5.rdbuf() << '\\n';\n}",
            "output": "hello world"
        }
    },
    "basic_istream::~basic_istream": {
        "description": {
            "texte": "Destructs the input stream."
        },
        "exemple": {
            "input": "#include <sstream>\n#include <iostream>\n \nvoid print_stringbuf(std::streambuf* p)\n{\n    std::istream buf(p); // buf shares the buffer with s1\n    int n;\n    buf >> n;\n    std::cout << n;\n} // calls the destructor of buf. p remains unaffected\n \nint main()\n{\n    std::istringstream s1(\"10 20\");\n    print_stringbuf(s1.rdbuf());\n    int n;\n    s1 >> n;\n    std::cout << ',' << n << '\\n';\n}",
            "output": "10,20"
        }
    },
    "basic_istream::operator=": {
        "description": {
            "texte": "1) The copy assignment operator is protected, and is deleted. Input streams are not CopyAssignable.2) The move assignment operator exchanges the gcount() values and all data members of the base class, except for rdbuf(), with rhs, as if by calling swap(*rhs). This move assignment operator is protected: it is only called by the move assignment operators of the derived movable input stream classes std::basic_ifstream and std::basic_istringstream, which know how to correctly move-assign the associated streambuffers."
        },
        "parametres": "   rhs   -   the basic_istream object from which to assign to *this \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::istringstream s1;\n    s1 = std::istringstream(\"test\"); // OK\n \n    std::cin = std::istringstream(\"test\"); // ERROR: 'operator=' is protected\n}"
        }
    },
    "basic_istream::get": {
        "description": {
            "texte": "Extracts character or characters from stream.All versions behave as UnformattedInputFunctions. After constructing and checking the sentry object, these functions perform the following:All versions set the value of gcount() to the number of characters extracted."
        },
        "parametres": "   ch   -   reference to the character to write the result to \n   s   -   pointer to the character string to store the characters to \n   count   -   size of character string pointed to by s \n   delim   -   delimiting character to stop the extraction at. It is not extracted and not stored. \n   strbuf   -   stream buffer to read the content to \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::istringstream s1(\"Hello, world.\");\n    char c1 = s1.get(); // reads 'H'\n    std::cout << \"after reading \" << c1 << \", gcount() == \" <<  s1.gcount() << '\\n';\n    char c2;\n    s1.get(c2);         // reads 'e'\n    char str[5];\n    s1.get(str, 5);     // reads \"llo,\"\n    std::cout << \"after reading \" << str << \", gcount() == \" <<  s1.gcount() << '\\n';\n    std::cout << c1 << c2 << str;\n    s1.get(*std::cout.rdbuf()); // reads the rest, not including '\\n'\n    std::cout << \"\\nAfter the last get(), gcount() == \" << s1.gcount() << '\\n';\n}",
            "output": "after reading H, gcount() == 1\nafter reading llo,, gcount() == 4\nHello, world.\nAfter the last get(), gcount() == 7"
        }
    },
    "basic_istream::peek": {
        "description": {
            "texte": "Behaves as UnformattedInputFunction. After constructing and testing the sentry object, reads the next character from the input stream without extracting it."
        },
        "exemple": {
            "input": "#include <sstream>\n#include <iostream>\nint main()\n{\n    std::istringstream s1(\"Hello, world.\");\n    char c1 = s1.peek();\n    char c2 = s1.get();\n    std::cout << \"Peeked: \" << c1 << \" got: \" << c2 << '\\n';\n}",
            "output": "Peeked: H got: H"
        }
    },
    "basic_istream::unget": {
        "description": {
            "texte": "Makes the most recently extracted character available again.Then the function behaves as UnformattedInputFunction. After constructing and checking the sentry object, if any ios_base::iostate flags are set, the function sets failbit and returns. Otherwise, calls rdbuf()->sungetc().If rdbuf()->sungetc() returns Traits::eof(), calls setstate(badbit).In any case, sets the gcount() counter to zero."
        },
        "exemple": {
            "input": "#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::istringstream s1(\"Hello, world.\");\n    char c1 = s1.get();\n    if (s1.unget())\n    {\n        char c2 = s1.get();\n        std::cout << \"Got: \" << c1 << \" got again: \" << c2 << '\\n';\n    }\n}",
            "output": "Got: H got again: H"
        }
    },
    "basic_istream::putback": {
        "description": {
            "texte": "Puts the character ch back to the input stream so the next extracted character will be ch.First clears eofbit, then behaves as UnformattedInputFunction. After constructing and checking the sentry object, if rdbuf() is not null, calls rdbuf()->sputbackc(ch), which calls rdbuf()->pbackfail(ch) if ch does not equal the most recently extracted character.If rdbuf() is null or if rdbuf->sputbackc(ch) returns Traits::eof(), calls setstate(badbit).In any case, sets the gcount() counter to zero."
        },
        "parametres": "   ch   -   character to put into input stream \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::stringstream s1(\"Hello, world\"); // IO stream\n    s1.get();\n    if (s1.putback('Y')) // modifies the buffer\n        std::cout << s1.rdbuf() << '\\n';\n    else\n        std::cout << \"putback failed\\n\";\n \n    std::istringstream s2(\"Hello, world\"); // input-only stream\n    s2.get();\n    if (s2.putback('Y')) // cannot modify input-only buffer\n        std::cout << s2.rdbuf() << '\\n';\n    else\n        std::cout << \"putback failed\\n\";\n \n    s2.clear();\n    if (s2.putback('H')) // non-modifying putback\n        std::cout << s2.rdbuf() << '\\n';\n    else\n        std::cout << \"putback failed\\n\";\n}",
            "output": "Yello, world\nputback failed\nHello, world"
        }
    },
    "basic_istream::getline": {
        "description": {
            "texte": "Extracts characters from stream until end of line or the specified delimiter delim.The first version is equivalent to getline(s, count, widen('\\n')).Behaves as UnformattedInputFunction. After constructing and checking the sentry object, extracts characters from *this and stores them in successive locations of the array whose first element is pointed to by s, until any of the following occurs (tested in the order shown):If the function extracts no characters (e.g. if count < 1), setstate(failbit) is executed.In any case, if count>0, it then stores a null character CharT() into the next successive location of the array and updates gcount()."
        },
        "parametres": "   s   -   pointer to the character string to store the characters to \n   count   -   size of character string pointed to by s \n   delim   -   delimiting character to stop the extraction at. It is extracted but not stored. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <array>\n \nint main()\n{\n    std::istringstream input(\"abc|def|gh\");\n    std::vector<std::array<char, 4>> v;\n \n    // note: the following loop terminates when std::ios_base::operator bool()\n    // on the stream returned from getline() returns false\n    for (std::array<char, 4> a; input.getline(&a[0], 4, '|'); ) {\n        v.push_back(a);\n    }\n \n    for (auto& a : v) {\n        std::cout << &a[0] << '\\n';\n    }\n}",
            "output": "abc\ndef\ngh"
        }
    },
    "basic_istream::ignore": {
        "description": {
            "texte": "Extracts and discards characters from the input stream until and including delim.ignore behaves as an UnformattedInputFunction. After constructing and checking the sentry object, it extracts characters from the stream and discards them until any one of the following conditions occurs:"
        },
        "parametres": "   count   -   number of characters to extract \n   delim   -   delimiting character to stop the extraction at. It is also extracted. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n#include <limits>\n \nint main()\n{\n    std::istringstream input(\"1\\n\"\n                             \"some non-numeric input\\n\"\n                             \"2\\n\");\n    for(;;) {\n        int n;\n        input >> n;\n \n        if (input.eof() || input.bad()) {\n            break;\n        } else if (input.fail()) {\n            input.clear(); // unset failbit\n            input.ignore(std::numeric_limits<std::streamsize>::max(), '\\n'); // skip bad input\n        } else {\n            std::cout << n << '\\n';\n        }\n    }\n}",
            "output": "1\n2"
        }
    },
    "basic_istream::read": {
        "description": {
            "texte": "Extracts characters from stream.Behaves as UnformattedInputFunction. After constructing and checking the sentry object, extracts characters and stores them into successive locations of the character array whose first element is pointed to by s. Characters are extracted and stored until any of the following conditions occurs:"
        },
        "parametres": "   s   -   pointer to the character array to store the characters to \n   count   -   number of characters to read \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cstdint>\n \nint main()\n{\n    // read() is often used for binary I/O\n    std::string bin = {'\\x12', '\\x12', '\\x12', '\\x12'};\n    std::istringstream raw(bin);\n    std::uint32_t n;\n    if(raw.read(reinterpret_cast<char*>(&n), sizeof n))\n        std::cout << std::hex << std::showbase << n << '\\n';\n \n    // prepare file for next snippet\n    std::ofstream(\"test.txt\", std::ios::binary) << \"abcd1\\nabcd2\\nabcd3\";\n \n    // read entire file into string\n    if(std::ifstream is{\"test.txt\", std::ios::binary | std::ios::ate}) {\n        auto size = is.tellg();\n        std::string str(size, '\\0'); // construct string to stream size\n        is.seekg(0);\n        if(is.read(&str[0], size))\n            std::cout << str << '\\n';\n    }\n}",
            "output": "0x12121212\nabcd1\nabcd2\nabcd3"
        }
    },
    "basic_istream::readsome": {
        "description": {
            "texte": "Extracts up to count immediately available characters from the input stream. The extracted characters are stored into the character array pointed to by s.Behaves as UnformattedInputFunction. After constructing and checking the sentry object,"
        },
        "parametres": "   s   -   pointer to the character array to store the characters to \n   count   -   maximum number of characters to read \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n \nint main()\n{\n    char c[10] = {};\n    std::istringstream input(\"This is sample text.\"); // std::stringbuf makes its entire\n                                                      // buffer available for unblocking read\n    input.readsome(c, 5); // reads 'This ' and stores in c[0] .. c[4]\n    input.readsome(c, 9); // reads 'is sample' and stores in c[0] .. c[8]\n    std::cout << c;\n}",
            "output": "is sample"
        }
    },
    "basic_istream::gcount": {
        "description": {
            "texte": "Returns the number of characters extracted by the last unformatted input operation.The following member functions of basic_istream change the value of subsequent gcount() calls:The following functions set gcount() to zero:"
        },
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n \nint main()\n{\n    char x[20];\n    std::istringstream stream(\"Hello World\");\n \n    stream.read(x, sizeof x);\n    std::cout << \"Characters extracted: \" << stream.gcount();\n}",
            "output": "Characters extracted: 11"
        }
    },
    "basic_istream::tellg": {
        "description": {
            "texte": "Returns input position indicator of the current associated streambuf object.Behaves as UnformattedInputFunction, except that gcount() is not affected. After constructing and checking the sentry object, if fail() == true, returns pos_type(-1). Otherwise, returns rdbuf()->pubseekoff(0, std::ios_base::cur, std::ios_base::in)."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <sstream>\n \nint main()\n{\n    std::string str = \"Hello, world\";\n    std::istringstream in(str);\n    std::string word;\n    in >> word;\n    std::cout << \"After reading the word \\\"\" << word\n              << \"\\\" tellg() returns \" << in.tellg() << '\\n';\n}",
            "output": "After reading the word \"Hello,\" tellg() returns 6"
        }
    },
    "basic_istream::seekg": {
        "description": {
            "texte": "Sets input position indicator of the current associated streambuf object. In case of failure, calls setstate(std::ios_base::failbit).seekg behaves as UnformattedInputFunction, except that gcount() is not affected. After constructing and checking the sentry object,"
        },
        "parametres": "   pos   -   absolute position to set the input position indicator to. \n   off   -   relative position to set the input position indicator to. \n   dir   -   defines base position to apply the relative offset to. It can be one of the following constants:    Constant   Explanation \n   beg   the beginning of a stream \n   end   the ending of a stream \n   cur   the current position of stream position indicator \n  \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <sstream>\n \nint main()\n{\n    std::string str = \"Hello, world\";\n    std::istringstream in(str);\n    std::string word1, word2;\n \n    in >> word1;\n    in.seekg(0); // rewind\n    in >> word2;\n \n    std::cout << \"word1 = \" << word1 << '\\n'\n              << \"word2 = \" << word2 << '\\n';\n}",
            "output": "word1 = Hello,\nword2 = Hello,"
        }
    },
    "basic_istream::sync": {
        "description": {
            "texte": "Synchronizes the input buffer with the associated data source.Behaves as UnformattedInputFunction, except that gcount() is not affected. After constructing and checking the sentry object,if rdbuf() is a null pointer, returns -1.Otherwise, calls rdbuf()->pubsync(). If that function returns -1, calls setstate(badbit) and returns -1. Otherwise, returns \u200b0\u200b."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n \nvoid file_abc()\n{\n    std::ofstream f(\"test.txt\");\n    f << \"abc\\n\";\n}\n \nvoid file_123()\n{\n    std::ofstream f(\"test.txt\");\n    f << \"123\\n\";\n}\n \nint main()\n{\n    file_abc(); // file now contains \"abc\"\n    std::ifstream f(\"test.txt\");\n    std::cout << \"Reading from the file\\n\";\n    char c;\n    f >> c; std::cout << c;\n    file_123(); // file now contains \"123\"\n    f >> c; std::cout << c;\n    f >> c; std::cout << c << '\\n';\n    f.close();\n \n    file_abc(); // file now contains \"abc\"\n    f.open(\"test.txt\");\n    std::cout << \"Reading from the file, with sync()\\n\";\n    f >> c; std::cout << c;\n    file_123(); // file now contains \"123\"\n    f.sync();\n    f >> c; std::cout << c;\n    f >> c; std::cout << c << '\\n';\n}",
            "output": "Reading from the file\nabc\nReading from the file, with sync()\na23"
        }
    },
    "basic_istream::swap": {
        "description": {
            "texte": "Calls basic_ios::swap(rhs) to swap all data members of the base class except for rdbuf(), and swaps the values of the gcount() counters between *this and rhs. This swap function is protected: it is called by the swap functions of the swappable input stream classes std::basic_ifstream and std::basic_istringstream, which know how to correctly swap the associated streambuffers."
        },
        "parametres": "   rhs   -   different basic_istream object of the same type to swap with \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <iostream>\n#include <utility>\nint main()\n{\n    std::istringstream s1(\"hello\");\n    std::istringstream s2(\"bye\");\n \n    s1.swap(s2); // OK, istringstream has a public swap()\n    std::swap(s1, s2); // OK, calls s1.swap(s2)\n//  std::cin.swap(s2); // ERROR: swap is a protected member\n \n    std::cout << s1.rdbuf();\n}",
            "output": "hello"
        }
    },
    "basic_istream::sentry": {
        "description": {
            "texte": "An object of class basic_istream::sentry is constructed in local scope at the beginning of each member function of std::basic_istream that performs input (both formatted and unformatted). Its constructor prepares the input stream: checks if the stream is already in a failed state, flushes the tie()'d output streams, skips leading whitespace unless noskipws flag is set, and performs other implementation-defined tasks if necessary. All cleanup, if necessary, is performed in the destructor, so that it is guaranteed to happen if exceptions are thrown during input."
        },
        "parametres": "   is   -   input stream to prepare \n   noskipws   -   true if whitespace should not be skipped \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n \nstruct Foo\n{\n   char n[5];\n};\n \nstd::istream& operator>>(std::istream& is, Foo& f)\n{\n    std::istream::sentry s(is);\n    if (s)\n        is.read(f.n, 5);\n    return is;\n}\n \nint main()\n{\n    std::string input = \"   abcde\";\n    std::istringstream stream(input);\n    Foo f;\n    stream >> f;\n    std::cout.write(f.n, 5);\n    std::cout << '\\n';\n}",
            "output": "abcde"
        }
    },
    "basic_ostream::basic_ostream": {
        "description": {
            "texte": "1) Constructs the basic_ostream object, assigning initial values to the base class by calling basic_ios::init(sb).2) The copy constructor is protected, and is deleted. Output streams are not copyable.3) The move constructor uses basic_ios<CharT, Traits>::move(rhs) to move all basic_ios members, except for the rdbuf(), from rhs into *this. This move constructor is protected: it is called by the move constructors of movable output stream classes std::basic_ofstream and std::basic_ostringstream, which know how to correctly move the associated streambuffer."
        },
        "parametres": "   sb   -   streambuffer to use as output sequence \n   rhs   -   basic_ostream to initialize from \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <utility>\n#include <iostream>\n \nint main()\n{\n    // ERROR: copy ctor is deleted\n//  std::ostream myout(std::cout);\n \n    // OK: shares buffer with cout\n    std::ostream myout(std::cout.rdbuf());\n \n    // ERROR: move constructor is protected\n//  std::ostream s2(std::move(std::ostringstream() << 7.1));    \n \n    // OK: move ctor called through the derived class\n    std::ostringstream s2(std::move(std::ostringstream() << 7.1)); \n    myout << s2.str() << '\\n';\n}",
            "output": "7.1"
        }
    },
    "basic_ostream::~basic_ostream": {
        "description": {
            "texte": "Destroys the basic_ostream object. This destructor does not perform any operation on the underlying streambuffer (rdbuf()): the destructors of the derived output streams such as std::basic_ofstream and std::basic_ostringstream are responsible for calling the destructors of the stream buffers."
        },
        "exemple": {
            "input": "#include <sstream>\n#include <iostream>\nvoid add_words(std::streambuf* p)\n{\n    std::ostream buf(p); // buf shares the buffer with s\n    buf << \" is the answer\";\n} // calls the destructor of buf. p remains unaffected\nint main()\n{\n    std::ostringstream s;\n    s << 42;\n    add_words(s.rdbuf());\n    s << \".\";\n    std::cout << s.str() << '\\n';\n}",
            "output": "42 is the answer."
        }
    },
    "basic_ostream::operator=": {
        "description": {
            "texte": "1) The copy assignment operator is protected, and is deleted. Output streams are not CopyAssignable.2) The move assignment operator exchanges all data members of the base class, except for rdbuf(), with rhs, as if by calling swap(*rhs). This move assignment operator is protected: it is only called by the move assignment operators of the derived movable output stream classes std::basic_ofstream and std::basic_ostringstream, which know how to correctly move-assign the associated streambuffers."
        },
        "parametres": "   rhs   -   the basic_ostream object from which to assign to *this \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <utility>\n#include <iostream>\nint main()\n{\n    std::ostringstream s;\n//  std::cout = s;                             // ERROR: copy assignment operator is deleted\n//  std::cout = std::move(s);                  // ERROR: move assignment operator is protected\n    s = std::move(std::ostringstream() << 42); // OK, moved through derived\n    std::cout << s.str() << '\\n';\n}",
            "output": "42"
        }
    },
    "basic_ostream::operator<<": {
        "description": {
            "texte": "Inserts data into the stream."
        },
        "parametres": "   value   -   integer, floating-point, boolean, or pointer value to insert \n   func   -   function to call \n   sb   -   pointer to the streambuffer to read the data from \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <sstream>\nint main()\n{\n    std::istringstream input(\" \\\"Some text.\\\" \");\n    volatile int n = 42;\n    double f = 3.14;\n    bool b = true;\n    std::cout << n   // int overload\n              << ' ' // non-member overload\n              << std::boolalpha << b // bool overload\n              << \" \" // non-member overload\n              << std::fixed << f // double overload\n              << input.rdbuf() // streambuf overload\n              << &n // bool overload: volatile int* doesn't convert to const void*\n              << std::endl; // function overload\n}",
            "output": "42 true 3.140000 \"Some text.\" true"
        }
    },
    "basic_ostream::put": {
        "description": {
            "texte": "Behaves as an UnformattedOutputFunction. After constructing and checking the sentry object, writes the character ch to the output stream.If the output fails for any reason, sets badbit."
        },
        "parametres": "   ch   -   character to write \n\n",
        "exemple": {
            "input": "#include <fstream>\n#include <iostream>\n \nint main()\n{\n    std::cout.put('a'); // normal usage\n    std::cout.put('\\n');\n \n    std::ofstream s(\"/does/not/exist/\");\n    s.clear(); // pretend the stream is good\n    std::cout << \"Unformatted output: \";\n    s.put('c'); // this will set badbit, but not failbit\n    std::cout << \" fail=\" << bool(s.rdstate() & s.failbit);\n    std::cout << \" bad=\" << s.bad() << '\\n';\n    s.clear();\n    std::cout << \"Formatted output:   \";\n    s << 'c'; // this will set badbit and failbit\n    std::cout << \" fail=\" << bool(s.rdstate() & s.failbit);\n    std::cout << \" bad=\" << s.bad() << '\\n';\n}",
            "output": "a\nUnformatted output:  fail=0 bad=1\nFormatted output:    fail=1 bad=1"
        }
    },
    "basic_ostream::write": {
        "description": {
            "texte": "Behaves as an UnformattedOutputFunction. After constructing and checking the sentry object, outputs the characters from successive locations in the character array whose first element is pointed to by s. Characters are inserted into the output sequence until one of the following occurs:"
        },
        "parametres": "   s   -   pointer to the character string to write \n   count   -   number of characters to write \n\n",
        "exemple": {
            "input": "#include <iostream>\n \nint main()\n{\n    int n = 0x41424344;\n    std::cout.write(reinterpret_cast<char*>(&n), sizeof n) << '\\n';\n \n    char c[]=\"This is sample text.\";\n    std::cout.write(c,4)<<'\\n';\n}",
            "output": "DCBA\nThis"
        }
    },
    "basic_ostream::tellp": {
        "description": {
            "texte": "Returns the output position indicator of the current associated streambuf object.If fail()==true, returns pos_type(-1). Otherwise, returns rdbuf()->pubseekoff(0, std::ios_base::cur, std::ios_base::out)."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\nint main()\n{\n    std::ostringstream s;\n    std::cout << s.tellp() << '\\n';\n    s << 'h';\n    std::cout << s.tellp() << '\\n';\n    s << \"ello, world \";\n    std::cout << s.tellp() << '\\n';\n    s << 3.14 << '\\n';\n    std::cout << s.tellp() << '\\n' << s.str();\n}",
            "output": "0\n1\n13\n18\nhello, world 3.14"
        }
    },
    "basic_ostream::seekp": {
        "description": {
            "texte": "Sets the output position indicator of the current associated streambuf object."
        },
        "parametres": "   pos   -   absolute position to set the output position indicator to. \n   off   -   relative position to set the output position indicator to. \n   dir   -   defines base position to apply the relative offset to. It can be one of the following constants:    Constant   Explanation \n   beg   the beginning of a stream \n   end   the ending of a stream \n   cur   the current position of stream position indicator \n  \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <iostream>\n \nint main()\n{\n    std::ostringstream os(\"hello, world\");\n    os.seekp(7);\n    os << 'W';\n    os.seekp(0, std::ios_base::end);\n    os << '!';\n    os.seekp(0);\n    os << 'H';\n    std::cout << os.str() << '\\n';\n}",
            "output": "Hello, World!"
        }
    },
    "basic_ostream::flush": {
        "description": {
            "texte": "Writes uncommitted changes to the underlying output sequence.If rdbuf() is a null pointer, does nothing.Otherwise, behaves as an UnformattedOutputFunction (since C++11). After constructing and checking the sentry object, calls rdbuf()->pubsync(). If the call returns -1, calls setstate(badbit)."
        },
        "exemple": {
            "input": "#include <thread>\n#include <iostream>\n#include <chrono>\nvoid f()\n{\n    std::cout << \"Output from thread...\";\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n    std::cout << \"...thread calls flush()\\n\";\n    std::cout.flush();\n}\n \nint main()\n{\n    std::thread t1(f);\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    std::clog << \"Output from main\\n\";\n    t1.join();\n}",
            "output": "Output from main\nOutput from thread.....thread calls flush()"
        }
    },
    "basic_ostream::swap": {
        "description": {
            "texte": "Calls basic_ios::swap(rhs) to swap all data members of the base class, except for rdbuf(), between *this and rhs. This swap function is protected: it is called by the swap functions of the swappable output stream classes std::basic_ofstream and std::basic_ostringstream, which know how to correctly swap the associated streambuffers."
        },
        "parametres": "   rhs   -   a basic_ostream of the same type to swap with \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <iostream>\n#include <utility>\nint main()\n{\n    std::ostringstream s1(\"hello\");\n    std::ostringstream s2(\"bye\");\n \n    s1.swap(s2); // OK, ostringstream has a public swap()\n    std::swap(s1, s2); // OK, calls s1.swap(s2)\n \n//  std::cout.swap(s2); // ERROR: swap is a protected member\n \n    std::cout << s1.str() << '\\n';\n}",
            "output": "hello"
        }
    },
    "basic_ostream::sentry": {
        "description": {
            "texte": "An object of class basic_ostream::sentry is constructed in local scope at the beginning of each member function of std::basic_ostream that performs output (both formatted and unformatted). Its constructor prepares the output stream: checks if the stream is already in a failed state, flushes the tie()'d output streams, and performs other implementation-defined tasks if necessary. Implementation-defined cleanup, as well as flushing of the output stream if necessary, is performed in the destructor, so that it is guaranteed to happen if exceptions are thrown during output."
        },
        "parametres": "   os   -   output stream to prepare \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n \nstruct Foo\n{\n    char n[6];\n};\n \nstd::ostream& operator<<(std::ostream& os, Foo& f)\n{\n    std::ostream::sentry s(os);\n    if (s) {\n        os.write(f.n, 5);\n    }\n    return os;\n}\n \nint main()\n{\n    Foo f = { \"abcde\" };\n    std::cout << f << '\\n';\n}",
            "output": "abcde"
        }
    },
    "basic_iostream::basic_iostream": {
        "description": {
            "texte": "Constructs new stream object."
        },
        "parametres": "   sb   -   streambuf to initialize with \n   other   -   another stream to initialize with \n\n"
    },
    "basic_iostream::~basic_iostream": {
        "description": {
            "texte": "Destructs the input/output stream."
        }
    },
    "basic_iostream::operator=": {
        "description": {
            "texte": "Assigns another stream object."
        },
        "parametres": "   other   -   another stream to assign state of \n\n"
    },
    "basic_iostream::swap": {
        "description": {
            "texte": "Exchanges the state with another input/output stream object. Effectively calls basic_istream<CharT,Traits>::swap(other).This member function is protected: it is called by the swap member functions of the derived stream classes std::basic_stringstream and std::basic_fstream, which know how to correctly swap the associated stream buffers."
        },
        "parametres": "   other   -   another stream to exchange the state with \n\n"
    },
    "basic_fstream::basic_fstream": {
        "description": {
            "texte": "Constructs new file stream."
        },
        "parametres": "   filename   -   the name of the file to be opened \n   mode   -   specifies stream open mode. It is bitmask type, the following constants are defined:    Constant   Explanation \n   app   seek to the end of stream before each write \n   binary   open in binary mode \n   in   open for reading \n   out   open for writing \n   trunc   discard the contents of the stream when opening \n   ate   seek to the end of stream immediately after open \n  \n   other   -   another file stream to use as source \n\n"
    },
    "basic_fstream::operator=": {
        "description": {
            "texte": "Move assigns the file stream other to *this, effectively move-assigning both the std::basic_iostream base class and the associated std::basic_filebuf.other is left with no associated file. Note that the base class move assignment swaps all stream state variables (except for rdbuf) between *this and other."
        },
        "parametres": "   other   -   file stream to move. \n\n"
    },
    "basic_fstream::swap": {
        "description": {
            "texte": "Exchanges the state of the stream with those of other.This is done by calling basic_iostream<CharT, Traits>::swap(other) and rdbuf()->swap(other.rdbuf())."
        },
        "parametres": "   other   -   stream to exchange the state with \n\n"
    },
    "basic_fstream::rdbuf": {
        "description": {
            "texte": "Returns pointer to the underlying raw file device object."
        }
    },
    "basic_fstream::is_open": {
        "description": {
            "texte": "Checks if the file stream has an associated file.Effectively calls rdbuf()->is_open()."
        },
        "exemple": {
            "input": "#include <string>\n#include <fstream>\n#include <iostream>\n \nint main()\n{\n    std::string filename = \"some_file\";\n \n    std::fstream fs(filename, std::ios::in);\n \n    std::cout << std::boolalpha;\n    std::cout << \"fs.is_open() = \" << fs.is_open() << '\\n';\n \n    if(!fs.is_open())\n    {\n       fs.clear();\n       fs.open(filename, std::ios::out);\n       std::cout << \"fs.is_open() = \" << fs.is_open() << '\\n';\n    }\n}",
            "output": "fs.is_open() = false\nfs.is_open() = true"
        }
    },
    "basic_fstream::open": {
        "description": {
            "texte": "Opens and associates the file with name filename with the file stream.Calls setstate(failbit) on failure."
        },
        "parametres": "   filename   -   the name of the file to be opened \n   mode   -   specifies stream open mode. It is bitmask type, the following constants are defined:    Constant   Explanation \n   app   seek to the end of stream before each write \n   binary   open in binary mode \n   in   open for reading \n   out   open for writing \n   trunc   discard the contents of the stream when opening \n   ate   seek to the end of stream immediately after open \n  \n\n",
        "exemple": {
            "input": "#include <string>\n#include <fstream>\n#include <iostream>\n \nint main()\n{\n    std::string filename = \"example.123\";\n \n    std::fstream fs;\n \n    fs.open(filename);\n \n    if(!fs.is_open())\n    {\n       fs.clear();\n       fs.open(filename, std::ios::out); //Create file.\n       fs.close();\n       fs.open(filename);\n    }\n \n    std::cout << std::boolalpha;\n    std::cout << \"fs.is_open() = \" << fs.is_open() << '\\n';\n    std::cout << \"fs.good() = \" << fs.good() << '\\n';\n}"
        }
    },
    "basic_fstream::close": {
        "description": {
            "texte": "Closes the associated file.Effectively calls rdbuf()->close(). If an error occurs during operation, setstate(failbit) is called."
        },
        "exemple": {
            "input": "#include <string>\n#include <fstream>\n#include <iostream>\n \nint main()\n{\n    std::fstream f1(\"example1\", std::ios::out),\n                 f2(\"example2\", std::ios::out),\n                 f3(\"example3\", std::ios::out);\n \n    std::cout << std::boolalpha\n              << f1.is_open() << '\\n'\n              << f2.is_open() << '\\n'\n              << f3.is_open() << '\\n';\n \n    f1.close();\n    f2.close();\n \n    std::cout << f1.is_open() << '\\n'\n              << f2.is_open() << '\\n'\n              << f3.is_open() << '\\n';\n}",
            "output": "true\ntrue\ntrue\nfalse\nfalse\ntrue"
        }
    },
    "basic_ifstream::basic_ifstream": {
        "description": {
            "texte": "Constructs new file stream."
        },
        "parametres": "   filename   -   the name of the file to be opened \n   mode   -   specifies stream open mode. It is bitmask type, the following constants are defined:    Constant   Explanation \n   app   seek to the end of stream before each write \n   binary   open in binary mode \n   in   open for reading \n   out   open for writing \n   trunc   discard the contents of the stream when opening \n   ate   seek to the end of stream immediately after open \n  \n   other   -   another file stream to use as source \n\n"
    },
    "basic_ifstream::operator=": {
        "description": {
            "texte": "Move assigns the file stream other to *this, effectively move-assigning both the std::basic_istream base class and the associated std::basic_filebuf.other is left with no associated file. Note that the base class move assignment swaps all stream state variables (except for rdbuf) between *this and other."
        },
        "parametres": "   other   -   file stream to move. \n\n"
    },
    "basic_ifstream::swap": {
        "description": {
            "texte": "Exchanges the state of the stream with those of other.This is done by calling basic_istream<CharT, Traits>::swap(other) and rdbuf()->swap(other.rdbuf())."
        },
        "parametres": "   other   -   stream to exchange the state with \n\n"
    },
    "basic_ifstream::rdbuf": {
        "description": {
            "texte": "Returns pointer to the underlying raw file device object."
        }
    },
    "basic_ifstream::is_open": {
        "description": {
            "texte": "Checks if the file stream has an associated file.Effectively calls rdbuf()->is_open()."
        },
        "exemple": {
            "input": "#include <string>\n#include <fstream>\n#include <iostream>\n//this file is called main.cpp\n \nbool file_exists(const std::string& str)\n{\n   std::ifstream fs(str);\n   return fs.is_open();\n}\n \nint main()\n{\n  std::boolalpha(std::cout);\n  std::cout << file_exists(\"main.cpp\")  << '\\n'\n            << file_exists(\"strange_file\") << '\\n';\n}",
            "output": "true\nfalse"
        }
    },
    "basic_ifstream::open": {
        "description": {
            "texte": "Opens and associates the file with name filename with the file stream.Calls setstate(failbit) on failure."
        },
        "parametres": "   filename   -   the name of the file to be opened \n   mode   -   specifies stream open mode. It is bitmask type, the following constants are defined:    Constant   Explanation \n   app   seek to the end of stream before each write \n   binary   open in binary mode \n   in   open for reading \n   out   open for writing \n   trunc   discard the contents of the stream when opening \n   ate   seek to the end of stream immediately after open \n  \n\n"
    },
    "basic_ifstream::close": {
        "description": {
            "texte": "Closes the associated file.Effectively calls rdbuf()->close(). If an error occurs during operation, setstate(failbit) is called."
        }
    },
    "basic_ofstream::basic_ofstream": {
        "description": {
            "texte": "Constructs new file stream."
        },
        "parametres": "   filename   -   the name of the file to be opened \n   mode   -   specifies stream open mode. It is bitmask type, the following constants are defined:    Constant   Explanation \n   app   seek to the end of stream before each write \n   binary   open in binary mode \n   in   open for reading \n   out   open for writing \n   trunc   discard the contents of the stream when opening \n   ate   seek to the end of stream immediately after open \n  \n   other   -   another file stream to use as source \n\n"
    },
    "basic_ofstream::operator=": {
        "description": {
            "texte": "Move assigns the file stream other to *this, effectively move-assigning both the std::basic_ostream base class and the associated std::basic_filebuf.other is left with no associated file. Note that the base class move assignment swaps all stream state variables (except for rdbuf) between *this and other."
        },
        "parametres": "   other   -   file stream to move. \n\n"
    },
    "basic_ofstream::swap": {
        "description": {
            "texte": "Exchanges the state of the stream with those of other.This is done by calling basic_ostream<CharT, Traits>::swap(other) and rdbuf()->swap(other.rdbuf())."
        },
        "parametres": "   other   -   stream to exchange the state with \n\n"
    },
    "basic_ofstream::rdbuf": {
        "description": {
            "texte": "Returns pointer to the underlying raw file device object."
        }
    },
    "basic_ofstream::is_open": {
        "description": {
            "texte": "Checks if the file stream has an associated file.Effectively calls rdbuf()->is_open()."
        }
    },
    "basic_ofstream::open": {
        "description": {
            "texte": "Opens and associates the file with name filename with the file stream.Calls setstate(failbit) on failure."
        },
        "parametres": "   filename   -   the name of the file to be opened \n   mode   -   specifies stream open mode. It is bitmask type, the following constants are defined:    Constant   Explanation \n   app   seek to the end of stream before each write \n   binary   open in binary mode \n   in   open for reading \n   out   open for writing \n   trunc   discard the contents of the stream when opening \n   ate   seek to the end of stream immediately after open \n  \n\n"
    },
    "basic_ofstream::close": {
        "description": {
            "texte": "Closes the associated file.Effectively calls rdbuf()->close(). If an error occurs during operation, setstate(failbit) is called."
        }
    },
    "basic_stringstream::basic_stringstream": {
        "description": {
            "texte": "Constructs new string stream."
        },
        "parametres": "   str   -   string to use as initial contents of the string stream \n   mode   -   specifies stream open mode. It is bitmask type, the following constants are defined:    Constant   Explanation \n   app   seek to the end of stream before each write \n   binary   open in binary mode \n   in   open for reading \n   out   open for writing \n   trunc   discard the contents of the stream when opening \n   ate   seek to the end of stream immediately after open \n  \n   other   -   another string stream to use as source \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\nint main()\n{\n    // default constructor (input/output stream)\n    std::stringstream buf1;\n    buf1 << 7;\n    int n = 0;\n    buf1 >> n;\n    std::cout << \"buf1 = \" << buf1.str() << \" n = \" << n << '\\n';\n \n    // input stream\n    std::istringstream inbuf(\"-10\");\n    inbuf >> n;\n    std::cout << \"n = \" << n << '\\n';\n \n    // output stream in append mode (C++11)\n    std::ostringstream buf2(\"test\", std::ios_base::ate);\n    buf2 << '1';\n    std::cout << buf2.str() << '\\n';\n}",
            "output": "buf1 = 7 n = 7\nn = -10\ntest1"
        }
    },
    "basic_stringstream::operator=": {
        "description": {
            "texte": "Move assigns the string stream other to *this, effectively move-assigning both the std::basic_iostream base class and the associated std::basic_stringbuf.Note that the base class move assignment swaps all stream state variables (except for rdbuf) between *this and other."
        },
        "parametres": "   other   -   string stream to move from \n\n"
    },
    "basic_stringstream::swap": {
        "description": {
            "texte": "Exchanges the state of the stream with those of other.This is done by callingbasic_iostream<CharT, Traits>::swap(other) and rdbuf()->swap(*other.rdbuf())."
        },
        "parametres": "   other   -   stream to exchange the state with \n\n"
    },
    "basic_stringstream::rdbuf": {
        "description": {
            "texte": "Returns pointer to the underlying raw string device object."
        }
    },
    "basic_stringstream::str": {
        "description": {
            "texte": "Manages the contents of the underlying string object.1) Returns a copy of the underlying string as if by calling rdbuf()->str().2) Replaces the contents of the underlying string as if by calling rdbuf()->str(new_str)."
        },
        "parametres": "   new_str   -   new contents of the underlying string \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <iostream>\nint main()\n{\n    int n;\n \n    std::istringstream in;  // could also use in(\"1 2\")\n    in.str(\"1 2\");\n    in >> n;\n    std::cout << \"after reading the first int from \\\"1 2\\\", the int is \"\n              << n << \", str() = \\\"\" << in.str() << \"\\\"\\n\";\n \n    std::ostringstream out(\"1 2\");\n    out << 3;\n    std::cout << \"after writing the int '3' to output stream \\\"1 2\\\"\"\n              << \", str() = \\\"\" << out.str() << \"\\\"\\n\";\n \n    std::ostringstream ate(\"1 2\", std::ios_base::ate);\n    ate << 3;\n    std::cout << \"after writing the int '3' to append stream \\\"1 2\\\"\"\n              << \", str() = \\\"\" << ate.str() << \"\\\"\\n\";\n}",
            "output": "after reading the first int from \"1 2\", the int is 1, str() = \"1 2\"\nafter writing the int '3' to output stream \"1 2\", str() = \"3 2\"\nafter writing the int '3' to append stream \"1 2\", str() = \"1 23\""
        }
    },
    "basic_istringstream::basic_istringstream": {
        "description": {
            "texte": "Constructs new string stream."
        },
        "parametres": "   str   -   string to use as initial contents of the string stream \n   mode   -   specifies stream open mode. It is bitmask type, the following constants are defined:    Constant   Explanation \n   app   seek to the end of stream before each write \n   binary   open in binary mode \n   in   open for reading \n   out   open for writing \n   trunc   discard the contents of the stream when opening \n   ate   seek to the end of stream immediately after open \n  \n   other   -   another string stream to use as source \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\nint main()\n{\n    // default constructor (input/output stream)\n    std::stringstream buf1;\n    buf1 << 7;\n    int n = 0;\n    buf1 >> n;\n    std::cout << \"buf1 = \" << buf1.str() << \" n = \" << n << '\\n';\n \n    // input stream\n    std::istringstream inbuf(\"-10\");\n    inbuf >> n;\n    std::cout << \"n = \" << n << '\\n';\n \n    // output stream in append mode (C++11)\n    std::ostringstream buf2(\"test\", std::ios_base::ate);\n    buf2 << '1';\n    std::cout << buf2.str() << '\\n';\n}",
            "output": "buf1 = 7 n = 7\nn = -10\ntest1"
        }
    },
    "basic_istringstream::operator=": {
        "description": {
            "texte": "Move assigns the string stream other to *this, effectively move-assigning both the std::basic_istream base class and the associated std::basic_stringbuf.Note that the base class move assignment swaps all stream state variables (except for rdbuf) between *this and other."
        },
        "parametres": "   other   -   string stream to move from \n\n"
    },
    "basic_istringstream::swap": {
        "description": {
            "texte": "Exchanges the state of the stream with those of other.This is done by callingbasic_istream<CharT, Traits>::swap(other) and rdbuf()->swap(*other.rdbuf())."
        },
        "parametres": "   other   -   stream to exchange the state with \n\n"
    },
    "basic_istringstream::rdbuf": {
        "description": {
            "texte": "Returns pointer to the underlying raw string device object."
        }
    },
    "basic_istringstream::str": {
        "description": {
            "texte": "Manages the contents of the underlying string object.1) Returns a copy of the underlying string as if by calling rdbuf()->str().2) Replaces the contents of the underlying string as if by calling rdbuf()->str(new_str)."
        },
        "parametres": "   new_str   -   new contents of the underlying string \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <iostream>\nint main()\n{\n    int n;\n \n    std::istringstream in;  // could also use in(\"1 2\")\n    in.str(\"1 2\");\n    in >> n;\n    std::cout << \"after reading the first int from \\\"1 2\\\", the int is \"\n              << n << \", str() = \\\"\" << in.str() << \"\\\"\\n\";\n \n    std::ostringstream out(\"1 2\");\n    out << 3;\n    std::cout << \"after writing the int '3' to output stream \\\"1 2\\\"\"\n              << \", str() = \\\"\" << out.str() << \"\\\"\\n\";\n \n    std::ostringstream ate(\"1 2\", std::ios_base::ate);\n    ate << 3;\n    std::cout << \"after writing the int '3' to append stream \\\"1 2\\\"\"\n              << \", str() = \\\"\" << ate.str() << \"\\\"\\n\";\n}",
            "output": "after reading the first int from \"1 2\", the int is 1, str() = \"1 2\"\nafter writing the int '3' to output stream \"1 2\", str() = \"3 2\"\nafter writing the int '3' to append stream \"1 2\", str() = \"1 23\""
        }
    },
    "basic_ostringstream::basic_ostringstream": {
        "description": {
            "texte": "Constructs new string stream."
        },
        "parametres": "   str   -   string to use as initial contents of the string stream \n   mode   -   specifies stream open mode. It is bitmask type, the following constants are defined:    Constant   Explanation \n   app   seek to the end of stream before each write \n   binary   open in binary mode \n   in   open for reading \n   out   open for writing \n   trunc   discard the contents of the stream when opening \n   ate   seek to the end of stream immediately after open \n  \n   other   -   another string stream to use as source \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\nint main()\n{\n    // default constructor (input/output stream)\n    std::stringstream buf1;\n    buf1 << 7;\n    int n = 0;\n    buf1 >> n;\n    std::cout << \"buf1 = \" << buf1.str() << \" n = \" << n << '\\n';\n \n    // input stream\n    std::istringstream inbuf(\"-10\");\n    inbuf >> n;\n    std::cout << \"n = \" << n << '\\n';\n \n    // output stream in append mode (C++11)\n    std::ostringstream buf2(\"test\", std::ios_base::ate);\n    buf2 << '1';\n    std::cout << buf2.str() << '\\n';\n}",
            "output": "buf1 = 7 n = 7\nn = -10\ntest1"
        }
    },
    "basic_ostringstream::operator=": {
        "description": {
            "texte": "Move assigns the string stream other to *this, effectively move-assigning both the std::basic_ostream base class and the associated std::basic_stringbuf.Note that the base class move assignment swaps all stream state variables (except for rdbuf) between *this and other."
        },
        "parametres": "   other   -   string stream to move from \n\n"
    },
    "basic_ostringstream::swap": {
        "description": {
            "texte": "Exchanges the state of the stream with those of other.This is done by callingbasic_ostream<CharT, Traits>::swap(other) and rdbuf()->swap(*other.rdbuf())."
        },
        "parametres": "   other   -   stream to exchange the state with \n\n"
    },
    "basic_ostringstream::rdbuf": {
        "description": {
            "texte": "Returns pointer to the underlying raw string device object."
        }
    },
    "basic_ostringstream::str": {
        "description": {
            "texte": "Manages the contents of the underlying string object.1) Returns a copy of the underlying string as if by calling rdbuf()->str().2) Replaces the contents of the underlying string as if by calling rdbuf()->str(new_str)."
        },
        "parametres": "   new_str   -   new contents of the underlying string \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <iostream>\nint main()\n{\n    int n;\n \n    std::istringstream in;  // could also use in(\"1 2\")\n    in.str(\"1 2\");\n    in >> n;\n    std::cout << \"after reading the first int from \\\"1 2\\\", the int is \"\n              << n << \", str() = \\\"\" << in.str() << \"\\\"\\n\";\n \n    std::ostringstream out(\"1 2\");\n    out << 3;\n    std::cout << \"after writing the int '3' to output stream \\\"1 2\\\"\"\n              << \", str() = \\\"\" << out.str() << \"\\\"\\n\";\n \n    std::ostringstream ate(\"1 2\", std::ios_base::ate);\n    ate << 3;\n    std::cout << \"after writing the int '3' to append stream \\\"1 2\\\"\"\n              << \", str() = \\\"\" << ate.str() << \"\\\"\\n\";\n}",
            "output": "after reading the first int from \"1 2\", the int is 1, str() = \"1 2\"\nafter writing the int '3' to output stream \"1 2\", str() = \"3 2\"\nafter writing the int '3' to append stream \"1 2\", str() = \"1 23\""
        }
    },
    "swap(std::basic_ostringstream)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::basic_ostringstream. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   streams whose state to swap \n\n"
    },
    "strstream::strstream": {
        "description": {
            "texte": "Constructs new input/output strstream and its underlying std::strstreambuf."
        },
        "parametres": "   s   -   char array to use as the output buffer \n   n   -   size of the array to be used for output \n   mode   -   specifies stream open mode. It is a bitmask type, the following constants are defined (although only app is used):    Constant   Explanation \n   app   seek to the end of stream before each write \n   binary   open in binary mode \n   in   open for reading \n   out   open for writing \n   trunc   discard the contents of the stream when opening \n   ate   seek to the end of stream immediately after open \n  \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <strstream>\n#include <string>\n \nint main()\n{\n    // dynamic buffer\n    std::strstream s1; // dynamic buffer\n    s1 << 1 << ' ' << 3.14 << \" example\" << std::ends;\n    std::cout << \"buffer holds '\" << s1.str() << \"'\\n\";\n    s1.freeze(false);\n \n    int n; double d;\n    std::string w;\n    s1 >> n >> d >> w;\n    std::cout << \"Read back: n = \" << n\n              << \" d = \" << d\n              << \" w = '\" << w << \"'\\n\";\n \n    // static buffer\n    char arr[20] = \"-1 -3.14 \";\n    std::strstream s2(arr, sizeof arr, std::ios_base::app);\n    s2 << \"another\" << std::ends;\n    std::cout << \"buffer holds: '\" << s2.str() << \"'\\n\";\n    s2 >> n >> d >> w;\n    std::cout << \"Read back: n = \" << n\n              << \" d = \" << d\n              << \" w = '\" << w << \"'\\n\";\n}",
            "output": "buffer holds '1 3.14 example'\nRead back: n = 1 d = 3.14 w = 'example'\nbuffer holds: '-1 -3.14 another'\nRead back: n = -1 d = -3.14 w = 'another'"
        }
    },
    "strstream::~strstream": {
        "description": {
            "texte": "Destroys a std::strstream object, which also destroys the member std::strstreambuf, which may call the deallocation function if the underlying buffer was dynamically-allocated and not frozen."
        },
        "exemple": {
            "input": "#include <strstream>\n#include <iostream>\n \nint main()\n{\n    {\n        std::ostrstream s; // dynamic buffer \n        s << 1.23 << std::ends;\n        std::cout << s.str() << '\\n';\n        s.freeze(false);\n    } // destructor called, buffer deallocated \n \n    {\n        std::ostrstream s;\n        s << 1.23 << std::ends;\n        std::cout << s.str() << '\\n';\n//        buf.freeze(false);\n    } // destructor called, memory leaked\n \n    {\n        std::istrstream s(\"1.23\"); // constant buffer\n        double d;\n        s >> d;\n        std::cout << d << '\\n';\n    } // destructor called, nothing to deallocate\n}",
            "output": "1.23\n1.23\n1.23"
        }
    },
    "strstream::rdbuf": {
        "description": {
            "texte": "Returns a pointer to the associated std::strstreambuf, casting away its constness (despite the const qualifier on the member function)."
        },
        "exemple": {
            "input": "#include <strstream>\nint main()\n{\n    const std::strstream buf;\n    std::strstreambuf* ptr = buf.rdbuf();\n}"
        }
    },
    "strstream::str": {
        "description": {
            "texte": "Returns the pointer to the beginning of the buffer, after freezing it. Effectively calls rdbuf()->str()."
        },
        "exemple": {
            "input": "#include <strstream>\n#include <iostream>\n \nint main()\n{\n    std::strstream dyn; // dynamically-allocated output buffer\n    dyn << \"Test: \" << 1.23; // not adding std::ends to demonstrate append behavior\n    std::cout << \"The output stream holds \\\"\";\n    std::cout.write(dyn.str(), dyn.pcount()) << \"\\\"\\n\"; \n    // the stream is now frozen due to str()\n    dyn << \" More text\" << std::ends;\n    std::cout << \"The output stream holds \\\"\";\n    std::cout.write(dyn.str(), dyn.pcount()) << \"\\\"\\n\";\n    dyn.freeze(false);\n}",
            "output": "The stream holds \"Test: 1.23\"\nThe stream holds \"Test: 1.23 More \""
        }
    },
    "strstream::pcount": {
        "description": {
            "texte": "Returns the number of characters that were output in the put area of the associated std::strstreambuf. Effectively calls rdbuf()->pcount()."
        },
        "exemple": {
            "input": "#include <strstream>\n#include <iostream>\n \nint main()\n{\n    std::strstream dyn; // dynamically-allocated output buffer\n    dyn << \"Test: \" << 1.23 << std::ends;\n    std::cout << \"The size of the output is \" << dyn.pcount()\n              << \" and it holds \\\"\" << dyn.str() << \"\\\"\\n\";\n    dyn.freeze(false);\n \n    char buf[10];\n    std::strstream user(buf, 10); // user-provided output buffer\n    user << 1.23; // note: no std::ends\n    std::cout.write(buf, user.pcount());\n    std::cout << '\\n';\n}",
            "output": "The size of the output is 11 and it holds \"Test: 1.23\"\n1.23"
        }
    },
    "strstream::freeze": {
        "description": {
            "texte": "If the stream is using a dynamically-allocated array for output, disables (flag == true) or enables (flag == false) automatic allocation/deallocation of the buffer. Effectively calls rdbuf()->freeze(flag)."
        },
        "parametres": "   flag   -   desired status \n\n",
        "exemple": {
            "input": "#include <strstream>\n#include <iostream>\n \nint main()\n{\n    std::strstream dyn; // dynamically-allocated output buffer\n    dyn << \"Test: \" << 1.23; // note: no std::ends to demonstrate appending\n    std::cout << \"The output stream contains \\\"\";\n    std::cout.write(dyn.str(), dyn.pcount()) << \"\\\"\\n\";\n    // the stream is now frozen due to str()\n    dyn << \" More text\"; // output to a frozen stream may be truncated\n    std::cout << \"The output stream contains \\\"\";\n    std::cout.write(dyn.str(), dyn.pcount()) << \"\\\"\\n\";\n    dyn.freeze(false); // freeze(false) must be called or the  destructor will leak\n \n    std::strstream dyn2; // dynamically-allocated output buffer\n    dyn2 << \"Test: \" << 1.23; // note: no std::ends\n    std::cout << \"The output stream contains \\\"\";\n    std::cout.write(dyn2.str(), dyn2.pcount()) << \"\\\"\\n\";\n    dyn2.freeze(false);   // unfreeze the stream after str()\n    dyn2 << \" More text\" << std::ends; // output will not be truncated (buffer grows)\n    std::cout << \"The output stream contains \\\"\" << dyn2.str() << \"\\\"\\n\";\n    dyn2.freeze(false); // freeze(false) must be called or the  destructor will leak \n}",
            "output": "The output stream contains \"Test: 1.23\"\nThe output stream contains \"Test: 1.23 More \"\nThe output stream contains \"Test: 1.23\"\nThe output stream contains \"Test: 1.23 More text\""
        }
    },
    "istrstream::istrstream": {
        "description": {
            "texte": "Constructs new istrstream and its underlying std::strstreambuf."
        },
        "parametres": "   s   -   C-string or char array to use as the contents of the stream \n   n   -   size of the array \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <strstream>\n \nint main()\n{\n    std::istrstream s1(\"1 2 3\"); // string literal\n    int n1,n2,n3;\n    if(s1 >> n1 >> n2 >> n3)\n        std::cout << n1 << \", \" << n2 << \", \" << n3 << '\\n';\n \n    char arr[] = {'4', ' ', '5', ' ', '6'};\n    std::istrstream s2(arr, sizeof arr);\n    if(s2 >> n1 >> n2 >> n3)\n        std::cout << n1 << \", \" << n2 << \", \" << n3 << '\\n';\n}",
            "output": "1, 2, 3\n4, 5, 6"
        }
    },
    "istrstream::~istrstream": {
        "description": {
            "texte": "Destroys a std::istrstream object, which also destroys the member std::strstreambuf."
        },
        "exemple": {
            "input": "#include <strstream>\n#include <iostream>\n \nint main()\n{\n    {\n        std::istrstream s(\"1.234\");\n        double d;\n        s >> d;\n        std::cout << d << '\\n';\n    } // destructor called\n}",
            "output": "1.234"
        }
    },
    "istrstream::rdbuf": {
        "description": {
            "texte": "Returns a pointer to the associated std::strstreambuf, casting away its constness (despite the const qualifier on the member function)."
        },
        "exemple": {
            "input": "#include <strstream>\nint main()\n{\n    const std::istrstream buf(\"example\");\n    std::strstreambuf* ptr = buf.rdbuf();\n}"
        }
    },
    "istrstream::str": {
        "description": {
            "texte": "Returns the pointer to the beginning of the buffer, after freezing it. Effectively calls rdbuf()->str()."
        }
    },
    "ostrstream::ostrstream": {
        "description": {
            "texte": "Constructs new output strstream and its underlying std::strstreambuf."
        },
        "parametres": "   s   -   char array to use as the output buffer \n   n   -   size of the array to be used as the output buffer \n   mode   -   specifies stream open mode. It is a bitmask type, the following constants are defined (although only app is used):    Constant   Explanation \n   app   seek to the end of stream before each write \n   binary   open in binary mode \n   in   open for reading \n   out   open for writing \n   trunc   discard the contents of the stream when opening \n   ate   seek to the end of stream immediately after open \n  \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <strstream>\n \nint main()\n{\n    std::ostrstream s1; // dynamic buffer\n    s1 << 1 << ' ' << 3.14 << \" example\\n\" << std::ends;\n    std::cout << s1.str();\n    s1.freeze(false);\n \n    char arr[15] = \"Hello\";\n \n    std::ostrstream s2(arr, sizeof arr, std::ios_base::app);\n    s2 << \", world!\" << std::ends;\n    std::cout << s2.str() << '\\n';\n    std::cout << arr << '\\n'; // streams use the provided arrays\n}",
            "output": "1 3.14 example\nHello, world!\nHello, world!"
        }
    },
    "ostrstream::~ostrstream": {
        "description": {
            "texte": "Destroys a std::ostrstream object, which also destroys the member std::strstreambuf, which may call the deallocation function if the underlying buffer was dynamically-allocated and not frozen."
        },
        "exemple": {
            "input": "#include <strstream>\n#include <iostream>\n \nint main()\n{\n    {\n        std::ostrstream s; // dynamic buffer \n        s << 1.23;\n        std::cout << s.str() << '\\n';\n        s.freeze(false);\n    } // destructor called, buffer deallocated \n \n    {\n        std::ostrstream s;\n        s << 1.23;\n        std::cout << s.str() << '\\n';\n//        buf.freeze(false);\n    } // destructor called, memory leaked\n}",
            "output": "1.23\n1.23"
        }
    },
    "ostrstream::rdbuf": {
        "description": {
            "texte": "Returns a pointer to the associated std::strstreambuf, casting away its constness (despite the const qualifier on the member function)."
        },
        "exemple": {
            "input": "#include <strstream>\nint main()\n{\n    const std::ostrstream buf;\n    std::strstreambuf* ptr = buf.rdbuf();\n}"
        }
    },
    "ostrstream::str": {
        "description": {
            "texte": "Returns the pointer to the beginning of the buffer, after freezing it. Effectively calls rdbuf()->str()."
        },
        "exemple": {
            "input": "#include <strstream>\n#include <iostream>\n \nint main()\n{\n    std::ostrstream dyn; // dynamically-allocated output buffer\n    dyn << \"Test: \" << 1.23; // not adding std::ends to demonstrate append behavior\n    std::cout << \"The output stream holds \\\"\";\n    std::cout.write(dyn.str(), dyn.pcount()) << \"\\\"\\n\"; \n    // the stream is now frozen due to str()\n    dyn << \" More text\" << std::ends;\n    std::cout << \"The output stream holds \\\"\";\n    std::cout.write(dyn.str(), dyn.pcount()) << \"\\\"\\n\";\n    dyn.freeze(false);\n}",
            "output": "The stream holds \"Test: 1.23\"\nThe stream holds \"Test: 1.23 More \""
        }
    },
    "ostrstream::freeze": {
        "description": {
            "texte": "If the stream is using a dynamically-allocated array for output, disables (flag == true) or enables (flag == false) automatic allocation/deallocation of the buffer. Effectively calls rdbuf()->freeze(flag)."
        },
        "parametres": "   flag   -   desired status \n\n",
        "exemple": {
            "input": "#include <strstream>\n#include <iostream>\n \nint main()\n{\n    std::ostrstream dyn; // dynamically-allocated output buffer\n    dyn << \"Test: \" << 1.23; // note: no std::ends to demonstrate appending\n    std::cout << \"The output stream contains \\\"\";\n    std::cout.write(dyn.str(), dyn.pcount()) << \"\\\"\\n\";\n    // the stream is now frozen due to str()\n    dyn << \" More text\"; // output to a frozen stream may be truncated\n    std::cout << \"The output stream contains \\\"\";\n    std::cout.write(dyn.str(), dyn.pcount()) << \"\\\"\\n\";\n    dyn.freeze(false); // freeze(false) must be called or the  destructor will leak\n \n    std::ostrstream dyn2; // dynamically-allocated output buffer\n    dyn2 << \"Test: \" << 1.23; // note: no std::ends\n    std::cout << \"The output stream contains \\\"\";\n    std::cout.write(dyn2.str(), dyn2.pcount()) << \"\\\"\\n\";\n    dyn2.freeze(false);   // unfreeze the stream after str()\n    dyn2 << \" More text\" << std::ends; // output will not be truncated (buffer grows)\n    std::cout << \"The output stream contains \\\"\" << dyn2.str() << \"\\\"\\n\";\n    dyn2.freeze(false); // freeze(false) must be called or the  destructor will leak \n}",
            "output": "The output stream contains \"Test: 1.23\"\nThe output stream contains \"Test: 1.23 More \"\nThe output stream contains \"Test: 1.23\"\nThe output stream contains \"Test: 1.23 More text\""
        }
    },
    "ostrstream::pcount": {
        "description": {
            "texte": "Returns the number of characters that were output in the put area of the associated std::strstreambuf. Effectively calls rdbuf()->pcount()."
        },
        "exemple": {
            "input": "#include <strstream>\n#include <iostream>\n \nint main()\n{\n    std::ostrstream dyn; // dynamically-allocated output buffer\n    dyn << \"Test: \" << 1.23 << std::ends;\n    std::cout << \"The size of the output is \" << dyn.pcount()\n              << \" and it holds \\\"\" << dyn.str() << \"\\\"\\n\";\n    dyn.freeze(false);\n \n    char buf[10];\n    std::ostrstream user(buf, 10); // user-provided output buffer\n    user << 1.23; // note: no std::ends\n    std::cout.write(buf, user.pcount());\n    std::cout << '\\n';\n}",
            "output": "The size of the output is 11 and it holds \"Test: 1.23\"\n1.23"
        }
    },
    "flush_emit": {
        "description": {
            "texte": "Flushes the output sequence os as if by calling os.flush(). Then, if os.rdbuf() actually points to a std::basic_syncbuf<CharT, Traits, Allocator> buf, calls buf.emit().This is an output-only I/O manipulator, it may be called with an expression such as out << std::flush_emit for any out of type std::basic_ostream."
        },
        "parametres": "   os   -   reference to output stream \n\n"
    },
    "emit_on_flush, std::no_emit_on_flush": {
        "description": {
            "texte": "If os.rdbuf() actually points to a std::basic_syncbuf<CharT, Traits, Allocator> buf, toggles whether it emits (i.e., transmits data to the underlying stream buffer) when flushed:Otherwise, these manipulators have no effect.This is an output-only I/O manipulator, it may be called with an expression such as out << std::emit_on_flush for any out of type std::basic_ostream."
        },
        "parametres": "   os   -   reference to output stream \n\n"
    },
    "basic_streambuf::~basic_streambuf": {
        "description": {
            "texte": "This destruction is empty: the members of this basic_streambuf (the pointers and the locale) are destructed in accordance with the usual object destruction sequence after this destructor returns. However, since it is declared public virtual, it allows the objects that are derived from std::basic_streambuf to be deleted through a pointer to base class."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n \nint main()\n{\n    std::filebuf* fbp = new std::filebuf;\n    fbp->open(\"test.txt\", std::ios_base::out);\n    fbp->sputn(\"Hello\\n\", 6);\n    std::streambuf* sbp = fbp;\n    delete sbp; // the file is closed, output flushed and written\n    std::ifstream f(\"test.txt\");\n    std::cout << f.rdbuf(); // proof\n}",
            "output": "Hello"
        }
    },
    "basic_streambuf::pubimbue, std::basic_streambuf::imbue": {
        "description": {
            "texte": "Changes the associated locale.1) Sets loc as the associated locale. Calls imbue(loc) of the most derived class.2) The base class version of this function has no effect. The derived classes may override this function in order to be informed about the changes of the locale. The derived class may cache the locale and member facets between calls to imbue()."
        },
        "parametres": "   loc   -   locale object to associate \n\n"
    },
    "basic_streambuf::getloc": {
        "description": {
            "texte": "Returns the associated locale.The associated locale is the value supplied to pubimbue() on the last call, or, if that function has not been called, the value of the global locale (std::locale) at the time of the construction of the streambuf."
        }
    },
    "basic_streambuf::pubseekoff, std::basic_streambuf::seekoff": {
        "description": {
            "texte": "Sets the position indicator of the input and/or output sequence relative to some other position.1) Calls seekoff(off, dir, which) of the most derived class.2) The base class version of this function has no effect. The derived classes may override this function to allow relative positioning of the position indicator."
        },
        "parametres": "   off   -   relative position to set the position indicator to. \n   dir   -   defines base position to apply the relative offset to. It can be one of the following constants:    Constant   Explanation \n   beg   the beginning of a stream \n   end   the ending of a stream \n   cur   the current position of stream position indicator \n  \n   which   -   defines which of the input and/or output sequences to affect. It can be one or a combination of the following constants:    Constant   Explanation \n   in   affect the input sequence \n   out   affect the output sequence \n  \n\n"
    },
    "basic_streambuf::pubseekpos, std::basic_streambuf::seekpos": {
        "description": {
            "texte": "Sets the position indicator of the input and/or output sequence to an absolute position.1) Calls seekpos(pos, which) of the most derived class.2) The base class version of this function has no effect. The derived classes may override this function to allow absolute positioning of the position indicator."
        },
        "parametres": "   pos   -   absolute position to set the position indicator to. \n   which   -   defines which of the input and/or output sequences to affect. It can be one or a combination of the following constants:    Constant   Explanation \n   in   affect the input sequence \n   out   affect the output sequence \n  \n\n"
    },
    "basic_streambuf::pubsync, std::basic_streambuf::sync": {
        "description": {
            "texte": "Synchronizes the controlled character sequence (the buffers) with the associated character sequence.1) Calls sync() of the most derived class.2) The base class version of this function has no effect. The derived classes may override this function to allow synchronizing the underlying device with the buffers.For output streams, this typically results in writing the contents of the put area into the associated sequence, i.e. flushing of the output buffer. For input streams, this typically empties the get area and forces a re-read from the associated sequence to pick up recent changes. The default behavior (found, for example, in std::basic_stringbuf), is to do nothing."
        }
    },
    "basic_streambuf::in_avail": {
        "description": {
            "texte": "Returns the number of characters available in the get area. If a read position is available, effectively returns egptr() - gptr(), the size of the get area. In this case, the number of bytes returned is the number of bytes that can be extracted from the buffer without calling underflow().If the get area is empty, calls showmanyc() to determine the number of bytes available in the associated character sequence. In this case, the value returned is the number of bytes that can be extracted from the buffer while it's guaranteed that underflow() would not return Traits::eof."
        }
    },
    "basic_streambuf::snextc": {
        "description": {
            "texte": "Advances the input sequence by one character and reads one character.The function calls sbumpc() to advance the input sequence. If that function returns Traits::eof() meaning that input sequence has been exhausted and uflow() could not retrieve more data, Traits::eof() is returned. Otherwise sgetc() is called in order to read the character."
        }
    },
    "basic_streambuf::sbumpc": {
        "description": {
            "texte": "Reads one character and advances the input sequence by one character.If the input sequence read position is not available, returns uflow(). Otherwise returns Traits::to_int_type(*gptr())."
        }
    },
    "basic_streambuf::sgetc": {
        "description": {
            "texte": "Reads one character from the input sequence.If the input sequence read position is not available, returns underflow(). Otherwise returns Traits::to_int_type(*gptr())."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::stringstream stream(\"Hello, world\");\n    std::cout << \"sgetc() returned '\" << (char)stream.rdbuf()->sgetc() << \"'\\n\";\n    std::cout << \"peek() returned '\" << (char)stream.peek() << \"'\\n\";\n    std::cout << \"get() returned '\" << (char)stream.get() << \"'\\n\";\n}",
            "output": "sgetc() returned 'H'\npeek() returned 'H'\nget() returned 'H'"
        }
    },
    "basic_streambuf::sgetn, std::basic_streambuf::xsgetn": {
        "description": {
            "texte": "The number of characters successfully read. If it is less than count the input sequence has reached the end."
        },
        "parametres": "   s   -   pointer to the beginning of a char_type array \n   count   -   maximum number of characters to write \n\n"
    },
    "basic_streambuf::sputc": {
        "description": {
            "texte": "Writes one character to the output sequence.If the output sequence write position is not available (the buffer is full), then calls overflow(ch)."
        },
        "parametres": "   ch   -   character to write \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream s;\n    s.rdbuf()->sputc('a');\n    std::cout << s.str() << '\\n';\n}",
            "output": "a"
        }
    },
    "basic_streambuf::sputn, std::basic_streambuf::xsputn": {
        "description": {
            "texte": "If the put area becomes full (pptr() == epptr()), this function may call overflow(), or achieve the effect of calling overflow() by some other, unspecified, means."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream s1;\n    std::streamsize sz = s1.rdbuf()->sputn(\"This is a test\", 14);\n    s1 << '\\n';\n    std::cout << \"The call to sputn() returned \" << sz << '\\n'\n              << \"The output sequence contains \" << s1.str();\n \n    std::istringstream s2;\n    sz = s2.rdbuf()->sputn(\"This is a test\", 14);\n    std::cout << \"The call to sputn() on an input stream returned \" << sz << '\\n';\n}",
            "output": "The call to sputn() returned 14\nThe output sequence contains This is a test\nThe call to sputn() on an input stream returned 0"
        }
    },
    "basic_streambuf::sputbackc": {
        "description": {
            "texte": "Puts back a character back to the get area.If a putback position is available in the get area (gptr() > eback()), and the character c is equal to the character one position to the left of gptr() (as determined by Traits::eq(c, gptr()[-1]), then simply decrements the next pointer (gptr()).Otherwise, calls pbackfail(Traits::to_int_type(c)) to either back up the get area or to modify both the get area and possibly the associated character sequence.The I/O stream function basic_istream::putback is implemented in terms of this function."
        },
        "parametres": "   c   -   character to put back \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::stringstream s(\"abcdef\"); // gptr() points to 'a' in \"abcdef\"\n    std::cout << \"Before putback, string holds \" << s.str() << '\\n';\n    char c1 = s.get(); // c1 = 'a', gptr() now points to 'b' in \"abcdef\"\n    char c2 = s.rdbuf()->sputbackc('z'); // same as s.putback('z')\n                                         // gptr() now points to 'z' in \"zbcdef\"\n    std::cout << \"After putback, string holds \" << s.str() << '\\n';\n    char c3 = s.get(); // c3 = 'z', gptr() now points to 'b' in \"zbcdef\"\n    char c4 = s.get(); // c4 = 'b', gptr() now points to 'c' in \"zbcdef\"\n    std::cout << c1 << c2 << c3 << c4 << '\\n';\n \n    s.rdbuf()->sputbackc('b');  // gptr() now points to 'b' in \"zbcdef\"\n    s.rdbuf()->sputbackc('z');  // gptr() now points to 'z' in \"zbcdef\"\n    int eof = s.rdbuf()->sputbackc('x');  // nothing to unget: pbackfail() fails\n    if (eof == EOF)\n        std::cout << \"No room to putback after 'z'\\n\";\n}",
            "output": "Before putback, string holds abcdef\nAfter putback, string holds zbcdef\nazzb\nNo room to putback after 'z'"
        }
    },
    "basic_streambuf::sungetc": {
        "description": {
            "texte": "If a putback position is available in the get area (gptr() > eback()), then decrements the next pointer (gptr()) and returns the character it now points to.If a putback position is not available, then calls pbackfail() to back up the input sequence if possible.The I/O stream function basic_istream::unget is implemented in terms of this function."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::stringstream s(\"abcdef\"); // gptr() poitns to 'a'\n    char c1 = s.get(); // c = 'a', gptr() now points to 'b' \n    char c2 = s.rdbuf()->sungetc(); // same as s.unget(): gptr() points to 'a' again \n    char c3 = s.get(); // c3 = 'a', gptr() now points to 'b'\n    char c4 = s.get(); // c4 = 'b', gptr() now points to 'c'\n    std::cout << c1 << c2 << c3 << c4 << '\\n';\n \n    s.rdbuf()->sungetc();  // back to 'b'\n    s.rdbuf()->sungetc();  // back to 'a'\n    int eof = s.rdbuf()->sungetc();  // nothing to unget: pbackfail() fails\n    if (eof == EOF)\n            std::cout << \"Nothing to unget after 'a'\\n\";\n}",
            "output": "aaab\nNothing to unget after 'a'"
        }
    },
    "basic_streambuf::basic_streambuf": {
        "description": {
            "texte": "Both constructors are protected, and are only called by the concrete streambuf classes, such as std::basic_filebuf, std::basic_stringbuf, or std::strstreambuf."
        },
        "parametres": "   rhs   -   a streambuf object to copy \n\n"
    },
    "basic_streambuf::operator=": {
        "description": {
            "texte": "Assigns the data members of other to *this."
        },
        "parametres": "   other   -   stream buffer to assign \n\n"
    },
    "basic_streambuf::swap": {
        "description": {
            "texte": "Exchanges the contents of the stream buffer with those of other."
        },
        "parametres": "   other   -   stream buffer to exchange contents with \n\n"
    },
    "basic_streambuf::showmanyc": {
        "description": {
            "texte": "Estimates the number of characters available for input in the associated character sequence. underflow() is guaranteed not to return Traits::eof() or throw an exception until at least that many characters are extracted."
        }
    },
    "basic_streambuf::underflow": {
        "description": {
            "texte": "Ensures that at least one character is available in the input area by updating the pointers to the input area (if needed) and reading more data in from the input sequence (if applicable). Returns the value of that character (converted to int_type with Traits::to_int_type(c)) on success or Traits::eof() on failure.The function may update gptr, egptr and eback pointers to define the location of newly loaded data (if any). On failure, the function ensures that either gptr() == nullptr or gptr() == egptr.The base class version of the function does nothing. The derived classes may override this function to allow updates to the get area in the case of exhaustion."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n \nclass null_filter_buf : public std::streambuf {\n    std::streambuf* src;\n    char ch; // single-byte buffer\nprotected:\n    int underflow() {\n        while( (ch= src->sbumpc()) == '\\0') ; // skip zeroes\n        setg(&ch, &ch, &ch+1); // make one read position available\n        return ch; // may return EOF\n    }\npublic:\n    null_filter_buf(std::streambuf* buf) : src(buf) {\n        setg(&ch, &ch+1, &ch+1); // buffer is initially full\n    }\n};\n \nvoid filtered_read(std::istream& in)\n{\n    std::streambuf* orig = in.rdbuf();\n    null_filter_buf buf(orig);\n    in.rdbuf(&buf);\n    for(char c; in.get(c); )\n            std::cout << c;\n    in.rdbuf(orig);\n}\n \nint main()\n{\n    char a[] = \"This i\\0s \\0an e\\0\\0\\0xample\";\n    std::istringstream in(std::string(std::begin(a), std::end(a)));\n    filtered_read(in);\n}",
            "output": "This is an example"
        }
    },
    "basic_streambuf::uflow": {
        "description": {
            "texte": "Ensures that at least one character is available in the input area by updating the pointers to the input area (if needed). On success returns the value of that character and advances the value of the get pointer by one character. On failure returns traits::eof().The function may update gptr, egptr and eback pointers to define the location of newly loaded data (if any). On failure, the function ensures that either gptr() == nullptr or gptr() == egptr.The base class version of the function calls underflow() and increments gptr()."
        }
    },
    "basic_streambuf::eback, gptr, egptr": {
        "description": {
            "texte": "Returns pointers defining the get area.1) Returns the pointer to the beginning of the get area.2) Returns the pointer to the current character (get pointer) in the get area.3) Returns the pointer one past the end of the get area."
        }
    },
    "basic_streambuf::gbump": {
        "description": {
            "texte": "Skips count characters in the get area. This is done by advancing the get pointer by count characters. No checks are done for underflow."
        },
        "parametres": "   count   -   number of characters to skip \n\n"
    },
    "basic_streambuf::setg": {
        "description": {
            "texte": "Sets the values of the pointers defining the get area. Specifically, after the call eback() == gbeg, gptr() == gcurr, egptr() == gend."
        },
        "parametres": "   gbeg   -   pointer to the new beginning of the get area \n   gcurr   -   pointer to the new current character (get pointer) in the get area \n   gend   -   pointer to the new end of the get area \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n \nclass null_filter_buf : public std::streambuf {\n    std::streambuf* src;\n    char ch; // single-byte buffer\nprotected:\n    int underflow() {\n        while( (ch= src->sbumpc()) == '\\0') ; // skip zeroes\n        setg(&ch, &ch, &ch+1); // make one read position available\n        return ch; // may return EOF\n    }\npublic:\n    null_filter_buf(std::streambuf* buf) : src(buf) {\n        setg(&ch, &ch+1, &ch+1); // buffer is initially full\n    }\n};\n \nvoid filtered_read(std::istream& in)\n{\n    std::streambuf* orig = in.rdbuf();\n    null_filter_buf buf(orig);\n    in.rdbuf(&buf);\n    for(char c; in.get(c); )\n            std::cout << c;\n    in.rdbuf(orig);\n}\n \nint main()\n{\n    char a[] = \"This i\\0s \\0an e\\0\\0\\0xample\";\n    std::istringstream in(std::string(std::begin(a), std::end(a)));\n    filtered_read(in);\n}",
            "output": "This is an example"
        }
    },
    "basic_streambuf::overflow": {
        "description": {
            "texte": "Ensures that there is space at the put area for at least one character by saving some initial subsequence of characters starting at pbase() to the output sequence and updating the pointers to the put area (if needed). If ch is not Traits::eof() (i.e. Traits::eq_int_type(ch, Traits::eof()) != true), it is either put to the put area or directly saved to the output sequence.The function may update pptr, epptr and pbase pointers to define the location to write more data. On failure, the function ensures that either pptr() == nullptr or pptr() == epptr.The base class version of the function does nothing. The derived classes may override this function to allow updates to the put area in the case of exhaustion."
        },
        "parametres": "   ch   -   the character to store in the put area \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <array>\n \n// Buffer for std::ostream implemented by std::array\ntemplate<std::size_t SIZE, class CharT = char>\nclass ArrayedStreamBuffer : public std::basic_streambuf<CharT> {\npublic:\n \n    using Base = std::basic_streambuf<CharT>;\n    using char_type = typename Base::char_type;\n    using int_type = typename Base::int_type;\n \n    ArrayedStreamBuffer() : buffer_{} // value-initialize buffer_ to all zeroes\n    {\n        Base::setp(buffer_.begin(), buffer_.end()); // set std::basic_streambuf\n            // put area pointers to work with 'buffer_'\n    }\n \n    int_type overflow(int_type ch) \n    {\n        std::cout << \"overflow\\n\";\n        return Base::overflow(ch);\n    }\n \n    void print_buffer()\n    {\n        for (const auto& i: buffer_) {\n            if (i == 0) {\n                std::cout << \"NULL\";\n            } else {\n                std::cout << i;\n            }\n            std::cout << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n \nprivate:\n    std::array<char_type, SIZE> buffer_;\n};\n \nint main()\n{\n    ArrayedStreamBuffer<10> streambuf;\n    std::ostream stream(&streambuf);\n \n    stream << \"hello\";\n    streambuf.print_buffer();\n    if (stream.good()) {\n        std::cout << \"stream is good\\n\";\n    }\n \n    stream << \"world\";\n    streambuf.print_buffer();\n    if (stream.good()) {\n        std::cout << \"stream is good\\n\";\n    }\n \n    stream << \"!\";\n    streambuf.print_buffer();\n    if (!stream.good()) {\n        std::cout << \"stream is not good\\n\";\n    }\n}",
            "output": "h e l l o NULL NULL NULL NULL NULL \nstream is good\nh e l l o w o r l d \nstream is good\noverflow\nh e l l o w o r l d \nstream is not good"
        }
    },
    "basic_streambuf::pbase, std::basic_streambuf::pptr, std::basic_streambuf::epptr": {
        "description": {
            "texte": "Returns pointers defining the put area.1) Returns the pointer to the beginning (\"base\") of the put area.2) Returns the pointer to the current character (put pointer) in the put area.3) Returns the pointer one past the end of the put area."
        }
    },
    "basic_streambuf::pbump": {
        "description": {
            "texte": "Repositions the put pointer (pptr()) by count characters, where count may be positive or negative. No checks are done for moving the pointer outside the put area [pbase(), epptr()).If the pointer is advanced and then overflow() is called to flush the put area to the associated character sequence, the effect is that extra count characters with undefined values are output."
        },
        "parametres": "   count   -   number to add to the put pointer \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <fstream>\n \nstruct showput_streambuf : std::filebuf\n{\n    using std::filebuf::pbump; // expose protected\n    std::string showput() const {\n        return std::string(pbase(), pptr());\n    }\n};\n \nint main()\n{\n    showput_streambuf mybuf;\n    mybuf.open(\"test.txt\", std::ios_base::out);\n    std::ostream str(&mybuf);\n    str << \"This is a test\" << std::flush << \"1234\";\n    std::cout << \"The put area contains: \" << mybuf.showput() << '\\n';\n    mybuf.pbump(10);\n    std::cout << \"after pbump(10), it contains \" << mybuf.showput() << '\\n';\n}",
            "output": "The put area contains: 1234\nafter pbump(10), it contains 1234 is a test"
        }
    },
    "basic_streambuf::setp": {
        "description": {
            "texte": "Sets the values of the pointers defining the put area. Specifically, after the call pbase() == pbeg, pptr() == pbeg, epptr() == pend."
        },
        "parametres": "   pbeg   -   pointer to the new beginning of the put area \n   pend   -   pointer to the new end of the put area \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <array>\n \n// Buffer for std::ostream implemented by std::array\ntemplate<std::size_t SIZE, class CharT = char>\nclass ArrayedStreamBuffer : public std::basic_streambuf<CharT>\n{\npublic:\n    using Base = std::basic_streambuf<CharT>;\n    using char_type = typename Base::char_type;\n \n    ArrayedStreamBuffer() : buffer_{} // value-initialize buffer_ to all zeroes\n    {\n        Base::setp(buffer_.begin(), buffer_.end()); // set std::basic_streambuf\n            // put area pointers to work with 'buffer_'\n    }\n \n    void print_buffer()\n    {\n        for (const auto& i: buffer_) {\n            if (i == 0) {\n                std::cout << \"NULL\";\n            } else {\n                std::cout << i;\n            }\n            std::cout << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n \nprivate:\n    std::array<char_type, SIZE> buffer_;\n};\n \nint main()\n{\n    ArrayedStreamBuffer<10> streambuf;\n    std::ostream stream(&streambuf);\n \n    stream << \"hello\";\n    stream << \",\";\n \n    streambuf.print_buffer();\n}",
            "output": "h e l l o , NULL NULL NULL NULL"
        }
    },
    "basic_streambuf::pbackfail": {
        "description": {
            "texte": "This protected virtual function is called by the public functions sungetc() and sputbackc() (which, in turn, are called by basic_istream::unget and basic_istream::putback) when either:The default base class version of this function does nothing and returns Traits::eof() in all situations. This function is overridden by the derived classes: basic_stringbuf::pbackfail, basic_filebuf::pbackfail, strstreambuf::pbackfail, and is expected to be overridden by user-defined and third-party library stream classes."
        },
        "parametres": "   ch   -   character to put back or Traits::eof() if only back out is requested \n\n"
    },
    "thread::thread": {
        "description": {
            "texte": "Constructs new thread object."
        },
        "parametres": "   other   -   another thread object to construct this thread object with \n   f   -   Callable object to execute in the new thread \n   args...   -   arguments to pass to the new function \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <utility>\n#include <thread>\n#include <chrono>\n \nvoid f1(int n)\n{\n    for (int i = 0; i < 5; ++i) {\n        std::cout << \"Thread 1 executing\\n\";\n        ++n;\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    }\n}\n \nvoid f2(int& n)\n{\n    for (int i = 0; i < 5; ++i) {\n        std::cout << \"Thread 2 executing\\n\";\n        ++n;\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    }\n}\n \nclass foo\n{\npublic:\n    void bar()\n    {\n        for (int i = 0; i < 5; ++i) {\n            std::cout << \"Thread 3 executing\\n\";\n            ++n;\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n    int n = 0;\n};\n \nclass baz\n{\npublic:\n    void operator()()\n    {\n        for (int i = 0; i < 5; ++i) {\n            std::cout << \"Thread 4 executing\\n\";\n            ++n;\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n    int n = 0;\n};\n \nint main()\n{\n    int n = 0;\n    foo f;\n    baz b;\n    std::thread t1; // t1 is not a thread\n    std::thread t2(f1, n + 1); // pass by value\n    std::thread t3(f2, std::ref(n)); // pass by reference\n    std::thread t4(std::move(t3)); // t4 is now running f2(). t3 is no longer a thread\n    std::thread t5(&foo::bar, &f); // t5 runs foo::bar() on object f\n    std::thread t6(b); // t6 runs baz::operator() on object b\n    t2.join();\n    t4.join();\n    t5.join();\n    t6.join();\n    std::cout << \"Final value of n is \" << n << '\\n';\n    std::cout << \"Final value of foo::n is \" << f.n << '\\n';\n}",
            "output": "Thread 1 executing\nThread 2 executing\nThread 3 executing\nThread 4 executing\nThread 3 executing\nThread 1 executing\nThread 2 executing\nThread 4 executing\nThread 2 executing\nThread 3 executing\nThread 1 executing\nThread 4 executing\nThread 3 executing\nThread 2 executing\nThread 1 executing\nThread 4 executing\nThread 3 executing\nThread 1 executing\nThread 2 executing\nThread 4 executing\nFinal value of n is 5\nFinal value of foo::n is 5"
        }
    },
    "thread::~thread": {
        "description": {
            "texte": "Destroys the thread object.If *this has an associated thread (joinable() == true), std::terminate() is called."
        }
    },
    "thread::operator=": {
        "description": {
            "texte": "If *this still has an associated running thread (i.e. joinable() == true), call std::terminate(). Otherwise, assigns the state of other to *this and sets other to a default constructed state.After this call, this->get_id() is equal to the value of other.get_id() prior to the call, and other no longer represents a thread of execution."
        },
        "parametres": "   other   -   another thread object to assign to this thread object \n\n"
    },
    "thread::joinable": {
        "description": {
            "texte": "Checks if the thread object identifies an active thread of execution. Specifically, returns true if get_id() != std::thread::id(). So a default constructed thread is not joinable.A thread that has finished executing code, but has not yet been joined is still considered an active thread of execution and is therefore joinable."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <thread>\n#include <chrono>\n \nvoid foo()\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nint main()\n{\n    std::thread t;\n    std::cout << \"before starting, joinable: \" << std::boolalpha << t.joinable()\n              << '\\n';\n \n    t = std::thread(foo);\n    std::cout << \"after starting, joinable: \" << t.joinable() \n              << '\\n';\n \n    t.join();\n    std::cout << \"after joining, joinable: \" << t.joinable() \n              << '\\n';\n}",
            "output": "before starting, joinable: false\nafter starting, joinable: true\nafter joining, joinable: false"
        }
    },
    "thread::get_id": {
        "description": {
            "texte": "Returns a value of std::thread::id identifying the thread associated with *this."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <thread>\n#include <chrono>\n \nvoid foo()\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nint main()\n{\n    std::thread t1(foo);\n    std::thread::id t1_id = t1.get_id();\n \n    std::thread t2(foo);\n    std::thread::id t2_id = t2.get_id();\n \n    std::cout << \"t1's id: \" << t1_id << '\\n';\n    std::cout << \"t2's id: \" << t2_id << '\\n';\n \n    t1.join();\n    t2.join();\n}",
            "output": "t1's id: 0x35a7210f\nt2's id: 0x35a311c4"
        }
    },
    "thread::native_handle": {
        "description": {
            "texte": "Returns the implementation defined underlying thread handle."
        },
        "exemple": {
            "input": "#include <thread>\n#include <mutex>\n#include <iostream>\n#include <chrono>\n#include <cstring>\n#include <pthread.h>\n \nstd::mutex iomutex;\nvoid f(int num)\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n \n    sched_param sch;\n    int policy; \n    pthread_getschedparam(pthread_self(), &policy, &sch);\n    std::lock_guard<std::mutex> lk(iomutex);\n    std::cout << \"Thread \" << num << \" is executing at priority \"\n              << sch.sched_priority << '\\n';\n}\n \nint main()\n{\n    std::thread t1(f, 1), t2(f, 2);\n \n    sched_param sch;\n    int policy; \n    pthread_getschedparam(t1.native_handle(), &policy, &sch);\n    sch.sched_priority = 20;\n    if (pthread_setschedparam(t1.native_handle(), SCHED_FIFO, &sch)) {\n        std::cout << \"Failed to setschedparam: \" << std::strerror(errno) << '\\n';\n    }\n \n    t1.join(); t2.join();\n}",
            "output": "Thread 2 is executing at priority 0\nThread 1 is executing at priority 20"
        }
    },
    "thread::hardware_concurrency": {
        "description": {
            "texte": "Returns the number of concurrent threads supported by the implementation. The value should be considered only a hint."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <thread>\n \nint main() {\n    unsigned int n = std::thread::hardware_concurrency();\n    std::cout << n << \" concurrent threads are supported.\\n\";\n}",
            "output": "4 concurrent threads are supported."
        }
    },
    "thread::join": {
        "description": {
            "texte": "Blocks the current thread until the thread identified by *this finishes its execution.The completion of the thread identified by *this synchronizes with the corresponding successful return from join().No synchronization is performed on *this itself. Concurrently calling join() on the same std::thread object from multiple threads constitutes a data race that results in undefined behavior."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <thread>\n#include <chrono>\n \nvoid foo()\n{\n    // simulate expensive operation\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nvoid bar()\n{\n    // simulate expensive operation\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nint main()\n{\n    std::cout << \"starting first helper...\\n\";\n    std::thread helper1(foo);\n \n    std::cout << \"starting second helper...\\n\";\n    std::thread helper2(bar);\n \n    std::cout << \"waiting for helpers to finish...\" << std::endl;\n    helper1.join();\n    helper2.join();\n \n    std::cout << \"done!\\n\";\n}",
            "output": "starting first helper...\nstarting second helper...\nwaiting for helpers to finish...\ndone!"
        }
    },
    "thread::detach": {
        "description": {
            "texte": "Separates the thread of execution from the thread object, allowing execution to continue independently. Any allocated resources will be freed once the thread exits.After calling detach *this no longer owns any thread."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n#include <thread>\n \nvoid independentThread() \n{\n    std::cout << \"Starting concurrent thread.\\n\";\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n    std::cout << \"Exiting concurrent thread.\\n\";\n}\n \nvoid threadCaller() \n{\n    std::cout << \"Starting thread caller.\\n\";\n    std::thread t(independentThread);\n    t.detach();\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    std::cout << \"Exiting thread caller.\\n\";\n}\n \nint main() \n{\n    threadCaller();\n    std::this_thread::sleep_for(std::chrono::seconds(5));\n}",
            "output": "Starting thread caller.\nStarting concurrent thread.\nExiting thread caller.\nExiting concurrent thread."
        }
    },
    "thread::swap": {
        "description": {
            "texte": "Exchanges the underlying handles of two thread objects."
        },
        "parametres": "   other   -   the thread to swap with \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <thread>\n#include <chrono>\n \nvoid foo()\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nvoid bar()\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nint main()\n{\n    std::thread t1(foo);\n    std::thread t2(bar);\n \n    std::cout << \"thread 1 id: \" << t1.get_id() << std::endl;\n    std::cout << \"thread 2 id: \" << t2.get_id() << std::endl;\n \n    std::swap(t1, t2);\n \n    std::cout << \"after std::swap(t1, t2):\" << std::endl;\n    std::cout << \"thread 1 id: \" << t1.get_id() << std::endl;\n    std::cout << \"thread 2 id: \" << t2.get_id() << std::endl;\n \n    t1.swap(t2);\n \n    std::cout << \"after t1.swap(t2):\" << std::endl;\n    std::cout << \"thread 1 id: \" << t1.get_id() << std::endl;\n    std::cout << \"thread 2 id: \" << t2.get_id() << std::endl;\n \n    t1.join();\n    t2.join();\n}",
            "output": "thread 1 id: 1892\nthread 2 id: 2584\nafter std::swap(t1, t2):\nthread 1 id: 2584\nthread 2 id: 1892\nafter t1.swap(t2):\nthread 1 id: 1892\nthread 2 id: 2584"
        }
    },
    "literals::chrono_literals::operator\"\"y": {
        "description": {
            "texte": "Forms a std::chrono::year literal representing a year in the proleptic Gregorian calendar."
        },
        "parametres": "   y   -   the year value \n\n"
    },
    "literals::chrono_literals::operator\"\"d": {
        "description": {
            "texte": "Forms a std::chrono::day literal representing a day of the month in the calendar."
        },
        "parametres": "   d   -   the day value \n\n"
    },
    "allocator::destroy": {
        "description": {
            "texte": "Calls the destructor of the object pointed to by p."
        },
        "parametres": "   p   -   pointer to the object that is going to be destroyed \n\n"
    },
    "allocator::allocate": {
        "description": {
            "texte": "Allocates n * sizeof(T) bytes of uninitialized storage by calling ::operator new(std::size_t) or ::operator new(std::size_t, std::align_val_t) (since C++17), but it is unspecified when and how this function is called. The pointer hint may be used to provide locality of reference: the allocator, if supported by the implementation, will attempt to allocate the new memory block as close as possible to hint."
        },
        "parametres": "   n   -   the number of objects to allocate storage for \n   hint   -   pointer to a nearby memory location \n\n"
    },
    "chrono::duration::operator+(unary), std::chrono::duration::operator-(unary)\n": {
        "description": {
            "texte": "Implements unary plus and unary minus for the durations.If rep_ is a member variable holding the number of ticks in a duration object, and D is the return type,"
        },
        "exemple": {
            "input": "#include <chrono>\n#include <iostream>\n \nint main()\n{\n    std::chrono::seconds s1(10);\n    std::chrono::seconds s2 = -s1;\n \n    std::cout << \"negated 10 seconds are \" << s2.count() << \" seconds\\n\";\n}",
            "output": "negated 10 seconds are -10 seconds"
        }
    },
    "reverse_iterator::operator++,+,+=,--,-,-=": {
        "description": {
            "texte": "Increments or decrements the iterator. Inverse operations are applied to the underlying operator because of the reverse order."
        }
    },
    "move_iterator::operator++,+,+=,--,-,-=": {
        "description": {
            "texte": "Increments or decrements the iterator."
        }
    },
    "operator>(std::linear_congruential_engine)\n": {
        "description": {
            "texte": "If a textual representation is written using os << x and that representation is restored into the same or a different object y of the same type using is >> y, then x==y.The textual representation is written with os.fmtflags set to ios_base::dec|ios_base::left and the fill character set to the space character. The textual representation of the engine's internal state is a set of decimal numbers separated by spaces."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   e   -   pseudo-random number engine \n\n"
    },
    "operator>(std::uniform_int_distribution)\n": {
        "description": {
            "texte": "Performs stream input and output operations on pseudo-random number distribution d."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   d   -   pseudo-random number distribution \n\n"
    },
    "atomic::operator++,++(int),--,--(int)": {
        "description": {
            "texte": "Atomically increments or decrements the current value. The operation is read-modify-write operation.For signed Integral types, arithmetic is defined to use two\u2019s complement representation. There are no undefined results.For T* types, the result may be an undefined address, but the operations otherwise have no undefined behavior. The program is ill-formed if T is not an object type."
        }
    },
    "chrono::duration::operator++, std::chrono::duration::operator--": {
        "description": {
            "texte": "Increments or decrements the number of ticks for this duration.If rep_ is a member variable holding the number of ticks in a duration object,"
        },
        "exemple": {
            "input": "#include <chrono>\n#include <iostream>\n \nint main()\n{\n    std::chrono::hours h(1);\n    std::chrono::minutes m = ++h;\n    m--;\n    std::cout << m.count() << \" minutes\\n\";\n}",
            "output": "119 minutes"
        }
    },
    "raw_storage_iterator::operator++, operator++(int)": {
        "description": {
            "texte": "Advances the iterator."
        }
    },
    "istream_iterator::operator++, operator++(int)": {
        "description": {
            "texte": "Reads a value from the underlying stream and stores it into the iterator object. If the read fails, the iterator becomes the end-of-stream iterator.The behavior is undefined if the iterator is end-of-stream iterator."
        }
    },
    "ostream_iterator::operator++": {
        "description": {
            "texte": "Does nothing. These operator overloads are provided to satisfy the requirements of LegacyOutputIterator. They make it possible for the expressions *iter++=value and *++iter=value to be used to output (insert) a value into the underlying stream."
        }
    },
    "istreambuf_iterator::operator++, operator++(int)": {
        "description": {
            "texte": "Advances the iterator by calling sbuf_->sbumpc() where sbuf_ is the stored pointer to the stream buffer.The behavior is undefined if the iterator is end-of-stream iterator."
        }
    },
    "ostreambuf_iterator::operator++": {
        "description": {
            "texte": "Does nothing. These operator overloads are provided to satisfy the requirements of LegacyOutputIterator. They make it possible for the expressions *iter++=value and *++iter=value to be used to output (insert) a value into the underlying stream."
        }
    },
    "regex_iterator::operator++, operator++(int)": {
        "description": {
            "texte": "Advances the iterator on the next match.At first, a local variable of type BidirIt is constructed with the value of match[0].second.If the iterator holds a zero-length match and start == end, *this is set to end-of-sequence iterator and the function returns.Otherwise, if the iterator holds a zero-length match the operator invokes the following:regex_search(start, end, match, *pregex,  flags | regex_constants::match_not_null |  regex_constants::match_continuous);If the call returns true, the function returns.Otherwise the operator increments start and continues as if the most recent match was not a zero-length match.If the most recent match was not a zero-length match, the operator sets flags to flags | regex_constants::match_prev_avail and invokes the following:regex_search(start, end, match, *pregex, flags);If the call returns false, the iterator sets *this to the end-of-sequence iterator, the function returns.In all cases in which the call to regex_search returns true, match.prefix().first will be equal to the previous value of match[0].second and for each index i in the range [0, match.size()) for which match[i].matched is true, match[i].position() will return distance(begin, match[i].first).This means that match[i].position() gives the offset from the beginning of the target sequence, which is often not the same as the offset from the sequence passed in the call to regex_search.It is unspecified how the implementation makes these adjustments. This means that a compiler may call an implementation-specific search function, in which case a user-defined specialization of regex_search will not be called.The behavior is undefined if the iterator is end-of-sequence iterator."
        }
    },
    "regex_token_iterator::operator++, operator++(int)": {
        "description": {
            "texte": "Advances the iterator on the next sub match.If *this is a suffix iterator, sets *this to an end-of-sequence iterator.Otherwise, if N + 1 < subs.size(), increments N and sets result to the address of the current match.Otherwise, sets N to \u200b0\u200b and increments position. If position is not an end-of-sequence iterator the operator sets result to the address of the current match.Otherwise, if any of the values stored in subs is equal to -1 and prev->suffix().length() is not \u200b0\u200b the operator sets *this to a suffix iterator that points to the range [prev->suffix().first, prev->suffix().second).Otherwise, sets *this to an end-of-sequence iterator.The behavior is undefined if the iterator is end-of-sequence iterator."
        }
    },
    "unique_ptr::operator[]": {
        "description": {
            "texte": "operator[] provides access to elements of an array managed by a unique_ptr.The parameter i shall be less than the number of elements in the array; otherwise, the behavior is undefined."
        },
        "parametres": "   i   -   the index of the element to be returned \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nint main() \n{\n    const int size = 10; \n    std::unique_ptr<int[]> fact(new int[size]);\n \n    for (int i = 0; i < size; ++i) {\n        fact[i] = (i == 0) ? 1 : i * fact[i-1];\n    }\n \n    for (int i = 0; i < size; ++i) {\n        std::cout << i << \": \" << fact[i] << '\\n';\n    }\n}",
            "output": "0: 1\n1: 1\n2: 2\n3: 6\n4: 24\n5: 120\n6: 720\n7: 5040\n8: 40320\n9: 362880"
        }
    },
    "reverse_iterator::operator[]": {
        "description": {
            "texte": "Returns a reference to the element at specified relative location."
        },
        "parametres": "   n   -   position relative to current location. \n\n"
    },
    "move_iterator::operator[]": {
        "description": {
            "texte": "Returns a reference to the element at specified relative location."
        },
        "parametres": "   n   -   position relative to current location. \n\n"
    },
    "match_results::operator[]": {
        "description": {
            "texte": "If n > 0 and n < size(), returns a reference to the std::sub_match representing the part of the target sequence that was matched by the nth captured marked subexpression).If n == 0, returns a reference to the std::sub_match representing the part of the target sequence matched by the entire matched regular expression.if n >= size(), returns a reference to a std::sub_match representing an unmatched sub-expression (an empty subrange of the target sequence).The behavior is undefined unless ready() == true."
        },
        "parametres": "   n   -   integral number specifying which match to return \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <regex>\n#include <string>\n \nint main()\n{\n    std::string target(\"baaaby\");\n    std::smatch sm;\n \n    std::regex re1(\"a(a)*b\");\n    std::regex_search(target, sm, re1);\n    std::cout << \"entire match: \" << sm[0] << '\\n'\n              << \"submatch #1: \" << sm[1] << '\\n';\n \n    std::regex re2(\"a(a*)b\");\n    std::regex_search(target, sm, re2);\n    std::cout << \"entire match: \" << sm[0] << '\\n'\n              << \"submatch #1: \" << sm[1] << '\\n';\n \n}",
            "output": "entire match: aaab\nsubmatch #1: a\nentire match: aaab\nsubmatch #1: aa"
        }
    },
    "unique_ptr::operator*": {
        "description": {
            "texte": "operator* and operator-> provide access to the object owned by *this.The behavior is undefined if get() == nullptr."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nstruct Foo {\n    void bar() { std::cout << \"Foo::bar\\n\"; }\n};\n \nvoid f(const Foo& foo) \n{\n    std::cout << \"f(const Foo&)\\n\";\n}\n \nint main() \n{\n    std::unique_ptr<Foo> ptr(new Foo);\n \n    ptr->bar();\n    f(*ptr);\n}",
            "output": "Foo::bar\nf(const Foo&)"
        }
    },
    "shared_ptr::operator*, std::shared_ptr::operator->": {
        "description": {
            "texte": "Dereferences the stored pointer. The behavior is undefined if the stored pointer is null."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nstruct Foo\n{\n   Foo(int in) : a(in) {}\n   void print() const\n   {\n      std::cout << \"a = \" << a << '\\n';\n   }\n   int a;\n};\n \nint main()\n{\n   auto ptr = std::make_shared<Foo>(10);\n   ptr->print();\n   (*ptr).print();\n}",
            "output": "a = 10\na = 10"
        }
    },
    "auto_ptr::operator*, std::auto_ptr::operator->": {
        "description": {
            "texte": "Dereferences a pointer to the managed object. The first version requires get() != 0."
        }
    },
    "raw_storage_iterator::operator*": {
        "description": {
            "texte": "Dereferences the iterator."
        }
    },
    "reverse_iterator::operator*,->": {
        "description": {
            "texte": "Returns a reference or pointer to the element previous to current."
        }
    },
    "back_insert_iterator::operator*": {
        "description": {
            "texte": "Does nothing, this member function is provided to satisfy the requirements of LegacyOutputIterator.It returns the iterator itself, which makes it possible to use code such as *iter = value to output (insert) the value into the underlying container."
        }
    },
    "front_insert_iterator::operator*": {
        "description": {
            "texte": "Does nothing, this member function is provided to satisfy the requirements of LegacyOutputIterator.It returns the iterator itself, which makes it possible to use code such as *iter = value to output (insert) the value into the underlying container."
        }
    },
    "insert_iterator::operator*": {
        "description": {
            "texte": "Does nothing, this member function is provided to satisfy the requirements of LegacyOutputIterator.It returns the iterator itself, which makes it possible to use code such as *iter = value to output (insert) the value into the underlying container."
        }
    },
    "move_iterator::operator*,->": {
        "description": {
            "texte": "Returns a rvalue-reference or pointer to the current element."
        }
    },
    "istream_iterator::operator*, operator->": {
        "description": {
            "texte": "Returns a pointer or a reference to the current element.The behavior is undefined if the iterator is end-of-stream iterator."
        }
    },
    "ostream_iterator::operator*": {
        "description": {
            "texte": "Does nothing, this member function is provided to satisfy the requirements of LegacyOutputIterator.It returns the iterator itself, which makes it possible to use code such as *iter = value to output (insert) the value into the underlying stream."
        }
    },
    "istreambuf_iterator::operator*, operator->": {
        "description": {
            "texte": "Reads a single character by calling sbuf_->sgetc() where sbuf_ is the stored pointer to the stream buffer.The behavior is undefined if the iterator is end-of-stream iterator."
        }
    },
    "ostreambuf_iterator::operator*": {
        "description": {
            "texte": "Does nothing, this member function is provided to satisfy the requirements of LegacyOutputIterator.It returns the iterator itself, which makes it possible to use code such as *iter = value to output (insert) the value into the underlying stream."
        }
    },
    "regex_iterator::operator*,operator->": {
        "description": {
            "texte": "Extracts the current std::match_results from a regex_iterator:"
        }
    },
    "regex_token_iterator::operator*, operator->": {
        "description": {
            "texte": "Returns a pointer or reference to the current match.The behavior is undefined if the iterator is end-of-sequence iterator."
        }
    },
    "reference_wrapper::operator()": {
        "description": {
            "texte": "Calls the Callable object, reference to which is stored. This function is available only if the stored reference points to a Callable object.T must be a complete type."
        },
        "parametres": "   args   -   arguments to pass to the called function \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <functional>\n \nvoid f1()\n{\n    std::cout << \"reference to function called\\n\";\n}\nvoid f2(int n)\n{\n    std::cout << \"bind expression called with \" << n << \" as the argument\\n\";\n}\n \nint main()\n{\n    std::reference_wrapper<void()> ref1 = std::ref(f1);\n    ref1();\n \n    auto b = std::bind(f2, std::placeholders::_1);\n    auto ref2 = std::ref(b);\n    ref2(7);\n \n    auto c = []{std::cout << \"lambda function called\\n\"; };\n    auto ref3 = std::ref(c);\n    ref3();\n}",
            "output": "reference to function called\nbind expression called with 7 as the argument\nlambda function called"
        }
    },
    "function::operator()": {
        "description": {
            "texte": "Invokes the stored callable function target with the parameters args.Effectively does INVOKE<R>(f, std::forward<Args>(args)...), where f is the target object of *this and INVOKE is the operation described in Callable."
        },
        "parametres": "   args   -   parameters to pass to the stored callable function target \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <functional>\n \nvoid call(std::function<int()> f)  // can be passed by value\n{ \n    std::cout << f() << '\\n';\n}\n \nint normal_function() \n{\n    return 42;\n}\n \nint main()\n{\n    int n = 1;\n    std::function<int()> f = [&n](){ return n; };\n    call(f);\n \n    n = 2;\n    call(f); \n \n    f = normal_function; \n    call(f);\n}",
            "output": "1\n2\n42"
        }
    },
    "locale::operator()": {
        "description": {
            "texte": "Compares two string arguments s1 and s2 according to the lexicographic comparison rules defined by this locale's std::collate<charT> facet. This operator allows any locale object that has a collate facet to be used as a binary predicate in the standard algorithms (such as std::sort) and ordered containers (such as std::set)."
        },
        "parametres": "   s1   -   the first string to compare \n   s2   -   the second string to compare \n\n",
        "exemple": {
            "input": "#include <locale>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cassert>\n \nint main()\n{\n    std::vector<std::wstring> v = {L\"\u0436\u0438\u043b\", L\"\u0431\u044b\u043b\", L\"\u043a\u043e\u0442\"};\n    std::sort(v.begin(), v.end(), std::locale(\"ru_RU.UTF8\"));\n    assert(v[0] == L\"\u0431\u044b\u043b\");\n    assert(v[1] == L\"\u0436\u0438\u043b\");\n    assert(v[2] == L\"\u043a\u043e\u0442\");\n}"
        }
    },
    "packaged_task::operator()": {
        "description": {
            "texte": "Calls the stored task with args as the arguments. The return value of the task or any exceptions thrown are stored in the shared state. The shared state is made ready and any threads waiting for this are unblocked."
        },
        "parametres": "   args   -   the parameters to pass on invocation of the stored task \n\n"
    },
    "linear_congruential_engine::operator()": {
        "description": {
            "texte": "Generates a pseudo-random value. The state of the engine is advanced by one position."
        }
    },
    "uniform_int_distribution::operator()": {
        "description": {
            "texte": "Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling g.operator().The first version uses the associated parameter set, the second version uses params. The associated parameter set is not modified."
        },
        "parametres": "   g   -   an uniform random bit generator object \n   params   -   distribution parameter set to use instead of the associated one \n   Type requirements \n   -Generator must meet the requirements of UniformRandomBitGenerator. \n\n"
    },
    "type_info::hash_code": {
        "description": {
            "texte": "Returns an unspecified value such that for all type_info objects referring to the same type, their hash_code() is the same.No other guarantees are given: type_info objects referring to different types may have the same hash_code (although the standard recommends that implementations avoid this as much as possible), and hash_code for the same type can change between invocations of the same program."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <typeinfo>\n#include <unordered_map>\n#include <string>\n#include <functional>\n#include <memory>\n \nstruct A {\n    virtual ~A() {}\n};\n \nstruct B : A {};\nstruct C : A {};\n \nusing TypeInfoRef = std::reference_wrapper<const std::type_info>;\n \nstruct Hasher {\n    std::size_t operator()(TypeInfoRef code) const\n    {\n        return code.get().hash_code();\n    }\n};\n \nstruct EqualTo {\n    bool operator()(TypeInfoRef lhs, TypeInfoRef rhs) const\n    {\n        return lhs.get() == rhs.get();\n    }\n};\n \nint main()\n{\n    std::unordered_map<TypeInfoRef, std::string, Hasher, EqualTo> type_names;\n \n    type_names[typeid(int)] = \"int\";\n    type_names[typeid(double)] = \"double\";\n    type_names[typeid(A)] = \"A\";\n    type_names[typeid(B)] = \"B\";\n    type_names[typeid(C)] = \"C\";\n \n    int i;\n    double d;\n    A a;\n \n    // note that we're storing pointer to type A\n    std::unique_ptr<A> b(new B);\n    std::unique_ptr<A> c(new C);\n \n    std::cout << \"i is \" << type_names[typeid(i)] << '\\n';\n    std::cout << \"d is \" << type_names[typeid(d)] << '\\n';\n    std::cout << \"a is \" << type_names[typeid(a)] << '\\n';\n    std::cout << \"b is \" << type_names[typeid(*b)] << '\\n';\n    std::cout << \"c is \" << type_names[typeid(*c)] << '\\n';\n}",
            "output": "i is int\nd is double\na is A\nb is B\nc is C"
        }
    },
    "auto_ptr::operator auto_ptr": {
        "description": {
            "texte": "Converts *this to an auto_ptr for a different type Y."
        }
    },
    "function::target": {
        "description": {
            "texte": "Returns a pointer to the stored callable function target."
        },
        "exemple": {
            "input": "#include <functional>\n#include <iostream>\n \nint f(int, int) { return 1; }\nint g(int, int) { return 2; }\nvoid test(std::function<int(int, int)> const& arg)\n{\n    std::cout << \"test function: \";\n    if (arg.target<std::plus<int>>())\n        std::cout << \"it is plus\\n\";\n    if (arg.target<std::minus<int>>())\n        std::cout << \"it is minus\\n\";\n \n    int (*const* ptr)(int, int) = arg.target<int(*)(int, int)>();\n    if (ptr && *ptr == f)\n        std::cout << \"it is the function f\\n\";\n    if (ptr && *ptr == g)\n        std::cout << \"it is the function g\\n\";\n}\n \nint main()\n{\n    test(std::function<int(int, int)>(std::plus<int>()));\n    test(std::function<int(int, int)>(std::minus<int>()));\n    test(std::function<int(int, int)>(f));\n    test(std::function<int(int, int)>(g));\n}",
            "output": "test function: it is plus\ntest function: it is minus\ntest function: it is the function f\ntest function: it is the function g"
        }
    },
    "allocator::construct": {
        "description": {
            "texte": "Constructs an object of type T in allocated uninitialized storage pointed to by p, using placement-new."
        },
        "parametres": "   p   -   pointer to allocated uninitialized storage \n   val   -   the value to use as the copy constructor argument \n   args...   -   the constructor arguments to use \n\n"
    },
    "pointer_traits::pointer_to": {
        "description": {
            "texte": "Constructs a dereferenceable pointer or pointer-like object (\"fancy pointer\") to its argument."
        },
        "parametres": "   r   -   reference to an object of type element_type&, except if element_type is void, in which case the type of r is unspecified \n\n"
    },
    "tuple_element\n": {
        "description": {
            "texte": "The partial specializations of std::tuple_element for pairs provide compile-time access to the types of the pair's elements, using tuple-like syntax. The program is ill-formed if I >= 2."
        },
        "exemple": {
            "input": "#include <tuple>\n#include <iostream>\n#include <string>\n \nnamespace detail {\n \ntemplate <std::size_t>\nstruct index_tag { explicit constexpr index_tag() = default; };\n \ntemplate <class T, class U>\nconstexpr T get_val_dispatch(std::pair<T, U> const& pair, index_tag<0>)\n{\n    return pair.first;\n}\n \ntemplate <class T, class U>\nconstexpr U get_val_dispatch(std::pair<T, U> const& pair, index_tag<1>)\n{\n    return pair.second;\n}\n \n} // namespace detail\n \ntemplate <std::size_t N, class T, class U>\nauto constexpr get_val(std::pair<T, U> const& pair)\n    -> typename std::tuple_element<N, std::pair<T, U>>::type\n{\n    return detail::get_val_dispatch(pair, detail::index_tag<N>{});\n}\n \nint main()\n{\n    auto var = std::make_pair(1, std::string{\"one\"});\n \n    std::cout << get_val<0>(var) << \" = \" << get_val<1>(var);\n}",
            "output": "1 = one"
        }
    },
    "hash::operator()": {
        "description": {
            "texte": "Specializations of std::hash should define an operator() that:"
        },
        "parametres": "   key   -   the object to be hashed \n\n",
        "exemple": {
            "input": "#include <functional>\n#include <iostream>\n#include <string>\n \nstruct Employee {\n  std::string name;\n  unsigned int ID;\n};\n \nnamespace std {\ntemplate <>\nclass hash<Employee> {\n public:\n  size_t operator()(const Employee &employee) const\n  {\n    // computes the hash of an employee using a variant \n    // of the Fowler-Noll-Vo hash function\n    size_t result = 2166136261;\n \n    for (size_t i = 0, ie = employee.name.size(); i != ie; ++i) {\n      result = (result * 16777619) ^ employee.name[i];\n    }\n \n    return result ^ (employee.ID << 1);\n  }\n};\n}\n \nint main()\n{\n  Employee employee;\n  employee.name = \"Zaphod Beeblebrox\";\n  employee.ID = 42;\n \n  std::hash<Employee> hash_fn;\n  std::cout << hash_fn(employee) << '\\n';\n}",
            "output": "177237019"
        }
    },
    "pair::pair": {
        "description": {
            "texte": " Constructs a new pair.1) Default constructor. Value-initializes both elements of the pair, first and second.2) Initializes first with x and second with y.3) Initializes first with std::forward<U1>(x) and second with std::forward<U2>(y).4) Initializes first with p.first and second with p.second.5) Initializes first with std::forward<U1>(p.first) and second with std::forward<U2>(p.second).6) Forwards the elements of first_args to the constructor of first and forwards the elements of second_args to the constructor of second. This is the only non-default constructor that can be used to create a pair of non-copyable non-movable types.7) Copy constructor is defaulted, and is constexpr if copying of both elements satisfies the requirements on constexpr functions.8) Move constructor is defaulted, and is constexpr if moving of both elements satisfies the requirements on constexpr functions."
        },
        "parametres": "   x   -   value to initialize the first element of this pair \n   y   -   value to initialize the second element of this pair \n   p   -   pair of values used to initialize both elements of this pair \n   first_args   -   tuple of constructor arguments to initialize the first element of this pair \n   second_args   -   tuple of constructor arguments to initialize the second element of this pair \n\n",
        "exemple": {
            "input": "#include <utility>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <iostream>\n \nint main()\n{\n    std::pair<int, float> p1;\n    std::cout << \"Value-initialized: \"\n              << p1.first << \", \" << p1.second << '\\n';\n \n    std::pair<int, double> p2(42, 0.123);\n    std::cout << \"Initialized with two values: \"\n              << p2.first << \", \" << p2.second << '\\n';\n \n    std::pair<char, int> p4(p2);\n    std::cout << \"Implicitly converted: \"\n              << p4.first << \", \" << p4.second << '\\n';\n \n    std::pair<std::complex<double>, std::string> p6(\n                    std::piecewise_construct, \n                    std::forward_as_tuple(0.123, 7.7),\n                    std::forward_as_tuple(10, 'a'));\n    std::cout << \"Piecewise constructed: \"\n              << p6.first << \", \" << p6.second << '\\n';\n}",
            "output": "Value-initialized: 0, 0\nInitialized with two values: 42, 0.123\nImplicitly converted: *, 0\nPiecewise constructed: (0.123,7.7), aaaaaaaaaa"
        }
    },
    "pair::operator=": {
        "description": {
            "texte": "Replaces the contents of the pair."
        },
        "parametres": "   other   -   pair of values to replace the contents of this pair \n\n"
    },
    "pair::swap": {
        "description": {
            "texte": "Swaps first with other.first and second with other.second."
        },
        "parametres": "   other   -   pair of values to swap \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <utility>\n#include <string>\nint main()\n{\n    std::pair<int, std::string> p1, p2;\n    p1 = std::make_pair(10, \"test\");\n    p2.swap(p1);\n    std::cout << \"(\" << p2.first << \", \" << p2.second << \")\\n\";\n}",
            "output": "(10, test)"
        }
    },
    "deduction guides for std::pair\n": {
        "description": {
            "texte": "One deduction guide is provided for std::pair to account for the edge cases missed by the implicit deduction guides.In particular, non-copyable arguments and array to pointer conversion."
        },
        "exemple": {
            "input": "#include <utility>\n \nint main()\n{\n    int a[2], b[3];\n    std::pair p{a, b}; // explicit deduction guide is used in this case\n}"
        }
    },
    "swap(std::function)\n": {
        "description": {
            "texte": "Overloads the std::swap algorithm for std::function. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   polymorphic function wrappers whose states to swap \n\n"
    },
    "swap(std::basic_stringstream)\n": {
        "description": {
            "texte": "Specializes the std::swap algorithm for std::basic_stringstream. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   streams whose state to swap \n\n"
    },
    "filesystem::swap(std::filesystem::path)": {
        "description": {
            "texte": "Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs)."
        },
        "parametres": "   lhs, rhs   -   paths whose states to swap \n\n"
    },
    "type_info::before": {
        "description": {
            "texte": "Returns true if the type of this type_info precedes the type of rhs in the implementation's collation order. No guarantees are given; in particular, the collation order can change between the invocations of the same program."
        },
        "parametres": "   rhs   -   another type information object to compare to \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <typeinfo>\n \nint main()\n{\n  if(typeid(int).before(typeid(char)))\n    std::cout << \"int goes before char in this implementation.\\n\";\n  else\n    std::cout << \"char goes before int in this implementation.\\n\";\n}",
            "output": "char goes before int in this implementation."
        }
    },
    "type_info::name": {
        "description": {
            "texte": "Returns an implementation defined null-terminated character string containing the name of the type. No guarantees are given; in particular, the returned string can be identical for several types and change between invocations of the same program."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <typeinfo>\n \nstruct Base { virtual ~Base() = default; };\nstruct Derived : Base {};\n \nint main() {\n        Base b1;\n        Derived d1;\n \n        const Base *pb = &b1;\n        std::cout << typeid(*pb).name() << '\\n';\n        pb = &d1;\n        std::cout << typeid(*pb).name() << '\\n';\n}",
            "output": "4Base\n7Derived"
        }
    },
    "shared_ptr::shared_ptr": {
        "description": {
            "texte": "Constructs new shared_ptr from a variety of pointer types that refer to an object to manage.When T is not an array type, the overloads (3), (4), and (6) enable shared_from_this with ptr, and the overload (13) enables shared_from_this with the pointer returned by r.release()."
        },
        "parametres": "   ptr   -   a pointer to an object to manage \n   d   -   a deleter to use to destroy the object \n   alloc   -   an allocator to use for allocations of data for internal use \n   r   -   another smart pointer to share the ownership to or acquire the ownership from \n\n",
        "exemple": {
            "input": "#include <memory>\n#include <iostream>\n \nstruct Foo {\n    Foo() { std::cout << \"Foo...\\n\"; }\n    ~Foo() { std::cout << \"~Foo...\\n\"; }\n};\n \nstruct D { \n    void operator()(Foo* p) const {\n        std::cout << \"Call delete from function object...\\n\";\n        delete p;\n    }\n};\n \nint main()\n{\n    {\n        std::cout << \"constructor with no managed object\\n\";\n        std::shared_ptr<Foo> sh1;\n    }\n \n    {\n        std::cout << \"constructor with object\\n\";\n        std::shared_ptr<Foo> sh2(new Foo);\n        std::shared_ptr<Foo> sh3(sh2);\n        std::cout << sh2.use_count() << '\\n';\n        std::cout << sh3.use_count() << '\\n';\n    }\n \n    {\n        std::cout << \"constructor with object and deleter\\n\";\n        std::shared_ptr<Foo> sh4(new Foo, D());\n        std::shared_ptr<Foo> sh5(new Foo, [](auto p) {\n           std::cout << \"Call delete from lambda...\\n\";\n           delete p;\n        });\n    }\n}",
            "output": "constructor with no managed object\nconstructor with object\nFoo...\n2\n2\n~Foo...\nconstructor with object and deleter\nFoo...\nFoo...\nCall delete from lambda...\n~Foo...\nCall delete from function object...\n~Foo.."
        }
    },
    "shared_ptr::~shared_ptr": {
        "description": {
            "texte": "If *this owns an object and it is the last shared_ptr owning it, the object is destroyed through the owned deleter.After the destruction, the smart pointers that shared ownership with *this, if any, will report a use_count() that is one less than its previous value."
        }
    },
    "shared_ptr::operator=": {
        "description": {
            "texte": "Replaces the managed object with the one managed by r.If *this already owns an object and it is the last shared_ptr owning it, and r is not the same as *this, the object is destroyed through the owned deleter.1) Shares ownership of the object managed by r. If r manages no object, *this manages no object too. Equivalent to shared_ptr<T>(r).swap(*this).2) Move-assigns a shared_ptr from r. After the assignment, *this contains a copy of the previous state of r, and r is empty. Equivalent to shared_ptr<T>(std::move(r)).swap(*this).3) Transfers the ownership of the object managed by r to *this. If r manages no object, *this manages no object too. After the assignment, *this contains the pointer previously held by r, and use_count()==1; also r is empty. Equivalent to shared_ptr<T>(r).swap(*this).4) Transfers the ownership of the object managed by r to *this. The deleter associated to r is stored for future deletion of the managed object. r manages no object after the call. Equivalent to shared_ptr<T>(std::move(r)).swap(*this)."
        },
        "parametres": "   r   -   another smart pointer to share the ownership to or acquire the ownership from \n\n"
    },
    "shared_ptr::reset": {
        "description": {
            "texte": "Replaces the managed object with an object pointed to by ptr. Optional deleter d can be supplied, which is later used to destroy the new object when no shared_ptr objects own it. By default, delete expression is used as deleter. Proper delete expression corresponding to the supplied type is always selected, this is the reason why the function is implemented as template using a separate parameter Y.If *this already owns an object and it is the last shared_ptr owning it, the object is destroyed through the owned deleter.If the object pointed to by ptr is already owned, the function results in undefined behavior."
        },
        "parametres": "   ptr   -   pointer to an object to acquire ownership of \n   d   -   deleter to store for deletion of the object \n   alloc   -   allocator to use for internal allocations \n\n",
        "exemple": {
            "input": "#include <memory>\n#include <iostream>\n \nstruct Foo {\n    Foo(int n = 0) noexcept : bar(n) {\n        std::cout << \"Foo: constructor, bar = \" << bar << '\\n';\n    }\n    ~Foo() {\n         std::cout << \"Foo: destructor, bar = \" << bar << '\\n';\n    }\n    int getBar() const noexcept { return bar; }\nprivate:\n    int bar;\n};\n \nint main()\n{\n    std::shared_ptr<Foo> sptr = std::make_shared<Foo>(1);\n    std::cout << \"The first Foo's bar is \" << sptr->getBar() << \"\\n\";\n \n    // reset the shared_ptr, hand it a fresh instance of Foo\n    // (the old instance will be destroyed after this call)\n    sptr.reset(new Foo);\n    std::cout << \"The second Foo's bar is \" << sptr->getBar() << \"\\n\";\n}",
            "output": "Foo: constructor, bar = 1\nThe first Foo's bar is 1\nFoo: constructor, bar = 0\nFoo: destructor, bar = 1\nThe second Foo's bar is 0\nFoo: destructor, bar = 0"
        }
    },
    "shared_ptr::swap": {
        "description": {
            "texte": "Exchanges the contents of *this and r."
        },
        "parametres": "   r   -   smart pointer to exchange the contents with \n\n"
    },
    "shared_ptr::get": {
        "description": {
            "texte": "Returns the stored pointer."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n#include <string_view>\n \nvoid output(std::string_view msg, int const* pInt)\n{\n    std::cout << msg << *pInt << \"\\n\";\n}\n \nint main()\n{\n    int* pInt = new int(42);\n    std::shared_ptr<int> pShared = std::make_shared<int>(42);\n \n    output(\"Naked pointer \", pInt);\n    // output(\"Shared pointer \", pShared); // compiler error\n    output(\"Shared pointer with get() \", pShared.get());\n \n    delete pInt;\n}",
            "output": "Naked pointer 42\nShared pointer with get() 42"
        }
    },
    "shared_ptr::operator[]": {
        "description": {
            "texte": "Index into the array pointed to by the stored pointer.The behavior is undefined if the stored pointer is null or if idx is negative.If T (the template parameter of shared_ptr) is an array type U[N], idx must be less than N, otherwise the behavior is undefined."
        },
        "parametres": "   idx   -   the array index \n\n"
    },
    "shared_ptr::use_count": {
        "description": {
            "texte": "Returns the number of different shared_ptr instances (this included) managing the current object. If there is no managed object, \u200b0\u200b is returned.In multithreaded environment, the value returned by use_count is approximate (typical implementations use a memory_order_relaxed load)."
        },
        "exemple": {
            "input": "#include <memory> \n#include <iostream> \n \nvoid fun(std::shared_ptr<int> sp)\n{\n    std::cout << \"fun: sp.use_count() == \" << sp.use_count() << '\\n'; \n}\n \nint main() \n{ \n    auto sp1 = std::make_shared<int>(5);\n    std::cout << \"sp1.use_count() == \" << sp1.use_count() << '\\n'; \n \n    fun(sp1);\n}",
            "output": "sp1.use_count() == 1\nfun: sp.use_count() == 2"
        }
    },
    "shared_ptr::unique": {
        "description": {
            "texte": "Checks if *this is the only shared_ptr instance managing the current object, i.e. whether use_count() == 1."
        },
        "exemple": {
            "input": "#include <memory> \n#include <iostream> \n \nint main() \n{ \n    auto sp1 = std::make_shared<int>(5);\n    std::cout << std::boolalpha;\n    std::cout << \"sp1.unique() == \" << sp1.unique() << '\\n'; \n \n    std::shared_ptr<int> sp2 = sp1; \n    std::cout << \"sp1.unique() == \" << sp1.unique() << '\\n'; \n}",
            "output": "sp1.unique() == true\nsp1.unique() == false"
        }
    },
    "shared_ptr::operator bool": {
        "description": {
            "texte": "Checks if *this stores a non-null pointer, i.e. whether get() != nullptr."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nvoid report(std::shared_ptr<int> ptr) \n{\n    if (ptr) {\n        std::cout << \"*ptr=\" << *ptr << \"\\n\";\n    } else {\n        std::cout << \"ptr is not a valid pointer.\\n\";\n    }\n}\n \nint main()\n{\n    std::shared_ptr<int> ptr;\n    report(ptr);\n \n    ptr = std::make_shared<int>(7);\n    report(ptr);\n}",
            "output": "ptr is not a valid pointer.\n*ptr=7"
        }
    },
    "shared_ptr::owner_before": {
        "description": {
            "texte": "Checks whether this shared_ptr precedes other in implementation defined owner-based (as opposed to value-based) order. The order is such that two smart pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by get() are different (e.g. because they point at different subobjects within the same object).This ordering is used to make shared and weak pointers usable as keys in associative containers, typically through std::owner_less."
        },
        "parametres": "   other   -   the std::shared_ptr or std::weak_ptr to be compared \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nstruct Foo {\n    int n1;\n    int n2; \n    Foo(int a, int b) : n1(a), n2(b) {}\n};\nint main()\n{   \n    auto p1 = std::make_shared<Foo>(1, 2);\n    std::shared_ptr<int> p2(p1, &p1->n1);\n    std::shared_ptr<int> p3(p1, &p1->n2);\n \n    std::cout << std::boolalpha\n              << \"p2 < p3 \" << (p2 < p3) << '\\n'\n              << \"p3 < p2 \" << (p3 < p2) << '\\n'\n              << \"p2.owner_before(p3) \" << p2.owner_before(p3) << '\\n'\n              << \"p3.owner_before(p2) \" << p3.owner_before(p2) << '\\n';\n \n    std::weak_ptr<int> w2(p2);\n    std::weak_ptr<int> w3(p3);\n    std::cout \n//              << \"w2 < w3 \" << (w2 < w3) << '\\n'  // won't compile \n//              << \"w3 < w2 \" << (w3 < w2) << '\\n'  // won't compile\n              << \"w2.owner_before(w3) \" << w2.owner_before(w3) << '\\n'\n              << \"w3.owner_before(w2) \" << w3.owner_before(w2) << '\\n';\n \n}",
            "output": "p2 < p3 true\np3 < p2 false\np2.owner_before(p3) false\np3.owner_before(p2) false\nw2.owner_before(w3) false\nw3.owner_before(w2) false"
        }
    },
    "deduction guides for std::shared_ptr\n": {
        "description": {
            "texte": "These deduction guides are provided for std::shared_ptr to account for the edge cases missed by the implicit deduction guides.Note that there is no class template argument deduction from pointer types because it is impossible to distinguish pointers obtained from array and non-array forms of new."
        },
        "exemple": {
            "input": "#include <memory>\n \nint main()\n{\n    auto p = std::make_shared<int>(42);\n    std::weak_ptr w{p};    // explicit deduction guide is used in this case\n    std::shared_ptr p2{w}; // explicit deduction guide is used in this case\n}"
        }
    },
    "atomic::fetch_add": {
        "description": {
            "texte": "Atomically replaces the current value with the result of arithmetic addition of the value and arg. The operation is read-modify-write operation. Memory is affected according to the value of order.For signed Integral types, arithmetic is defined to use two\u2019s complement representation. There are no undefined results.For T* types, the result may be an undefined address, but the operation otherwise has no undefined behavior. The program is ill-formed if T is not an object type."
        },
        "parametres": "   arg   -   the other argument of arithmetic addition \n   order   -   memory order constraints to enforce \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <thread>\n#include <atomic>\n \nstd::atomic<long long> data;\nvoid do_work()\n{\n    data.fetch_add(1, std::memory_order_relaxed);\n}\n \nint main()\n{\n    std::thread th1(do_work);\n    std::thread th2(do_work);\n    std::thread th3(do_work);\n    std::thread th4(do_work);\n    std::thread th5(do_work);\n \n    th1.join();\n    th2.join();\n    th3.join();\n    th4.join();\n    th5.join();\n \n    std::cout << \"Result:\" << data << '\\n';\n}",
            "output": "Result:5"
        }
    },
    "allocator::allocator": {
        "description": {
            "texte": "Constructs the default allocator. Since the default allocator is stateless, the constructors have no visible effect."
        },
        "parametres": "   other   -   another allocator to construct with \n\n"
    },
    "allocator::address": {
        "description": {
            "texte": "Returns the actual address of x even in presence of overloaded operator&."
        },
        "parametres": "   x   -   the object to acquire address of \n\n"
    },
    "allocator::deallocate": {
        "description": {
            "texte": "Deallocates the storage referenced by the pointer p, which must be a pointer obtained by an earlier call to allocate().The argument n must be equal to the first argument of the call to allocate() that originally produced p; otherwise, the behavior is undefined.Calls ::operator delete(void*) or ::operator delete(void*, std::align_val_t) (since C++17), but it is unspecified when and how it is called."
        },
        "parametres": "   p   -   pointer obtained from allocate() \n   n   -   number of objects earlier passed to allocate() \n\n"
    },
    "allocator::max_size": {
        "description": {
            "texte": "Returns the maximum theoretically possible value of n, for which the call allocate(n, 0) could succeed.In most implementations, this returns std::numeric_limits<size_type>::max() / sizeof(value_type)."
        }
    },
    "exception::exception": {
        "description": {
            "texte": "Constructs new exception object."
        },
        "parametres": "   other   -   another exception to assign the contents of \n\n"
    },
    "exception::operator=": {
        "description": {
            "texte": "Copy assignment operator. Assigns the contents of other."
        },
        "parametres": "   other   -   another exception to assign the contents of \n\n"
    },
    "exception::what": {
        "description": {
            "texte": "Returns the explanatory string."
        }
    },
    "chrono::time_point::time_point": {
        "description": {
            "texte": "Constructs a new time_point from one of several optional data sources."
        },
        "parametres": "   d   -   a duration to copy from \n   t   -   a time_point to convert from \n\n",
        "exemple": {
            "input": "#include <chrono>\n#include <iostream>\n \nusing Clock = std::chrono::high_resolution_clock;\nusing TimePoint = std::chrono::time_point<Clock>;\n \nvoid print_ms(const TimePoint& point) \n{\n    using Ms = std::chrono::milliseconds;\n    const Clock::duration since_epoch = point.time_since_epoch();\n    std::cout << std::chrono::duration_cast<Ms>(since_epoch).count() << \" ms\\n\";\n}\n \nint main() \n{\n    const TimePoint default_value = TimePoint(); // (1)\n    print_ms(default_value); // 0 ms\n \n    const Clock::duration duration_4_seconds = std::chrono::seconds(4);\n    const TimePoint time_point_4_seconds(duration_4_seconds); // (2)\n      // 4 seconds from start of epoch\n    print_ms(time_point_4_seconds); // 4000 ms\n \n    const TimePoint time_point_now = Clock::now(); // (3)\n    print_ms(time_point_now); // 43098276 ms\n}",
            "output": "0 ms\n4000 ms\n43098276 ms"
        }
    },
    "chrono::time_point::time_since_epoch": {
        "description": {
            "texte": "Returns a duration representing the amount of time between *this and the clock's epoch."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n#include <ctime>\n \nint main()\n{\n    const auto p0 = std::chrono::time_point<std::chrono::system_clock>{};\n    const auto p1 = std::chrono::system_clock::now();\n    const auto p2 = p1 - std::chrono::hours(24);\n \n    std::time_t epoch_time = std::chrono::system_clock::to_time_t(p0);\n    std::cout << \"epoch: \" << std::ctime(&epoch_time);\n    std::time_t today_time = std::chrono::system_clock::to_time_t(p1);\n    std::cout << \"today: \" << std::ctime(&today_time);\n \n    std::cout << \"hours since epoch: \"\n              << std::chrono::duration_cast<std::chrono::hours>(\n                   p1.time_since_epoch()).count() \n              << '\\n';\n    std::cout << \"yesterday, hours since epoch: \"\n              << std::chrono::duration_cast<std::chrono::hours>(\n                   p2.time_since_epoch()).count() \n              << '\\n';\n}",
            "output": "epoch: Thu Jan  1 00:00:00 1970\ntoday: Fri Jun 30 10:44:11 2017\nhours since epoch: 416338\nyesterday, hours since epoch: 416314"
        }
    },
    "chrono::time_point::operator+, operator-": {
        "description": {
            "texte": "Modifies the time point by the given duration."
        },
        "parametres": "   d   -   a time offset to apply \n\n"
    },
    "chrono::time_point::operator++, std::chrono::time_point::operator--": {
        "description": {
            "texte": "Modifies the point in time *this represents by one tick of the duration.If d_ is a member variable holding the duration (i.e., time since epoch) of this time_point object,"
        }
    },
    "chrono::time_point::min": {
        "description": {
            "texte": "Returns a time_point with the smallest possible duration, i.e. time_point(std::chrono::duration::min())."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <ratio>\n#include <chrono>\n \nconstexpr auto steady_min = std::chrono::steady_clock::time_point::min();\n \nint main()\n{\n    auto last_frame = steady_min;\n    std::chrono::duration<float, std::milli> game_time {0.0F};\n \n    for (std::size_t count = 0; count < 5; ++count) {\n        auto current_frame = std::chrono::steady_clock::now();\n        // initialize timer if first frame ever:\n        if (last_frame == steady_min)\n            last_frame = current_frame;\n        game_time += current_frame - last_frame;\n        std::cout << \"Drawing frame at \" << game_time.count() << \" ms\\n\";\n        // animate frame at time offset game_time ...\n    }\n}",
            "output": "Drawing frame at 0 ms\nDrawing frame at 0.17551 ms\nDrawing frame at 0.358325 ms\nDrawing frame at 0.545384 ms\nDrawing frame at 0.736717 ms"
        }
    },
    "chrono::time_point::max": {
        "description": {
            "texte": "Returns a time_point with the largest possible duration, i.e. time_point(std::chrono::duration::max())."
        },
        "exemple": {
            "input": "#include <chrono>\n#include <vector>\n#include <iostream>\n \nint main() \n{\n    std::chrono::time_point<std::chrono::system_clock> now =\n        std::chrono::system_clock::now();\n    std::vector<std::chrono::time_point<std::chrono::system_clock>> times {\n        now - std::chrono::hours(24),\n        now - std::chrono::hours(48),\n        now + std::chrono::hours(24),\n    };  \n \n    std::chrono::time_point<std::chrono::system_clock> earliest =\n        std::chrono::time_point<std::chrono::system_clock>::max();\n \n    std::cout << \"all times:\\n\";\n    for (const auto &time : times) {\n        std::time_t t = std::chrono::system_clock::to_time_t(time);\n        std::cout << std::ctime(&t);\n \n        if (time < earliest) earliest = time;\n    }\n \n    std::time_t t = std::chrono::system_clock::to_time_t(earliest);\n    std::cout << \"earliest:\\n\" << std::ctime(&t);\n}",
            "output": "all times:\nSun Oct  7 19:06:48 2012\nSat Oct  6 19:06:48 2012\nTue Oct  9 19:06:48 2012\nearliest:\nSat Oct  6 19:06:48 2012"
        }
    },
    "chrono::duration::duration": {
        "description": {
            "texte": "Constructs a new duration from one of several optional data sources."
        },
        "parametres": "   r   -   a tick count \n   d   -   a duration to copy from \n\n",
        "exemple": {
            "input": "#include <chrono>\nint main()\n{\n    std::chrono::hours h(1); // one hour\n    std::chrono::milliseconds ms{3}; // 3 milliseconds\n    std::chrono::duration<int, std::kilo> ks(3); // 3000 seconds\n \n    // error: treat_as_floating_point<int>::value == false,\n    // This duration allows whole tick counts only\n//  std::chrono::duration<int, std::kilo> d3(3.5);\n \n    // 30Hz clock using fractional ticks\n    std::chrono::duration<double, std::ratio<1, 30>> hz30(3.5);\n \n    // 3000 microseconds constructed from 3 milliseconds\n    std::chrono::microseconds us = ms;\n    // error: 1/1000000 is not divisible by 1/1000\n//  std::chrono::milliseconds ms2 = us\n    std::chrono::duration<double, std::milli> ms2 = us; // 3.0 milliseconds\n}"
        }
    },
    "chrono::duration::operator=": {
        "description": {
            "texte": "Assigns the contents of one duration to another."
        },
        "parametres": "   other   -   duration to copy from \n\n"
    },
    "chrono::duration::count": {
        "description": {
            "texte": "Returns the number of ticks for this duration."
        },
        "exemple": {
            "input": "#include <chrono>\n#include <iostream>\nint main()\n{\n    std::chrono::milliseconds ms{3}; // 3 milliseconds\n    // 6000 microseconds constructed from 3 milliseconds\n    std::chrono::microseconds us = 2*ms;\n    // 30Hz clock using fractional ticks\n    std::chrono::duration<double, std::ratio<1, 30>> hz30(3.5);\n \n    std::cout <<  \"3 ms duration has \" << ms.count() << \" ticks\\n\"\n              <<  \"6000 us duration has \" << us.count() << \" ticks\\n\"\n              <<  \"3.5 30Hz duration has \" << hz30.count() << \" ticks\\n\";       \n}",
            "output": "3 ms duration has 3 ticks\n6000 us duration has 6000 ticks\n3.5 30Hz duration has 3.5 ticks"
        }
    },
    "chrono::duration::zero": {
        "description": {
            "texte": "Returns a zero-length duration.If the representation rep of the duration requires some other implementation to return a zero-length duration, std::chrono::duration_values can be specialized to return the desired value."
        }
    },
    "chrono::duration::min": {
        "description": {
            "texte": "Returns a duration with the lowest possible value.If the representation rep of the duration requires some other implementation to return a minimum-length duration, std::chrono::duration_values can be specialized to return the desired value."
        }
    },
    "chrono::duration::max": {
        "description": {
            "texte": "Returns a duration with the largest possible value.If the representation rep of the duration requires some other implementation to return a maximum-length duration, std::chrono::duration_values can be specialized to return the desired value."
        }
    },
    "chrono::duration::operator+=, -=, *=, /=, %=": {
        "description": {
            "texte": "Performs compound assignments between two durations with the same period or between a duration and a tick count value.If rep_ is the member variable holding the number of ticks in this duration object,"
        },
        "parametres": "   d   -   duration on the right-hand side of the operator \n   rhs   -   number of ticks on the right-hand side of the operator \n\n",
        "exemple": {
            "input": "#include <chrono>\n#include <iostream>\n \nint main()\n{\n    std::chrono::minutes m(11);\n    m *= 2;\n    m += std::chrono::hours(10); // hours implicitly convert to minutes\n    std::cout << m.count() << \" minutes equals \"\n              << std::chrono::duration_cast<std::chrono::hours>(m).count() \n              << \" hours and \";\n    m %= std::chrono::hours(1);\n    std::cout << m.count() << \" minutes\\n\";\n}",
            "output": "622 minutes equals 10 hours and 22 minutes"
        }
    },
    "chrono::operator<< (std::chrono::duration)": {
        "description": {
            "texte": "Inserts a textual representation of d into os. The behavior is undefined if CharT is neither char or wchar_t, or if Rep is neither a floating-point type nor a integral type with conversion rank equal to or greater than short.Behaves as if it forms a std::basic_string<CharT, Traits> str initially consisting of the characters in std::to_string(d.count()) (if CharT is char) or std::to_wstring(d.count()) (if CharT is wchar_t). Appends to str a suffix based on Period::type according to the following table, and inserts str into the stream with os << str;.For std::micro, if the character \u00b5 (U+00B5) cannot be represented in the encoding used for CharT, the suffix \"us\" is used instead.For the last two rows of the table, num and den in the suffix are Period::type::num and Period::type::den formatted as a decimal number with no leading zeroes, respectively."
        }
    },
    "chrono::to_stream (std::chrono::duration)": {
        "description": {
            "texte": "Outputs d (interpreted as a time of day since midnight) to the stream os, formatted according to the null-terminated format string fmt."
        }
    },
    "chrono::from_stream (std::chrono::duration)": {
        "description": {
            "texte": "Attempts to parse the input stream is into the std::chrono::duration d, interpreted as the time of day since midnight, according to the format string fmt.Behaves as an UnformattedInputFunction, except that it has an unspecified effect on is.gcount(). After constructing and checking the sentry object, attempts to parse the input stream is into d according to the format string fmt. If the parse fails to decode a valid duration, is.setstate(std::ios_base::failbit) is called and d is not modified.If the format specifier %Z is used and successfully parsed, the parsed value is assigned to *abbrev if abbrev is not null. If the format specifier %z or a modified variant is used and successfully parsed, the parsed value is assigned to *offset if offset is not null."
        }
    },
    "function::function": {
        "description": {
            "texte": "Constructs a std::function from a variety of sources.When the target is a function pointer or a std::reference_wrapper, small object optimization is guaranteed, that is, these targets are always directly stored inside the std::function object, no dynamic allocation takes place. Other large objects may be constructed in dynamic allocated storage and accessed by the std::function object through a pointer."
        },
        "parametres": "   other   -   the function object used to initialize *this \n   f   -   a callable used to initialize *this \n   alloc   -   an Allocator used for internal memory allocation \n   Type requirements \n   -F must meet the requirements of Callable and CopyConstructible. \n   -Alloc must meet the requirements of Allocator. \n\n"
    },
    "function::operator=": {
        "description": {
            "texte": "Assigns a new target to std::function."
        },
        "parametres": "   other   -   another std::function object to copy the target of \n   f   -   a callable to initialize the target with \n   Type requirements \n   -F must meet the requirements of Callable. \n\n"
    },
    "function::swap": {
        "description": {
            "texte": "Exchanges the stored callable objects of *this and other."
        },
        "parametres": "   other   -   function wrapper to exchange the stored callable object with \n\n"
    },
    "function::assign": {
        "description": {
            "texte": "Initializes the target with f. alloc is used to allocate memory for any internal data structures that the function might use.Equivalent to function(allocator_arg, alloc, std::forward<F>(f)).swap(*this)."
        },
        "parametres": "   f   -   callable function to initialize the target with \n   alloc   -   allocator to use to allocate memory for the internal data structures \n\n"
    },
    "function::operator bool": {
        "description": {
            "texte": "Checks whether *this stores a callable function target, i.e. is not empty."
        },
        "exemple": {
            "input": "#include <functional>\n#include <iostream>\n \nvoid sampleFunction()\n{\n    std::cout << \"This is the sample function!\\n\";\n}\n \nvoid checkFunc( std::function<void()> &func )\n{\n    // Use operator bool to determine if callable target is available.\n    if( func )  \n    {\n        std::cout << \"Function is not empty! Calling function.\\n\";\n        func();\n    }\n    else\n    {\n        std::cout << \"Function is empty. Nothing to do.\\n\";\n    }\n}\n \nint main()\n{\n    std::function<void()> f1;\n    std::function<void()> f2( sampleFunction );\n \n    std::cout << \"f1: \";\n    checkFunc( f1 );\n \n    std::cout << \"f2: \";\n    checkFunc( f2 );\n}",
            "output": "f1: Function is empty. Nothing to do.\nf2: Function is not empty! Calling function.\nThis is the sample function!"
        }
    },
    "function::target_type": {
        "description": {
            "texte": "Returns the type of the stored function."
        },
        "exemple": {
            "input": "#include <functional>\n#include <iostream>\n \nint f(int a) { return -a; }\nint main()\n{\n    // fn1 and fn2 have the same type, but their targets do not\n    std::function<int(int)> fn1(f),\n                            fn2([](int a) {return -a;});\n    std::cout << fn1.target_type().name() << '\\n'\n              << fn2.target_type().name() << '\\n';\n}",
            "output": "int (*)(int)\nmain::$_0"
        }
    },
    "deduction guides for std::function\n": {
        "description": {
            "texte": "The type deduced by these deduction guides may change in a later standard revision (in particular, this might happen if noexcept support is added to std::function in a later standard)."
        },
        "exemple": {
            "input": "#include <functional>\nint func(double) { return 0; }\nint main() {\n  std::function f{func}; // guide #1 deduces function<int(double)>\n  int i = 5;\n  std::function g = [&](double) { return i; }; // guide #2 deduces function<int(double)>\n}"
        }
    },
    "nested_exception::nested_exception": {
        "description": {
            "texte": "Constructs new nested_exception object."
        },
        "parametres": "   other   -   nested exception to initialize the contents with \n\n"
    },
    "nested_exception::operator=": {
        "description": {
            "texte": "Replaces the stored exception with the one held in other."
        },
        "parametres": "   other   -   nested exception to replace the contents with \n\n"
    },
    "nested_exception::rethrow_nested": {
        "description": {
            "texte": "Rethrows the stored exception. If there is no stored exceptions (i.e. nested_ptr() returns null pointer), then std::terminate is called."
        }
    },
    "nested_exception::nested_ptr": {
        "description": {
            "texte": "Returns a pointer to the stored exception, if any."
        }
    },
    "bad_exception::bad_exception": {
        "description": {
            "texte": "Constructs new bad_exception object."
        },
        "parametres": "   other   -   bad_exception object to initialize with \n\n"
    },
    "bad_exception::operator=": {
        "description": {
            "texte": "Assigns the contents of other."
        },
        "parametres": "   other   -   another bad_exception object to assign \n\n"
    },
    "bad_exception::what": {
        "description": {
            "texte": "Returns the explanatory string."
        }
    },
    "locale::locale": {
        "description": {
            "texte": "Contstructs a new locale object."
        },
        "parametres": "   other   -   another locale to copy \n   std_name   -   name of the system locale to use \n   f   -   pointer to a facet to merge with other \n   cat   -   the locale category used to identify the facets to merge with other \n   one   -   another locale to take facets from \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n#include <codecvt>\n \nint main()\n{\n    std::locale l1;  // l1 is a copy of the classic \"C\" locale\n    std::locale l2(\"en_US.UTF-8\"); // l2 is a unicode locale\n    std::locale l3(l1, l2, std::locale::ctype); // l3 is \"C\" except for ctype, which is unicode\n    std::locale l4(l1, new std::codecvt_utf8<wchar_t>); // l4 is \"C\" except for codecvt\n    std::cout << \"Locale names:\\nl1: \" << l1.name() << \"\\nl2: \" << l2.name()\n               << \"\\nl3: \" << l3.name() << \"\\nl4: \" << l4.name() << '\\n';\n}",
            "output": "Locale names:\nl1: C\nl2: en_US.UTF-8\nl3: LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=C;LC_COLLATE=C;LC_MONETARY=C;LC_MESSAGES=C;LC_PAPER=C;LC_NAME=C;LC_ADDRESS=C;LC_TELEPHONE=C;LC_MEASUREMENT=C;LC_IDENTIFICATION=C\nl4: *"
        }
    },
    "locale::combine": {
        "description": {
            "texte": "Constructs a locale object which is a copy of *this except for the facet of type Facet, which is copied from other."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n \nint main()\n{\n    const double number = 1000.25;\n    std::cout << \"\\\"C\\\" locale: \" << number << '\\n';\n    std::locale loc = std::locale().combine<std::numpunct<char>>(std::locale(\"en_US.UTF8\"));\n    std::cout.imbue(loc);\n    std::cout << \"\\\"C\\\" locale with en_US numpunct: \" << number << '\\n';\n}",
            "output": "\"C\" locale: 1000.25\n\"C\" locale with en_US numpunct: 1,000.25"
        }
    },
    "wstring_convert::from_bytes": {
        "description": {
            "texte": "Performs multibyte to wide conversion, using the codecvt facet supplied at construction.1) Converts byte as if it was a string of length 1 to wide_string.2) Converts the null-terminated multibyte character sequence beginning at the character pointed to by ptr to wide_string.3) Converts the narrow string str to wide_string.4) Converts the narrow multibyte character sequence [first, last) to wide_string.In all cases, the conversion begins in initial shift state, unless non-initial starting state was provided to this wstring_convert constructor. The number of characters converted and the final value of the conversion state are remembered and can be accessed with state() and converted()."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <locale>\n#include <codecvt>\n \nint main()\n{\n    std::string utf8 =  u8\"z\\u00df\\u6c34\\U0001d10b\"; // or u8\"z\u00df\u6c34\ud834\udd0b\"\n                        // or \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9d\\x84\\x8b\";\n \n    // the UTF-8 / UTF-16 standard conversion facet\n    std::u16string utf16 = std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t>{}.from_bytes(utf8.data());\n    std::cout << \"UTF16 conversion produced \" << utf16.size() << \" code units:\\n\";\n    for (char16_t c : utf16)\n        std::cout << std::hex << std::showbase << c << '\\n';\n \n    // the UTF-8 / UTF-32 standard conversion facet\n    std::u32string utf32 = std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t>{}.from_bytes(utf8);\n    std::cout << \"UTF32 conversion produced \" << std::dec << utf32.size() << \" code units:\\n\";\n    for (char32_t c : utf32)\n        std::cout << std::hex << std::showbase << c << '\\n';\n}",
            "output": "UTF16 conversion produced 5 code units:\n0x7a\n0xdf\n0x6c34\n0xd834\n0xdd0b\nUTF32 conversion produced 4 code units:\n0x7a\n0xdf\n0x6c34\n0x1d10b"
        }
    },
    "wstring_convert::to_bytes": {
        "description": {
            "texte": "Performs wide to multibyte conversion, using the codecvt facet supplied at construction.In all cases, the conversion begins in initial shift state, unless non-initial starting state was provided to this wstring_convert constructor. The number of characters converted and the final value of the conversion state are remembered and can be accessed with state() and converted()."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <locale>\n#include <codecvt>\n#include <iomanip>\n \n// utility function for output\nvoid hex_print(const std::string& s)\n{\n    std::cout << std::hex << std::setfill('0');\n    for(unsigned char c : s)\n        std::cout << std::setw(2) << static_cast<int>(c) << ' ';\n    std::cout << std::dec << '\\n';\n}\n \nint main()\n{\n    // wide character data\n    std::wstring wstr =  L\"z\\u00df\\u6c34\\U0001f34c\"; // or L\"z\u00df\u6c34\ud83c\udf4c\"\n \n    // wide to UTF-8\n    std::wstring_convert<std::codecvt_utf8<wchar_t>> conv1;\n    std::string u8str = conv1.to_bytes(wstr);\n    std::cout << \"UTF-8 conversion produced \" << u8str.size() << \" bytes:\\n\";\n    hex_print(u8str);\n \n    // wide to UTF-16le\n    std::wstring_convert<std::codecvt_utf16<wchar_t, 0x10ffff, std::little_endian>> conv2;\n    std::string u16str = conv2.to_bytes(wstr);\n    std::cout << \"UTF-16le conversion produced \" << u16str.size() << \" bytes:\\n\";\n    hex_print(u16str);\n}",
            "output": "UTF-8 conversion produced 10 bytes:\n7a c3 9f e6 b0 b4 f0 9f 8d 8c \nUTF-16le conversion produced 10 bytes:\n7a 00 df 00 34 6c 3c d8 4c df"
        }
    },
    "error_category::error_category": {
        "description": {
            "texte": "Constructs the error category object."
        }
    },
    "error_category::~error_category": {
        "description": {
            "texte": "Destroys the object."
        }
    },
    "error_category::name": {
        "description": {
            "texte": "Returns a pointer to a null-terminated byte string that specifies the name of the error category."
        }
    },
    "error_category::default_error_condition": {
        "description": {
            "texte": "Returns the error condition for the given error code.Equivalent to std::error_condition(code, *this)."
        },
        "parametres": "   code   -   error code for which to return error condition \n\n"
    },
    "error_category::equivalent": {
        "description": {
            "texte": "Checks whether error code is equivalent to an error condition for the error category represented by *this."
        },
        "parametres": "   code   -   specifies the error code to compare \n   condition   -   specifies the error condition to compare \n\n"
    },
    "error_category::message": {
        "description": {
            "texte": "Returns a string describing the given error condition for the error category represented by *this."
        },
        "parametres": "   condition   -   specifies the error condition to describe \n\n"
    },
    "error_category::operator==,!=,<": {
        "description": {
            "texte": "Compares to another error category."
        },
        "parametres": "   code   -   specifies the error code to compare \n   condition   -   specifies the error condition to compare \n\n"
    },
    "error_condition::error_condition": {
        "description": {
            "texte": "Constructs new error condition."
        },
        "parametres": "   other   -   another error condition to initialize with \n   val   -   error code \n   cat   -   error category \n   e   -   error condition enum \n\n"
    },
    "error_condition::operator=": {
        "description": {
            "texte": "Assigns contents to an error condition."
        },
        "parametres": "   other   -   another error condition to initialize with \n   e   -   error condition enum \n\n"
    },
    "error_condition::assign": {
        "description": {
            "texte": "Assigns contents to an error condition. Sets the error code to val and error category to cat."
        },
        "parametres": "   val   -   error code \n   cat   -   error category \n\n"
    },
    "error_condition::clear": {
        "description": {
            "texte": "Clears the state of the error condition. Sets the error code to \u200b0\u200b and error category to std::generic_category."
        }
    },
    "error_condition::value": {
        "description": {
            "texte": "Returns the stored error code."
        }
    },
    "error_condition::category": {
        "description": {
            "texte": "Returns the stored error category."
        }
    },
    "error_condition::message": {
        "description": {
            "texte": "Returns an explanatory message for the stored error code and error category. Effectively calls category().message(value())."
        }
    },
    "error_condition::operator bool": {
        "description": {
            "texte": "Checks whether the stored error code is not zero."
        }
    },
    "is_error_condition_enum\n": {
        "description": {
            "texte": "Specifies that std::errc is an error condition enum. This enables implicit conversion to std::error_condition."
        }
    },
    "system_error::system_error": {
        "description": {
            "texte": "Constructs new system error object."
        },
        "parametres": "   ec   -   error code \n   ev   -   underlying error code in the enumeration associated with ecat \n   ecat   -   the category of error \n   what_arg   -   explanatory string \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <system_error>\n \nint main()\n{\n    try\n    {\n        throw std::system_error(EDOM, std::generic_category(), \"hello world\");\n    }\n    catch (const std::system_error& ex)\n    {\n        std::cout << ex.code() << '\\n';\n        std::cout << ex.code().message() << '\\n';\n        std::cout << ex.what() << '\\n';\n    }\n}",
            "output": "generic:33\nNumerical argument out of domain\nhello world: Numerical argument out of domain"
        }
    },
    "system_error::code": {
        "description": {
            "texte": "Returns the stored error code."
        }
    },
    "system_error::what": {
        "description": {
            "texte": "Returns the explanatory string."
        }
    },
    "future::future": {
        "description": {
            "texte": "Constructs a std::future object."
        },
        "parametres": "   other   -   another std::future to acquire shared state from \n\n"
    },
    "future::operator=": {
        "description": {
            "texte": "Assigns the contents of another future object.1) Releases any shared state and move-assigns the contents of other to *this. After the assignment, other.valid() == false and this->valid() will yield the same value as other.valid() before the assignment.2) std::future is not CopyAssignable."
        },
        "parametres": "   other   -   a std::future that will transfer state to *this \n\n"
    },
    "future::share": {
        "description": {
            "texte": "Transfers the shared state of *this, if any, to a std::shared_future object. Multiple std::shared_future objects may reference the same shared state, which is not possible with std::future.After calling share on a std::future, valid() == false."
        }
    },
    "future::get": {
        "description": {
            "texte": "The get method waits until the future has a valid result and (depending on which template is used) retrieves it. It effectively calls wait() in order to wait for the result.The generic template and two template specializations each contain a single version of get. The three versions of get differ only in the return type.The behavior is undefined if valid() is false before the call to this function.Any shared state is released. valid() is false after a call to this method."
        },
        "exemple": {
            "input": "#include <thread>\n#include <future>\n#include <iostream>\n#include <string>\n#include <chrono>\n \nstd::string time() {\n    static auto start = std::chrono::steady_clock::now();\n    std::chrono::duration<double> d = std::chrono::steady_clock::now() - start;\n    return \"[\" + std::to_string(d.count()) + \"s]\";\n}\nint main() {\n    using namespace std::chrono_literals;\n    {\n        std::cout << time() << \" launching thread\\n\";\n        std::future<int> f = std::async(std::launch::async, []{\n            std::this_thread::sleep_for(1s);\n            return 7;\n        });\n        std::cout << time() << \" waiting for the future, f.valid() == \"\n                  << f.valid() << \"\\n\";\n        int n = f.get();\n        std::cout << time() << \" future.get() returned with \" << n << \". f.valid() = \"\n                  << f.valid() << '\\n';\n    }\n \n    {\n        std::cout << time() << \" launching thread\\n\";\n        std::future<int> f = std::async(std::launch::async, []{\n            std::this_thread::sleep_for(1s);\n            return true ? throw std::runtime_error(\"7\") : 7;\n        });\n        std::cout << time() << \" waiting for the future, f.valid() == \"\n                  << f.valid() << \"\\n\";\n        try {\n            int n = f.get();\n            std::cout << time() << \" future.get() returned with \" << n\n                      << \" f.valid() = \" << f.valid() << '\\n';\n        } catch(const std::exception& e) {\n            std::cout << time() << \" caught exception \" << e.what()\n                      << \", f.valid() == \" << f.valid() << \"\\n\";\n        }\n    }\n}",
            "output": "[0.000004s] launching thread\n[0.000461s] waiting for the future, f.valid() == 1\n[1.001156s] future.get() returned with 7. f.valid() = 0\n[1.001192s] launching thread\n[1.001275s] waiting for the future, f.valid() == 1\n[2.002356s] caught exception 7, f.valid() == 0"
        }
    },
    "future::valid": {
        "description": {
            "texte": "Checks if the future refers to a shared state.This is the case only for futures that were not default-constructed or moved from (i.e. returned by std::promise::get_future(), std::packaged_task::get_future() or std::async()) until the first time get() or share() is called.The behavior is undefined if any member function other than the destructor, the move-assignment operator, or valid is called on a future  that does not refer to shared state (although implementations are encouraged to throw std::future_error indicating no_state in this case). It is valid to move from a future object for which valid() is false."
        }
    },
    "future::wait": {
        "description": {
            "texte": "Blocks until the result becomes available. valid() == true after the call.The behavior is undefined if valid()== false before the call to this function."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <future>\n#include <thread>\n \nint fib(int n)\n{\n  if (n < 3) return 1;\n  else return fib(n-1) + fib(n-2);\n}\n \nint main()\n{\n    std::future<int> f1 = std::async(std::launch::async, [](){\n        return fib(20);\n    });\n    std::future<int> f2 = std::async(std::launch::async, [](){\n        return fib(25);\n    });\n \n    std::cout << \"waiting...\\n\";\n    f1.wait();\n    f2.wait();\n \n    std::cout << \"f1: \" << f1.get() << '\\n';\n    std::cout << \"f2: \" << f2.get() << '\\n';\n}",
            "output": "waiting...\nf1: 6765\nf2: 75025"
        }
    },
    "future::wait_for": {
        "description": {
            "texte": "Waits for the result to become available. Blocks until specified timeout_duration has elapsed or the result becomes available, whichever comes first. Returns value identifies the state of the result.This function may block for longer than timeout_duration due to scheduling or resource contention delays.The standard recommends that a steady clock is used to measure the duration. If an implementation uses a system clock instead, the wait time may also be sensitive to clock adjustments.The behavior is undefined if valid()== false before the call to this function."
        },
        "parametres": "   timeout_duration   -   maximum duration to block for \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <future>\n#include <thread>\n#include <chrono>\n \nint main()\n{\n    std::future<int> future = std::async(std::launch::async, [](){ \n        std::this_thread::sleep_for(std::chrono::seconds(3));\n        return 8;  \n    }); \n \n    std::cout << \"waiting...\\n\";\n    std::future_status status;\n    do {\n        status = future.wait_for(std::chrono::seconds(1));\n        if (status == std::future_status::deferred) {\n            std::cout << \"deferred\\n\";\n        } else if (status == std::future_status::timeout) {\n            std::cout << \"timeout\\n\";\n        } else if (status == std::future_status::ready) {\n            std::cout << \"ready!\\n\";\n        }\n    } while (status != std::future_status::ready); \n \n    std::cout << \"result is \" << future.get() << '\\n';\n}",
            "output": "waiting...\ntimeout\ntimeout\nready!\nresult is 8"
        }
    },
    "future::wait_until": {
        "description": {
            "texte": "wait_until waits for a result to become available. It blocks until specified timeout_time has been reached or the result becomes available, whichever comes first. The return value indicates why wait_until returned.The behavior is undefined if valid()== false before the call to this function."
        },
        "parametres": "   timeout_time   -   maximum time point to block until \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <future>\n#include <thread>\n#include <chrono>\n \nint main()\n{\n    std::chrono::system_clock::time_point two_seconds_passed\n        = std::chrono::system_clock::now() + std::chrono::seconds(2);\n \n    // Make a future that that takes 1 second to completed\n    std::promise<int> p1;\n    std::future<int> f_completes = p1.get_future();\n    std::thread([](std::promise<int> p1)\n                { \n                    std::this_thread::sleep_for(std::chrono::seconds(1)); \n                    p1.set_value_at_thread_exit(9); \n                }, \n                std::move(p1)\n    ).detach();\n \n    // Make a future that that takes 5 seconds to completed\n    std::promise<int> p2;\n    std::future<int> f_times_out = p2.get_future();\n    std::thread([](std::promise<int> p2)\n                { \n                    std::this_thread::sleep_for(std::chrono::seconds(5)); \n                    p2.set_value_at_thread_exit(8); \n                }, \n                std::move(p2)\n    ).detach();\n \n    std::cout << \"Waiting for 2 seconds...\" << std::endl;\n \n    if(std::future_status::ready == f_completes.wait_until(two_seconds_passed))\n        { std::cout << \"f_completes: \" << f_completes.get() << \"\\n\"; }\n    else\n        { std::cout << \"f_completes did not complete!\\n\"; }\n \n    if(std::future_status::ready == f_times_out.wait_until(two_seconds_passed))\n        { std::cout << \"f_times_out: \" << f_times_out.get() << \"\\n\"; }\n    else\n        { std::cout << \"f_times_out did not complete!\\n\"; }\n \n    std::cout << \"Done!\\n\";\n}",
            "output": "Waiting for 2 seconds...\nf_completes: 9\nf_times_out did not complete!\nDone!"
        }
    },
    "promise::set_value": {
        "description": {
            "texte": "The operation behaves as though set_value, set_exception, set_value_at_thread_exit, and set_exception_at_thread_exit acquire a single mutex associated with the promise object while updating the promise object.An exception is thrown if there is no shared state or the shared state already stores a value or exception.Calls to this function do not introduce data races with calls to get_future (but they need not synchronize with each other)."
        },
        "parametres": "   value   -   value to store in the shared state \n\n",
        "exemple": {
            "input": "#include <thread>\n#include <future>\n#include <cctype>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::istringstream iss_numbers{\"3 4 1 42 23 -23 93 2 -289 93\"};\n    std::istringstream iss_letters{\" a 23 b,e a2 k k?a;si,ksa c\"};\n \n    std::vector<int> numbers;\n    std::vector<char> letters;\n    std::promise<void> numbers_promise, letters_promise;\n \n    auto numbers_ready = numbers_promise.get_future();\n    auto letter_ready = letters_promise.get_future();\n \n    std::thread value_reader([&]\n    {\n        // I/O operations.\n        std::copy(std::istream_iterator<int>{iss_numbers},\n                  std::istream_iterator<int>{},\n                  std::back_inserter(numbers));\n \n        //Notify for numbers.\n        numbers_promise.set_value();\n \n        std::copy_if(std::istreambuf_iterator<char>{iss_letters},\n                     std::istreambuf_iterator<char>{},\n                     std::back_inserter(letters),\n                     ::isalpha);\n \n        //Notify for letters.\n        letters_promise.set_value();\n    });\n \n \n    numbers_ready.wait();\n \n    std::sort(numbers.begin(), numbers.end());\n \n    if (letter_ready.wait_for(std::chrono::seconds(1)) ==\n            std::future_status::timeout)\n    {\n        //output the numbers while letters are being obtained.\n        for (int num : numbers) std::cout << num << ' ';\n        numbers.clear(); //Numbers were already printed.\n    }\n \n    letter_ready.wait();\n    std::sort(letters.begin(), letters.end());\n \n    //If numbers were already printed, it does nothing.\n    for (int num : numbers) std::cout << num << ' ';\n    std::cout << '\\n';\n \n    for (char let : letters) std::cout << let << ' ';\n    std::cout << '\\n';\n \n    value_reader.join();\n}",
            "output": "-289 -23 1 2 3 4 23 42 93 93 \na a a a b c e i k k k s s"
        }
    },
    "char_traits::assign": {
        "description": {
            "texte": "Assigns a character."
        },
        "parametres": "   a   -   character value to assign \n   r   -   character to assign to \n   p   -   pointer to a character sequence to assign to \n   count   -   the length of the character sequence \n\n"
    },
    "char_traits::eq, std::char_traits::lt": {
        "description": {
            "texte": "Compares two characters."
        },
        "parametres": "   a, b   -   character values to compare \n\n"
    },
    "char_traits::move": {
        "description": {
            "texte": "Copies count character from character string pointed to by src to character string pointed to by dest.Performs correctly even if the copied character ranges overlap, i.e. src is in [dest, dest + count)."
        },
        "parametres": "   dest   -   pointer to a character string to copy to \n   src   -   pointer to a character string to copy from \n   count   -   the number of characters to copy \n\n"
    },
    "char_traits::copy": {
        "description": {
            "texte": "Copies count character from character string pointed to by src to character string pointed to by dest.Formally, for each i in [0, count), performs assign(src[i], dest[i]).The behavior is undefined if copied character ranges overlap, i.e. src is in [dest, dest + count)."
        },
        "parametres": "   dest   -   pointer to a character string to copy to \n   src   -   pointer to a character string to copy from \n   count   -   the number of characters to copy \n\n"
    },
    "char_traits::compare": {
        "description": {
            "texte": "Compares the first count characters of the character strings s1 and s2. The comparison is done lexicographically.If count is zero, strings are considered equal."
        },
        "parametres": "   s1, s2   -   pointers to character strings to compare \n   count   -   the number of characters to compare from each character string \n\n"
    },
    "char_traits::length": {
        "description": {
            "texte": "Returns the length of the character sequence pointed to by s, that is, the position of the terminating null character (CharT())."
        },
        "parametres": "   s   -   pointer to a character sequence to return length of \n\n",
        "exemple": {
            "input": "#include <iostream>\n \nvoid print(const char* str)\n{\n  std::cout << \"string '\" << str << \"' \";\n  std::cout << \"length = \" << std::char_traits<char>::length(str) << '\\n';\n}\n \nint main()\n{\n  print(\"foo\");\n \n  std::string s(\"booo\");\n  print(s.c_str());\n}",
            "output": "string 'foo' length = 3\nstring 'booo' length = 4"
        }
    },
    "char_traits::find": {
        "description": {
            "texte": "Searches for character ch within the first count characters of the sequence pointed to by p."
        },
        "parametres": "   p   -   pointer to a character string to search \n   count   -   the number of characters to analyze \n   ch   -   the character to search for \n\n"
    },
    "char_traits::to_char_type": {
        "description": {
            "texte": "Converts a value of int_type to char_type. If there are no equivalent value (such as when c is a copy of the eof value), the results are unspecified.Formally, returns the value x such that X::eq_int_type(c, X::to_int_type(x)) is true, and an unspecified value if no such x exists."
        },
        "parametres": "   c   -   value to convert \n\n"
    },
    "char_traits::to_int_type": {
        "description": {
            "texte": "Converts a value of char_type to int_type."
        },
        "parametres": "   c   -   value to convert \n\n"
    },
    "char_traits::eq_int_type": {
        "description": {
            "texte": "Checks whether two values of type int_type are equal.Formally,"
        },
        "parametres": "   c1, c2   -   values to compare \n\n"
    },
    "char_traits::eof": {
        "description": {
            "texte": "Returns a value not equivalent to any valid value of type char_type.Formally, returns a value e such that X::eq_int_type(e, X::to_int_type(c)) is false for all values c."
        }
    },
    "char_traits::not_eof": {
        "description": {
            "texte": "Checks whether e is not equivalent to eof value.Formally."
        },
        "parametres": "   e   -   value to analyze \n\n"
    },
    "wstring_convert::wstring_convert": {
        "description": {
            "texte": "The following behavior-changing defect reports were applied retroactively to previously published C++ standards."
        },
        "parametres": "   pcvt   -   pointer to the conversion facet of type Codecvt (behavior is undefined if this pointer is null) \n   state   -   initial value of the conversion shift state \n   byte_err   -   narrow string to display on errors \n   wide_err   -   wide string to display on errors \n\n",
        "exemple": {
            "input": "#include <locale>\n#include <utility>\n#include <codecvt>\n \n// utility wrapper to adapt locale-bound facets for wstring/wbuffer convert\ntemplate<class Facet>\nstruct deletable_facet : Facet\n{\n    using Facet::Facet; // inherit constructors\n    ~deletable_facet() {}\n};\n \nint main()\n{\n    // UTF-16le / UCS4 conversion\n    std::wstring_convert<\n         std::codecvt_utf16<char32_t, 0x10ffff, std::little_endian>\n    > u16to32;\n \n    // UTF-8 / wide string conversion with custom messages\n    std::wstring_convert<std::codecvt_utf8<wchar_t>> u8towide(\"Error!\", L\"Error!\");\n \n    // GB18030 / wide string conversion facet\n    typedef deletable_facet<std::codecvt_byname<wchar_t, char, std::mbstate_t>> F;\n    std::wstring_convert<F> gbtowide(new F(\"zh_CN.gb18030\"));\n}"
        }
    },
    "wstring_convert:: ~wstring_convert": {
        "description": {
            "texte": "Destroys the wstring_convert object and deletes the pointer to the conversion facet."
        },
        "exemple": {
            "input": "#include <locale>\n#include <utility>\n#include <codecvt>\n \n// utility wrapper to adapt locale-bound facets for wstring/wbuffer convert\ntemplate<class Facet>\nstruct deletable_facet : Facet\n{\n    template<class ...Args>\n    deletable_facet(Args&& ...args) : Facet(std::forward<Args>(args)...) {}\n    ~deletable_facet() {}\n};\n \nint main()\n{\n    // GB18030 / UCS4 conversion, using locale-based facet directly\n    // typedef std::codecvt_byname<char32_t, char, std::mbstate_t> gbfacet_t;\n    // Compiler error: \"calling a protected destructor of codecvt_byname<> in ~wstring_convert\"\n    // std::wstring_convert<gbfacet_t> gbto32(new gbfacet_t(\"zh_CN.gb18030\"));\n \n    // GB18030 / UCS4 conversion facet using a facet with public destructor\n    typedef deletable_facet<std::codecvt_byname<char32_t, char, std::mbstate_t>> gbfacet_t;\n    std::wstring_convert<gbfacet_t> gbto32(new gbfacet_t(\"zh_CN.gb18030\"));\n} // destructor called here"
        }
    },
    "wstring_convert::converted": {
        "description": {
            "texte": "Returns the number of source characters that were processed by the most recent from_bytes() or to_bytes()."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <locale>\n#include <codecvt>\nint main()\n{\n    std::string utf8 =  u8\"z\\u00df\\u6c34\\U0001d10b\"; // or u8\"z\u00df\u6c34\ud834\udd0b\"\n                        // or \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9d\\x84\\x8b\";\n    std::cout << \"original UTF-8 string size: \" << utf8.size() << '\\n';\n \n    // the UTF-8 - UTF-32 standard conversion facet\n    std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t> cvt;\n \n    // UTF-8 to UTF-32\n    std::u32string utf32 = cvt.from_bytes(utf8);\n    std::cout << \"UTF-32 string size: \" << utf32.size() << '\\n';\n    std::cout << \"converted() == \" << cvt.converted() << '\\n';\n    // UTF-32 to UTF-8\n    utf8 = cvt.to_bytes(utf32);\n    std::cout << \"new UTF-8 string size: \" << utf8.size() << '\\n';\n    std::cout << \"converted() == \" << cvt.converted() << '\\n';\n}",
            "output": "original UTF-8 string size: 10\nUTF-32 string size: 4\nconverted() == 10\nnew UTF-8 string size: 10\nconverted() == 4"
        }
    },
    "wstring_convert::state": {
        "description": {
            "texte": "Returns the current value of the conversion state, which is stored in this wstring_convert object. The conversion state may be explicitly set in the constructor and is updated by all conversion operations."
        }
    },
    "span::span": {
        "description": {
            "texte": "Constructs a span."
        },
        "parametres": "   ptr, first   -   pointer to the first element of the sequence \n   count   -   number of elements in the sequence \n   last   -   pointer past the last element of the sequence \n   arr   -   array to construct a view for \n   cont   -   container to construct a view for \n   s   -   another span to convert from \n   other   -   another span to copy from \n\n"
    },
    "span::operator=": {
        "description": {
            "texte": "Assigns other to *this. This defaulted assignment operator performs a shallow copy of the data pointer and the size, i.e., after a call to this function, data() == other.data() and size() == other.size()."
        },
        "parametres": "   other   -   another span to copy from \n\n"
    },
    "span::front": {
        "description": {
            "texte": "Returns a reference to the first element in the span.Calling front on an empty span results in undefined behavior."
        }
    },
    "span::back": {
        "description": {
            "texte": "Returns a reference to the last element in the span.Calling back on an empty span results in undefined behavior."
        }
    },
    "span::operator[]": {
        "description": {
            "texte": "Returns a reference to the idx-th element of the sequence. The behavior is undefined if idx is out of range (i.e., if it is greater than or equal to size())."
        },
        "parametres": "   idx   -   the index of the element to access \n\n"
    },
    "span::data": {
        "description": {
            "texte": "Returns a pointer to the beginning of the sequence."
        }
    },
    "span::begin, std::span::cbegin": {
        "description": {
            "texte": "Returns an iterator to the first element of the span.If the span is empty, the returned iterator will be equal to end()."
        }
    },
    "span::end, std::span::cend": {
        "description": {
            "texte": "Returns an iterator to the element following the last element of the span.This element acts as a placeholder; attempting to access it results in undefined behavior."
        }
    },
    "span::rbegin, std::span::crbegin": {
        "description": {
            "texte": "Returns a reverse iterator to the first element of the reversed span. It corresponds to the last element of the non-reversed span. If the span is empty, the returned iterator is equal to rend()."
        }
    },
    "span::rend, std::span::crend": {
        "description": {
            "texte": "Returns a reverse iterator to the element following the last element of the reversed span. It corresponds to the element preceding the first element of the non-reversed span. This element acts as a placeholder, attempting to access it results in undefined behavior."
        }
    },
    "span::empty": {
        "description": {
            "texte": "Checks if the span is empty."
        }
    },
    "span::size": {
        "description": {
            "texte": "Returns the number of elements in the span."
        }
    },
    "span::size_bytes": {
        "description": {
            "texte": "Returns the size of the sequence in bytes."
        }
    },
    "span::first": {
        "description": {
            "texte": "Obtains a span that is a view over the first Count elements of this span. The behavior is undefined if Count > size()."
        }
    },
    "span::last": {
        "description": {
            "texte": "Obtains a span that is a view over the last Count elements of this span. The behavior is undefined if Count > size()."
        }
    },
    "span::subspan": {
        "description": {
            "texte": "Obtains a span that is a view over the Count elements of this span starting at offset Offset. If Count is std::dynamic_extent, the number of elements in the subspan is size() - offset (i.e., it ends at the end of *this.).The behavior is undefined if either Offset or Count is out of range. This happens if.The extent E of the span returned by (1) is determined as follows:"
        }
    },
    "begin,end(std::span)\n": {
        "description": {
            "texte": "These functions are not visible to ordinary unqualified or qualified lookup, and can only be found by argument-dependent lookup when std::span<T, Extent> is an associated class of the arguments."
        },
        "parametres": "   s   -   a span \n\n"
    },
    "get(std::span)\n": {
        "description": {
            "texte": "Obtains a reference to the Ith element of the span s.The span must have static extent (i.e., N != std::dynamic_extent) and I must be an integer value in range [0, N). This is enforced at compile time as opposed to operator[]."
        },
        "parametres": "   s   -   span whose contents to extract \n\n"
    },
    "tuple_size(std::span)\n": {
        "description": {
            "texte": "Provides access to the number of elements in a static-extent span as a compile-time constant expression. If the span has dynamic extent, the tuple_size specialization is an incomplete type."
        }
    },
    "allocator_traits::construct": {
        "description": {
            "texte": "If possible, constructs an object of type T in allocated uninitialized storage pointed to by p, by calling.a.construct(p, std::forward<Args>(args)...).If the above is not possible (e.g. a does not have the member function construct(),), then calls placement-new as.::new (static_cast<void*>(p)) T(std::forward<Args>(args)...)."
        },
        "parametres": "   a   -   allocator to use for construction \n   args...   -   the constructor arguments to pass to a.construct() or to placement-new \n\n"
    },
    "reverse_iterator::reverse_iterator": {
        "description": {
            "texte": "Constructs a new iterator adaptor."
        },
        "parametres": "   x   -   iterator to adapt \n   other   -   iterator adaptor to copy \n\n"
    },
    "reverse_iterator::operator=": {
        "description": {
            "texte": "The underlying iterator is assigned the value of the underlying iterator of other, i.e. other.base()."
        },
        "parametres": "   other   -   iterator adaptor to assign \n\n"
    },
    "reverse_iterator::base": {
        "description": {
            "texte": "Returns the underlying base iterator. That is std::reverse_iterator(it).base() == it.The base iterator refers to the element that is next (from the std::reverse_iterator::iterator_type perspective) to the element the reverse_iterator is currently pointing to. That is &*(rit.base() - 1) == &*rit."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n#include <vector>\n \nint main()\n{\n  std::vector<int> v = { 0, 1, 2, 3, 4, 5 };\n \n  using RevIt = std::reverse_iterator<std::vector<int>::iterator>;\n  {\n    const auto it = v.begin() + 3;\n    RevIt r_it(it);\n \n    std::cout << \"*it == \" << *it << \", *r_it.base() == \" << *r_it.base()\n    << '\\n' << \"*r_it == \" << *r_it <<\", *(r_it.base()-1) == \" << *(r_it.base()-1) << \"\\n\";\n  }\n  {\n    RevIt r_end(v.begin());\n    RevIt r_begin(v.end());\n \n    for (auto it = r_end.base(); it != r_begin.base(); ++it) {\n      std::cout << *it << \" \";\n    }\n    std::cout << \"\\n\";\n  }\n}",
            "output": "*it == 3, *r_it.base() == 3\n*r_it == 2, *(r_it.base()-1) == 2\n0 1 2 3 4 5"
        }
    },
    "move_iterator::move_iterator": {
        "description": {
            "texte": "Constructs a new iterator adaptor."
        },
        "parametres": "   x   -   iterator to adapt \n   other   -   iterator adaptor to copy \n\n"
    },
    "move_iterator::operator=": {
        "description": {
            "texte": "The underlying iterator is assigned the value of the underlying iterator of other, i.e. other.base()."
        },
        "parametres": "   other   -   iterator adaptor to assign \n\n"
    },
    "move_iterator::base": {
        "description": {
            "texte": "Returns the underlying base iterator."
        }
    },
    "back_insert_iterator::operator=": {
        "description": {
            "texte": "Inserts the given value value to the container."
        },
        "parametres": "   value   -   the value to insert \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n#include <deque>\n \nint main()\n{\n    std::deque<int> q;\n    std::back_insert_iterator< std::deque<int> > it(q);\n \n    for (int i=0; i<10; ++i)\n        it = i; // calls q.push_back(i)\n \n    for (auto& elem : q) std::cout << elem << ' ';\n}",
            "output": "0 1 2 3 4 5 6 7 8 9"
        }
    },
    "front_insert_iterator::operator=": {
        "description": {
            "texte": "Inserts the given value value to the container."
        },
        "parametres": "   value   -   the value to insert \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n#include <deque>\n \nint main()\n{\n    std::deque<int> q;\n    std::front_insert_iterator< std::deque<int> > it(q);\n \n    for (int i=0; i<10; ++i)\n        it = i; // calls q.push_front(i)\n \n    for (auto& elem : q) std::cout << elem << ' ';\n}",
            "output": "9 8 7 6 5 4 3 2 1 0"
        }
    },
    "insert_iterator::operator=": {
        "description": {
            "texte": "Inserts the given value value to the container."
        },
        "parametres": "   value   -   the value to insert \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n#include <deque>\n \nint main()\n{\n    std::deque<int> q;\n    std::insert_iterator< std::deque<int> > it(q, q.begin());\n \n    for (int i=0; i<10; ++i)\n        it = i; // inserts i\n \n    for (auto& elem : q) std::cout << elem << ' ';\n}",
            "output": "0 1 2 3 4 5 6 7 8 9"
        }
    },
    "istream_iterator::istream_iterator": {
        "description": {
            "texte": "The following behavior-changing defect reports were applied retroactively to previously published C++ standards."
        },
        "parametres": "   stream   -   stream to initialize the istream_iterator with \n   other   -   another istream_iterator of the same type \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n#include <algorithm>\n#include <sstream>\nint main()\n{\n    std::istringstream stream(\"1 2 3 4 5\");\n    std::copy(\n        std::istream_iterator<int>(stream),\n        std::istream_iterator<int>(),\n        std::ostream_iterator<int>(std::cout, \" \")\n    );\n}",
            "output": "1 2 3 4 5"
        }
    },
    "ostream_iterator::ostream_iterator": {
        "description": {
            "texte": "1) Constructs the iterator with stream as the associated stream and delim as the delimiter.2) Constructs the iterator with stream as the associated stream and a null pointer as the delimiter."
        },
        "parametres": "   stream   -   the output stream to be accessed by this iterator \n   delim   -   the null-terminated character string to be inserted into the stream after each output \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n#include <algorithm>\nint main()\n{\n    std::ostream_iterator<int> i1(std::cout, \", \");\n    std::fill_n(i1, 5, -1);\n    std::ostream_iterator<double> i2(std::cout);\n    *i2++ = 3.14;\n}",
            "output": "-1, -1, -1, -1, -1, 3.14"
        }
    },
    "ostream_iterator::operator=": {
        "description": {
            "texte": "Inserts value into the associated stream, then inserts the delimiter, if one was specified at construction time.If out_stream is a pointer to the associated std::basic_ostream and delim is the delimiter specified at the construction of this object, then the effect is equivalent to.*out_stream << value; if(delim != 0) *out_stream << delim; return *this;"
        },
        "parametres": "   value   -   the object to insert \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n \nint main()\n{\n    std::ostream_iterator<int> i1(std::cout, \", \");\n    *i1++ = 1; // usual form, used by standard algorithms\n    *++i1 = 2;\n    i1 = 3; // neither * nor ++ are necessary\n    std::ostream_iterator<double> i2(std::cout);\n    i2 = 3.14;\n}",
            "output": "1, 2, 3, 3.14"
        }
    },
    "istreambuf_iterator::equal": {
        "description": {
            "texte": "Checks whether both *this and it are valid, or both are invalid, regardless of the stream buffer objects they use."
        },
        "parametres": "   it   -   another stream buffer iterator to compare to \n\n"
    },
    "ostreambuf_iterator::operator=": {
        "description": {
            "texte": "If failed() returns false, inserts the character c into the associated stream buffer by calling pbuf->sputc(c), where pbuf is the private member of type streambuf_type*. Otherwise, does nothing.If the call to pbuf->sputc(c) returns Traits::eof, sets the failed() flag to true."
        },
        "parametres": "   c   -   the character to insert \n\n"
    },
    "ostreambuf_iterator::failed": {
        "description": {
            "texte": "Returns true if the iterator encountered the end-of-file condition, that is, if an earlier call to std::basic_streambuf::sputc (made by operator=) returned Traits::eof."
        }
    },
    "filesystem::begin(directory_iterator), std::filesystem::end(directory_iterator)": {
        "description": {
            "texte": "These non-member functions enable the use of directory_iterators with range-based for loops."
        },
        "parametres": "   iter   -   a directory_iterator \n\n",
        "exemple": {
            "input": "#include <fstream>\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::create_directories(\"sandbox/a/b\");\n    std::ofstream(\"sandbox/file1.txt\");\n    std::ofstream(\"sandbox/file2.txt\");\n    for(auto& p: fs::directory_iterator(\"sandbox\"))\n        std::cout << p << '\\n';\n    fs::remove_all(\"sandbox\");\n}",
            "output": "\"sandbox/a\"\n\"sandbox/file1.txt\"\n\"sandbox/file2.txt\""
        }
    },
    "filesystem::begin(recursive_directory_iterator), std::filesystem::end(recursive_directory_iterator)": {
        "description": {
            "texte": "These non-member functions enable the use of recursive_directory_iterators with range-based for loops."
        },
        "parametres": "   iter   -   a recursive_directory_iterator \n\n",
        "exemple": {
            "input": "#include <fstream>\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::create_directories(\"sandbox/a/b\");\n    std::ofstream(\"sandbox/file1.txt\");\n    fs::create_symlink(\"a\", \"sandbox/syma\");\n    for(auto& p: fs::recursive_directory_iterator(\"sandbox\"))\n        std::cout << p << '\\n';\n    fs::remove_all(\"sandbox\");\n}",
            "output": "\"sandbox/a\"\n\"sandbox/a/b\"\n\"sandbox/file1.txt\"\n\"sandbox/syma\""
        }
    },
    "mutex::unlock": {
        "description": {
            "texte": "Unlocks the mutex.The mutex must be locked by the current thread of execution, otherwise, the behavior is undefined.This operation synchronizes-with (as defined in std::memory_order) any subsequent lock operation that obtains ownership of the same mutex."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n#include <thread>\n#include <mutex>\n \nint g_num = 0;  // protected by g_num_mutex\nstd::mutex g_num_mutex;\n \nvoid slow_increment(int id) \n{\n    for (int i = 0; i < 3; ++i) {\n        g_num_mutex.lock();\n        ++g_num;\n        std::cout << id << \" => \" << g_num << '\\n';\n        g_num_mutex.unlock();\n \n        std::this_thread::sleep_for(std::chrono::seconds(1));\n    }\n}\n \nint main()\n{\n    std::thread t1(slow_increment, 0);\n    std::thread t2(slow_increment, 1);\n    t1.join();\n    t2.join();\n}",
            "output": "0 => 1\n1 => 2\n0 => 3\n1 => 4\n0 => 5\n1 => 6"
        }
    },
    "mutex::lock": {
        "description": {
            "texte": "Locks the mutex. If another thread has already locked the mutex, a call to lock will block execution until the lock is acquired.If lock is called by a thread that already owns the mutex, the behavior is undefined: for example, the program may deadlock. An implementation that can detect the invalid usage is encouraged to throw a std::system_error with error condition resource_deadlock_would_occur instead of deadlocking.Prior unlock() operations on the same mutex synchronize-with (as defined in std::memory_order) this operation."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n#include <thread>\n#include <mutex>\n \nint g_num = 0;  // protected by g_num_mutex\nstd::mutex g_num_mutex;\n \nvoid slow_increment(int id) \n{\n    for (int i = 0; i < 3; ++i) {\n        g_num_mutex.lock();\n        ++g_num;\n        std::cout << id << \" => \" << g_num << '\\n';\n        g_num_mutex.unlock();\n \n        std::this_thread::sleep_for(std::chrono::seconds(1));\n    }\n}\n \nint main()\n{\n    std::thread t1(slow_increment, 0);\n    std::thread t2(slow_increment, 1);\n    t1.join();\n    t2.join();\n}",
            "output": "0 => 1\n1 => 2\n0 => 3\n1 => 4\n0 => 5\n1 => 6"
        }
    },
    "basic_filebuf::basic_filebuf": {
        "description": {
            "texte": "Contructs new std::basic_filebuf object."
        },
        "parametres": "   rhs   -   another basic_filebuf \n\n"
    },
    "basic_filebuf::~basic_filebuf": {
        "description": {
            "texte": "Calls close() to close the associated file and destructs all other members of basic_filebuf. If an exception is thrown by close(), it is caught and not rethrown."
        }
    },
    "basic_filebuf::operator=": {
        "description": {
            "texte": "Assigns another basic_filebuf object."
        },
        "parametres": "   rhs   -   another basic_filebuf that will be moved from \n\n",
        "exemple": {
            "input": "#include <fstream>\n#include <string>\n#include <iostream>\n \nint main()\n{\n \n    std::ifstream fin(\"test.in\"); // read-only\n    std::ofstream fout(\"test.out\"); // write-only\n \n    std::string s;\n    getline(fin, s);\n    std::cout << s << '\\n'; // output\n \n    *fin.rdbuf() = std::move(*fout.rdbuf());\n \n    getline(fin, s);\n    std::cout << s << '\\n'; // empty line\n \n    std::cout << std::boolalpha << fout.is_open() << '\\n'; // prints \"false\"\n \n}"
        }
    },
    "basic_filebuf::swap": {
        "description": {
            "texte": "Swaps the state and the contents of *this and rhs."
        },
        "parametres": "   rhs   -   another basic_filebuf \n\n",
        "exemple": {
            "input": "#include <fstream>\n#include <string>\n#include <iostream>\n \nint main()\n{\n    std::ifstream fin(\"test.in\"); // read-only\n    std::ofstream fout(\"test.out\"); // write-only\n \n    std::string s;\n    getline(fin, s);\n    std::cout << s << '\\n'; // outputs the first line of test.in\n \n    fin.rdbuf()->swap(*fout.rdbuf()); //swap the underlying buffers\n \n    getline(fin, s); // fails: cannot read from a write-only filebuf\n    std::cout << s << '\\n'; // prints empty line\n}"
        }
    },
    "basic_filebuf::is_open": {
        "description": {
            "texte": "Returns true if the most recent call to open() succeeded and there has been no call to close() since then."
        },
        "exemple": {
            "input": "#include <fstream>\n#include <iostream>\n \nint main()\n{\n    std::ifstream fs(\"test.txt\");\n    std::filebuf fb;\n    fb.open(\"test.txt\", std::ios_base::in);\n    std::cout << std::boolalpha\n              << \"direct call: \" << fb.is_open() << '\\n'\n              << \"through streambuf: \" << fs.rdbuf()->is_open() << '\\n'\n              << \"through fstream: \" << fs.is_open() << '\\n';\n}",
            "output": "direct call: true\nthrough streambuf: true\nthrough fstream: true"
        }
    },
    "basic_filebuf::open": {
        "description": {
            "texte": "Opens the file with the given name (s, p.c_str() (since C++17) or str.c_str(), depending on the overload).The file is opened as if by calling std::fopen with the second argument (mode) determined as follows:If openmode is not one of the modes listed, the open() fails.If the open operation succeeds and openmode & std::ios_base::ate != 0 (the ate bit is set), repositions the file position to the end of file, as if by calling std::fseek(file, 0, SEEK_END), where file is the pointer returned by calling fopen. If the repositioning fails, calls close() and returns a null pointer to indicate failure.If the associated file was already open, returns a null pointer right away."
        },
        "parametres": "   s, str, p   -   the file name to open; s must point to a null-terminated string \n   openmode   -   the file opening mode, a binary OR of the std::ios_base modes \n\n"
    },
    "basic_filebuf::close": {
        "description": {
            "texte": "If a put area exist (e.g. file was opened for writing), first calls overflow(Traits::eof()) to write all pending output to the file, including any unshift sequences.If the most recently called function, out of underflow(), overflow(), seekpos(), and seekoff(), was overflow(), then calls std::codecvt::unshift(), perhaps multiple times, to determine the unshift sequence according to the imbued locale, and writes that sequence to file with overflow(Traits::eof()).Then, closes the file as if by calling std::fclose(), regardless of whether any of the preceding calls succeeded or failed.If any of the function calls made, including the call to std::fclose(), fails, returns a null pointer. If any of the function calls made throws an exception, the exception is caught and rethrown after calling std::fclose(). If the file is already closed, returns a null pointer right away.In any case, updates the private member variable that is accessed by is_open()."
        }
    },
    "basic_filebuf::showmanyc": {
        "description": {
            "texte": "If implemented, returns the number of characters left to read from the file."
        },
        "exemple": {
            "input": "#include <fstream>\n#include <iostream>\n \nstruct mybuf : std::filebuf\n{\n     using std::filebuf::showmanyc;\n};\n \nint main()\n{\n    mybuf fin;\n    fin.open(\"main.cpp\", std::ios_base::in);\n    std::cout << \"showmanyc() returns \" << fin.showmanyc() << '\\n';\n}",
            "output": "showmanyc() returns 267"
        }
    },
    "basic_filebuf::underflow": {
        "description": {
            "texte": "Reads more data into the input area.Behaves like the base class std::basic_streambuf::underflow, except that to read the data from the associated character sequence (the file) into the get area, first reads the bytes from the file into a temporary buffer (allocated as large as necessary), then uses std::codecvt::in of the imbued locale to convert the external (typically, multibyte) representation to the internal form which is then used to populate the get area. The conversion may be skipped if the locale's std::codecvt::always_noconv returns true."
        },
        "exemple": {
            "input": "#include <fstream>\n#include <iostream>\n \nstruct mybuf : std::filebuf\n{\n    int underflow() {\n         std::cout << \"Before underflow(): size of the get area is \"\n                   << egptr()-eback() << \" with \"\n                   << egptr()-gptr() << \" read positions available\\n\";\n         int rc = std::filebuf::underflow();\n         std::cout << \"underflow() returns \" << rc << \".\\nAfter the call, \"\n                   << \"size of the get area is \"\n                   << egptr()-eback() << \" with \"\n                   << egptr()-gptr() << \" read positions available\\n\";\n        return rc;\n    }\n};\n \nint main()\n{\n    mybuf buf;\n    buf.open(\"test.txt\", std::ios_base::in);\n    std::istream stream(&buf);\n    while(stream.get()) ;\n}",
            "output": "Before underflow(): size of the get area is 0 with 0 read positions available\nunderflow() returns 73.\nAfter the call, size of the get area is 110 with 110 read positions available\nBefore underflow(): size of the get area is 110 with 0 read positions available\nunderflow() returns -1.\nAfter the call, size of the get area is 0 with 0 read positions available"
        }
    },
    "basic_filebuf::uflow": {
        "description": {
            "texte": "Behaves like the underflow(), except that if underflow() succeeds (does not return Traits::eof()), then advances the next pointer for the get area. In other words, consumes one of the characters obtained by underflow()."
        }
    },
    "basic_filebuf::pbackfail": {
        "description": {
            "texte": "This protected virtual function is called by the public functions basic_streambuf::sungetc and basic_streambuf::sputbackc (which, in turn, are called by basic_istream::unget and basic_istream::putback).This function never modifies the file, only the get area of the in-memory buffer.If the file is not open (is_open()==false, this function returns Traits::eof() immediately."
        },
        "parametres": "   c   -   the character to put back, or Traits::eof() to indicate that backing up of the get area is requested \n\n"
    },
    "basic_filebuf::overflow": {
        "description": {
            "texte": "Writes some data from the put area to the associated character sequence (to the file).Behaves like the base class std::basic_streambuf::overflow, except that to write the data, first uses std::codecvt::out of the imbued locale to convert the characters into external (possibly multibyte) representation, stored in a temporary buffer (allocated as large as necessary), then uses file I/O to copy all fully-converted bytes into the file.If std::codecvt::always_noconv is true, the call to std::codecvt::out may be skipped.If the conversion fails with std::codecvt_base::error, returns Traits::eof() without attempting any output.If the associated file is not open (is_open() == false), returns Traits::eof() before doing anything."
        }
    },
    "basic_filebuf::setbuf": {
        "description": {
            "texte": "If s is a null pointer and n is zero, the filebuf becomes unbuffered for output, meaning pbase() and pptr() are null and any output is immediately sent to file.Otherwise, a call to setbuf() replaces the internal buffer (the controlled character sequence) with the user-supplied character array whose first element is pointed to by s and allows this std::basic_filebuf object to use up to n bytes in that array for buffering.This function is protected virtual, it may only be called through pubsetbuf() or from member functions of a user-defined class derived from std::basic_filebuf."
        },
        "parametres": "   s   -   pointer to the first CharT in the user-provided buffer or null \n   n   -   the number of CharT elements in the user-provided buffer or zero \n\n",
        "exemple": {
            "input": "#include <fstream>\n#include <iostream>\n#include <string>\n \nint main()\n{\n        int cnt = 0;\n        std::ifstream file;\n        char buf[10241];\n \n        file.rdbuf()->pubsetbuf(buf, sizeof buf);\n        file.open(\"/usr/share/dict/words\");\n \n        for (std::string line; getline(file, line); )\n                ++cnt;\n        std::cout << cnt << '\\n';\n}"
        }
    },
    "basic_filebuf::seekoff": {
        "description": {
            "texte": "Repositions the file pointer, if possible, to the position that corresponds to exactly off characters from beginning, end, or current position of the file (depending on the value of dir.If the associated file is not open (is_open()==false, fails immediately.If the multibyte character encoding is state-dependent (codecvt::encoding() returned -1) or variable-length (codecvt::encoding() returned \u200b0\u200b) and the offset off is not \u200b0\u200b, fails immediately: this function cannot determine the number of bytes that correspond to off characters.If dir is not std::basic_ios::cur or the offset off is not \u200b0\u200b, and the most resent operation done on this filebuf object was output (that is, either the put buffer is not empty, or the most recently called function was overflow()), then calls std::codecvt::unshift to determine the unshift sequence necessary, and writes that sequence to the file by calling overflow().Then converts the argument dir to a value whence of type int as follows:Then, if the character encoding is fixed-width (codecvt::encoding() returns some positive number width, moves the file pointer as if by std::fseek(file, width*off, whence).Otherwise, moves the file pointer as if by std::fseek(file, 0, whence).The openmode argument, required by the base class function signature, is usually ignored, because std::basic_filebuf maintains only one file position."
        },
        "parametres": "   off   -   relative position to set the position indicator to. \n   dir   -   defines base position to apply the relative offset to. It can be one of the following constants:    Constant   Explanation \n   beg   the beginning of a stream \n   end   the ending of a stream \n   cur   the current position of stream position indicator \n  \n   which   -   defines which of the input and/or output sequences to affect. It can be one or a combination of the following constants:    Constant   Explanation \n   in   affect the input sequence \n   out   affect the output sequence \n  \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <locale>\nint main()\n{\n    // prepare a 10-byte file holding 4 characters in UTF8\n    std::ofstream(\"text.txt\") << u8\"z\\u00df\\u6c34\\U0001d10b\"; // or u8\"z\u00df\u6c34\ud834\udd0b\"\n                                           // or \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9d\\x84\\x8b\";\n \n    // open using a non-converting encoding\n    std::ifstream f1(\"text.txt\");\n    std::cout << \"f1's locale's encoding() returns \"\n              << std::use_facet<std::codecvt<char, char, std::mbstate_t>>(f1.getloc()).encoding() << '\\n'\n              << \"pubseekoff(3, beg) returns \" << f1.rdbuf()->pubseekoff(3, std::ios_base::beg) << '\\n'\n              << \"pubseekoff(0, end) returns \" << f1.rdbuf()->pubseekoff(0, std::ios_base::end) << '\\n';;\n \n    // open using UTF-8\n    std::wifstream f2(\"text.txt\");\n    f2.imbue(std::locale(\"en_US.UTF-8\"));\n    std::cout << \"f2's locale's encoding() returns \"\n              << std::use_facet<std::codecvt<wchar_t, char, std::mbstate_t>>(f2.getloc()).encoding() << '\\n'\n              << \"pubseekoff(3, beg) returns \" << f2.rdbuf()->pubseekoff(3, std::ios_base::beg) << '\\n'\n              << \"pubseekoff(0, end) returns \" << f2.rdbuf()->pubseekoff(0, std::ios_base::end) << '\\n';\n \n}",
            "output": "f1's locale's encoding() returns 1\npubseekoff(3, beg) returns 3\npubseekoff(0, end) returns 10\nf2's locale's encoding() returns 0\npubseekoff(3, beg) returns -1\npubseekoff(0, end) returns 10"
        }
    },
    "basic_filebuf::seekpos": {
        "description": {
            "texte": "Repositions the file pointer, if possible, to the position indicated by sp.If the associated file is not open (is_open()==false), fails immediately.If the file is open for writing, first writes the put area and any unshift sequences required by the currently imbued locale, using overflow().Then repositions the file pointer, as if by calling std::fsetpos().If the file is open for reading, updates the get area if necessary.If sp was not obtained by calling seekoff() or seekpos() on the same file, the behavior is undefined."
        },
        "parametres": "   sp   -   file position obtained by seekoff() or seekpos() called earlier on the same file \n   which   -   defines which of the input and/or output sequences to affect. It can be one or a combination of the following constants:    Constant   Explanation \n   in   affect the input sequence \n   out   affect the output sequence \n  \n\n",
        "exemple": {
            "input": "#include <fstream>\n#include <iostream>\n \nstruct mybuf : std::filebuf\n{\n    pos_type seekpos(pos_type sp, std::ios_base::openmode which) {\n         std::cout << \"Before seekpos(\" << sp << \"), size of the get area is \"\n                   << egptr()-eback() << \" with \"\n                   << egptr()-gptr() << \" read positions available\\n\";\n         pos_type rc = std::filebuf::seekpos(sp, which);\n         std::cout << \"seekpos() returns \" << rc << \".\\nAfter the call, \"\n                   << \"size of the get area is \"\n                   << egptr()-eback() << \" with \"\n                   << egptr()-gptr() << \" read positions available\\n\";\n// uncomment if get area is emptied by seekpos()\n//         std::filebuf::underflow();\n//         std::cout << \"after forced underflow(), size of the get area is \"\n//                   << egptr()-eback() << \" with \"\n//                   << egptr()-gptr() << \" read positions available\\n\";\n        return rc;\n    }\n};\n \nint main()\n{\n    mybuf buf;\n    buf.open(\"test.txt\", std::ios_base::in);\n    std::istream stream(&buf);\n    stream.get(); // read one char to force underflow()\n    stream.seekg(2);\n}",
            "output": "Before seekpos(2), size of the get area is 110 with 109 read positions available\nseekpos() returns 2.\nAfter the call, size of the get area is 110 with 108 read positions available"
        }
    },
    "basic_filebuf::sync": {
        "description": {
            "texte": "If a put area exists (e.g. the file was opened for writing), calls overflow() to write all pending output to the file, then flushes the file as if by calling std::fflush.If a get area exists (e.g. the file was opened for reading), the effect is implementation-defined. Typical implementation may empty out the get area and move the current file position back by the corresponding number of bytes."
        }
    },
    "basic_filebuf::imbue": {
        "description": {
            "texte": "Changes the associated locale so that all characters inserted or extracted after this call (and until another call to imbue()) are converted using the std::codecvt facet of loc.If the old locale's encoding is state-dependent and file is not positioned at the beginning, then the new locale must have the same std::codecvt facet as the one previously imbued."
        },
        "parametres": "   loc   -   the locale to imbue the stream with \n\n"
    },
    "basic_stringbuf::basic_stringbuf": {
        "description": {
            "texte": "Typically called by the constructor of std::basic_stringstream.The level of support for the open modes other than std::ios_base::in and std::ios_base::out varies among implementations. C++11 explicitly specifies the support for std::ios_base::ate in str() and in this constructor, but std::ios_base::app, std::ios_base::trunc, and std::ios_base::binary have different effects on different implementations."
        },
        "parametres": "   new_str   -   a basic_string used to initialize the buffer \n   rhs   -   another basic_stringbuf \n   which   -   specifies stream open mode. It is bitmask type, the following constants are defined:    Constant   Explanation \n   app   seek to the end of stream before each write \n   binary   open in binary mode \n   in   open for reading \n   out   open for writing \n   trunc   discard the contents of the stream when opening \n   ate   seek to the end of stream immediately after open \n  \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n \nint main()\n{\n    // default constructor (mode = in|out)\n    std::stringbuf buf1;\n    buf1.sputc('1');\n    std::cout << &buf1 << '\\n';\n \n    // string constructor in at-end mode (C++11)\n    std::stringbuf buf2(\"test\", std::ios_base::in\n                              | std::ios_base::out\n                              | std::ios_base::ate);\n    buf2.sputc('1');\n    std::cout << &buf2 << '\\n';\n \n    // append mode test (results differ among compilers)\n    std::stringbuf buf3(\"test\", std::ios_base::in\n                              | std::ios_base::out\n                              | std::ios_base::app);\n    buf3.sputc('1');\n    buf3.pubseekpos(1);\n    buf3.sputc('2');\n    std::cout << &buf3 << '\\n';\n}",
            "output": "1\ntest1\nest12 (Sun Studio) 2st1 (GCC)"
        }
    },
    "basic_stringbuf::operator=": {
        "description": {
            "texte": "*this."
        },
        "parametres": "   rhs   -   another basic_stringbuf that will be moved from \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <string>\n#include <iostream>\n \nint main()\n{\n \n    std::istringstream one(\"one\");\n    std::ostringstream two(\"two\");\n \n    std::cout << \"Before move, one = \\\"\" << one.str() << '\"'\n              << \" two = \\\"\" << two.str() << \"\\\"\\n\";\n \n    *one.rdbuf() = std::move(*two.rdbuf());\n \n    std::cout << \"After move, one = \\\"\" << one.str() << '\"'\n              << \" two = \\\"\" << two.str() << \"\\\"\\n\";\n}",
            "output": "Before move, one = \"one\" two = \"two\"\nAfter move, one = \"two\" two = \"\""
        }
    },
    "basic_stringbuf::swap": {
        "description": {
            "texte": "Swaps the state and the contents of *this and rhs."
        },
        "parametres": "   rhs   -   another basic_stringbuf \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <string>\n#include <iostream>\n \nint main()\n{\n \n    std::istringstream one(\"one\");\n    std::ostringstream two(\"two\");\n \n    std::cout << \"Before swap, one = \\\"\" << one.str() << '\"'\n              << \" two = \\\"\" << two.str() << \"\\\"\\n\";\n \n    *one.rdbuf()->swap(*two.rdbuf());\n \n    std::cout << \"Before swap, one = \\\"\" << one.str() << '\"'\n              << \" two = \\\"\" << two.str() << \"\\\"\\n\";\n}",
            "output": "Before swap, one = \"one\" two = \"two\"\nBefore swap, one = \"two\" two = \"one\""
        }
    },
    "basic_stringbuf::str": {
        "description": {
            "texte": "Gets and sets the underlying string."
        },
        "parametres": "   s   -   a string object holding the replacement character sequence \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <iostream>\nint main()\n{\n    int n;\n \n    std::istringstream in;  // could also use in(\"1 2\")\n    in.rdbuf()->str(\"1 2\"); // set the get area\n    in >> n;\n    std::cout << \"after reading the first int from \\\"1 2\\\", the int is \" \n              << n << \", str() = \\\"\" << in.rdbuf()->str() << \"\\\"\\n\"; // or in.str()\n \n    std::ostringstream out(\"1 2\");\n    out << 3;\n    std::cout << \"after writing the int '3' to output stream \\\"1 2\\\"\"\n              << \", str() = \\\"\" << out.str() << \"\\\"\\n\";\n \n    std::ostringstream ate(\"1 2\", std::ios_base::ate); // C++11\n    ate << 3;\n    std::cout << \"after writing the int '3' to append stream \\\"1 2\\\"\"\n              << \", str() = \\\"\" << ate.str() << \"\\\"\\n\";\n}",
            "output": "after reading the first int from \"1 2\", the int is 1, str() = \"1 2\"\nafter writing the int '3' to output stream \"1 2\", str() = \"3 2\"\nafter writing the int '3' to append stream \"1 2\", str() = \"1 23\""
        }
    },
    "basic_stringbuf::underflow": {
        "description": {
            "texte": "Reads the next character from the get area of the buffer.Specifically:Any character in the buffer which has been initialized, regardless of whether it originated from the string passed in the constructor or was appended by overflow(), is considered to be part of the input sequence."
        },
        "exemple": {
            "input": "#include <sstream>\n#include <iostream>\n \nstruct mybuf : std::stringbuf\n{\n    mybuf(const std::string& new_str,\n          std::ios_base::openmode which = std::ios_base::in|std::ios_base::out)\n           : std::stringbuf(new_str, which) {}\n \n    int_type overflow(int_type c) {\n        std::cout << \"Before overflow(): get area size is \" << egptr()-eback() << ' '\n                  << \" the put area size is \" << epptr()-pbase() << '\\n';\n        int_type rc = std::stringbuf::overflow(c);\n        std::cout << \"After overflow(): get area size is \" << egptr()-eback() << ' '\n                  << \" put area size is \" << epptr()-pbase() << '\\n';\n        return rc;\n    }\n \n    int_type underflow() {\n        std::cout << \"Before underflow(): get area size is \" << egptr()-eback() << ' '\n                  << \" put area size is \" << epptr()-pbase() << '\\n';\n        int_type ch = std::stringbuf::underflow();\n        std::cout << \"After underflow(): get area size is \" << egptr()-eback() << ' '\n                  << \" put area size is \" << epptr()-pbase() << '\\n';\n        if(ch == EOF)\n            std::cout << \"underflow() returns EOF\\n\";\n        else\n            std::cout << \"underflow() returns '\" << char(ch) << \"'\\n\";\n        return ch;\n    }\n};\n \nint main()\n{\n    mybuf sbuf(\"123\"); // read-write stream\n    std::iostream stream(&sbuf);\n    int n;\n    stream >> n; // calls sgetc() four times\n                 // three calls return the characters '1', '2', '3'\n                 // the fourth call, gptr() == egptr() and underflow() is called\n                 // underflow returns EOF\n    std::cout << n << '\\n';\n    stream.clear(); // clear the eofbit\n \n    stream << \"123456\"; // sputc() is called 6 times\n                        // first three calls store \"123\" in the existing buffer\n                        // 4th call finds that pptr() == epptr() and calls overflow()\n                        // overflow() grows the buffer and sets egptr() to 4\n                        // 5th and 6th calls store '5' and '6', advancing pptr()\n    stream >> n; // calls sgetc() 4 times\n                 // 1st call returns the '4' that was made available by overflow()\n                 // on the 2nd call, egptr() == egptr() and underflow() is called\n                 // underflow advances egptr() to equal pptr() (which is 6)\n                 // 3rd sgetc() returns '6'\n                 // 4th sgetc() finds gptr() == egptr(), calls underflow()\n                 // underflow() returns EOF\n    std::cout << n << '\\n';\n}",
            "output": "Before underflow(): get area size is 3  put area size is 3\nAfter underflow(): get area size is 3  put area size is 3\nunderflow() returns EOF\n123\nBefore overflow(): get area size is 3  the put area size is 3\nAfter overflow(): get area size is 4  put area size is 35\nBefore underflow(): get area size is 4  put area size is 35\nAfter underflow(): get area size is 6  put area size is 35\nunderflow() returns '5'\nBefore underflow(): get area size is 6  put area size is 35\nAfter underflow(): get area size is 6  put area size is 35\nunderflow() returns EOF\n456"
        }
    },
    "basic_stringbuf::pbackfail": {
        "description": {
            "texte": "This protected virtual function is called by the public functions basic_streambuf::sungetc and basic_streambuf::sputbackc (which, in turn, are called by basic_istream::unget and basic_istream::putback)."
        },
        "parametres": "   c   -   the character to put back, or Traits::eof() to indicate that backing up of the get area is requested \n\n"
    },
    "basic_stringbuf::overflow": {
        "description": {
            "texte": "Appends the character c to the output character sequence.If c is the end-of-file indicator (traits::eq_int_type(c,traits::eof()) == true), then there is no character to append. The function does nothing and returns an unspecified value other than traits::eof().Otherwise, if the output sequence has a write position available or this function can successfully make a write position available, then calls sputc(c) and returns c.This function can make a write position available if the stringbuf is open for output (mode & ios_base::out) != 0): in this case, it reallocates (or initially allocates) the buffer big enough to hold the entire current buffer plus at least one more character. If the stringbuf is also open for input ((mode & ios_base::in) != 0), then overflow also increases the size of the get area by moving egptr() to point just past the new write position."
        },
        "parametres": "   c   -   the character to store in the put area \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <iostream>\n \nstruct mybuf : std::stringbuf\n{\n    mybuf(const std::string& new_str,\n          std::ios_base::openmode which = std::ios_base::in|std::ios_base::out)\n           : std::stringbuf(new_str, which) {}\n    int_type overflow(int_type c = EOF) override\n    {\n        std::cout << \"stringbuf::overflow('\" << char(c) << \"') called\\n\"\n                  << \"Before: size of get area: \" << egptr() - eback() << '\\n'\n                  << \"        size of put area: \" << epptr() - pbase() << '\\n';\n        int_type ret = std::stringbuf::overflow(c);\n        std::cout << \"After : size of get area: \" << egptr() - eback() << '\\n'\n                  << \"        size of put area: \" << epptr() - pbase() << '\\n';\n        return ret;\n    }\n};\n \nint main()\n{\n    std::cout << \"read-write stream:\\n\";\n    mybuf sbuf(\"   \"); // read-write stream\n    std::iostream stream(&sbuf);\n    stream << 1234;\n    std::cout << sbuf.str() << '\\n';\n \n    std::cout << \"\\nread-only stream:\\n\";\n    mybuf ro_buf(\"   \", std::ios_base::in); // read-only stream\n    std::iostream ro_stream(&ro_buf);\n    ro_stream << 1234;\n \n    std::cout << \"\\nwrite-only stream:\\n\";\n    mybuf wr_buf(\"   \", std::ios_base::out); // write-only stream\n    std::iostream wr_stream(&wr_buf);\n    wr_stream << 1234;\n}",
            "output": "read-write stream:\nstringbuf::overflow('4') called\nBefore: size of get area: 3\n        size of put area: 3\nAfter : size of get area: 4\n        size of put area: 512\n1234\n \nread-only stream:\nstringbuf::overflow('1') called\nBefore: size of get area: 3\n        size of put area: 0\nAfter : size of get area: 3\n        size of put area: 0\n \nwrite-only stream:\nstringbuf::overflow('4') called\nBefore: size of get area: 0\n        size of put area: 3\nAfter : size of get area: 0\n        size of put area: 512"
        }
    },
    "basic_stringbuf::setbuf": {
        "description": {
            "texte": "If s is a null pointer and n is zero, this function has no effect.Otherwise, the effect is implementation-defined: some implementations do nothing, while some implementations clear the std::string member currently used as the buffer and begin using the user-supplied character array of size n, whose first element is pointed to by s, as the buffer and the input/output character sequence.This function is protected virtual, it may only be called through pubsetbuf() or from member functions of a user-defined class derived from std::basic_stringbuf."
        },
        "parametres": "   s   -   pointer to the first CharT in the user-provided buffer or null \n   n   -   the number of CharT elements in the user-provided buffer or zero \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::ostringstream ss;\n    char c[1024] = {};\n    ss.rdbuf()->pubsetbuf(c, 1024);\n    ss << 3.14 << '\\n';\n    std::cout << c << '\\n';\n}",
            "output": "3.14 (on GNU g++/libstdc++ and SunPro C++/roguewave)\n<nothing> (on MS Visual Studio 2010, SunPro C++/stlport4, CLang++/libc++)"
        }
    },
    "basic_stringbuf::seekoff": {
        "description": {
            "texte": "Repositions std::basic_streambuf::gptr and/or std::basic_streambuf::pptr, if possible, to the position that corresponds to exactly off characters from beginning, end, or current position of the get and/or put area of the buffer.If the pointer (either gptr or pptr or both) is repositioned, it is done as follows:"
        },
        "parametres": "   off   -   relative position to set the next pointer(s) to \n   dir   -   defines base position to apply the relative offset to. It can be one of the following constants:    Constant   Explanation \n   beg   the beginning of a stream \n   end   the ending of a stream \n   cur   the current position of stream position indicator \n  \n   which   -   defines whether the input sequences, the output sequence, or both are affected. It can be one or a combination of the following constants:    Constant   Explanation \n   in   affect the input sequence \n   out   affect the output sequence \n  \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n \nint main()\n{\n    std::stringstream ss(\"123\"); // in/out\n    std::cout << \"put pos = \" << ss.tellp()\n              << \" get pos = \" << ss.tellg() << '\\n';\n \n    // absolute positioning both pointers\n    ss.rdbuf()->pubseekoff(1, std::ios_base::beg); // move both 1 forward\n    std::cout << \"put pos = \" << ss.tellp()\n              << \" get pos = \" << ss.tellg() << '\\n';\n \n    // try to move both pointers 1 forward from current position\n    if(-1 == ss.rdbuf()->pubseekoff(1, std::ios_base::cur))\n        std::cout << \"moving both pointers from current position failed\\n\";\n    std::cout << \"put pos = \" << ss.tellp()\n              << \" get pos = \" << ss.tellg() << '\\n';\n \n    // move the write pointer 1 forward, but not the read pointer\n    // can also be called as ss.seekp(1, std::ios_base::cur);\n    ss.rdbuf()->pubseekoff(1, std::ios_base::cur, std::ios_base::out);\n    std::cout << \"put pos = \" << ss.tellp()\n              << \" get pos = \" << ss.tellg() << '\\n';\n \n    ss << 'a'; // write at put position\n    std::cout << \"Wrote 'a' at put position, the buffer is now \" << ss.str() << '\\n';\n    char ch;\n    ss >> ch;\n    std::cout << \"reading at get position gives '\" << ch << \"'\\n\";\n}",
            "output": "put pos = 0 get pos = 0\nput pos = 1 get pos = 1\nmoving both pointers from current position failed\nput pos = 1 get pos = 1\nput pos = 2 get pos = 1\nWrote 'a' at put position, the buffer is now 12a\nreading at get position gives '2'"
        }
    },
    "basic_stringbuf::seekpos": {
        "description": {
            "texte": "Repositions std::basic_streambuf::gptr and/or std::basic_streambuf::pptr, if possible, to the position indicated by sp.Effectively executes seekoff(off_type(sp), std::ios_base::beg, which)."
        },
        "parametres": "   sp   -   stream position, such as one obtained by seekoff() or seekpos() \n   which   -   defines whether the input sequences, the output sequence, or both are affected. It can be one or a combination of the following constants:    Constant   Explanation \n   in   affect the input sequence \n   out   affect the output sequence \n  \n\n",
        "exemple": {
            "input": "#include <sstream>\n#include <iostream>\n \nstruct mybuf : std::stringbuf\n{\n    mybuf(const std::string& str) : std::stringbuf(str) {}\n    pos_type seekpos(pos_type sp, std::ios_base::openmode which) {\n         std::cout << \"Before seekpos(\" << sp << \"), size of the get area is \"\n                   << egptr()-eback() << \" with \"\n                   << egptr()-gptr() << \" read positions available\\n\";\n         pos_type rc = std::stringbuf::seekpos(sp, which);\n         std::cout << \"seekpos() returns \" << rc << \".\\nAfter the call, \"\n                   << \"size of the get area is \"\n                   << egptr()-eback() << \" with \"\n                   << egptr()-gptr() << \" read positions available\\n\";\n        return rc;\n    }\n};\n \nint main()\n{\n    mybuf buf(\"12345\");\n    std::iostream stream(&buf);\n    stream.seekg(2);\n}",
            "output": "Before seekpos(2), size of the get area is 5 with 5 read positions available\nseekpos() returns 2.\nAfter the call, size of the get area is 5 with 3 read positions available"
        }
    },
    "strstreambuf::strstreambuf": {
        "description": {
            "texte": "These constructors are typically called by the constructors of std::strstream."
        },
        "parametres": "   alsize   -   the initial size of the dynamically allocated buffer \n   palloc   -   pointer to user-provided allocation function \n   pfree   -   pointer to user-provided deallocation function \n   gnext   -   pointer to the start of the get area in the user-provided array \n   pbeg   -   pointer to the start of the put area in the user-provided array \n   n   -   the number of bytes in the get area (if pbeg is null) or in the put area (if pbeg is not null) of the user-provided array \n\n",
        "exemple": {
            "input": "#include <strstream>\n#include <iostream>\n \nint main()\n{\n    std::strstreambuf dyn; // dynamic\n    std::strstream dyn_s; // equivalent stream\n    dyn_s << 1.23 << std::ends;\n    std::cout << dyn_s.str() << '\\n';\n    dyn_s.freeze(false);\n \n    char buf[10];\n    std::strstreambuf user(buf, 10, buf); // user-provided output buffer\n    std::ostrstream user_s(buf, 10); // equivalent stream\n    user_s << 1.23 << std::ends;\n    std::cout << buf << '\\n';\n \n    std::strstreambuf lit(\"1 2 3\", 5); // constant\n    std::istrstream lit_s(\"1 2 3\"); // equivalent stream\n    int i, j, k;\n    lit_s >> i >> j >> k;\n    std::cout << i << ' ' << j << ' ' << k << '\\n';\n}",
            "output": "1.23\n1.23\n1 2 3"
        }
    },
    "strstreambuf::~strstreambuf": {
        "description": {
            "texte": "Destroys a std::strstreambuf object. if the object is managing a dynamically-allocated buffer (the buffer state is \"allocated\") and if the object is not frozen, then deallocates the buffer using the deallocation function provided at construction or delete[] if none was provided."
        },
        "exemple": {
            "input": "#include <strstream>\n#include <iostream>\n \nvoid* my_alloc(size_t n)\n{\n    std::cout << \"my_alloc(\" << n << \") called\\n\";\n    return new char[n];\n}\n \nvoid my_free(void* p)\n{\n    std::cout << \"my_free() called\\n\";\n    delete[] (char*)p;\n}\n \nint main()\n{\n    {\n        std::strstreambuf buf(my_alloc, my_free);\n        std::ostream s(&buf);\n        s << 1.23 << std::ends;\n        std::cout << buf.str() << '\\n';\n        buf.freeze(false);\n    } // destructor called here, buffer deallocated\n \n    {\n        std::strstreambuf buf(my_alloc, my_free);\n        std::ostream s(&buf);\n        s << 1.23 << std::ends;\n        std::cout << buf.str() << '\\n';\n//        buf.freeze(false);\n    } // destructor called here, memory leak!\n}",
            "output": "my_alloc(4096) called\n1.23\nmy_free() called\nmy_alloc(4096) called\n1.23"
        }
    },
    "strstreambuf::freeze": {
        "description": {
            "texte": "If the buffer uses dynamic allocation, sets the frozen status of the stream to freezefl.While the stream is frozen, overflow() will not reallocate the buffer and the destructor will not deallocate the buffer (thereby causing a memory leak)."
        },
        "parametres": "   freezefl   -   new value to set the freeze status to \n\n",
        "exemple": {
            "input": "#include <strstream>\n#include <iostream>\n \nint main()\n{\n    {\n        std::strstream dyn; // dynamically-allocated read/write buffer\n        dyn << \"Test: \" << 1.23; // note: no std::ends to demonstrate append behavior\n        std::cout << \"dynamic buffer holds \" << dyn.pcount() << \" characters: '\";\n        std::cout.write(dyn.str(), dyn.pcount()) << \"'\\n\";\n        // the buffer is now frozen, further output will not make the buffer grow\n        dyn << \"more output, hopefully enough to run out of the allocated space\" << std::ends;\n        std::cout << \"After more output, it holds \"\n                  << dyn.pcount() << \" characters: '\" << dyn.str() << \"'\\n\";\n        dyn.freeze(false); // unfreeze before destructor\n    } // memory freed by the destructor\n \n    {\n        char arr[20];\n        std::ostrstream st(arr, sizeof arr); // fixed-size buffer\n        st << 1.23; // note: no std::ends to demonstrate append behavior\n        std::cout << \"static buffer holds \"\n                  << st.pcount() << \" characters: '\";\n        std::cout.write(st.str(), st.pcount());\n        std::cout << \"'\\n\";\n        st << \"more output, hopefully enough to run out of the allocated space\" << std::ends;\n        std::cout << \"static buffer holds \"\n                  << st.pcount() << \" characters: '\";\n        std::cout.write(st.str(), st.pcount());\n        std::cout << \"'\\n\";\n    } // nothing to deallocate, no need to unfreeze,\n}",
            "output": "dynamic buffer holds 10 characters: 'Test: 1.23'\nAfter more output, it holds 16 characters: 'Test: 1.23more o'\nstatic buffer holds 4 characters: '1.23'\nstatic buffer holds 20 characters: '1.23more output, hop'"
        }
    },
    "strstreambuf::str": {
        "description": {
            "texte": "Calls freeze(), then returns a copy of start pointer of the get area, std::streambuf::eback().The start of the get area, for all writeable std::strstreambuf objects constructed through the interface provided by std::strstream, is also the start of the put area."
        },
        "exemple": {
            "input": "#include <strstream>\n#include <iostream>\n \nint main()\n{\n    std::strstream dyn; // dynamically-allocated read/write buffer\n    dyn << \"Test: \" << 1.23 << std::ends;\n    std::strstreambuf* buf = dyn.rdbuf();\n    std::cout << \"R/W buffer holds \\\"\" << buf->str() // or dyn.str()\n              << \"\\\"\\n\";\n    dyn.freeze(false); // after calling .str() on a dynamic strstream\n \n    char arr[10];\n    std::ostrstream user(arr, 10); // fixed-size write-only buffer\n    buf = user.rdbuf();\n    user << 1.23 << std::ends;\n    std::cout << \"Write-only buffer holds \\\"\" << buf->str() // or user.str()\n              << \"\\\"\\n\";\n \n    std::istrstream lit(\"1 2 3\"); // fixed-size read-only buffer\n    buf = lit.rdbuf();\n    std::cout << \"Read-only buffer holds \\\"\" << buf->str() // or lit.str()\n              << \"\\\"\\n\";\n}",
            "output": "R/W buffer holds \"Test: 1.23\"\nWrite-only buffer holds \"1.23\"\nRead-only buffer holds \"1 2 31 2 3\""
        }
    },
    "strstreambuf::pcount": {
        "description": {
            "texte": " Returns the number of characters written to the output sequence.If the next pointer for the put area (std::streambuf::pptr()) is a null pointer, returns zero.Otherwise, returns the next pointer in the put area minus the beginning pointer in the put area, that is pptr() - pbase()."
        },
        "exemple": {
            "input": "#include <strstream>\n#include <iostream>\n \nint main()\n{\n    std::strstream dyn; // dynamically-allocated output buffer\n    dyn << \"Test: \" << 1.23 << std::ends;\n    std::strstreambuf* buf = dyn.rdbuf();\n    std::cout << \"The size of the output is \"\n              << buf->pcount() // or just buf.pcount()\n              << \" and it holds \\\"\" << dyn.str() << \"\\\"\\n\";\n    dyn.freeze(false); // after calling .str() on a dynamic strstream\n \n    char arr[10];\n    std::ostrstream user(arr, 10); // user-provided output buffer\n    buf = user.rdbuf();\n    user << 1.23; // note: no std::ends\n    std::cout.write(arr, buf->pcount()); // or just user.pcount()\n    std::cout << '\\n';\n \n    std::istrstream lit(\"1 2 3\"); // read-only fixed-size buffer\n    buf = lit.rdbuf();\n    // istrstream has no member pcount(), so lit.pcount() won't work\n    std::cout << \"Input-only pcount() = \" << buf->pcount() << '\\n';\n}",
            "output": "The size of the output is 11 and it holds \"Test: 1.23\"\n1.23\nInput-only pcount() = 0"
        }
    },
    "strstreambuf::underflow": {
        "description": {
            "texte": "Reads the next character from the get area of the buffer.If the input sequence has a read position available (gptr() < egptr(), returns (unsigned char)(*gptr()).Otherwise, if pptr() is not null and pptr() > egptr() (there is a put area and it is located after the get area), extends the end of the get area to include the characters that were recently written into the put area by incrementing egptr() to some value between gptr() and pptr(), and then returns (unsigned char)(*gptr()).Otherwise, returns EOF to indicate failure."
        },
        "exemple": {
            "input": "#include <strstream>\n#include <iostream>\n \nstruct mybuf : std::strstreambuf\n{\n    int_type overflow(int_type c) \n    {\n        std::cout << \"Before overflow(): size of the get area is \" << egptr()-eback()\n                  << \" size of the put area is \" << epptr()-pbase() << '\\n';\n        int_type rc = std::strstreambuf::overflow(c);\n        std::cout << \"After overflow(): size of the get area is \" << egptr()-eback()\n                  << \" size of the put area is \" << epptr()-pbase() << '\\n';\n        return rc;\n    }\n \n    int_type underflow() \n    {\n        std::cout << \"Before underflow(): size of the get area is \" << egptr()-eback()\n                  << \" size of the put area is \" << epptr()-pbase() << '\\n';\n        int_type ch = std::strstreambuf::underflow();\n        std::cout << \"After underflow(): size of the get area is \" << egptr()-eback()\n                  << \" size of the put area is \" << epptr()-pbase() << '\\n';\n        if (ch == EOF) {\n            std::cout << \"underflow() returns EOF\\n\";\n        } else {\n            std::cout << \"underflow() returns '\" << char(ch) << \"'\\n\";\n        }\n        return ch;\n    }\n};\n \nint main()\n{\n    mybuf sbuf; // read-write dynamic strstreambuf\n    std::iostream stream(&sbuf);\n \n    int n;\n    stream >> n;\n    stream.clear();\n    stream << \"123\";\n    stream >> n;\n    std::cout << n << '\\n';\n}",
            "output": "Before underflow(): size of the get area is 0 size of the put area is 0\nAfter underflow(): size of the get area is 0 size of the put area is 0\nunderflow() returns EOF\nBefore overflow(): size of the get area is 0 size of the put area is 0\nAfter overflow(): size of the get area is 0 size of the put area is 32\nBefore underflow(): size of the get area is 0 size of the put area is 32\nAfter underflow(): size of the get area is 3 size of the put area is 32\nunderflow() returns '1'\nBefore underflow(): size of the get area is 3 size of the put area is 32\nAfter underflow(): size of the get area is 3 size of the put area is 32\nunderflow() returns EOF\n123"
        }
    },
    "strstreambuf::pbackfail": {
        "description": {
            "texte": "This protected virtual function is called by the public functions basic_streambuf::sungetc and basic_streambuf::sputbackc (which, in turn, are called by basic_istream::unget and basic_istream::putback)."
        },
        "parametres": "   c   -   the character to put back, or Traits::eof() to indicate that backing up of the get area is requested \n\n"
    },
    "strstreambuf::overflow": {
        "description": {
            "texte": "Appends the character c to the put area of the buffer, reallocating if possible."
        },
        "parametres": "   c   -   the character to store in the put area \n\n",
        "exemple": {
            "input": "#include <strstream>\n#include <iostream>\n \nstruct mybuf : std::strstreambuf\n{\n    int_type overflow(int_type c) \n    {\n        std::cout << \"Before overflow(): size of the put area is \" << epptr()-pbase()\n                  << \" with \" << epptr()-pptr() << \" write positions available\\n\";\n        int_type rc = std::strstreambuf::overflow(c);\n        std::cout << \"After overflow(): size of the put area is \" << epptr()-pbase()\n                  << \" with \" << epptr()-pptr() << \" write positions available\\n\";\n        return rc;\n    }\n};\n \nint main()\n{\n    mybuf sbuf; // read-write dynamic strstreambuf\n    std::iostream stream(&sbuf);\n \n    stream << \"Sufficiently long string to overflow the initial allocation, at least \"\n           << \" on some systems.\";\n}",
            "output": "Before overflow(): size of the put area is 16 with 0 write positions available\nAfter overflow(): size of the put area is 32 with 15 write positions available\nBefore overflow(): size of the put area is 32 with 0 write positions available\nAfter overflow(): size of the put area is 64 with 31 write positions available\nBefore overflow(): size of the put area is 64 with 0 write positions available\nAfter overflow(): size of the put area is 128 with 63 write positions available"
        }
    },
    "strstreambuf::setbuf": {
        "description": {
            "texte": "If s is a null pointer and n is zero, this function has no effect.Otherwise, the effect is implementation-defined: some implementations do nothing, while some implementations deallocate the dynamic member array used as the buffer and begin using the user-supplied character array of size n, whose first element is pointed to by s.This function is protected virtual, it may only be called through pubsetbuf() or from member functions of a user-defined class derived from std::strstreambuf."
        },
        "parametres": "   s   -   pointer to the first byte in the user-provided buffer \n   n   -   the number of bytes in the user-provided buffer \n\n",
        "exemple": {
            "input": "#include <strstream>\n#include <iostream>\n \nint main()\n{\n    char a[100] = {};\n    std::strstream str;\n    str.rdbuf()->pubsetbuf(a, sizeof a);\n    str << \"Test string\" << std::ends;\n    std::cout << \"user-provided buffer holds '\" << a << \"'\\n\";\n}",
            "output": "user-provided buffer holds 'Test string'"
        }
    },
    "strstreambuf::seekoff": {
        "description": {
            "texte": "Repositions std::basic_streambuf::gptr and/or std::basic_streambuf::pptr, if possible, to the position that corresponds to exactly off characters from beginning, end, or current position of the get and/or put area of the buffer.If the pointer (either gptr or pptr or both) is repositioned, it is done as follows:"
        },
        "parametres": "   off   -   relative position to set the next pointer(s) to \n   way   -   defines base position to apply the relative offset to. It can be one of the following constants:    Constant   Explanation \n   beg   the beginning of a stream \n   end   the ending of a stream \n   cur   the current position of stream position indicator \n  \n   which   -   defines whether the input sequences, the output sequence, or both are affected. It can be one or a combination of the following constants:    Constant   Explanation \n   in   affect the input sequence \n   out   affect the output sequence \n  \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <strstream>\n \nint main()\n{\n    char a[] = \"123\";\n    std::strstream ss(a, sizeof a); // in/out\n    std::cout << \"put pos = \" << ss.tellp()\n              << \" get pos = \" << ss.tellg() << '\\n';\n \n    // absolute positioning both pointers\n    ss.rdbuf()->pubseekoff(1, std::ios_base::beg); // move both forward\n    std::cout << \"put pos = \" << ss.tellp()\n              << \" get pos = \" << ss.tellg() << '\\n';\n \n    // try to move both pointers 1 forward from current position\n    if(-1 == ss.rdbuf()->pubseekoff(1, std::ios_base::cur))\n        std::cout << \"moving both pointers from current position failed\\n\";\n    std::cout << \"put pos = \" << ss.tellp()\n              << \" get pos = \" << ss.tellg() << '\\n';\n \n    // move the write pointer 1 forward, but not the read pointer\n    // can also be called as ss.seekp(1, std::ios_base::cur);\n    ss.rdbuf()->pubseekoff(1, std::ios_base::cur, std::ios_base::out);\n    std::cout << \"put pos = \" << ss.tellp()\n              << \" get pos = \" << ss.tellg() << '\\n';\n \n    ss << 'a'; // write at put position\n    std::cout << \"Wrote 'a' at put position, the buffer is now: '\";\n    std::cout.write(a, sizeof a);\n    std::cout << \"'\\n\";\n    char ch;\n    ss >> ch;\n    std::cout << \"reading at get position gives '\" << ch << \"'\\n\";\n}",
            "output": "put pos = 0 get pos = 0\nput pos = 1 get pos = 1\nmoving both pointers from current position failed\nput pos = 1 get pos = 1\nput pos = 2 get pos = 1\nWrote 'a' at put position, the buffer is now: '12a'\nreading at get position gives '2'"
        }
    },
    "strstreambuf::seekpos": {
        "description": {
            "texte": "Repositions std::basic_streambuf::gptr and/or std::basic_streambuf::pptr, if possible, to the position indicated by sp.If std::ios_base::in is set in which, attempts to reposition gptr() (the next pointer in the get area). If std::ios_base::out is set in which, attempts to reposition pptr() (the next pointer in the put area). If neither bit is set in which, the operation fails.Each next pointer is repositioned as follows:"
        },
        "parametres": "   sp   -   stream position, such as one obtained by seekoff() or seekpos() \n   which   -   defines whether the input sequences, the output sequence, or both are affected. It can be one or a combination of the following constants:    Constant   Explanation \n   in   affect the input sequence \n   out   affect the output sequence \n  \n\n",
        "exemple": {
            "input": "#include <strstream>\n#include <cstring>\n#include <iostream>\n \nstruct mybuf : std::strstreambuf\n{\n    mybuf(const char* str) : std::strstreambuf(str, std::strlen(str)) {}\n    pos_type seekpos(pos_type sp, std::ios_base::openmode which) {\n         std::cout << \"Before seekpos(\" << sp << \"), size of the get area is \"\n                   << egptr()-eback() << \" with \"\n                   << egptr()-gptr() << \" read positions available\\n\";\n         pos_type rc = std::strstreambuf::seekpos(sp, which);\n         std::cout << \"seekpos() returns \" << rc << \".\\nAfter the call, \"\n                   << \"size of the get area is \"\n                   << egptr()-eback() << \" with \"\n                   << egptr()-gptr() << \" read positions available\\n\";\n        return rc;\n    }\n};\n \nint main()\n{\n    mybuf buf(\"12345\");\n    std::iostream stream(&buf);\n    stream.seekg(2);\n}",
            "output": "Before seekpos(2), size of the get area is 5 with 5 read positions available\nseekpos() returns 2.\nAfter the call, size of the get area is 5 with 3 read positions available"
        }
    },
    "basic_syncbuf::basic_syncbuf": {
        "description": {
            "texte": "Typically called by the appropriate constructors of std::basic_osyncstream."
        },
        "parametres": "   obuf   -   pointer to the std::basic_streambuf to wrap \n   a   -   the allocator to use for temporary storage \n   rhs   -   another std::basic_syncbuf to move from \n\n"
    },
    "basic_syncbuf::operator=": {
        "description": {
            "texte": "First, calls emit() to transmit all pending output (and delayed flush, if any) to the wrapped stream.Then performs move-assignment by moving all contents from other, including the temporary storage, the wrapped stream pointer, policy, and all other state (such as the mutex pointer). After move, other is not associated with a stream, and other.get_wrapped()==nullptr. The put area member pointers of the base class std::basic_streambuf of other are guaranteed to be null. Destroying a moved-from other will not produce any output.If std::allocator_traits<Allocator>::propagate_on_container_move_assignment::value is false, then the allocator is unchanged. Otherwise, after move-assignment, get_allocator() equals other.get_allocator()."
        },
        "parametres": "   other   -   another std::basic_syncbuf to move from \n\n"
    },
    "basic_syncbuf::~basic_syncbuf": {
        "description": {
            "texte": "Calls emit() to transmit all pending output (and delayed flush, if any) to the wrapped stream. If an exception is thrown by this call, it is caught and ignored."
        }
    },
    "basic_syncbuf::swap": {
        "description": {
            "texte": "Exchanges the contents of the sync stream buffer with those of other."
        },
        "parametres": "   other   -   sync stream buffer to exchange contents with \n\n"
    },
    "basic_syncbuf::emit": {
        "description": {
            "texte": "Atomically transmits all pending output to the wrapped stream.All emit() calls transferring characters to the same wrapped stream buffer object appear to execute in a total order, where each emit() call synchronizes-with subsequent emit() calls in that total order, even if these calls are made through difference instances of std::basic_syncbuf/std::basic_osyncstream. In practice, this means that emit() takes a lock uniquely associated with the wrapped stream object: for example, it could be held in a static hash map where the address of the wrapped stream is used as the key.If a call had been made to sync since the last call to emit(), then also flushes the wrapped stream by calling pubsync() on it."
        }
    },
    "basic_syncbuf::get_wrapped": {
        "description": {
            "texte": "Returns a pointer to the wrapped std::basic_streambuf."
        }
    },
    "basic_syncbuf::get_allocator": {
        "description": {
            "texte": "Returns a copy of the allocator that was passed in as the constructor argument or replaced through the assignment operator."
        }
    },
    "basic_syncbuf::set_emit_on_sync": {
        "description": {
            "texte": "Changes the current emit-on-sync policy.The value false (the default) indicates that any flush will be postponed until a call to emit.The value true makes flushes apply immediately."
        },
        "parametres": "   b   -   new value for the emit-on-sync policy \n\n"
    },
    "basic_syncbuf::sync": {
        "description": {
            "texte": "First, records that a flush is pending, by updating the appropriate private flag.Then, if the current emit-on-sync policy is true, makes a call to emit().Otherwise (if the emit-on-sync policy is false, which is the default), the flush is suspended until emit() is called, such as through std::basic_osyncstream::emit() or std::basic_osyncstream::~basic_osyncstream."
        }
    },
    "basic_osyncstream::basic_osyncstream": {
        "description": {
            "texte": "Constructs new synchronized output stream."
        },
        "parametres": "   buf   -   pointer to the std::basic_streambuf that will be wrapped \n   os   -   reference to a std::basic_ostream, whose rdbuf() will be wrapped \n   a   -   the allocator to pass to the constructor of the member std::basic_syncbuf \n   other   -   another osyncstream to move from \n\n"
    },
    "basic_osyncstream::operator=": {
        "description": {
            "texte": "Move-assigns a synchronized output stream:First, calls emit(). If an exception is thrown by the call to emit(), it is caught and ignored.Then, move-assigns the wrapped std::basic_syncbuf from the corresponding member of other (after this move-assignment, other.get_wrapped() returns a null pointer and destruction of other produces no output) and move-assigns the base std::basic_ostream (this swaps all stream state variables except for rdbuf between *this and other)."
        },
        "parametres": "   other   -   another osyncstream to move from \n\n"
    },
    "basic_osyncstream::~basic_osyncstream": {
        "description": {
            "texte": "Destroys a synchronized output stream.First, calls emit(). If an exception is thrown by the call to emit(), it is caught and ignored. Then, destroys the member std::basic_syncbuf and the base std::basic_ostream as usual."
        }
    },
    "basic_osyncstream::rdbuf": {
        "description": {
            "texte": "Returns a pointer to the underlying std::basic_syncbuf."
        }
    },
    "basic_osyncstream::get_wrapped": {
        "description": {
            "texte": "Returns a pointer to the wrapped std::basic_streambuf, obtained by calling get_wrapped() on the underlying std::basic_syncbuf."
        },
        "exemple": {
            "input": "#include <syncstream>\n#include <iostream>\nint main()\n{\n  std::osyncstream bout1(std::cout);\n  bout1 << \"Hello, \";\n  {\n    std::osyncstream(bout1.get_wrapped()) << \"Goodbye, \" << \"Planet!\" << '\\n';\n  } // emits the contents of the temporary buffer\n  bout1 << \"World!\" << '\\n';\n} // emits the contents of bout1",
            "output": "Goodbye, Planet!\nHello, World!"
        }
    },
    "basic_osyncstream::emit": {
        "description": {
            "texte": "Emits all buffered output and executes any pending flushes, by calling emit() on the underlying std::basic_syncbuf."
        },
        "exemple": {
            "input": "#include <syncstream>\n#include <iostream>\nint main()\n{\n  {\n    std::osyncstream bout(std::cout);\n    std::bout << \"Hello,\" << '\\n'; // no flush\n    std::bout.emit(); // characters transferred; cout not flushed\n    std::bout << \"World!\" << std::endl; // flush noted; cout not flushed\n    std::bout.emit(); // characters transferred; cout flushed\n    std::bout << \"Greetings.\" << '\\n'; // no flush\n  } // destructor calls emit(): characters transferred; cout not flushed\n \n  // emit can be used for local exception-handling on the wrapped stream\n  std::osyncstream bout(std::cout);\n  bout << \"Hello, \" << \"World!\" << '\\n';\n  try {\n    bout.emit();\n  } catch (...) {\n    // handle exceptions\n  }\n}",
            "output": "Hello,\nWorld!\nGreetings.\nHello, World!"
        }
    },
    "fpos::state": {
        "description": {
            "texte": "Manages the file position state.For the specializations of std::fpos that are used in the standard library, State is always std::mbstate_t."
        },
        "parametres": "   st   -   new value for the state \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n#include <cwchar>\n \nint main()\n{\n    std::istringstream s(\"test\");\n    std::mbstate_t st = s.tellg().state();\n \n    if(std::mbsinit(&st))\n        std::cout << \"The stream is in the initial shift state\\n\";\n}",
            "output": "The stream is in the initial shift state"
        }
    },
    "locale::id": {
        "description": {
            "texte": "The class std::locale::id provides implementation-specific identification of a locale facet. Each class derived from std::locale::facet must have a public static member named id of type std::locale::id and each std::locale object maintains a list of facets it implements, indexed by their ids.Facets with the same id belong to the same facet category and replace each other when added to a locale object."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n \nstruct myfacet : std::locale::facet\n{\n    myfacet(std::size_t refs = 0) : facet(refs) {}\n    static std::locale::id id;\n};\n \nstd::locale::id myfacet::id;\n \nint main()\n{\n    std::locale myloc(std::locale(), new myfacet);\n    std::cout << \"has_facet<myfacet>(myloc) returns \" << std::boolalpha\n              << std::has_facet<myfacet>(myloc) << '\\n';\n}",
            "output": "has_facet<myfacet>(myloc) returns true"
        }
    },
    "locale::facet": {
        "description": {
            "texte": "std::locale::facet is the base class for facets. It provides a common base class so that locales could store pointers to the facets they implement in a single indexed container, and it abstracts support for facet reference counting. Whenever a facet is added to a locale, the locale increments the reference count in the facet (through an implementation-specific mechanism). Whenever a locale is destructed or modified, it decrements the reference count in each facet it no longer implements. Whenever a facet's reference count becomes zero, the locale performs delete static_cast<std::locale::facet*>(f) where f is the pointer to the facet."
        }
    },
    "locale::~locale": {
        "description": {
            "texte": "Non-virtual destructor which decrements reference counts of all facets held by *this. Those facets whose reference count becomes zero are deleted."
        }
    },
    "locale::operator=": {
        "description": {
            "texte": "Creates a copy of other, replacing the contents of *this. The reference counts of all facets held by other are incremented. The reference counts of all facets previously held by *this are decremented, and those facets whose reference count becomes zero are deleted."
        }
    },
    "locale::name": {
        "description": {
            "texte": "Returns the name of the locale, which is the name by which it is known to the operating system, such as \"POSIX\" or \"en_US.UTF8\" or \"English_United States.1252\". If the locale is not a copy of a system-supplied locale, the string \"*\" is returned."
        },
        "exemple": {
            "input": "#include <locale>\n#include <iostream>\n#include <string>\n \nint main()\n{\n    std::locale loc(std::locale(), new std::ctype<char>);\n    std::cout << \"The default locale is \" << std::locale().name() << '\\n'\n              << \"The user's locale is \" << std::locale(\"\").name() << '\\n'\n              << \"A nameless locale is \" << loc.name() << '\\n';\n}",
            "output": "The default locale is C\nThe user's locale is en_US.UTF8\nA nameless locale is *"
        }
    },
    "locale::global": {
        "description": {
            "texte": "Replaces the global C++ locale with loc, which means all future calls to the std::locale default constructor will now return a copy of loc. If loc has a name, also replaces the C locale as if by std::setlocale(LC_ALL, loc.name().c_str());. This function is the only way to modify the global C++ locale, which is otherwise equivalent to std::locale::classic() at program startup."
        },
        "parametres": "   loc   -   the new global C++ locale \n\n"
    },
    "locale::classic": {
        "description": {
            "texte": "Obtains a reference to the C++ locale that implements the classic \"C\" locale semantics. This locale, unlike the global locale, cannot be altered."
        }
    },
    "wbuffer_convert::wbuffer_convert": {
        "description": {
            "texte": "The following behavior-changing defect reports were applied retroactively to previously published C++ standards."
        },
        "parametres": "   bytebuf   -   pointer to std::streambuf to serve as the underlying narrow character stream \n   pcvt   -   pointer to a standalone (not managed by a locale) std::codecvt facet. The behavior is undefined if this pointer is null. \n   state   -   the initial value of the character conversion state \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n#include <locale>\n#include <codecvt>\nint main()\n{\n    // wrap a UTF-8 string stream in a UCS4 wbuffer_convert\n    std::stringbuf utf8buf(u8\"z\\u00df\\u6c34\\U0001f34c\");  // or u8\"z\u00df\u6c34\ud83c\udf4c\"\n                       // or \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9f\\x8d\\x8c\";\n    std::wbuffer_convert<std::codecvt_utf8<wchar_t>> conv_in(&utf8buf);\n    std::wistream ucsbuf(&conv_in);\n    std::cout << \"Reading from a UTF-8 stringbuf via wbuffer_convert:\\n\";\n    for(wchar_t c; ucsbuf.get(c); )\n        std::cout << std::hex << std::showbase << c << '\\n';\n \n    // wrap a UTF-8 aware std::cout in a UCS4 wbuffer_convert to output UCS4\n    std::wbuffer_convert<std::codecvt_utf8<wchar_t>> conv_out(std::cout.rdbuf());\n    std::wostream out(&conv_out);\n    std::cout << \"Sending UCS4 data to std::cout via wbuffer_convert:\\n\";\n    out << L\"z\\u00df\\u6c34\\U0001f34c\\n\";\n}",
            "output": "Reading from a UTF-8 stringbuf via wbuffer_convert produces\n0x7a\n0xdf\n0x6c34\n0x1f34c\nSending UCS4 data to std::cout via wbuffer_convert:\nz\u00df\u6c34\ud83c\udf4c"
        }
    },
    "wbuffer_convert::~wbuffer_convert": {
        "description": {
            "texte": "Destroys the wbuffer_convert object and deletes the pointer to the conversion facet."
        },
        "exemple": {
            "input": "#include <locale>\n#include <utility>\n#include <iostream>\n#include <codecvt>\n \n// utility wrapper to adapt locale-bound facets for wstring/wbuffer convert\ntemplate<class Facet>\nstruct deletable_facet : Facet\n{\n    template<class ...Args>\n    deletable_facet(Args&& ...args) : Facet(std::forward<Args>(args)...) {}\n    ~deletable_facet() {}\n};\n \nint main()\n{\n    // GB18030 / UCS4 conversion, using locale-based facet directly\n    // typedef std::codecvt_byname<char32_t, char, std::mbstate_t> gbfacet_t;\n    // Compiler error: \"calling a protected destructor of codecvt_byname<> in ~wbuffer_convert\"\n    // std::wbuffer_convert<gbfacet_t, char32_t> gbto32(std::cout.rdbuf(),\n    //                                        new gbfacet_t(\"zh_CN.gb18030\"));\n \n    // GB18030 / UCS4 conversion facet using a facet with public destructor\n    typedef deletable_facet<std::codecvt_byname<char32_t, char, std::mbstate_t>> gbfacet_t;\n    std::wbuffer_convert<gbfacet_t, char32_t> gbto32(std::cout.rdbuf(),\n                                           new gbfacet_t(\"zh_CN.gb18030\"));\n} // destructor called here"
        }
    },
    "wbuffer_convert::rdbuf": {
        "description": {
            "texte": "1) returns the pointer to the underlying byte stream.2) replaces the associated byte stream with bytebuf ."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n#include <locale>\n#include <codecvt>\nint main()\n{\n    // convert UTF-8 to UCS4\n    std::stringbuf utf8buf(u8\"z\\u00df\\u6c34\\U0001d10b\");  // or u8\"z\u00df\u6c34\ud834\udd0b\"\n                       // or \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9d\\x84\\x8b\";\n    std::wbuffer_convert<std::codecvt_utf8<wchar_t>> conv(&utf8buf);\n    std::wistream ucsbuf(&conv);\n    std::cout << \"Reading from a UTF-8 stringbuf via wbuffer_convert:\\n\";\n    for(wchar_t c; ucsbuf.get(c); )\n        std::cout << std::hex << std::showbase << c << '\\n';\n \n    // reuse the same wbuffer_convert to handle UCS4 to UTF-8 output\n    conv.rdbuf(std::cout.rdbuf());\n    std::wostream out(&conv);\n    std::cout << \"Sending UCS4 data to std::cout via wbuffer_convert:\\n\";\n    out << L\"z\\u00df\\u6c34\\U0001d10b\\n\";\n}",
            "output": "Reading from a UTF-8 stringbuf via wbuffer_convert:\n0x7a\n0xdf\n0x6c34\n0x1d10b\nSending UCS4 data to std::cout via wbuffer_convert:\nz\u00df\u6c34\ud834\udd0b"
        }
    },
    "wbuffer_convert::state": {
        "description": {
            "texte": "Returns the current value of the conversion state, which is stored in this wbuffer_convert object. The conversion state may be explicitly set in the constructor and is updated by all conversion operations."
        }
    },
    "time_get::date_order, std::time_get::do_date_order": {
        "description": {
            "texte": "The valid values (inherited from std::time_base) are:"
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n \nvoid show_date_order()\n{\n    std::time_base::dateorder d = std::use_facet<std::time_get<char>>(\n                                           std::locale()\n                                  ).date_order();\n    switch (d)\n    {\n        case std::time_base::no_order: std::cout << \"no_order\\n\"; break;\n        case std::time_base::dmy: std::cout << \"day, month, year\\n\"; break;\n        case std::time_base::mdy: std::cout << \"month, day, year\\n\"; break;\n        case std::time_base::ymd: std::cout << \"year, month, day\\n\"; break;\n        case std::time_base::ydm: std::cout << \"year, day, month\\n\"; break;\n    }\n}\n \nint main()\n{\n    std::locale::global(std::locale(\"en_US.utf8\"));\n    std::cout << \"In U.S. locale, the default date order is: \";\n    show_date_order();\n \n    std::locale::global(std::locale(\"ja_JP.utf8\"));\n    std::cout << \"In Japanese locale, the default date order is: \";\n    show_date_order();\n \n    std::locale::global(std::locale(\"de_DE.utf8\"));\n    std::cout << \"In German locale, the default date order is: \";\n    show_date_order();\n}",
            "output": "In U.S. locale, the default date order is: month, day, year\nIn Japanese locale, the default date order is: year, month, day\nIn German locale, the default date order is: day, month, year"
        }
    },
    "time_get::get_date, std::time_get::do_get_date": {
        "description": {
            "texte": "Iterator pointing one past the last character in [beg, end) that was recognized as a part of a valid date."
        },
        "parametres": "   beg   -   iterator designating the start of the sequence to parse \n   end   -   one past the end iterator for the sequence to parse \n   str   -   a stream object that this function uses to obtain locale facets when needed, e.g. std::ctype to skip whitespace or std::collate to compare strings \n   err   -   stream error flags object that is modified by this function to indicate errors \n   t   -   pointer to the std::tm object that will hold the result of this function call \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n#include <sstream>\n#include <iterator>\n#include <ctime>\n \nvoid try_get_date(const std::string& s)\n{\n    std::cout << \"Parsing the date out of '\" << s <<\n                 \"' in the locale \" << std::locale().name() << '\\n';\n    std::istringstream str(s);\n    std::ios_base::iostate err = std::ios_base::goodbit;\n \n    std::tm t;\n    std::istreambuf_iterator<char> ret =\n        std::use_facet<std::time_get<char>>(str.getloc()).get_date(\n            {str}, {}, str, err, &t\n        );\n    str.setstate(err);\n    if(str) {\n        std::cout << \"Day: \"   << t.tm_mday << ' '\n                  << \"Month: \" << t.tm_mon + 1 << ' '\n                  << \"Year: \"  << t.tm_year + 1900 << '\\n';\n    } else {\n        std::cout << \"Parse failed. Unparsed string: \";\n        std::copy(ret, {}, std::ostreambuf_iterator<char>(std::cout));\n        std::cout << '\\n';\n    }\n}\nint main()\n{\n    std::locale::global(std::locale(\"en_US.utf8\"));\n    try_get_date(\"02/01/2013\");\n    try_get_date(\"02-01-2013\");\n \n    std::locale::global(std::locale(\"ja_JP.utf8\"));\n    try_get_date(\"2013\u5e7402\u670801\u65e5\");\n}",
            "output": "Parsing the date out of '02/01/2013' in the locale en_US.utf8\nDay: 1 Month: 2 Year: 2013\nParsing the date out of '02-01-2013' in the locale en_US.utf8\nParse failed. Unparsed string: -01-2013\nParsing the date out of '2013\u5e7402\u670801\u65e5' in the locale ja_JP.utf8\nDay: 1 Month: 2 Year: 2013"
        }
    },
    "ctype::ctype": {
        "description": {
            "texte": "Creates a std::ctype<char> facet and forwards the starting reference count refs to the base class constructor, locale::facet::facet().If tbl is null, classic_table() is used by all classification member functions. Otherwise, tbl must be a pointer to the first element of an array of masks, at least std::ctype<char>::table_size in size, and that array is used by all of this facet's classification member functions.If del is true, it is assumed that the array was allocated with new[], and the destructor of this facet will call delete[] tbl."
        },
        "parametres": "   tbl   -   classification table to use or a null pointer \n   del   -   indicator whether the table needs to be deleted. \n   refs   -   starting reference count \n\n"
    },
    "ctype::~ctype": {
        "description": {
            "texte": "Destructs a std::ctype facet. This destructor is protected and virtual (due to base class destructor being virtual). An object of type std::ctype, like most facets, can only be destroyed when the last std::locale object that implements this facet goes out of scope or if a user-defined class is derived from std::ctype and implements a public destructor."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nstruct Destructible_ctype : public std::ctype<wchar_t>\n{\n    Destructible_ctype(std::size_t refs = 0) : ctype(refs) {}\n    // note: the implicit destructor is public\n};\nint main()\n{\n    Destructible_ctype dc;\n    // std::ctype<wchar_t> c;  // compile error: protected destructor\n}"
        }
    },
    "ctype::scan_is, std::ctype::do_scan_is": {
        "description": {
            "texte": "Pointer to the first character in [beg, end) that satisfies the mask, or end if no such character was found."
        },
        "parametres": "   m   -   mask to search for \n   beg   -   pointer to the first character in an array of characters to search \n   end   -   one past the end pointer for the array of characters to search \n\n",
        "exemple": {
            "input": "#include <locale>\n#include <clocale>\n#include <iostream>\n#include <iterator>\n \nint main()\n{\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::wcout.imbue(std::locale(\"en_US.utf8\"));\n    auto& f = std::use_facet<std::ctype<wchar_t>>(std::wcout.getloc());\n \n    // skip until the first letter\n    wchar_t s1[] = L\"      \\t\\t\\n  \u041a\u043e\u0448\u043a\u0430\";\n    const wchar_t* p1 = f.scan_is(std::ctype_base::alpha, std::begin(s1), std::end(s1));\n    std::wcout << \"'\" << p1 << \"'\\n\";\n \n    // skip until the first letter\n    wchar_t s2[] = L\"123456789\u30cd\u30d7\u30cd\u30d7\";\n    const wchar_t* p2 = f.scan_is(std::ctype_base::alpha, std::begin(s2), std::end(s2));\n    std::wcout << \"'\" << p2 << \"'\\n\";\n}",
            "output": "'\u041a\u043e\u0448\u043a\u0430'\n'\u30cd\u30d7\u30cd\u30d7'"
        }
    },
    "ctype::scan_not, std::ctype::do_scan_not": {
        "description": {
            "texte": "Pointer to the first character in [beg, end) that doesn't satisfy the mask, or end if no such character was found."
        },
        "parametres": "   m   -   mask to search for \n   beg   -   pointer to the first character in an array of characters to search \n   end   -   one past the end pointer for the array of characters to search \n\n",
        "exemple": {
            "input": "#include <locale>\n#include <clocale>\n#include <iostream>\n#include <iterator>\n \nint main()\n{\n    std::setlocale(LC_ALL, \"en_US.utf8\");\n    std::wcout.imbue(std::locale(\"en_US.utf8\"));\n    auto& f = std::use_facet<std::ctype<wchar_t>>(std::wcout.getloc());\n \n    // skip leading whitespace\n    wchar_t s1[] = L\"      \\t\\t\\n  \u041a\u043e\u0448\u043a\u0430\";\n    const wchar_t* p1 = f.scan_not(std::ctype_base::space, std::begin(s1), std::end(s1));\n    std::wcout << \"'\" << p1 << \"'\\n\";\n \n    // skip leading digits\n    wchar_t s2[] = L\"123456789\u30cd\u30d7\u30cd\u30d7\";\n    const wchar_t* p2 = f.scan_not(std::ctype_base::digit, std::begin(s2), std::end(s2));\n    std::wcout << \"'\" << p2 << \"'\\n\";\n}",
            "output": "'\u041a\u043e\u0448\u043a\u0430'\n'\u30cd\u30d7\u30cd\u30d7'"
        }
    },
    "ctype::toupper, std::ctype::do_toupper": {
        "description": {
            "texte": "Only 1:1 character mapping can be performed by this function, e.g. the uppercase form of '\u00df' is (with some exceptions) the two-character string \"SS\", which cannot be obtained by do_toupper."
        },
        "parametres": "   c   -   character to convert \n   beg   -   pointer to the first character in an array of characters to convert \n   end   -   one past the end pointer for the array of characters to convert \n\n",
        "exemple": {
            "input": "#include <locale>\n#include <iostream>\n \nvoid try_upper(const std::ctype<wchar_t>& f, wchar_t c)\n{\n    wchar_t up = f.toupper(c);\n    if (up != c) {\n        std::wcout << \"Upper case form of \\'\" << c << \"' is \" << up << '\\n';\n    } else {\n        std::wcout << '\\'' << c << \"' has no upper case form\\n\";\n    }\n}\n \nint main()\n{\n    std::locale::global(std::locale(\"en_US.utf8\"));\n    std::wcout.imbue(std::locale());\n    std::wcout << \"In US English UTF-8 locale:\\n\";\n    auto& f = std::use_facet<std::ctype<wchar_t>>(std::locale());\n    try_upper(f, L's');\n    try_upper(f, L'\u017f');\n    try_upper(f, L'\u00df');\n \n    std::wstring str = L\"Hello, World!\";\n    std::wcout << \"Uppercase form of the string '\" << str << \"' is \";\n    f.toupper(&str[0], &str[0] + str.size());\n    std::wcout << \"'\" << str << \"'\\n\";\n}",
            "output": "In US English UTF-8 locale:\nUpper case form of 's' is S\nUpper case form of '\u017f' is S\n'\u00df' has no upper case form\nUppercase form of the string 'Hello, World!' is 'HELLO, WORLD!'"
        }
    },
    "ctype::tolower, std::ctype::do_tolower": {
        "description": {
            "texte": "Only 1:1 character mapping can be performed by this function, e.g. the Greek uppercase letter '\u03a3' has two lowercase forms, depending on the position in a word: '\u03c3' and '\u03c2'. A call to do_tolower cannot be used to obtain the correct lowercase form in this case."
        },
        "parametres": "   c   -   character to convert \n   beg   -   pointer to the first character in an array of characters to convert \n   end   -   one past the end pointer for the array of characters to convert \n\n",
        "exemple": {
            "input": "#include <locale>\n#include <iostream>\n \nvoid try_lower(const std::ctype<wchar_t>& f, wchar_t c)\n{\n    wchar_t up = f.tolower(c);\n    if (up != c) {\n        std::wcout << \"Lower case form of \\'\" << c << \"' is \" << up << '\\n';\n    } else {\n        std::wcout << '\\'' << c << \"' has no lower case form\\n\";\n    }\n}\n \nint main()\n{\n    std::locale::global(std::locale(\"en_US.utf8\"));\n    std::wcout.imbue(std::locale());\n    std::wcout << \"In US English UTF-8 locale:\\n\";\n    auto& f = std::use_facet<std::ctype<wchar_t>>(std::locale());\n    try_lower(f, L'\u03a3');\n    try_lower(f, L'\u0190');\n    try_lower(f, L'\uff21');\n \n    std::wstring str = L\"HELLo, wORLD!\";\n    std::wcout << \"Lowercase form of the string '\" << str << \"' is \";\n    f.tolower(&str[0], &str[0] + str.size());\n    std::wcout << \"'\" << str << \"'\\n\";\n}",
            "output": "In US English UTF-8 locale:\nLower case form of '\u03a3' is \u03c3\nLower case form of '\u0190' is \u025b\nLower case form of '\uff21' is \uff41\nLowercase form of the string 'HELLo, wORLD!' is 'hello, world!'"
        }
    },
    "ctype::widen, do_widen": {
        "description": {
            "texte": "Widening always returns a wide character, but only the characters from the basic source character set (latin letters, digits, and punctuations required to write a C++ program) are guaranteed to have a unique, well-defined, widening transformation, which is also guaranteed to be reversible (by narrow()). In practice, all characters whose multibyte representation is a single byte are usually widened to their wide character counterparts, and the rest of the possible single-byte values are usually mapped into the same placeholder value, typically CharT(-1).Widening, if successful, preserves all character classification categories known to is()."
        },
        "parametres": "   c   -   character to convert \n   dflt   -   default value to produce if the conversion fails \n   beg   -   pointer to the first character in an array of characters to convert \n   end   -   one past the end pointer for the array of characters to convert \n   dst   -   pointer to the first element of the array of char to fill \n\n",
        "exemple": {
            "input": "#include <locale>\n#include <iostream>\n \nvoid try_widen(const std::ctype<wchar_t>& f, char c)\n{\n    wchar_t w = f.widen(c);\n    std::cout << \"The single-byte character \" << +(unsigned char)c\n              << \" widens to \" << +w << '\\n';\n}\n \nint main()\n{\n    std::locale::global(std::locale(\"cs_CZ.iso88592\"));\n    auto& f = std::use_facet<std::ctype<wchar_t>>(std::locale());\n    std::cout << std::hex << std::showbase << \"In Czech ISO-8859-2 locale:\\n\";\n    try_widen(f, 'a');\n    try_widen(f, '\\xdf'); // German letter \u00df (U+00df) in ISO-8859-2\n    try_widen(f, '\\xec'); // Czech letter \u011b (U+011b) in ISO-8859-2\n \n    std::locale::global(std::locale(\"cs_CZ.utf8\"));\n    auto& f2 = std::use_facet<std::ctype<wchar_t>>(std::locale());\n    std::cout << \"In Czech UTF-8 locale:\\n\";\n    try_widen(f2, 'a');\n    try_widen(f2, '\\xdf'); \n    try_widen(f2, '\\xec'); \n}",
            "output": "In Czech ISO-8859-2 locale:\nThe single-byte character 0x61 widens to 0x61\nThe single-byte character 0xdf widens to 0xdf\nThe single-byte character 0xec widens to 0x11b\nIn Czech UTF-8 locale:\nThe single-byte character 0x61 widens to 0x61\nThe single-byte character 0xdf widens to 0xffffffff\nThe single-byte character 0xec widens to 0xffffffff"
        }
    },
    "ctype::narrow, do_narrow": {
        "description": {
            "texte": "Narrowing is always successful and is always reversible (by calling widen()) for all characters from the basic source character set (latin letters, digits, and punctuations required to write a C++ program).Narrowing, if successful, preserves all character classification categories known to is().Narrowing of any digit character guarantees that if the result is subtracted from the character literal '0', the difference equals the digit value of the original character."
        },
        "parametres": "   c   -   character to convert \n   dflt   -   default value to produce if the conversion fails \n   beg   -   pointer to the first character in an array of characters to convert \n   end   -   one past the end pointer for the array of characters to convert \n   dst   -   pointer to the first element of the array of char to fill \n\n",
        "exemple": {
            "input": "#include <locale>\n#include <iostream>\n \nvoid try_narrow(const std::ctype<wchar_t>& f, wchar_t c)\n{\n    char n = f.narrow(c, 0);\n    if (n) {\n        std::wcout << '\\'' << c << \"' narrowed to \" << +(unsigned char)n << '\\n';\n    } else {\n        std::wcout << '\\'' << c << \"' could not be narrowed\\n\";\n    }\n}\n \nint main()\n{\n    std::locale::global(std::locale(\"en_US.utf8\"));\n    std::wcout.imbue(std::locale());\n    std::wcout << std::hex << std::showbase << \"In US English UTF-8 locale:\\n\";\n    auto& f = std::use_facet<std::ctype<wchar_t>>(std::locale());\n    try_narrow(f, L'A');\n    try_narrow(f, L'\uff21');\n    try_narrow(f, L'\u011b');\n \n    std::locale::global(std::locale(\"cs_CZ.iso88592\"));\n    auto& f2 = std::use_facet<std::ctype<wchar_t>>(std::locale());\n    std::wcout << \"In Czech ISO-8859-2 locale:\\n\";\n    try_narrow(f2, L'A');\n    try_narrow(f2, L'\uff21');\n    try_narrow(f2, L'\u011b');\n}",
            "output": "In US English UTF-8 locale:\n'A' narrowed to 0x41\n'\uff21' could not be narrowed\n'\u011b' could not be narrowed\nIn Czech ISO-8859-2 locale:\n'A' narrowed to 0x41\n'\uff21' could not be narrowed\n'\u011b' narrowed to 0xec"
        }
    },
    "ctype::table": {
        "description": {
            "texte": "Returns the classification table that was provided in the constructor of this instance of std::ctype<char>, or returns a copy of classic_table() if none was provided."
        }
    },
    "ctype::classic_table": {
        "description": {
            "texte": "Returns the classification table that matches the classification used by the minimal \"C\" locale."
        }
    },
    "ctype::is": {
        "description": {
            "texte": "If (unsigned char)c >= std::ctype<char>::table_size, then an implementation-defined value is substituted instead of table()[(unsigned char)c], possibly different for different values of c."
        },
        "parametres": "   c   -   character to classify \n   m   -   mask to use for classifying a single character \n   low   -   pointer to the first character in an array of characters to classify \n   high   -   one past the end pointer for the array of characters to classify \n   vec   -   pointer to the first element of the array of masks to fill \n\n"
    },
    "ctype::scan_is": {
        "description": {
            "texte": "Locates the first character in the character array [beg, end) that satisfies the classification mask m, that is, the first character c such that table()[(unsigned char) c] & m would return true.If (unsigned char)c >= std::ctype<char>::table_size, then an implementation-defined value is substituted instead of table()[(unsigned char)c], possibly different for different values of c."
        },
        "parametres": "   m   -   mask to search for \n   beg   -   pointer to the first character in an array of characters to search \n   end   -   one past the end pointer for the array of characters to search \n\n",
        "exemple": {
            "input": "#include <locale>\n#include <iostream>\n#include <iterator>\n \nint main()\n{\n    std::locale loc(\"\");\n    auto& f = std::use_facet<std::ctype<char>>(loc);\n \n    // skip until the first letter\n    char s1[] = \"      \\t\\t\\n  Test\";\n    const char* p1 = f.scan_is(std::ctype_base::alpha, std::begin(s1), std::end(s1));\n    std::cout << \"'\" << p1 << \"'\\n\";\n \n    // skip until the first letter\n    char s2[] = \"123456789abcd\";\n    const char* p2 = f.scan_is(std::ctype_base::alpha, std::begin(s2), std::end(s2));\n    std::cout << \"'\" << p2 << \"'\\n\";\n}",
            "output": "'Test'\n'abcd'"
        }
    },
    "ctype::scan_not": {
        "description": {
            "texte": "Locates the first character in the character array [beg, end) that does not satisfy the classification mask m, that is, the first character c such that table()[(unsigned char)c] & m would return false.If (unsigned char)c >= std::ctype<char>::table_size, then an implementation-defined value is substituted instead of table()[(unsigned char)c], possibly different for different values of c."
        },
        "parametres": "   m   -   mask to search for \n   beg   -   pointer to the first character in an array of characters to search \n   end   -   one past the end pointer for the array of characters to search \n\n",
        "exemple": {
            "input": "#include <locale>\n#include <iostream>\n#include <iterator>\n \nint main()\n{\n    auto& f = std::use_facet<std::ctype<char>>(std::locale());\n \n    // skip leading whitespace\n    char s1[] = \"      \\t\\t\\n  Test\";\n    const char* p1 = f.scan_not(std::ctype_base::space, std::begin(s1), std::end(s1));\n    std::cout << \"'\" << p1 << \"'\\n\";\n \n    // skip leading digits\n    char s2[] = \"123456789abcd\";\n    const char* p2 = f.scan_not(std::ctype_base::digit, std::begin(s2), std::end(s2));\n    std::cout << \"'\" << p2 << \"'\\n\";\n}",
            "output": "'Test'\n'abcd'"
        }
    },
    "codecvt::codecvt": {
        "description": {
            "texte": "Creates a std::codecvt facet and forwards the starting reference count refs to the base class constructor, locale::facet::facet()."
        },
        "parametres": "   refs   -   starting reference count \n\n"
    },
    "codecvt::~codecvt": {
        "description": {
            "texte": "Destructs a std::codecvt facet. This destructor is protected and virtual (due to base class destructor being virtual). An object of type std::codecvt, like most facets, can only be destroyed when the last std::locale object that implements this facet goes out of scope or if a user-defined class is derived from std::codecvt and implements a public destructor."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nstruct Destructible_codecvt : public std::codecvt<wchar_t, char, std::mbstate_t>\n{\n    Destructible_codecvt(std::size_t refs = 0) : codecvt(refs) {}\n    // note: the implicit destructor is public\n};\nint main()\n{\n    Destructible_codecvt dc;\n    // std::codecvt<wchar_t> c;  // compile error: protected destructor\n}"
        }
    },
    "codecvt::out, do_out": {
        "description": {
            "texte": "If this codecvt facet does not define a conversion, no characters are converted. to_next is set to be equal to to, state is unchanged, and std::codecvt_base::noconv is returned."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <locale>\n \nint main()\n{\n    std::locale::global(std::locale(\"en_US.utf8\"));\n    auto& f = std::use_facet<std::codecvt<wchar_t, char, std::mbstate_t>>(std::locale());\n    std::wstring internal = L\"z\\u00df\\u6c34\\U0001f34c\"; // L\"z\u00df\u6c34\ud83c\udf4c\"\n \n    // note that the following can be done with wstring_convert\n    std::mbstate_t mb{}; // initial shift state\n    std::string external(internal.size() * f.max_length(), '\\0'); \n    const wchar_t* from_next;\n    char* to_next;\n    f.out(mb, &internal[0], &internal[internal.size()], from_next,\n              &external[0], &external[external.size()], to_next);\n    // error checking skipped for brevity\n    external.resize(to_next - &external[0]);\n \n    std::cout << \"The string in narrow multibyte encoding: \" << external << '\\n';\n}",
            "output": "The string in narrow multibyte encoding: z\u00df\u6c34\ud83c\udf4c"
        }
    },
    "codecvt::in, std::codecvt::do_in": {
        "description": {
            "texte": "If this codecvt facet does not define a conversion, no characters are converted. to_next is set to be equal to to, state is unchanged, and std::codecvt_base::noconv is returned."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <locale>\n \nint main()\n{\n    std::locale::global(std::locale(\"en_US.utf8\"));\n    auto& f = std::use_facet<std::codecvt<wchar_t, char, std::mbstate_t>>(std::locale());\n    std::string external = u8\"z\\u00df\\u6c34\\U0001d10b\"; // or u8\"z\u00df\u6c34\ud834\udd0b\"\n                          // or \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9d\\x84\\x8b\";\n \n    // note that the following can be done with wstring_convert\n    std::mbstate_t mb = std::mbstate_t(); // initial shift state\n    std::wstring internal(external.size(), '\\0'); \n    const char* from_next;\n    wchar_t* to_next;\n    f.in(mb, &external[0], &external[external.size()], from_next,\n             &internal[0], &internal[internal.size()], to_next);\n    // error checking skipped for brevity\n    internal.resize(to_next - &internal[0]);\n \n    std::wcout << L\"The string in wide encoding: \" << internal << '\\n';\n}",
            "output": "The string in wide encoding: z\u00df\u6c34\ud834\udd0b"
        }
    },
    "codecvt::unshift, do_unshift": {
        "description": {
            "texte": "A value of type std::codecvt_base::result, indicating the success status as follows:The non-converting specialization std::codecvt<char, char, std::mbstate_t> always returns std::codecvt_base::noconv."
        }
    },
    "codecvt::encoding, do_encoding": {
        "description": {
            "texte": "The exact number of externT characters that correspond to one internT character, if constant. \u200b0\u200b if the number varies, -1 if the encoding is state-dependent.The non-converting specialization std::codecvt<char, char, std::mbstate_t> returns 1."
        },
        "exemple": {
            "input": "#include <locale>\n#include <iostream>\n \nint main()\n{\n    std::cout << \"en_US.utf8 is a variable-length encoding, encoding() returns \"\n              << std::use_facet<std::codecvt<wchar_t, char, std::mbstate_t>>(\n                    std::locale(\"en_US.utf8\")\n              ).encoding() << '\\n';\n \n    std::cout << \"zh_CN.gb18030 is also variable-length, encoding() == \"\n              << std::use_facet<std::codecvt<wchar_t, char, std::mbstate_t>>(\n                    std::locale(\"zh_CN.gb18030\")\n              ).encoding() << '\\n';\n \n    std::cout << \"ru_RU.koi8r is a single-byte encoding encoding() == \"\n              << std::use_facet<std::codecvt<wchar_t, char, std::mbstate_t>>(\n                    std::locale(\"ru_RU.koi8r\")\n              ).encoding() << '\\n';\n}",
            "output": "en_US.utf8 is a variable-length encoding, encoding() returns 0\nzh_CN.gb18030 is also variable-length, encoding() == 0\nru_RU.koi8r is a single-byte encoding encoding() == 1"
        }
    },
    "codecvt::always_noconv, do_always_noconv": {
        "description": {
            "texte": "true if this conversion facet performs no conversions, false otherwise.The non-converting specialization std::codecvt<char, char, std::mbstate_t> returns true."
        },
        "exemple": {
            "input": "#include <locale>\n#include <iostream>\n \nint main()\n{\n    std::cout << \"The non-converting char<->char codecvt::always_noconv() returns \" \n              << std::boolalpha\n              << std::use_facet<std::codecvt<char, char, std::mbstate_t>>(\n                    std::locale()\n                 ).always_noconv() << \"\\n\"\n              << \"while wchar_t<->char codecvt::always_noconv() returns \"\n              << std::use_facet<std::codecvt<wchar_t, char, std::mbstate_t>>(\n                    std::locale()\n                 ).always_noconv() << \"\\n\";\n \n}",
            "output": "The non-converting char<->char codecvt::always_noconv() returns true\nwhile wchar_t<->char codecvt::always_noconv() returns false"
        }
    },
    "codecvt::length, do_length": {
        "description": {
            "texte": "The number of externT characters that would be consumed if converted by do_in() until either all from_end-from characters were consumed or max internT characters were produced, or a conversion error occurred.The non-converting specialization std::codecvt<char, char, std::mbstate_t> returns std::min(max, from_end-from)."
        },
        "exemple": {
            "input": "#include <locale>\n#include <string>\n#include <iostream>\n \nint main()\n{\n    //  narrow multibyte encoding\n    std::string s = \"z\\u00df\\u6c34\\U0001d10b\"; // or u8\"z\u00df\u6c34\ud834\udd0b\"\n                      // or \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9d\\x84\\x8b\";\n    std::mbstate_t mb = std::mbstate_t();\n    std::cout << \"Only the first \" <<\n              std::use_facet<std::codecvt<wchar_t, char, std::mbstate_t>>(\n                    std::locale(\"en_US.utf8\")\n              ).length(mb, &s[0], &s[s.size()], 2)\n              << \" bytes out of \" << s.size() << \" would be consumed \"\n                 \" to produce the first 2 characters\\n\";\n}",
            "output": "Only the first 3 bytes out of 10 would be consumed to produce the first 2 characters"
        }
    },
    "codecvt::max_length, do_max_length": {
        "description": {
            "texte": "The maximum number of ExternT characters that could be consumed if converted by in() to produce one InternT character.The non-converting specialization std::codecvt<char, char, std::mbstate_t> returns 1."
        },
        "exemple": {
            "input": "#include <locale>\n#include <iostream>\n#include <codecvt>\n \nint main()\n{\n    std::cout << \"In codecvt_utf8, the longest multibyte character is \"\n              << std::codecvt_utf8<wchar_t>().max_length() << \" bytes long\\n\";\n \n    std::cout << \"In header-consuming codecvt_utf8, the longest multibyte character is \"\n              << std::codecvt_utf8<wchar_t,\n                                   0x10ffff,\n                                   std::consume_header>().max_length() << \" bytes long\\n\";\n \n    std::cout << \"In this system's en_US.utf8, the longest multibyte character is \"\n              << std::use_facet<std::codecvt<wchar_t, char, std::mbstate_t>>(\n                    std::locale(\"en_US.utf8\")\n              ).max_length() << \" bytes long\\n\";\n \n    std::cout << \"In this system's zh_CN.gb18030, the longest multibyte character is \"\n              << std::use_facet<std::codecvt<wchar_t, char, std::mbstate_t>>(\n                    std::locale(\"zh_CN.gb18030\")\n              ).max_length() << \" bytes long\\n\";\n}",
            "output": "In codecvt_utf8, the longest multibyte character is 4 bytes long\nIn header-consuming codecvt_utf8, the longest multibyte character is 7 bytes long\nIn this system's en_US.utf8, the longest multibyte character is 6 bytes long\nIn this system's zh_CN.gb18030, the longest multibyte character is 4 bytes long"
        }
    },
    "collate::collate": {
        "description": {
            "texte": "Creates a std::collate facet and forwards the starting reference count refs to the base class constructor, locale::facet::facet()."
        },
        "parametres": "   refs   -   starting reference count \n\n"
    },
    "collate::~collate": {
        "description": {
            "texte": "Destructs a std::collate facet. This destructor is protected and virtual (due to base class destructor being virtual). An object of type std::collate, like most facets, can only be destroyed when the last std::locale object that implements this facet goes out of scope or if a user-defined class is derived from std::collate and implements a public destructor."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nstruct Destructible_collate : public std::collate<wchar_t>\n{\n    Destructible_collate(std::size_t refs = 0) : collate(refs) {}\n    // note: the implicit destructor is public\n};\nint main()\n{\n    Destructible_collate dc;\n    // std::collate<wchar_t> c;  // compile error: protected destructor\n}"
        }
    },
    "collate::compare, std::collate::do_compare": {
        "description": {
            "texte": "1 if the first string is greater than the second (that is, follows the second in the collation order), -1 if the first string is less than the second (precedes the second in the collation order), zero if the two strings are equivalent."
        },
        "parametres": "   low1   -   pointer to the first character of the first string \n   high1   -   one past the end pointer for the first string \n   low2   -   pointer to the first character of the second string \n   high2   -   one past the end pointer for the second string \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <locale>\n \ntemplate<typename CharT>\nvoid try_compare(const std::locale& l, const CharT* p1, const CharT* p2)\n{\n    auto& f = std::use_facet<std::collate<CharT>>(l);\n \n    std::basic_string<CharT> s1(p1), s2(p2);\n    if(f.compare(&s1[0], &s1[0] + s1.size(),\n                 &s2[0], &s2[0] + s2.size() ) < 0)\n         std::wcout << p1 << \" before \" << p2 << '\\n';\n    else\n         std::wcout << p2 << \" before \" << p1 << '\\n';\n}\n \nint main()\n{\n    std::locale::global(std::locale(\"en_US.utf8\"));\n    std::wcout.imbue(std::locale());\n \n    std::wcout << \"In the American locale: \";\n    try_compare(std::locale(), \"hrnec\", \"chrt\");\n    std::wcout << \"In the Czech locale: \";\n    try_compare(std::locale(\"cs_CZ.utf8\"), \"hrnec\", \"chrt\");\n \n    std::wcout << \"In the American locale: \";\n    try_compare(std::locale(), L\"\u00e5r\", L\"\u00e4ngel\");\n    std::wcout << \"In the Swedish locale: \";\n    try_compare(std::locale(\"sv_SE.utf8\"), L\"\u00e5r\", L\"\u00e4ngel\");\n}",
            "output": "In the American locale: chrt before hrnec\nIn the Czech locale: hrnec before chrt\nIn the American locale: \u00e4ngel before \u00e5r\nIn the Swedish locale: \u00e5r before \u00e4ngel"
        }
    },
    "collate::transform, do_transform": {
        "description": {
            "texte": "The string transformed so that lexicographic comparison of the transformed strings may be used instead of collating of the originals. In the \"C\" locale, the returned string is the exact copy of [low, high). In other locales, the contents of the returned string are implementation-defined, and the size may be considerably longer."
        },
        "parametres": "   low   -   pointer to the first character in the sequence to transform \n   high   -   one past the end pointer for the sequence to transform \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <locale>\n \nint main()\n{\n    std::locale::global(std::locale(\"sv_SE.utf8\"));\n    auto& f = std::use_facet<std::collate<wchar_t>>(std::locale());\n \n    std::wstring in1 = L\"\\u00e4ngel\";\n    std::wstring in2 = L\"\\u00e5r\";\n \n    std::wstring out1 = f.transform(&in1[0], &in1[0] + in1.size());\n    std::wstring out2 = f.transform(&in2[0], &in2[0] + in2.size());\n \n    std::wcout << \"In the Swedish locale: \";\n    if(out1 < out2)\n         std::wcout << in1 << \" before \" << in2 << '\\n';\n    else\n         std::wcout << in2 << \" before \" << in1 << '\\n';\n \n    std::wcout << \"In lexicographic comparison: \";\n    if(in1 < in2)\n         std::wcout << in1 << \" before \" << in2 << '\\n';\n    else\n         std::wcout << in2 << \" before \" << in1 << '\\n';\n \n}",
            "output": "In the Swedish locale: \u00e5r before \u00e4ngel\nIn lexicographic comparison: \u00e4ngel before \u00e5r"
        }
    },
    "collate::hash, std::collate::do_hash": {
        "description": {
            "texte": "The hash value that respects collation order."
        },
        "parametres": "   beg   -   pointer to the first character in the sequence to hash \n   end   -   one past the end pointer for the sequence to hash \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <locale>\n#include <unordered_set>\n \nstruct CollateHash {\n    template<typename CharT>\n    std::size_t operator()(const std::basic_string<CharT>& s) const\n    {\n        return std::use_facet<std::collate<CharT>>(std::locale()).hash(\n                   &s[0], &s[0] + s.size()\n               );\n    }\n};\nstruct CollateEq {\n    template<typename CharT>\n    bool operator()(const std::basic_string<CharT>& s1,\n                    const std::basic_string<CharT>& s2) const\n    {\n        return std::use_facet<std::collate<CharT>>(std::locale()).compare(\n                     &s1[0], &s1[0] + s1.size(),\n                     &s2[0], &s2[0] + s2.size()\n               ) == 0;\n    }\n};\n \nint main()\n{\n    std::locale::global(std::locale(\"en_US.utf8\"));\n    std::wcout.imbue(std::locale());\n \n    std::unordered_set<std::wstring, CollateHash, CollateEq> s2 = {L\"Foo\", L\"Bar\"};\n    for(auto& str: s2)\n        std::wcout << str << ' ';\n    std::cout << '\\n';\n}",
            "output": "Bar Foo"
        }
    },
    "messages::messages": {
        "description": {
            "texte": "Creates a std::messages facet and forwards the starting reference count refs to the base class constructor, locale::facet::facet()."
        },
        "parametres": "   refs   -   starting reference count \n\n"
    },
    "messages::~messages": {
        "description": {
            "texte": "Destructs a std::messages facet. This destructor is protected and virtual (due to base class destructor being virtual). An object of type std::messages, like most facets, can only be destroyed when the last std::locale object that implements this facet goes out of scope or if a user-defined class is derived from std::messages and implements a public destructor."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nstruct Destructible_messages : public std::messages<wchar_t>\n{\n    Destructible_messages(std::size_t refs = 0) : messages(refs) {}\n    // note: the implicit destructor is public\n};\nint main()\n{\n    Destructible_messages dc;\n    // std::messages<wchar_t> c;  // compile error: protected destructor\n}"
        }
    },
    "messages::open, std::messages::do_open": {
        "description": {
            "texte": "1) Public member function, calls the protected virtual member function do_open of the most derived class.2) Obtains a value of type catalog (inherited from std::messages_base), which can be passed to get() to retrieve messages from the message catalog named by name. This value is usable until passed to close()."
        },
        "parametres": "   name   -   name of the message catalog to open \n   loc   -   a locale object that provides additional facets that may be required to read messages from the catalog, such as std::codecvt to perform wide/multibyte conversions \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n \nint main()\n{\n    std::locale loc(\"de_DE.utf8\");\n    std::cout.imbue(loc);\n    auto& facet = std::use_facet<std::messages<char>>(loc);\n    auto cat = facet.open(\"sed\", loc);\n    if(cat < 0 )\n        std::cout << \"Could not open german \\\"sed\\\" message catalog\\n\";\n    else\n        std::cout << \"\\\"No match\\\" in German: \"\n                  << facet.get(cat, 0, 0, \"No match\") << '\\n'\n                  << \"\\\"Memory exhausted\\\" in German: \"\n                  << facet.get(cat, 0, 0, \"Memory exhausted\") << '\\n';\n    facet.close(cat);\n}",
            "output": "\"No match\" in German: Keine \u00dcbereinstimmung\n\"Memory exhausted\" in German: Speicher ersch\u00f6pft"
        }
    },
    "messages::get, std::messages::do_get": {
        "description": {
            "texte": "1) Public member function, calls the protected virtual member function do_get of the most derived class.2) Obtains a message from the open message catalog cat using the values set, msgid and dfault in implementation-defined manner. If the expected message is not found in the catalog, returns a copy of dfault."
        },
        "parametres": "   cat   -   identifier of message catalog obtained from open() and not yet passed to close() \n   set   -   implementation-defined argument, message set in POSIX \n   msgid   -   implementation-defined argument, message id in POSIX \n   dfault   -   the string to look up in the catalog (if the catalog uses string look-up) and also the string to return in case of a failure \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n \nint main()\n{\n    std::locale loc(\"de_DE.utf8\");\n    std::cout.imbue(loc);\n    auto& facet = std::use_facet<std::messages<char>>(loc);\n    auto cat = facet.open(\"sed\", loc);\n    if(cat < 0 )\n        std::cout << \"Could not open german \\\"sed\\\" message catalog\\n\";\n    else\n        std::cout << \"\\\"No match\\\" in German: \"\n                  << facet.get(cat, 0, 0, \"No match\") << '\\n'\n                  << \"\\\"Memory exhausted\\\" in German: \"\n                  << facet.get(cat, 0, 0, \"Memory exhausted\") << '\\n';\n    facet.close(cat);\n}",
            "output": "\"No match\" in German: Keine \u00dcbereinstimmung\n\"Memory exhausted\" in German: Speicher ersch\u00f6pft"
        }
    },
    "messages::close, std::messages::do_close": {
        "description": {
            "texte": "1) public member function, calls the protected virtual member function do_close of the most derived class.2) Releases the implementation-defined resources associated with an open catalog that is designated by the value c of type catalog (inherited from std::messages_base), which was obtained from open()."
        },
        "parametres": "   c   -   a valid open catalog identifier, on which close() has not yet been called \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n \nint main()\n{\n    std::locale loc(\"de_DE.utf8\");\n    std::cout.imbue(loc);\n    auto& facet = std::use_facet<std::messages<char>>(loc);\n    auto cat = facet.open(\"sed\", loc);\n    if(cat < 0 )\n        std::cout << \"Could not open german \\\"sed\\\" message catalog\\n\";\n    else\n        std::cout << \"\\\"No match\\\" in German: \"\n                  << facet.get(cat, 0, 0, \"No match\") << '\\n'\n                  << \"\\\"Memory exhausted\\\" in German: \"\n                  << facet.get(cat, 0, 0, \"Memory exhausted\") << '\\n';\n    facet.close(cat);\n}",
            "output": "\"No match\" in German: Keine \u00dcbereinstimmung\n\"Memory exhausted\" in German: Speicher ersch\u00f6pft"
        }
    },
    "time_get::time_get": {
        "description": {
            "texte": "Creates a std::time_get facet and forwards the starting reference count refs to the base class constructor, locale::facet::facet()."
        },
        "parametres": "   refs   -   starting reference count \n\n"
    },
    "time_get::~time_get": {
        "description": {
            "texte": "Destructs a std::time_get facet. This destructor is protected and virtual (due to base class destructor being virtual). An object of type std::time_get, like most facets, can only be destroyed when the last std::locale object that implements this facet goes out of scope or if a user-defined class is derived from std::time_get and implements a public destructor."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nstruct Destructible_time_get : public std::time_get<wchar_t>\n{\n    Destructible_time_get(std::size_t refs = 0) : time_get(refs) {}\n    // note: the implicit destructor is public\n};\nint main()\n{\n    Destructible_time_get dc;\n    // std::time_get<wchar_t> c;  // compile error: protected destructor\n}"
        }
    },
    "time_get::get_time, std::time_get::do_get_time": {
        "description": {
            "texte": "Iterator pointing one past the last character in [beg, end) that was recognized as a part of a valid date."
        },
        "parametres": "   beg   -   iterator designating the start of the sequence to parse \n   end   -   one past the end iterator for the sequence to parse \n   str   -   a stream object that this function uses to obtain locale facets when needed, e.g. std::ctype to skip whitespace \n   err   -   stream error flags object that is modified by this function to indicate errors \n   t   -   pointer to the std::tm object that will hold the result of this function call \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n#include <sstream>\n#include <iterator>\n \nvoid try_get_time(const std::string& s)\n{\n    std::cout << \"Parsing the time out of '\" << s <<\n                 \"' in the locale \" << std::locale().name() << '\\n';\n    std::istringstream str(s);\n    std::ios_base::iostate err = std::ios_base::goodbit;\n \n    std::tm t;\n    std::istreambuf_iterator<char> ret =\n        std::use_facet<std::time_get<char>>(str.getloc()).get_time(\n            {str}, {}, str, err, &t\n        );\n    str.setstate(err);\n    if(str) {\n        std::cout << \"Hours: \"   << t.tm_hour << ' '\n                  << \"Minutes: \" << t.tm_min  << ' '\n                  << \"Seconds: \" << t.tm_sec  << '\\n';\n    } else {\n        std::cout << \"Parse failed. Unparsed string: \";\n        std::copy(ret, {}, std::ostreambuf_iterator<char>(std::cout));\n        std::cout << '\\n';\n    }\n}\nint main()\n{\n    std::locale::global(std::locale(\"ru_RU.utf8\"));\n    try_get_time(\"21:40:11\");\n    try_get_time(\"21-40-11\");\n \n    std::locale::global(std::locale(\"ja_JP.utf8\"));\n    try_get_time(\"21\u664237\u520658\u79d2\");\n}",
            "output": "Parsing the time out of '21:40:11' in the locale ru_RU.utf8\nHours: 21 Minutes: 40 Seconds: 11\nParsing the time out of '21-40-11' in the locale ru_RU.utf8\nParse failed. Unparsed string: -40-11\nParsing the time out of '21\u664237\u520658\u79d2' in the locale ja_JP.utf8\nHours: 21 Minutes: 37 Seconds: 58"
        }
    },
    "time_get::get_weekday, std::time_get::do_get_weekday": {
        "description": {
            "texte": "If it finds abbreviated name, followed by the characters that are valid for the full name, it continues reading until it consumes all the characters for the full name or finds a character that isn't expected, in which case parsing fails even if the first few characters were a valid abbreviation.The parsed weekday is stored in the std::tm field t->tm_wday.If the end iterator is reached before a valid weekday name is read, the function sets std::ios_base::eofbit in err. If a parsing error is encountered, the function sets std::ios_base::failbit in err."
        },
        "parametres": "   beg   -   iterator designating the start of the sequence to parse \n   end   -   one past the end iterator for the sequence to parse \n   str   -   a stream object that this function uses to obtain locale facets when needed, e.g. std::ctype to skip whitespace or std::collate to compare strings \n   err   -   stream error flags object that is modified by this function to indicate errors \n   t   -   pointer to the std::tm object that will hold the result of this function call \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n#include <sstream>\n#include <iterator>\n \nvoid try_get_wday(const std::string& s)\n{\n    std::cout << \"Parsing the weekday out of '\" << s <<\n                 \"' in the locale \" << std::locale().name() << '\\n';\n    std::istringstream str(s);\n    std::ios_base::iostate err = std::ios_base::goodbit;\n \n    std::tm t;\n    std::istreambuf_iterator<char> ret =\n        std::use_facet<std::time_get<char>>(str.getloc()).get_weekday(\n            {str}, {}, str, err, &t\n        );\n    str.setstate(err);\n    std::istreambuf_iterator<char> last{};\n    if(str) {\n        std::cout << \"Successfully parsed, weekday number is \" << t.tm_wday;\n        if(ret != last) {\n            std::cout << \" Remaining content: \";\n            std::copy(ret, last, std::ostreambuf_iterator<char>(std::cout));\n        } else {\n            std::cout << \" the input was fully consumed\";\n        }\n    } else {\n        std::cout << \"Parse failed. Unparsed string: \";\n        std::copy(ret, last, std::ostreambuf_iterator<char>(std::cout));\n    }\n    std::cout << '\\n';\n}\nint main()\n{\n    std::locale::global(std::locale(\"lt_LT.utf8\"));\n    try_get_wday(\"\u0160t\");\n    try_get_wday(\"\u0160e\u0161tadienis\");\n \n    std::locale::global(std::locale(\"en_US.utf8\"));\n    try_get_wday(\"SATELLITE\");\n \n    std::locale::global(std::locale(\"ja_JP.utf8\"));\n    try_get_wday(\"\u571f\u66dc\u65e5\");\n}",
            "output": "Parsing the weekday out of '\u0160t' in the locale lt_LT.utf8\nSuccessfully parsed, weekday number is 6 the input was fully consumed\nParsing the weekday out of '\u0160e\u0161tadienis' in the locale lt_LT.utf8\nSuccessfully parsed, weekday number is 6 the input was fully consumed\nParsing the weekday out of 'SATELLITE' in the locale en_US.utf8\nSuccessfully parsed, weekday number is 6 Remaining content: ELLITE\nParsing the weekday out of '\u571f\u66dc\u65e5' in the locale ja_JP.utf8\nSuccessfully parsed, weekday number is 6 the input was fully consumed"
        }
    },
    "time_get::get_monthname, std::time_get::do_get_monthname": {
        "description": {
            "texte": "If it finds abbreviated name, followed by the characters that are valid for the full name, it continues reading until it consumes all the characters for the full name or finds a character that isn't expected, in which case parsing fails even if the first few characters were a valid abbreviation.The parsed month is stored in the std::tm field t->tm_mon.If the end iterator is reached before a valid month name is read, the function sets std::ios_base::eofbit in err. If a parsing error is encountered, the function sets std::ios_base::failbit in err."
        },
        "parametres": "   beg   -   iterator designating the start of the sequence to parse \n   end   -   one past the end iterator for the sequence to parse \n   str   -   a stream object that this function uses to obtain locale facets when needed, e.g. std::ctype to skip whitespace or std::collate to compare strings \n   err   -   stream error flags object that is modified by this function to indicate errors \n   t   -   pointer to the std::tm object that will hold the result of this function call \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n#include <sstream>\n#include <iterator>\n#include <ctime>\n \nvoid try_get_mon(const std::string& s)\n{\n    std::cout << \"Parsing the month out of '\" << s <<\n                 \"' in the locale \" << std::locale().name() << '\\n';\n    std::istringstream str(s);\n    std::ios_base::iostate err = std::ios_base::goodbit;\n \n    std::tm t;\n    std::istreambuf_iterator<char> ret =\n        std::use_facet<std::time_get<char>>(str.getloc()).get_monthname(\n            {str}, {}, str, err, &t\n        );\n    str.setstate(err);\n    std::istreambuf_iterator<char> last{};\n    if(str) {\n        std::cout << \"Successfully parsed, month number is \" << t.tm_mon;\n        if(ret != last) {\n            std::cout << \". Remaining content: \";\n            std::copy(ret, last, std::ostreambuf_iterator<char>(std::cout));\n        } else {\n            std::cout << \". The input was fully consumed\";\n        }\n    } else {\n        std::cout << \"Parse failed. Unparsed string: \";\n        std::copy(ret, last, std::ostreambuf_iterator<char>(std::cout));\n    }\n    std::cout << '\\n';\n}\nint main()\n{\n    std::locale::global(std::locale(\"ja_JP.utf8\"));\n    try_get_mon(\"2\u6708\");\n    std::locale::global(std::locale(\"th_TH.utf8\"));\n    try_get_mon(\"\u0e01\u0e38\u0e21\u0e20\u0e32\u0e1e\u0e31\u0e19\u0e18\u0e4c\");\n    std::locale::global(std::locale(\"el_GR.utf8\"));\n    try_get_mon(\"\u03a6\u03b5\u03b2\");\n    try_get_mon(\"\u03a6\u03b5\u03b2\u03c1\u03bf\u03c5\u03ac\u03c1\u03b9\u03bf\u03c2\");\n    std::locale::global(std::locale(\"en_US.utf8\"));\n    try_get_mon(\"Febrile\");\n}",
            "output": "Parsing the month out of '2\u6708' in the locale ja_JP.utf8\nSuccessfully parsed, month number is 1. The input was fully consumed\nParsing the month out of '\u0e01\u0e38\u0e21\u0e20\u0e32\u0e1e\u0e31\u0e19\u0e18\u0e4c' in the locale th_TH.utf8\nSuccessfully parsed, month number is 1. The input was fully consumed\nParsing the month out of '\u03a6\u03b5\u03b2' in the locale el_GR.utf8\nSuccessfully parsed, month number is 1. The input was fully consumed\nParsing the month out of '\u03a6\u03b5\u03b2\u03c1\u03bf\u03c5\u03ac\u03c1\u03b9\u03bf\u03c2' in the locale el_GR.utf8\nSuccessfully parsed, month number is 1. The input was fully consumed\nParsing the month out of 'Febrile' in the locale en_US.utf8\nParse failed. Unparsed string: ile"
        }
    },
    "time_get::get_year, std::time_get::do_get_year": {
        "description": {
            "texte": "The parsed year is stored in the std::tm structure field t->tm_year.If the end iterator is reached before a valid date is read, the function sets std::ios_base::eofbit in err. If a parsing error is encountered, the function sets std::ios_base::failbit in err."
        },
        "parametres": "   beg   -   iterator designating the start of the sequence to parse \n   end   -   one past the end iterator for the sequence to parse \n   str   -   a stream object that this function uses to obtain locale facets when needed, e.g. std::ctype to skip whitespace or std::collate to compare strings \n   err   -   stream error flags object that is modified by this function to indicate errors \n   t   -   pointer to the std::tm object that will hold the result of this function call \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n#include <sstream>\n#include <iterator>\n \nvoid try_get_year(const std::string& s)\n{\n    std::cout << \"Parsing the year out of '\" << s <<\n                 \"' in the locale \" << std::locale().name() << '\\n';\n    std::istringstream str(s);\n    std::ios_base::iostate err = std::ios_base::goodbit;\n \n    std::tm t;\n    std::istreambuf_iterator<char> ret =\n        std::use_facet<std::time_get<char>>(str.getloc()).get_year(\n            {str}, {}, str, err, &t\n        );\n    str.setstate(err);\n    std::istreambuf_iterator<char> last{};\n    if (str) {\n        std::cout << \"Successfully parsed, year is \" << 1900 + t.tm_year;\n        if (ret != last) {\n            std::cout << \" Remaining content: \";\n            std::copy(ret, last, std::ostreambuf_iterator<char>(std::cout));\n        } else {\n            std::cout << \" the input was fully consumed\";\n        }\n    } else {\n        std::cout << \"Parse failed. Unparsed string: \";\n        std::copy(ret, last, std::ostreambuf_iterator<char>(std::cout));\n    }\n    std::cout << '\\n';\n}\n \nint main()\n{\n    std::locale::global(std::locale(\"en_US.utf8\"));\n    try_get_year(\"13\");\n    try_get_year(\"2013\");\n \n    std::locale::global(std::locale(\"ja_JP.utf8\"));\n    try_get_year(\"2013\u5e74\");\n}",
            "output": "Parsing the year out of '13' in the locale en_US.utf8\nSuccessfully parsed, year is 2013 the input was fully consumed\nParsing the year out of '2013' in the locale en_US.utf8\nSuccessfully parsed, year is 2013 the input was fully consumed\nParsing the year out of '2013\u5e74' in the locale ja_JP.utf8\nSuccessfully parsed, year is 2013 Remaining content: \u5e74"
        }
    },
    "time_put::time_put": {
        "description": {
            "texte": "Creates a std::time_put facet and forwards the starting reference count refs to the base class constructor, locale::facet::facet()."
        },
        "parametres": "   refs   -   starting reference count \n\n"
    },
    "time_put::~time_put": {
        "description": {
            "texte": "Destructs a std::time_put facet. This destructor is protected and virtual (due to base class destructor being virtual). An object of type std::time_put, like most facets, can only be destroyed when the last std::locale object that implements this facet goes out of scope or if a user-defined class is derived from std::time_put and implements a public destructor."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nstruct Destructible_time_put : public std::time_put<wchar_t>\n{\n    Destructible_time_put(std::size_t refs = 0) : time_put(refs) {}\n    // note: the implicit destructor is public\n};\nint main()\n{\n    Destructible_time_put dc;\n    // std::time_put<wchar_t> c;  // compile error: protected destructor\n}"
        }
    },
    "time_put::put, std::time_put::do_put": {
        "description": {
            "texte": "Converts the calendar date and time stored in the std::tm object pointed to by t into a character string, according to the format string [fmtbeg, fmtend). The format string is the same as used by std::srtftime, but each format specifier is processed by an individual call to do_put(), which can be customized by extending this facet."
        },
        "parametres": "   out   -   output iterator where the result of the conversion is written \n   str   -   a stream object that this function uses to obtain locale facets when needed, e.g. std::ctype to narrow characters \n   t   -   pointer to the std::tm object from which the date/time values are obtained \n   fmtbeg   -   pointer to the first character of a sequence of char_type characters specifying the conversion format The format string consists of zero or more conversion specifiers and ordinary characters (except %). All ordinary characters, including the terminating null character, are copied to the output string without modification. Each conversion specification begins with % character, optionally followed by E or O modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The following format specifiers are available:\n   Conversion specifier   Explanation   Used fields \n   %   writes literal %. The full conversion specification must be %%.   \n   n(C++11)   writes newline character   \n   t(C++11)   writes horizontal tab character   \n   Year \n   Y   writes year as a decimal number, e.g. 2017   tm_year \n   EY(C++11)   writes year in the alternative representation, e.g.\u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   tm_year \n   y   writes last 2 digits of year as a decimal number (range [00,99])   tm_year \n   Oy(C++11)   writes last 2 digits of year using the alternative numeric system, e.g. \u5341\u4e00 instead of 11 in ja_JP locale   tm_year \n   Ey(C++11)   writes year as offset from locale's alternative calendar period %EC (locale-dependent)   tm_year \n   C(C++11)   writes first 2 digits of year as a decimal number (range [00,99])   tm_year \n   EC(C++11)   writes name of the base year (period) in the locale's alternative representation, e.g. \u5e73\u6210 (Heisei era) in ja_JP   tm_year \n   G(C++11)   writes ISO 8601 week-based year, i.e. the year that contains the specified week. In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday \n   g(C++11)   writes last 2 digits of ISO 8601 week-based year, i.e. the year that contains the specified week (range [00,99]). In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday \n   Month \n   b   writes abbreviated month name, e.g. Oct (locale dependent)   tm_mon \n   h(C++11)   synonym of b   tm_mon \n   B   writes full month name, e.g. October (locale dependent)   tm_mon \n   m   writes month as a decimal number (range [01,12])   tm_mon \n   Om(C++11)   writes month using the alternative numeric system, e.g. \u5341\u4e8c instead of 12 in ja_JP locale   tm_mon \n   Week \n   U   writes week of the year as a decimal number (Sunday is the first day of the week) (range [00,53])   tm_year, tm_wday, tm_yday \n   OU(C++11)   writes week of the year, as by %U, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday \n   W   writes week of the year as a decimal number (Monday is the first day of the week) (range [00,53])   tm_year, tm_wday, tm_yday \n   OW(C++11)   writes week of the year, as by %W, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday \n   V(C++11)   writes ISO 8601 week of the year (range [01,53]). In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday \n   OV(C++11)   writes week of the year, as by %V, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday \n   Day of the year/month \n   j   writes day of the year as a decimal number (range [001,366])   tm_yday \n   d   writes day of the month as a decimal number (range [01,31])   tm_mday \n   Od(C++11)   writes zero-based day of the month using the alternative numeric system, e.g \u4e8c\u5341\u4e03 instead of 27 in ja_JP locale Single character is preceded by a space.\n  tm_mday \n   e(C++11)   writes day of the month as a decimal number (range [1,31]). Single digit is preceded by a space.\n  tm_mday \n   Oe(C++11)   writes one-based day of the month using the alternative numeric system, e.g. \u4e8c\u5341\u4e03 instead of 27 in ja_JP locale Single character is preceded by a space.\n  tm_mday \n   Day of the week \n   a   writes abbreviated weekday name, e.g. Fri (locale dependent)   tm_wday \n   A   writes full weekday name, e.g. Friday (locale dependent)   tm_wday \n   w   writes weekday as a decimal number, where Sunday is 0 (range [0-6])   tm_wday \n   Ow(C++11)   writes weekday, where Sunday is 0, using the alternative numeric system, e.g. \u4e8c instead of 2 in ja_JP locale   tm_wday \n   u(C++11)   writes weekday as a decimal number, where Monday is 1 (ISO 8601 format) (range [1-7])   tm_wday \n   Ou(C++11)   writes weekday, where Monday is 1, using the alternative numeric system, e.g. \u4e8c instead of 2 in ja_JP locale   tm_wday \n   Hour, minute, second \n   H   writes hour as a decimal number, 24 hour clock (range [00-23])   tm_hour \n   OH(C++11)   writes hour from 24-hour clock using the alternative numeric system, e.g. \u5341\u516b instead of 18 in ja_JP locale   tm_hour \n   I   writes hour as a decimal number, 12 hour clock (range [01,12])   tm_hour \n   OI(C++11)   writes hour from 12-hour clock using the alternative numeric system, e.g. \u516d instead of 06 in ja_JP locale   tm_hour \n   M   writes minute as a decimal number (range [00,59])   tm_min \n   OM(C++11)   writes minute using the alternative numeric system, e.g. \u4e8c\u5341\u4e94 instead of 25 in ja_JP locale   tm_min \n   S   writes second as a decimal number (range [00,60])   tm_sec \n   OS(C++11)   writes second using the alternative numeric system, e.g. \u4e8c\u5341\u56db instead of 24 in ja_JP locale   tm_sec \n   Other \n   c   writes standard date and time string, e.g. Sun Oct 17 04:41:13 2010 (locale dependent)   all \n   Ec(C++11)   writes alternative date and time string, e.g. using \u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   all \n   x   writes localized date representation (locale dependent)   all \n   Ex(C++11)   writes alternative date representation, e.g. using \u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   all \n   X   writes localized time representation (locale dependent)   all \n   EX(C++11)   writes alternative time representation (locale dependent)   all \n   D(C++11)   equivalent to \"%m/%d/%y\"   tm_mon, tm_mday, tm_year \n   F(C++11)   equivalent to \"%Y-%m-%d\" (the ISO 8601 date format)   tm_mon, tm_mday, tm_year \n   r(C++11)   writes localized 12-hour clock time (locale dependent)   tm_hour, tm_min, tm_sec \n   R(C++11)   equivalent to \"%H:%M\"   tm_hour, tm_min \n   T(C++11)   equivalent to \"%H:%M:%S\" (the ISO 8601 time format)   tm_hour, tm_min, tm_sec \n   p   writes localized a.m. or p.m. (locale dependent)   tm_hour \n   z(C++11)   writes offset from UTC in the ISO 8601 format (e.g. -0430), or no characters if the time zone information is not available   tm_isdst \n   Z   writes locale-dependent time zone name or abbreviation, or no characters if the time zone information is not available   tm_isdst \n\n \n   fmtend   -   pointer one past the last character of a sequence of char_type characters specifying the conversion format \n   fill   -   fill character (usually space) \n   format   -   the character that names a conversion specifier \n   modifier   -   the optional modifier that may appear between % and the conversion specifier \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <ctime>\n \nvoid try_time_put(const std::tm* t, const std::string& fmt)\n{\n        std::cout.imbue(std::locale());\n        std::cout << \"In the locale '\" << std::cout.getloc().name() << \"' : '\";\n \n        std::use_facet<std::time_put<char>>(std::cout.getloc()).put(\n                    {std::cout}, std::cout, ' ', t, &fmt[0], &fmt[0] + fmt.size());\n \n        std::cout << \"'\\n\";\n}\n \nint main()\n{\n    std::time_t t = std::time(NULL);\n    std::tm tm = *std::localtime(&t);\n \n    std::string fmt = \"%c\";\n    std::cout << \"Using the format string '\" << fmt\n              << \"' to format the time: \" << std::ctime(&t) << '\\n';\n \n    std::locale::global(std::locale(\"de_DE.utf8\"));\n    try_time_put(&tm, fmt);\n \n    std::locale::global(std::locale(\"el_GR.utf8\"));\n    try_time_put(&tm, fmt);\n \n    std::locale::global(std::locale(\"ja_JP.utf8\"));\n    try_time_put(&tm, fmt);\n}",
            "output": "Using the format string '%c' to format the time: Mon Feb 11 22:58:50 2013\n \nIn the locale 'de_DE.utf8' : 'Mo 11 Feb 2013 23:02:38 EST'\nIn the locale 'el_GR.utf8' : '\u0394\u03b5\u03c5 11 \u03a6\u03b5\u03b2 2013 11:02:38 \u03bc\u03bc EST'\nIn the locale 'ja_JP.utf8' : '2013\u5e7402\u670811\u65e5 23\u664202\u520638\u79d2'"
        }
    },
    "num_get::num_get": {
        "description": {
            "texte": "Creates a std::num_get facet and forwards the starting reference count refs to the base class constructor, locale::facet::facet()."
        },
        "parametres": "   refs   -   starting reference count \n\n"
    },
    "num_get::~num_get": {
        "description": {
            "texte": "Destructs a std::num_get facet. This destructor is protected and virtual (due to base class destructor being virtual). An object of type std::num_get, like most facets, can only be destroyed when the last std::locale object that implements this facet goes out of scope or if a user-defined class is derived from std::num_get and implements a public destructor."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nstruct Destructible_num_get : public std::num_get<wchar_t>\n{\n    Destructible_num_get(std::size_t refs = 0) : num_get(refs) {}\n    // note: the implicit destructor is public\n};\nint main()\n{\n    Destructible_num_get dc;\n    // std::num_get<wchar_t> c;  // compile error: protected destructor\n}"
        }
    },
    "num_get::get, std::num_get::do_get": {
        "description": {
            "texte": "Conversion occurs in three stages."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iterator>\n#include <locale>\n \nstruct base { long x; };\n \ntemplate <class CharT, class Traits>\nstd::basic_istream<CharT, Traits>&\n    operator >>(std::basic_istream<CharT, Traits>& is,\n                base& b)\n{\n    std::ios_base::iostate err = std::ios_base::goodbit;\n    try // setting err could throw\n    {\n        typename std::basic_istream<CharT, Traits>::sentry s(is);\n \n        if (s) // if stream is ready for input\n        {\n            std::use_facet<std::num_get<CharT>>(is.getloc()).get(is, {}, is, err, b.x);\n        }\n    } catch(std::ios_base::failure& error)\n    {\n        // handle the exception\n    }\n    return is;\n}\n \nint main()\n{\n    base b;\n \n    std::cin >> b;\n}"
        }
    },
    "num_put::num_put": {
        "description": {
            "texte": "Creates a std::num_put facet and forwards the starting reference count refs to the base class constructor, locale::facet::facet()."
        },
        "parametres": "   refs   -   starting reference count \n\n"
    },
    "num_put::~num_put": {
        "description": {
            "texte": "Destructs a std::num_put facet. This destructor is protected and virtual (due to base class destructor being virtual). An object of type std::num_put, like most facets, can only be destroyed when the last std::locale object that implements this facet goes out of scope or if a user-defined class is derived from std::num_put and implements a public destructor."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nstruct Destructible_num_put : public std::num_put<wchar_t>\n{\n    Destructible_num_put(std::size_t refs = 0) : num_put(refs) {}\n    // note: the implicit destructor is public\n};\nint main()\n{\n    Destructible_num_put dc;\n    // std::num_put<wchar_t> c;  // compile error: protected destructor\n}"
        }
    },
    "num_put::put, std::num_put::do_put": {
        "description": {
            "texte": "Conversion occurs in four stages.In any case, str.width(0) is called to cancel the effects of std::setw.Every successive character c from the sequence of CharT's from Stage 3 is output as if by *out++ = c."
        },
        "parametres": "   out   -   iterator pointing to the first character to be overwritten \n   str   -   stream to retrieve the formatting information from \n   fill   -   padding character used when the results needs to be padded to the field width \n   v   -   value to convert to string and output \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n \n// this custom num_put outputs squares of all integers (except long long)\nstruct squaring_num_put : std::num_put<char> {\n    iter_type do_put(iter_type s, std::ios_base& f,\n                     char_type fill, long v) const\n    {\n        return std::num_put<char>::do_put(s, f, fill, v*v );\n    }\n \n    iter_type do_put(iter_type s, std::ios_base& f,\n                     char_type fill, unsigned long v) const\n    {\n        return std::num_put<char>::do_put(s, f, fill, v*v);\n    }\n};\n \nint main()\n{\n    auto& facet = std::use_facet<std::num_put<char>>(std::locale());\n    facet.put(std::cout, std::cout, '0', 2.71);\n    std::cout << '\\n';\n \n    std::cout.imbue(std::locale(std::cout.getloc(), new squaring_num_put));\n    std::cout << 6 << ' ' << -12 << '\\n';\n}",
            "output": "2.71\n36 144"
        }
    },
    "numpunct::numpunct": {
        "description": {
            "texte": "Creates a std::numpunct facet and forwards the starting reference count refs to the base class constructor, locale::facet::facet()."
        },
        "parametres": "   refs   -   starting reference count \n\n"
    },
    "numpunct::~numpunct": {
        "description": {
            "texte": "Destructs a std::numpunct facet. This destructor is protected and virtual (due to base class destructor being virtual). An object of type std::numpunct, like most facets, can only be destroyed when the last std::locale object that implements this facet goes out of scope or if a user-defined class is derived from std::numpunct and implements a public destructor."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nstruct Destructible_numpunct : public std::numpunct<wchar_t>\n{\n    Destructible_numpunct(std::size_t refs = 0) : numpunct(refs) {}\n    // note: the implicit destructor is public\n};\nint main()\n{\n    Destructible_numpunct dc;\n    // std::numpunct<wchar_t> c;  // compile error: protected destructor\n}"
        }
    },
    "numpunct::decimal_point, do_decimal_point": {
        "description": {
            "texte": "The value of type char_type to use as the decimal separator. The standard specializations of std::numpunct return '.' and L'.'."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n \nstruct slash : std::numpunct<char> {\n    char do_decimal_point()   const { return '/'; }  // separate with slash\n};\n \nint main()\n{\n    std::cout.precision(10);\n    std::cout << \"default locale: \" << 1234.5678 << '\\n';\n    std::cout.imbue(std::locale(std::cout.getloc(), new slash));\n    std::cout << \"locale with modified numpunct: \" << 1234.5678 << '\\n';\n}",
            "output": "default locale: 1234.5678\nlocale with modified numpunct: 1234/5678"
        }
    },
    "numpunct::thousands_sep, do_thousands_sep": {
        "description": {
            "texte": "The object of type char_type to use as the thousands separator. The standard specializations of std::numpunct return ',' and L','."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n \nstruct space_out : std::numpunct<char> {\n    char do_thousands_sep()   const { return ' '; }  // separate with spaces\n    std::string do_grouping() const { return \"\\1\"; } // groups of 1 digit\n};\n \nint main()\n{\n    std::cout << \"default locale: \" << 12345678 << '\\n';\n    std::cout.imbue(std::locale(std::cout.getloc(), new space_out));\n    std::cout << \"locale with modified numpunct: \" << 12345678 << '\\n';\n}",
            "output": "default locale: 12345678\nlocale with modified numpunct: 1 2 3 4 5 6 7 8"
        }
    },
    "numpunct::grouping, std::numpunct::do_grouping": {
        "description": {
            "texte": "The groups are stored as binary values: three-digit group is '\\3', and 51-digit group is '3'. The character at index zero of the returned string holds the number of digits in the rightmost group. The character at index 1 holds the number of digits in the second group from the right, etc. The grouping indicated by the last character in the returned string is reused to group all remaining digits in the (left part of) the number."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <limits>\n#include <locale>\n \nstruct space_out : std::numpunct<char>\n{\n    char do_thousands_sep()   const { return ' ';  } // separate with spaces\n    std::string do_grouping() const { return \"\\1\"; } // groups of 1 digit\n};\n \nstruct g123 : std::numpunct<char>\n{\n    std::string do_grouping() const { return \"\\1\\2\\3\"; }\n};\n \nint main()\n{\n    std::cout << \"default locale: \" << 12345678 << '\\n';\n    std::cout.imbue(std::locale(std::cout.getloc(), new space_out));\n    std::cout << \"locale with modified numpunct: \" << 12345678 << '\\n';\n    std::cout.imbue(std::locale(std::cout.getloc(), new g123));\n    std::cout << \"Locale with \\\\1\\\\2\\\\3 grouping: \" << \n              std::numeric_limits<unsigned long long>::max() << '\\n';\n}",
            "output": "default locale: 12345678\nlocale with modified numpunct: 1 2 3 4 5 6 7 8\nLocale with \\1\\2\\3 grouping: 18,446,744,073,709,551,61,5"
        }
    },
    "money_get::money_get": {
        "description": {
            "texte": "Creates a std::money_get facet and forwards the starting reference count refs to the base class constructor, locale::facet::facet()."
        },
        "parametres": "   refs   -   starting reference count \n\n"
    },
    "money_get::~money_get": {
        "description": {
            "texte": "Destructs a std::money_get facet. This destructor is protected and virtual (due to base class destructor being virtual). An object of type std::money_get, like most facets, can only be destroyed when the last std::locale object that implements this facet goes out of scope or if a user-defined class is derived from std::money_get and implements a public destructor."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nstruct Destructible_money_get : public std::money_get<wchar_t>\n{\n    Destructible_money_get(std::size_t refs = 0) : money_get(refs) {}\n    // note: the implicit destructor is public\n};\nint main()\n{\n    Destructible_money_get dc;\n    // std::money_get<wchar_t> c;  // compile error: protected destructor\n}"
        }
    },
    "money_get::get, do_get": {
        "description": {
            "texte": "Parses monetary value from an input iterator and writes the result to a long double or string.If the input iterator beg becomes equal to end before the parsing was completed, sets both failbit and eofbit in err. If parsing fails for another reason, sets the failbit in err. Either way, does not modify the output parameter ((units or digits) on error.If the parsing succeeds, does not change err, and stores the result in units or digits.The formatting pattern used by this function is always mp.neg_format().If mp.grouping() does not permit thousands separators, the first separator encountered is treated as a parsing error, otherwise they are treated as optional.If money_base::space or money_base::none is the last element in the pattern, the parser does not attempt to consume any whitespace after the other components of the monetary value were parsed. Otherwise, one or more whitespace characters are consumed where money_base::space appears.If showbase flag is set in str.flags(), the currency symbol or currency string is required, if it is not set, the currency symbol is optional.If the first character of the string returned by mp.positive_sign() or mp.negative_sign() is found in the money_base::sign position of the formatting pattern, it is consumed, and the rest of the characters in that string are expected and consumed after all other components of the monetary value. If both mp.positive_sign() and mp.negative_sign() are non-empty, the sign is required and must match the first character of one of these strings. If one of theses strings is empty, the sign is optional (and if it is absent, the sign of the result corresponds to the string that was empty). If both strings are empty, or have the same first character, the result is given the positive sign. If the output parameter is a string (digits) and the result is negative, the value ct.widen('-') is stored as the first character of the result.Digits from the input are extracted in order in which they appear and are placed in digits (after widening by ct.widen() as necessary), or into a temporary buffer buf1, from which the value of units is constructed as if by.(where n is the number of characters extracted from the input and stored in buf1 and buf2 is another sufficiently large character buffer).",
            "code": "static const char src[] = \"0123456789-\";\nCharT atoms[sizeof(src)];\nct.widen(src, src + sizeof(src) - 1, atoms);\nfor (int i = 0; i < n; ++i)\nbuf2[i] = src[find(atoms, atoms+sizeof(src), buf1[i]) - atoms];\nbuf2[n] = 0;\nsscanf(buf2, \"%Lf\", &units);"
        },
        "exemple": {
            "input": "#include <iostream>\n#include <sstream>\n#include <locale>\n \nvoid demo_money_get(std::locale loc, const std::string& input)\n{\n    std::istringstream str(input);\n    str.imbue(loc);\n    long double units;\n// note, the following can be written simple with std::get_money(units)\n    std::ios_base::iostate err = std::ios_base::goodbit;\n    std::istreambuf_iterator<char> ret =\n        std::use_facet<std::money_get<char>>(loc).get(\n                 std::istreambuf_iterator<char>(str),\n                 std::istreambuf_iterator<char>(),\n                 false, str, err, units);\n    str.setstate(err);\n    std::istreambuf_iterator<char> last{};\n    if(str) {\n        std::cout << \"Successfully parsed '\" << str.str() << \"' as \"\n                  << units/100 << \" units\\n\";\n        if(ret != last) {\n            std::cout << \"Remaining content: '\";\n            std::copy(ret, last, std::ostreambuf_iterator<char>(std::cout));\n            std::cout << \"'\\n\";\n        } else {\n            std::cout << \"The input was fully consumed\\n\";\n        }\n    } else {\n            std::cout << \"Parse failed. Unparsed string: '\";\n            std::copy(ret, last, std::ostreambuf_iterator<char>(std::cout));\n            std::cout << \"'\\n\";\n    }\n}\n \nint main()\n{\n    demo_money_get(std::locale(\"en_US.utf8\"), \"-$5.12 abc\");\n    demo_money_get(std::locale(\"ms_MY.utf8\"), \"(RM5.12) def\");\n}",
            "output": "Successfully parsed '-$5.12 abc' as -5.12 units\nRemaining content: ' abc'\nSuccessfully parsed '(RM5.12) def' as -5.12 units\nRemaining content: ' def'"
        }
    },
    "money_put::money_put": {
        "description": {
            "texte": "Creates a std::money_put facet and forwards the starting reference count refs to the base class constructor, locale::facet::facet()."
        },
        "parametres": "   refs   -   starting reference count \n\n"
    },
    "money_put::~money_put": {
        "description": {
            "texte": "Destructs a std::money_put facet. This destructor is protected and virtual (due to base class destructor being virtual). An object of type std::money_put, like most facets, can only be destroyed when the last std::locale object that implements this facet goes out of scope or if a user-defined class is derived from std::money_put and implements a public destructor."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nstruct Destructible_money_put : public std::money_put<wchar_t>\n{\n    Destructible_money_put(std::size_t refs = 0) : money_put(refs) {}\n    // note: the implicit destructor is public\n};\nint main()\n{\n    Destructible_money_put dc;\n    // std::money_put<wchar_t> c;  // compile error: protected destructor\n}"
        }
    },
    "money_put::put, do_put": {
        "description": {
            "texte": "Formats monetary value and writes the result to output stream.Given the character sequence from the previous steps, if the first character equals ct.widen('-'), calls mp.neg_format() to obtain the formatting pattern, otherwise calls mp.pos_format(), where mp is the std::moneypunct<CharT, intl> facet imbued in str.getloc().Thousands separator and decimal point characters are inserted as required by mp.grouping(), mp.frac_digits(), mp.decimal_point(), and mp.thousands_sep(), and the resulting string is placed in the output sequence where value appears in the formatting pattern.If str.flags() & str.showbase is non-zero (the std::showbase manipulator was used), then the currency symbol or string is generated by calling mp.curr_symbol() and placed in the output sequence where symbol appears in the formatting pattern.If mp.positive_sign() (in case positive format pattern is used) or mp.negative_sign() (in case negative format pattern is used) returns a string with more than one character, the first character returned is placed in the output sequence where sign appears in the formatting pattern, and the rest of the characters are placed after all other characters, for example, formatting pattern {sign, value, space, symbol} with units 123 and negative_sign of \"-\" may result in \"-1.23 \u20ac\", while negative_sign of \"()\" would generate \"(1.23 \u20ac)\".If the number of characters generated for the specified format is less than the value returned by str.width(), then copies of fill are inserted to bring the total length of the output sequence to exactly str.width(), as follows:In the end, calls str.width(0) to cancel the effects of any std::setw."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <locale>\n \nstruct my_punct : std::moneypunct_byname<char, false> {\n    my_punct(const char* name) : moneypunct_byname(name) {}\n    string_type do_negative_sign() const { return \"()\"; }\n};\n \nint main()\n{\n    std::locale loc(\"ru_RU.utf8\");\n    std::cout.imbue(loc);\n    long double units = -123.45;\n    std::cout << \"In Russian locale, \" << units << \" prints as \"\n              << std::showbase;\n// note, the following is equivalent to simply std::put_money(units)\n    std::use_facet<std::money_put<char>>(loc).put(\n             {std::cout}, false, std::cout, std::cout.fill(), units);\n    std::cout << '\\n';\n \n    std::cout.imbue(std::locale(std::cout.getloc(), new my_punct(\"ru_RU.utf8\")));\n    std::cout << \"With negative_sign set to \\\"()\\\", it prints  as \";\n    std::use_facet<std::money_put<char>>(loc).put(\n             {std::cout}, false, std::cout, std::cout.fill(), units);\n    std::cout << '\\n';\n}",
            "output": "In Russian locale, -123,45 prints as -1.23 \u0440\u0443\u0431\nWith negative_sign set to \"()\", it prints  as (1.23 \u0440\u0443\u0431)"
        }
    },
    "moneypunct::moneypunct": {
        "description": {
            "texte": "Creates a std::moneypunct facet and forwards the starting reference count refs to the base class constructor, locale::facet::facet()."
        },
        "parametres": "   refs   -   starting reference count \n\n"
    },
    "moneypunct::~moneypunct": {
        "description": {
            "texte": "Destructs a std::moneypunct facet. This destructor is protected and virtual (due to base class destructor being virtual). An object of type std::moneypunct, like most facets, can only be destroyed when the last std::locale object that implements this facet goes out of scope or if a user-defined class is derived from std::moneypunct and implements a public destructor."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nstruct Destructible_moneypunct : public std::moneypunct<wchar_t>\n{\n    Destructible_moneypunct(std::size_t refs = 0) : moneypunct(refs) {}\n    // note: the implicit destructor is public\n};\nint main()\n{\n    Destructible_moneypunct dc;\n    // std::moneypunct<wchar_t> c;  // compile error: protected destructor\n}"
        }
    },
    "moneypunct::decimal_point, do_decimal_point": {
        "description": {
            "texte": "The object of type CharT holding the decimal point character."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <locale>\n \nvoid show_dpt(const char* locname)\n{\n    std::locale loc(locname);\n    std::cout.imbue(loc);\n    std::cout << locname << \" decimal point is '\"\n              << std::use_facet<std::moneypunct<char>>(loc).decimal_point()\n              << \"' for example: \" << std::showbase << std::put_money(123);\n    if (std::use_facet<std::moneypunct<char>>(loc).frac_digits() == 0)\n        std::cout << \" (does not use frac digits) \";\n \n    std::cout << '\\n';\n}\n \nint main()\n{\n    show_dpt(\"en_US.utf8\");\n    show_dpt(\"ja_JP.utf8\");\n    show_dpt(\"sv_SE.utf8\");\n    show_dpt(\"de_DE.utf8\");\n \n}",
            "output": "en_US.utf8 decimal point is '.' for example: $1.23\nja_JP.utf8 decimal point is '.' for example: \uffe5123 (does not use frac digits)\nsv_SE.utf8 decimal point is ',' for example: 1,23 kr\nde_DE.utf8 decimal point is ',' for example: 1,23 \u20ac"
        }
    },
    "moneypunct::thousands_sep, do_thousands_sep": {
        "description": {
            "texte": "The object of type char_type to use as the thousands separator. In common U.S. locales, this is ',' or L','."
        },
        "exemple": {
            "input": "#include <locale>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\nstruct space_out : std::moneypunct<char> {\n    pattern do_pos_format()      const { return { {value, none, none, none} };}\n    int do_frac_digits()         const { return 0; }\n    char_type do_thousands_sep() const { return ' ';}\n    string_type do_grouping()    const { return \"\\002\";}\n};\nint main()\n{\n    std::cout.imbue(std::locale(\"en_US.UTF-8\"));\n    std::cout << \"american locale: \" << std::showbase\n              << std::put_money(12345678.0)<< '\\n';\n \n    std::cout.imbue(std::locale(std::cout.getloc(), new space_out));\n    std::cout << \"locale with modified moneypunct: \"\n              << std::put_money(12345678.0)<< '\\n';\n}",
            "output": "american locale: $123,456.78\nlocale with modified moneypunct: 12 34 56 78"
        }
    },
    "moneypunct::grouping, do_grouping": {
        "description": {
            "texte": "The object of type std::string holding the groups. The standard specializations of std::moneypunct return an empty string, indicating no grouping. Typical groupings (e.g. the en_US locale) return \"\\003\"."
        },
        "exemple": {
            "input": "#include <locale>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\nstruct space_out : std::moneypunct<char> {\n    pattern do_pos_format()      const { return { {value, none, none, none} };}\n    int do_frac_digits()         const { return 0; }\n    char_type do_thousands_sep() const { return ' ';}\n    string_type do_grouping()    const { return \"\\002\";}\n};\nint main()\n{\n    std::cout.imbue(std::locale(\"en_US.UTF-8\"));\n    std::cout << \"american locale: \" << std::showbase\n              << std::put_money(12345678.0)<< '\\n';\n \n    std::cout.imbue(std::locale(std::cout.getloc(), new space_out));\n    std::cout << \"locale with modified moneypunct: \"\n              << std::put_money(12345678.0)<< '\\n';\n}",
            "output": "american locale: $123,456.78\nlocale with modified moneypunct: 12 34 56 78"
        }
    },
    "moneypunct::curr_symbol, do_curr_symbol": {
        "description": {
            "texte": "The object of type string_type holding the currency symbol or code."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\nvoid show_ccy(const char* locname)\n{\n    std::locale loc(locname);\n    std::cout << locname << \" currency symbol is \"\n              << std::use_facet<std::moneypunct<char, true>>(loc).curr_symbol()\n              << \"or \" << std::use_facet<std::moneypunct<char>>(loc).curr_symbol()\n              << \" for short\\n\";\n}\nint main()\n{\n    show_ccy(\"en_US.utf8\");\n    show_ccy(\"ja_JP.utf8\");\n    show_ccy(\"sv_SE.utf8\");\n    show_ccy(\"ru_RU.utf8\");\n    show_ccy(\"vi_VN.utf8\");\n}",
            "output": "en_US.utf8 currency symbol is USD or $ for short\nja_JP.utf8 currency symbol is JPY or \uffe5 for short\nsv_SE.utf8 currency symbol is SEK or kr for short\nru_RU.utf8 currency symbol is RUB or \u0440\u0443\u0431 for short\nvi_VN.utf8 currency symbol is VND or \u20ab for short"
        }
    },
    "moneypunct::frac_digits, do_frac_digits": {
        "description": {
            "texte": "The number of digits to be displayed after the decimal point. In common U.S. locales, this is the value 2."
        },
        "exemple": {
            "input": "#include <locale>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\nstruct space_out : std::moneypunct<char> {\n    pattern do_pos_format()      const { return { {value, none, none, none} };}\n    int do_frac_digits()         const { return 0; }\n    char_type do_thousands_sep() const { return ' ';}\n    string_type do_grouping()    const { return \"\\002\";}\n};\nint main()\n{\n    std::cout.imbue(std::locale(\"en_US.UTF-8\"));\n    std::cout << \"american locale: \" << std::showbase\n              << std::put_money(12345678.0)<< '\\n';\n \n    std::cout.imbue(std::locale(std::cout.getloc(), new space_out));\n    std::cout << \"locale with modified moneypunct: \"\n              << std::put_money(12345678.0)<< '\\n';\n}",
            "output": "american locale: $123,456.78\nlocale with modified moneypunct: 12 34 56 78"
        }
    },
    "moneypunct::positive_sign, do_positive_sign, negative_sign, do_negative_sign": {
        "description": {
            "texte": "Only the first character of the string returned is the character that appears in the pos_format()/neg_format() position indicated by the value sign. The rest of the characters appear after the rest of the monetary string.In particular, for negative_sign of \"-\", the formatting may appear as \"-1.23 \u20ac\", while for negative_sign of \"()\" it would appear as \"(1.23 \u20ac)\"."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <iomanip>\n#include <locale>\n \nstruct my_punct : std::moneypunct_byname<char, false> {\n    my_punct(const char* name) : moneypunct_byname(name) {}\n    string_type do_negative_sign() const { return \"()\"; }\n};\n \nint main()\n{\n    std::locale loc(\"de_DE.utf8\");\n    std::cout.imbue(loc);\n    std::cout << loc.name() << \" negative sign is '\"\n              << std::use_facet<std::moneypunct<char>>(loc).negative_sign()\n              << \"' for example: \" << std::showbase << std::put_money(-1234) << '\\n';\n \n    std::locale loc2(\"ms_MY.utf8\");\n    std::cout.imbue(loc2);\n    std::cout << loc2.name() << \" negative sign is '\"\n              << std::use_facet<std::moneypunct<char>>(loc2).negative_sign()\n              << \"' for example: \" << std::put_money(-1234) << '\\n';\n \n    std::cout.imbue(std::locale(std::cout.getloc(), new my_punct(\"de_DE.utf8\")));\n    std::cout << \"de_DE.utf8 with negative_sign set to \\\"()\\\": \"\n              << std::put_money(-1234) << '\\n';\n \n}",
            "output": "de_DE.utf8 negative sign is '-' for example: -12,34 \u20ac\nms_MY.utf8 negative sign is '()' for example: (RM12.34)\nde_DE.utf8 with negative_sign set to \"()\": (12,34 \u20ac)"
        }
    },
    "moneypunct::pos_format, do_pos_format, neg_format, do_neg_format": {
        "description": {
            "texte": "The standard specializations of std::moneypunct return the pattern {symbol, sign, none, value}"
        },
        "exemple": {
            "input": "#include <locale>\n#include <iostream>\n#include <iomanip>\n \nstruct my_punct : std::moneypunct_byname<char, false> {\n    my_punct(const char* name) : moneypunct_byname(name) {}\n    pattern do_pos_format() const { return { {value, space, symbol, sign} };}\n    pattern do_neg_format() const { return { {value, space, symbol, sign} };}\n};\nint main()\n{\n    std::cout.imbue(std::locale(\"en_US.utf8\"));\n    std::cout << \"american locale: \" << std::showbase\n              << std::put_money(12345678.0) << '\\n';\n \n    std::cout.imbue(std::locale(std::cout.getloc(), new my_punct(\"en_US.utf8\")));\n    std::cout << \"locale with modified moneypunct:\\n\"\n              << std::put_money(12345678.0)  << '\\n'\n              << std::put_money(-12345678.0) << '\\n';\n}",
            "output": "american locale: $123,456.78\nlocale with modified moneypunct:\n123,456.78 $\n123,456.78 $-"
        }
    },
    "ctype_byname\n": {
        "description": {
            "texte": "This specialization of std::ctype_byname encapsulates character classification features for type char. Like its base class std::ctype<char> and unlike general-purpose std::ctype_byname, table lookup is used to classify characters."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n \nint main()\n{\n    char c = '\\xde'; // capital letter thorn\n \n    std::locale loc(\"C\");\n \n    std::cout << \"isupper('\u00de', C locale) returned \"\n               << std::boolalpha << std::isupper(c, loc) << '\\n';\n \n    loc = std::locale(loc, new std::ctype_byname<char>(\"en_US.utf8\"));\n \n    std::cout << \"isupper('\u00de', C locale with Unicode ctype<char>) returned \"\n              << std::boolalpha << std::isupper(c, loc) << '\\n';\n \n    loc = std::locale(loc, new std::ctype_byname<char>(\"is_IS.iso88591\"));\n \n    std::cout << \"isupper('\u00de', C locale with Islandic ctype<char>) returned \"\n              << std::boolalpha << std::isupper(c, loc) << '\\n';\n}",
            "output": "isupper('\u00de', C locale) returned false\nisupper('\u00de', C locale with Unicode ctype<char>) returned false\nisupper('\u00de', C locale with Islandic ctype<char>) returned true"
        }
    },
    "basic_regex::basic_regex": {
        "description": {
            "texte": "Constructs a new regular expression from a sequence of characters interpreted according to the flags f."
        },
        "parametres": "   s   -   pointer to a null-terminated string \n   count   -   length of a character sequence used to initialize the regex \n   first, last   -   range of a character sequence used to initialize the regex \n   str   -   a basic_string used as a source used to initialize the regex \n   other   -   another regex to use as source to initialize the regex \n   init   -   initializer list used to initialize the regex \n   f   -   flags used to guide the interpretation of the character sequence as a regular expression \n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n\n"
    },
    "basic_regex::operator=": {
        "description": {
            "texte": "Assigns the contents."
        },
        "parametres": "   other   -   another regex object \n   ptr   -   pointer to a null-terminated character string \n   il   -   initializer list containing characters to assign \n   p   -   string containing characters to assign \n\n"
    },
    "basic_regex::assign": {
        "description": {
            "texte": "Assigns the contents to the regular expression."
        },
        "parametres": "   other   -   another regular expression to assign \n   s   -   pointer to a character sequence to assign \n   str   -   string to assign \n   first, last   -   the range of characters to assign \n   ilist   -   initializer list containing characters to assign \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n"
    },
    "basic_regex::mark_count": {
        "description": {
            "texte": "Returns the number of marked sub-expressions (also known as capture groups) within the regular expression."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <regex>\n \nint main()\n{    \n    std::regex r1{\"abcde\"};\n    std::cout << \"r1 has \" << r1.mark_count() << \" subexpressions\" <<  '\\n';\n    //  Expected: 0\n \n    std::regex r2{\"ab(c)de\"};\n    std::cout << \"r2 has \" << r2.mark_count() << \" subexpressions\" << '\\n';\n    //  Expected: 1\n \n    std::regex r3{\"a(bc)d(e)\"}; \n    std::cout << \"r3 has \" << r3.mark_count() << \" subexpressions\" << '\\n';\n    //  Expected: 2\n \n    //  nested sub-expressions\n    std::regex r4{\"abc(de(fg))\"};\n    std::cout << \"r4 has \" << r4.mark_count() << \" subexpressions\" << '\\n';\n    //  Expected: 2\n \n    //  escaped parentheses\n    std::regex r5{\"a(bc\\\\(\\\\)de)\"};\n    std::cout << \"r5 has \" << r5.mark_count() << \" subexpressions\" << '\\n';\n    //  Expected: 1\n \n    //  using nosubs flag\n    std::regex r6 {\"ab(c)de\", std::regex_constants::nosubs};\n    std::cout << \"r6 has \" << r6.mark_count() << \" subexpressions\" << '\\n';\n    //  Expected: 0\n}",
            "output": "r1 has 0 subexpressions\nr2 has 1 subexpressions\nr3 has 2 subexpressions\nr4 has 2 subexpressions\nr5 has 1 subexpressions\nr6 has 0 subexpressions"
        }
    },
    "basic_regex::flags": {
        "description": {
            "texte": "Returns the regular expression syntax flags as set in the constructor or the last call to assign()."
        }
    },
    "basic_regex::getloc": {
        "description": {
            "texte": "Returns the current locale associated with the regular expression.Effectively calls traits_i.getloc() where traits_i is a default initialized instance of the type Traits, stored within the regular expression object."
        }
    },
    "basic_regex::imbue": {
        "description": {
            "texte": "Replaces the current locale with loc. The regular expression does not match any character sequence after the call.Effectively calls traits_i.imbue(loc) where traits_i is a default initialized instance of the type Traits stored within the regular expression object."
        },
        "parametres": "   loc   -   new locale to use \n\n"
    },
    "basic_regex::swap": {
        "description": {
            "texte": "Exchanges the contents of two regular expressions."
        },
        "parametres": "   other   -   the regular expression to swap with \n\n"
    },
    "basic_regex constants": {
        "description": {
            "texte": "std::basic_regex defines several constants that govern general regex matching syntax.These constants are duplicated from std::regex_constants:At most one grammar option must be chosen out of ECMAScript, basic, extended, awk, grep, egrep. If no grammar is chosen, ECMAScript is assumed to be selected. The other options serve as modifiers, such that std::regex(\"meow\", std::regex::icase) is equivalent to std::regex(\"meow\", std::regex::ECMAScript|std::regex::icase)."
        }
    },
    "deduction guides for std::basic_regex\n": {
        "description": {
            "texte": "This deduction guide is provided for std::basic_regex to allow deduction from an iterator range."
        },
        "exemple": {
            "input": "#include <regex>\n#include <vector>\nint main() {\n   std::vector<char> v = {'a', 'b', 'c'};\n   std::basic_regex re{v.begin(), v.end()}; // uses explicit deduction guide\n}"
        }
    },
    "sub_match::sub_match": {
        "description": {
            "texte": "Default constructs a std::sub_match. The matched member is set to false and the value of other members is undefined.This is the only publicly accessible and defined constructor."
        }
    },
    "sub_match::length": {
        "description": {
            "texte": "(none)."
        }
    },
    "sub_match::operator string_type, std::sub_match::str": {
        "description": {
            "texte": "Converts to an object of the underlying std::basic_string type.The first version is an implicit conversion, the second one is explicit."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <regex>\n#include <string>\nint main()\n{\n  std::ssub_match sm;\n  std::string s = sm;  // implicit conversion\n  std::cout << s.length() << '\\n';\n}",
            "output": "\u200b0\u200b"
        }
    },
    "sub_match::compare": {
        "description": {
            "texte": "This function is infrequently used directly by application code. Instead, one of the non-member comparison operators are used."
        },
        "parametres": "   m   -   a reference to another sub_match \n   s   -   a reference to a string to compare to \n   c   -   a pointer to a null-terminated character sequence of the underlying value_type to compare to \n\n"
    },
    "match_results::~match_results": {
        "description": {
            "texte": "Destructs the match_results object and the associated sub-matches."
        }
    },
    "match_results::operator=": {
        "description": {
            "texte": "Assigns the contents."
        },
        "parametres": "   other   -   another match results object \n\n"
    },
    "match_results::get_allocator": {
        "description": {
            "texte": "Returns the allocator associated with the object."
        }
    },
    "match_results::ready": {
        "description": {
            "texte": "Indicates if the match results are ready (valid) or not.A default-constructed match result has no result state (is not ready), and can only be made ready by one of the regex algorithms. The ready state implies that all match results have been fully established.The result of calling most member functions of the match_results object that is not ready is undefined."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <regex>\n#include <string>\n \nint main()\n{\n    std::string target(\"pattern\");\n    std::smatch sm;\n    std::cout << \"default constructed smatch is \"\n              << (sm.ready() ? \" ready\\n\" : \" not ready\\n\");\n \n    std::regex re1(\"tte\");\n    std::regex_search(target, sm, re1);\n \n    std::cout << \"after search, smatch is \"\n              << (sm.ready() ? \" ready\\n\" : \" not ready\\n\");\n}",
            "output": "default constructed smatch is  not ready\nafter search, smatch is  ready"
        }
    },
    "match_results::size": {
        "description": {
            "texte": "Returns the number of submatches, i.e. std::distance(begin(), end()).Returns 0 if *this does not represent the result of a successful match."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <regex>\n#include <string>\n \nint main()\n{\n    std::regex re(\"a(a)*b\");\n    std::string target(\"aaab\");\n    std::smatch sm;\n \n    std::cout << sm.size() << '\\n';\n \n    std::regex_match(target, sm, re);\n    std::cout << sm.size() << '\\n';\n}",
            "output": "0\n2"
        }
    },
    "match_results::max_size": {
        "description": {
            "texte": "Returns the maximum number of submatches the match_results type is able to hold due to system or library implementation limitations, i.e. std::distance(begin(), end()) for the largest number of submatches."
        }
    },
    "match_results::empty": {
        "description": {
            "texte": "Checks whether the match was successful."
        }
    },
    "match_results::length": {
        "description": {
            "texte": "Returns the length of the specified sub-match.If n == 0, the length of the entire matched expression is returned.If n > 0 && n < size(), the length of nth sub-match is returned.if n >= size(), a length of the unmatched match is returned.The call is equivalent to (*this)[n].length()."
        },
        "parametres": "   n   -   integral number specifying which match to examine \n\n"
    },
    "match_results::position": {
        "description": {
            "texte": "Returns the position of the first character of the specified sub-match.If n == 0, the position of the first character of the entire matched expression is returned.If n > 0 && n < size(), the position of the first character of the nth sub-match is returned.if n >= size(), a position of the first character of the unmatched match is returned."
        },
        "parametres": "   n   -   integral number specifying which match to examine \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <regex>\n#include <string>\n \nint main()\n{\n    std::regex re(\"a(a)*b\");\n    std::string target(\"aaab\");\n    std::smatch sm;\n \n    std::regex_match(target, sm, re);\n    std::cout << sm.position(1) << '\\n';\n}",
            "output": "1"
        }
    },
    "match_results::str": {
        "description": {
            "texte": "Returns a string representing the indicated sub-match.If n == 0, a string representing entire matched expression is returned.If n > 0 && n < size(), a string representing nth sub-match is returned.if n >= size(), a string representing the unmatched match is returned.The call is equivalent to string_type((*this)[n]);"
        },
        "parametres": "   n   -   integral number specifying which match to return \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <regex>\n#include <string>\n \nint main()\n{\n    std::string target(\"baaaby\");\n    std::smatch sm;\n \n    std::regex re1(\"a(a)*b\");\n    std::regex_search(target, sm, re1);\n    std::cout << \"entire match: \" << sm.str(0) << '\\n'\n              << \"submatch #1: \" << sm.str(1) << '\\n';\n \n    std::regex re2(\"a(a*)b\");\n    std::regex_search(target, sm, re2);\n    std::cout << \"entire match: \" << sm.str(0) << '\\n'\n              << \"submatch #1: \" << sm.str(1) << '\\n';\n \n}",
            "output": "entire match: aaab\nsubmatch #1: a\nentire match: aaab\nsubmatch #1: aa"
        }
    },
    "match_results::prefix": {
        "description": {
            "texte": "Obtains a reference to the std::sub_match object representing the target sequence between the start of the beginning of the target sequence and the start of the entire match of the regular expression.The behavior is undefined unless ready() == true."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <regex>\n#include <string>\n \nint main()\n{\n  std::regex re(\"a(a)*b\");\n  std::string target(\"baaaby\");\n  std::smatch sm;\n \n  std::regex_search(target, sm, re);\n  std::cout << sm.prefix().str() << '\\n';\n}",
            "output": "b"
        }
    },
    "match_results::suffix": {
        "description": {
            "texte": "Obtains a reference to the std::sub_match object representing the target sequence between the end of the entire match of the regular expression and the end of the target sequence.The behavior is undefined unless ready() == true."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <regex>\n#include <string>\n \nint main()\n{\n    std::regex re(\"a(a)*b\");\n    std::string target(\"baaaby\");\n    std::smatch sm;\n \n    std::regex_search(target, sm, re);\n    std::cout << sm.suffix().str() << '\\n';\n}",
            "output": "y"
        }
    },
    "match_results::begin, std::match_results::cbegin": {
        "description": {
            "texte": "Returns an iterator to the beginning of the list of sub-matches. If match was successful, the iterator will point to the entire matched expression."
        }
    },
    "match_results::end, std::match_results::cend": {
        "description": {
            "texte": "Returns an iterator to the end of the list of sub-matches."
        }
    },
    "match_results::format": {
        "description": {
            "texte": "format outputs a format string, replacing any format specifiers or escape sequences in that string with match data from *this.The flags bitmask determines which format specifiers and escape sequences are recognized.The behavior of format is undefined if ready() != true."
        },
        "parametres": "   fmt_begin, fmt_end   -   pointers to a range of characters defining the format character sequence \n   fmt   -   std::basic_string defining the format character sequence \n   fmt_s   -   pointer to a null-terminated character string defining the format character sequence \n   out   -   iterator that the resulting character sequence is copied to \n   flags   -   std::regex_constants::match_flag_type bitmask specifying which format specifiers and escape sequences are recognized \n   Type requirements \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <regex>\n \nint main()\n{\n    std::string s = \"for a good time, call 867-5309\";\n    std::regex phone_regex(\"\\\\d{3}-\\\\d{4}\");\n    std::smatch phone_match;\n \n    if (std::regex_search(s, phone_match, phone_regex)) {\n        std::string fmt_s = phone_match.format(\n            \"$`\"    // $` means characters before the match\n            \"[$&]\"  // $& means the matched characters\n            \"$'\");  // $' means characters following the match\n        std::cout << fmt_s << '\\n';\n    }   \n}",
            "output": "for a good time, call [867-5309]"
        }
    },
    "match_results::swap": {
        "description": {
            "texte": "Exchanges the shared states of two match_results objects."
        },
        "parametres": "   other   -   the match_results to swap with \n\n"
    },
    "regex_iterator::regex_iterator": {
        "description": {
            "texte": "Constructs a new regex_iterator:"
        },
        "parametres": "   a   -   BidirIt to the beginning of the target character sequence \n   b   -   BidirIt to the end of the target character sequence \n   re   -   regular expression used to search the target character sequence \n   m   -   flags that govern the behavior of re \n\n"
    },
    "regex_iterator::operator=": {
        "description": {
            "texte": "Assigns the contents of other."
        },
        "parametres": "   other   -   regex iterator to assign \n\n"
    },
    "regex_token_iterator::regex_token_iterator": {
        "description": {
            "texte": "Constructs a new regex_token_iterator:The behavior is undefined if any value in submatches is less than -1."
        },
        "parametres": "   a   -   LegacyBidirectionalIterator to the beginning of the target character sequence \n   b   -   LegacyBidirectionalIterator to the end of the target character sequence \n   re   -   regular expression used to search the target character sequence \n   submatch   -   the index of the submatch that should be returned. \"0\" represents the entire match, and \"-1\" represents the parts that are not matched (e.g, the stuff between matches). \n   submatches   -   the sequence of submatch indices that should be iterated over within each match, may include the special value -1 for the non-matched fragments \n   m   -   flags that govern the behavior of re \n\n"
    },
    "regex_token_iterator::operator=": {
        "description": {
            "texte": "Assigns the contents of other."
        },
        "parametres": "   other   -   regex iterator to assign \n\n"
    },
    "regex_error::regex_error": {
        "description": {
            "texte": "Constructs a regex_error with a given ecode of type std::regex_constants::error_type ."
        }
    },
    "regex_error::code": {
        "description": {
            "texte": "Returns the std::regex_constants::error_type that was passed to the std::regex_error constructor."
        }
    },
    "regex_traits::regex_traits": {
        "description": {
            "texte": "Default-constructs the std::regex_traits object, including default-constructing the private std::locale member or any other internal state as necessary."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <regex>\n \nint main()\n{\n    std::locale::global(std::locale(\"en_US.utf8\"));\n    std::regex_traits<char> r1;\n    std::regex_traits<wchar_t> r2;\n    std::cout << \"The regex locale is \" << r1.getloc().name() << '\\n';\n}",
            "output": "The regex locale is en_US.utf8"
        }
    },
    "regex_traits::length": {
        "description": {
            "texte": "Calculates the length of a null-terminated character sequence, that is, the smallest i such that p[i]==0.Standard library specializations of std::regex_traits execute std::char_traits<CharT>::length(p);"
        },
        "parametres": "   p   -   pointer to the first element of the null-terminated character sequence \n\n",
        "exemple": {
            "input": "#include <regex>\n#include <iostream>\n \nint main()\n{\n    std::cout << std::regex_traits<char>::length(u8\"\u041a\u043e\u0448\u043a\u0430\") << '\\n'\n              << std::regex_traits<wchar_t>::length(L\"\u041a\u043e\u0448\u043a\u0430\") << '\\n';\n}",
            "output": "10\n5"
        }
    },
    "regex_traits::translate": {
        "description": {
            "texte": "Obtains the comparison key for the character c, such that all characters that are equivalent to this character in the imbued locale produce the same key.When the regex library needs to match two characters c1 and c2 and the flag std::regex_constants::collate is true, it executes regex_traits<>::translate(c1) == regex_traits<>::translate(c2).Standard library specializations of std::regex_traits return c unmodified."
        },
        "parametres": "   c   -   character that needs to be examined for equivalence \n\n"
    },
    "regex_traits::translate_nocase": {
        "description": {
            "texte": "Obtains the comparison key for the character c, such that all characters that are equivalent to this character in the imbued locale, ignoring the case differences, if any, produce the same key.When the regex library needs to match two characters c1 and c2 and the flag std::regex_constants::icase is true, it executes regex_traits<>::translate_nocase(c1) == regex_traits<>::translate_nocase(c2).Standard library specializations of std::regex_traits return std::use_facet<std::ctype<CharT>>(getloc()).tolower(c), that is, convert c to lowercase, using the currently imbued locale."
        },
        "parametres": "   c   -   character that needs to be examined for equivalence, ignoring case \n\n"
    },
    "regex_traits::transform": {
        "description": {
            "texte": "Obtains the sort key for the character sequence [first, last), such that if a sort key compares less than another sort key with operator<, then the character sequence that produced the first sort key comes before the character sequence that produced the second sort key, in the currently imbued locale's collation order.For example when the regex flag std::regex_constants::collate is set, then the sequence [a-b] would match some character c1 if traits.transform(\"a\") <= traits.transform(c1) <= traits.transform(\"b\"). Note that this function takes a character sequence as the argument to accomodate to the ranges defined like [[.ae.]-d].Standard library specializations of std::regex_traits return std::use_facet<std::collate<CharT>>(getloc()).transform(str.data(), str.data() + str.length()) for some temporary string str constructed as string_type str(first, last)."
        },
        "parametres": "   first, last   -   a pair of LegacyForwardIterators which determines the sequence of characters to compare \n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n\n"
    },
    "regex_traits::transform_primary": {
        "description": {
            "texte": "For the character sequence [first, last), obtains the primary sort key in the imbued locale's collating order, that is, the sort key that is based on the positions of the letters and collation units in the national alphabet, ignoring case, diacritics, variants, etc. If a primary sort key compares less than another primary sort key with operator<, then the character sequence that produced the first sort key comes before the character sequence that produced the second sort key, in the currently imbued locale's primary collation order.The regex library uses this trait to match characters against equivalence classes. For example, the regex [[=a=]] is equivalent to the character c1 if traits.transform_primary(c1) is equivalent to traits.transform_primary(\"a\") (which is true for any c1 from \"A\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5a\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\" in the U.S. English locale). Note that transform_primary() takes a character sequence argument because equivalence classes may be multicharacter, such as [[=ch=]] in Czech or [[=dzs=]] in Hungarian.There is no portable way to define primary sort key in terms of std::locale since the conversion from the collation key returned by std::collate::transform() to the primary equivalence key is locale-specific, and if the user replaces the std::collate facet, that conversion is no longer known to the standard library's std::regex_traits. Standard library specializations of std::regex_traits return an empty string unless the std::collate facet of the currently-imbued locale was not replaced by the user, and still matches the system-supplied std::collate facet), in which case std::collate_byname<charT>::transform(first, last) is executed and the sort key it produces is converted to the expected primary sort key using a locale-specific conversion."
        },
        "parametres": "   first, last   -   a pair of iterators which determines the sequence of characters to compare \n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <regex>\n \nint main()\n{\n    std::locale::global(std::locale(\"en_US.UTF-8\"));\n    std::wstring str = L\"A\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5a\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\";\n    std::wregex re(L\"[[=a=]]*\", std::regex::basic);\n    std::cout << std::boolalpha << std::regex_match(str, re) << '\\n';\n}",
            "output": "true"
        }
    },
    "regex_traits::lookup_collatename": {
        "description": {
            "texte": "If the character sequence [first, last) represents the name of a valid collating element in the currently imbued locale, returns the name of that collating element. Otherwise, returns an empty string.Collating elements are the symbols found in POSIX regular expressions between [. and .]. For example, [.a.] matches the character a in the C locale. [.tilde.] matches the character ~ in the C locale as well. [.ch.] matches the digraph ch in Czech locale, but generates std::regex_error with error code std::regex_constants::error_collate in most other locales."
        },
        "parametres": "   first, last   -   a pair of iterators which determines the sequence of characters that represents a collating element name \n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <regex>\n \nstruct noisy_traits : std::regex_traits<char> {\n \n    template< class Iter >\n    string_type lookup_collatename( Iter first, Iter last ) const {\n        string_type result = regex_traits::lookup_collatename(first, last);\n        std::cout << \"regex_traits<>::lookup_collatename(\\\"\"\n                  << string_type(first, last)\n                  << \"\\\") returns \\\"\" << result << \"\\\"\\n\";\n        return result;\n    }\n};\n \nint main()\n{\n    std::string str = \"z|}a\"; // C locale collation order: x,y,z,{,|,},~\n    std::basic_regex<char, noisy_traits> re(\"[x-[.tilde.]]*a\", std::regex::basic);\n    std::cout << std::boolalpha << std::regex_match(str, re) << '\\n';\n}",
            "output": "regex_traits<>::lookup_collatename(\"tilde\") returns \"~\"\ntrue"
        }
    },
    "regex_traits::lookup_classname": {
        "description": {
            "texte": "If the character sequence [first, last) represents the name of a valid character class in the currently imbued locale (that is, the string between [: and :] in regular expressions), returns the implementation-defined value representing this character class. Otherwise, returns zero.If the parameter icase is true, the character class ignores character case, e.g. the regex [:lower:] with std::regex_constants::icase generates a call to regex_traits<>::lookup_classname() with [first, last) indicating the string \"lower\" and icase == true. This call returns the same bitmask as the call generated by the regex [:alpha:] with icase == false.The following character classes are always recognized, in both narrow and wide character forms, and the classifications returned (with icase == false) correspond to the matching classifications obtained by the std::ctype facet of the imbued locale, as follows:The classification returned for the string \"w\" may be exactly the same as \"alnum\", in which case isctype() adds '_' explicitly.Additional classifications such as \"jdigit\" or \"jkanji\" may be provided by system-supplied locales (in which case they are also accessible through std::wctype)."
        },
        "parametres": "   first, last   -   a pair of iterators which determines the sequence of characters that represents a name of a character class \n   icase   -   if true, ignores the upper/lower case distinction in the character classification \n   Type requirements \n   -ForwardIt must meet the requirements of LegacyForwardIterator. \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n#include <regex>\n#include <cwctype>\n \n// This custom regex traits uses wctype/iswctype to implement lookup_classname/isctype\nstruct wctype_traits : std::regex_traits<wchar_t>\n{\n    using char_class_type = std::wctype_t;\n    template<class It>\n    char_class_type lookup_classname(It first, It last, bool=false) const {\n        return std::wctype(std::string(first, last).c_str());\n    }\n    bool isctype(wchar_t c, char_class_type f) const {\n        return std::iswctype(c, f);\n    }\n};\n \nint main()\n{\n    std::locale::global(std::locale(\"ja_JP.utf8\"));\n    std::wcout.sync_with_stdio(false);\n    std::wcout.imbue(std::locale());\n \n    std::wsmatch m;\n    std::wstring in = L\"\u98a8\u306e\u8c37\u306e\u30ca\u30a6\u30b7\u30ab\";\n    // matches all characters (they are classified as alnum)\n    std::regex_search(in, m, std::wregex(L\"([[:alnum:]]+)\"));\n    std::wcout << \"alnums: \" << m[1] << '\\n'; // prints \"\u98a8\u306e\u8c37\u306e\u30ca\u30a6\u30b7\u30ab\"\n    // matches only the katakana\n    std::regex_search(in, m,\n                      std::basic_regex<wchar_t, wctype_traits>(L\"([[:jkata:]]+)\"));\n    std::wcout << \"katakana: \" << m[1] << '\\n'; // prints \"\u30ca\u30a6\u30b7\u30ab\"\n}",
            "output": "alnums: \u98a8\u306e\u8c37\u306e\u30ca\u30a6\u30b7\u30ab\nkatakana: \u30ca\u30a6\u30b7\u30ab"
        }
    },
    "regex_traits::isctype": {
        "description": {
            "texte": "Determines whether the character c belongs to the character class identified by f, which, in turn, is a value returned by lookup_classname() or a bitwise OR of several such values.The version of this function provided in the standard library specializations of std::regex_traits does the following:"
        },
        "parametres": "   c   -   the character to classify \n   f   -   the bitmask obtained from one or several calls to lookup_classname() \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <regex>\n \nint main()\n{\n    std::regex_traits<char> t;\n    std::string str_alnum = \"alnum\";\n    auto a = t.lookup_classname(str_alnum.begin(), str_alnum.end());\n    std::string str_w = \"w\"; // [:w:] is [:alnum:] plus '_'\n    auto w = t.lookup_classname(str_w.begin(), str_w.end());\n    std::cout << std::boolalpha\n              << t.isctype('A', w) << ' ' << t.isctype('A', a) << '\\n'\n              << t.isctype('_', w) << ' ' << t.isctype('_', a) << '\\n'\n              << t.isctype(' ', w) << ' ' << t.isctype(' ', a) << '\\n';\n}",
            "output": "true true\ntrue false\nfalse false"
        }
    },
    "regex_traits::value": {
        "description": {
            "texte": "Determines the value represented by the digit ch in the numeric base radix, given the currently imbued locale. This function is called by std::regex when processing Quantifiers such as {1} or {2,5}, Backreferences such as \\1, and hexadecimal and Unicode character escapes."
        },
        "parametres": "   ch   -   the character that may represent a digit \n   radix   -   either 8, 10, or 16 \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <locale>\n#include <regex>\n#include <map>\n \n// This custom regex traits allows japanese numerals\nstruct jnum_traits : std::regex_traits<wchar_t>\n{   \n    static std::map<wchar_t, int> data;\n    int value(wchar_t ch, int radix ) const {\n        wchar_t up = std::toupper(ch, getloc());\n        return data.count(up) ? data[up] : regex_traits::value(ch, radix);\n    }\n};\nstd::map<wchar_t, int> jnum_traits::data = {{L'\u3007',0}, {L'\u4e00',1}, {L'\u4e8c',2},\n                                            {L'\u4e09',3}, {L'\u56db',4}, {L'\u4e94',5},\n                                            {L'\u516d',6}, {L'\u4e03',7}, {L'\u516b',8},\n                                            {L'\u4e5d',9}, {L'\uff21',10}, {L'\uff22',11},\n                                            {L'\uff23',12}, {L'\uff24',13}, {L'\uff25',14},\n                                            {L'\uff26',15}};\nint main()\n{   \n    std::locale::global(std::locale(\"ja_JP.utf8\"));\n    std::wcout.sync_with_stdio(false);\n    std::wcout.imbue(std::locale());\n \n    std::wstring in = L\"\u98a8\";\n \n    if(std::regex_match(in, std::wregex(L\"\\\\u98a8\")))\n        std::wcout << \"\\\\u98a8 matched \" << in << '\\n';\n \n    if(std::regex_match(in, std::basic_regex<wchar_t, jnum_traits>(L\"\\\\u\u4e5d\u516b\uff41\u516b\")))\n        std::wcout << L\"\\\\u\u4e5d\u516b\uff41\u516b with custom traits matched \" << in << '\\n';\n}",
            "output": "\\u98a8 matched \u98a8\n\\u\u4e5d\u516b\uff41\u516b with custom traits matched \u98a8"
        }
    },
    "regex_traits::imbue": {
        "description": {
            "texte": "Replaces the current locale with a copy of loc. If loc is different than the current locale, then all cached data is invalidated.After the call getloc() == loc."
        },
        "parametres": "   loc   -   the locale to imbue \n\n"
    },
    "regex_traits::getloc": {
        "description": {
            "texte": "Returns the current locale of the traits object.If imbue() has been never called for this object, then the global locale at the time of the call is returned. Otherwise, the locale passed to the last call to imbue() is returned."
        }
    },
    "atomic::atomic": {
        "description": {
            "texte": "Constructs new atomic variable."
        },
        "parametres": "   desired   -   value to initialize with \n\n"
    },
    "atomic::operator=": {
        "description": {
            "texte": "desired."
        },
        "parametres": "   desired   -   value to assign \n\n"
    },
    "atomic::is_lock_free": {
        "description": {
            "texte": "Checks whether the atomic operations on all objects of this type are lock-free."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <utility>\n#include <atomic>\n \nstruct A { int a[100]; };\nstruct B { int x, y; };\nint main()\n{\n    std::cout << std::boolalpha\n              << \"std::atomic<A> is lock free? \"\n              << std::atomic<A>{}.is_lock_free() << '\\n'\n              << \"std::atomic<B> is lock free? \"\n              << std::atomic<B>{}.is_lock_free() << '\\n';\n}",
            "output": "std::atomic<A> is lock free? false\nstd::atomic<B> is lock free? true"
        }
    },
    "atomic::store": {
        "description": {
            "texte": "Atomically replaces the current value with desired. Memory is affected according to the value of order.order must be one of std::memory_order_relaxed, std::memory_order_release or std::memory_order_seq_cst. Otherwise the behavior is undefined."
        },
        "parametres": "   desired   -   the value to store into the atomic variable \n   order   -   memory order constraints to enforce \n\n"
    },
    "atomic::load": {
        "description": {
            "texte": "Atomically loads and returns the current value of the atomic variable. Memory is affected according to the value of order.order must be one of std::memory_order_relaxed, std::memory_order_consume, std::memory_order_acquire or std::memory_order_seq_cst. Otherwise the behavior is undefined."
        },
        "parametres": "   order   -   memory order constraints to enforce \n\n"
    },
    "atomic::operator T": {
        "description": {
            "texte": "Atomically loads and returns the current value of the atomic variable. Equivalent to load()."
        }
    },
    "atomic::exchange": {
        "description": {
            "texte": "Atomically replaces the underlying value with desired. The operation is read-modify-write operation. Memory is affected according to the value of order."
        },
        "parametres": "   desired   -   value to assign \n   order   -   memory order constraints to enforce \n\n"
    },
    "atomic::compare_exchange_weak, std::atomic::compare_exchange_strong": {
        "description": {
            "texte": "Atomically compares the object representation (until C++20)value representation (since C++20) of *this with that of expected, and if those are bitwise-equal, replaces the former with desired (performs read-modify-write operation). Otherwise, loads the actual value stored in *this into expected (performs load operation).The memory models for the read-modify-write and load operations are success and failure respectively. In the (2) and (4) versions order is used for both read-modify-write and load operations, except that std::memory_order_acquire and std::memory_order_relaxed are used for the load operation if order == std::memory_order_acq_rel, or order == std::memory_order_release respectively."
        },
        "parametres": "   expected   -   reference to the value expected to be found in the atomic object \n   desired   -   the value to store in the atomic object if it is as expected \n   success   -   the memory synchronization ordering for the read-modify-write operation if the comparison succeeds. All values are permitted. \n   failure   -   the memory synchronization ordering for the load operation if the comparison fails. Cannot be std::memory_order_release or std::memory_order_acq_rel and cannot specify stronger ordering than success (until C++17) \n   order   -   the memory synchronization ordering for both operations \n\n",
        "exemple": {
            "input": "#include <atomic>\ntemplate<typename T>\nstruct node\n{\n    T data;\n    node* next;\n    node(const T& data) : data(data), next(nullptr) {}\n};\n \ntemplate<typename T>\nclass stack\n{\n    std::atomic<node<T>*> head;\n public:\n    void push(const T& data)\n    {\n      node<T>* new_node = new node<T>(data);\n \n      // put the current value of head into new_node->next\n      new_node->next = head.load(std::memory_order_relaxed);\n \n      // now make new_node the new head, but if the head\n      // is no longer what's stored in new_node->next\n      // (some other thread must have inserted a node just now)\n      // then put that new head into new_node->next and try again\n      while(!head.compare_exchange_weak(new_node->next, new_node,\n                                        std::memory_order_release,\n                                        std::memory_order_relaxed))\n          ; // the body of the loop is empty\n \n// Note: the above use is not thread-safe in at least \n// GCC prior to 4.8.3 (bug 60272), clang prior to 2014-05-05 (bug 18899)\n// MSVC prior to 2014-03-17 (bug 819819). The following is a workaround:\n//      node<T>* old_head = head.load(std::memory_order_relaxed);\n//      do {\n//          new_node->next = old_head;\n//       } while(!head.compare_exchange_weak(old_head, new_node,\n//                                           std::memory_order_release,\n//                                           std::memory_order_relaxed));\n    }\n};\nint main()\n{\n    stack<int> s;\n    s.push(1);\n    s.push(2);\n    s.push(3);\n}",
            "output": "#include <atomic>\n#include <iostream>\n \nstd::atomic<int>  ai;\n \nint  tst_val= 4;\nint  new_val= 5;\nbool exchanged= false;\n \nvoid valsout()\n{\n    std::cout << \"ai= \" << ai\n              << \"  tst_val= \" << tst_val\n              << \"  new_val= \" << new_val\n              << \"  exchanged= \" << std::boolalpha << exchanged\n              << \"\\n\";\n}\n \nint main()\n{\n    ai= 3;\n    valsout();\n \n    // tst_val != ai   ==>  tst_val is modified\n    exchanged= ai.compare_exchange_strong( tst_val, new_val );\n    valsout();\n \n    // tst_val == ai   ==>  ai is modified\n    exchanged= ai.compare_exchange_strong( tst_val, new_val );\n    valsout();\n}"
        }
    },
    "atomic::is_always_lock_free": {
        "description": {
            "texte": "Equals true if this atomic type is always lock-free and false if it is never or sometimes lock-free.The value of this constant is consistent with both the macro ATOMIC_xxx_LOCK_FREE, where defined, with the member function is_lock_free and non-member function std::atomic_is_lock_free."
        }
    },
    "atomic::fetch_sub": {
        "description": {
            "texte": "Atomically replaces the current value with the result of arithmetic subtraction of the value and arg. The operation is read-modify-write operation. Memory is affected according to the value of order.For signed Integral types, arithmetic is defined to use two\u2019s complement representation. There are no undefined results.For T* types, the result may be an undefined address, but the operation otherwise has no undefined behavior. The program is ill-formed if T is not an object type."
        },
        "parametres": "   arg   -   the other argument of arithmetic subtraction \n   order   -   memory order constraints to enforce \n\n"
    },
    "atomic::fetch_and": {
        "description": {
            "texte": "Atomically replaces the current value with the result of bitwise AND of the value and arg. The operation is read-modify-write operation. Memory is affected according to the value of order."
        },
        "parametres": "   arg   -   the other argument of bitwise AND \n   order   -   memory order constraints to enforce \n\n"
    },
    "atomic::fetch_or": {
        "description": {
            "texte": "Atomically replaces the current value with the result of bitwise OR of the value and arg. The operation is read-modify-write operation. Memory is affected according to the value of order."
        },
        "parametres": "   arg   -   the other argument of bitwise OR \n   order   -   memory order constraints to enforce \n\n"
    },
    "atomic::fetch_xor": {
        "description": {
            "texte": "Atomically replaces the current value with the result of bitwise XOR of the value and arg. The operation is read-modify-write operation. Memory is affected according to the value of order."
        },
        "parametres": "   arg   -   the other argument of bitwise XOR \n   order   -   memory order constraints to enforce \n\n"
    },
    "atomic::operator+=,-=,&=,|=,^=": {
        "description": {
            "texte": "Atomically replaces the current value with the result of computation involving the previous value and arg. The operation is read-modify-write operation.For signed Integral types, arithmetic is defined to use two\u2019s complement representation. There are no undefined results.For T* types, the result may be an undefined address, but the operations otherwise have no undefined behavior. The program is ill-formed if T is not an object type."
        },
        "parametres": "   arg   -   the argument for the arithmetic operation \n\n"
    },
    "atomic_ref::atomic_ref": {
        "description": {
            "texte": "Constructs a new atomic_ref object."
        },
        "parametres": "   obj   -   object to reference \n   ref   -   another atomic_ref object to copy from \n\n"
    },
    "atomic_ref::operator=": {
        "description": {
            "texte": "desired."
        },
        "parametres": "   desired   -   value to assign \n\n"
    },
    "atomic_ref::is_lock_free": {
        "description": {
            "texte": "Checks whether the atomic operations on this object are lock-free."
        }
    },
    "atomic_ref::store": {
        "description": {
            "texte": "Atomically replaces the current value of the referenced object with desired. Memory is affected according to the value of order.order must be one of std::memory_order_relaxed, std::memory_order_release or std::memory_order_seq_cst. Otherwise the behavior is undefined."
        },
        "parametres": "   desired   -   the value to store into the referenced object \n   order   -   memory order constraints to enforce \n\n"
    },
    "atomic_ref::load": {
        "description": {
            "texte": "Atomically loads and returns the current value of the referenced object. Memory is affected according to the value of order.order must be one of std::memory_order_relaxed, std::memory_order_consume, std::memory_order_acquire or std::memory_order_seq_cst. Otherwise the behavior is undefined."
        },
        "parametres": "   order   -   memory order constraints to enforce \n\n"
    },
    "atomic_ref::operator T": {
        "description": {
            "texte": "Atomically loads and returns the current value of the referenced object. Equivalent to load()."
        }
    },
    "atomic_ref::exchange": {
        "description": {
            "texte": "Atomically replaces the value of the referenced object with desired. The operation is a read-modify-write operation. Memory is affected according to the value of order."
        },
        "parametres": "   desired   -   value to assign \n   order   -   memory order constraints to enforce \n\n"
    },
    "atomic_ref::compare_exchange_weak, std::atomic_ref::compare_exchange_strong": {
        "description": {
            "texte": "Atomically compares the value representation of the referenced object with that of expected, and if those are bitwise-equal, replaces the former with desired (performs a read-modify-write operation). Otherwise, loads the actual value stored in the referenced object into expected (performs a load operation).The memory models for the read-modify-write and load operations are success and failure respectively. In the (2) and (4) versions order is used for both read-modify-write and load operations, except that std::memory_order_acquire and std::memory_order_relaxed are used for the load operation if order == std::memory_order_acq_rel, or order == std::memory_order_release respectively."
        },
        "parametres": "   expected   -   reference to the value expected to be found in the object referenced by the atomic_ref object \n   desired   -   the value to store in the the referenced object if it is as expected \n   success   -   the memory synchronization ordering for the read-modify-write operation if the comparison succeeds. All values are permitted. \n   failure   -   the memory synchronization ordering for the load operation if the comparison fails. Cannot be std::memory_order_release or std::memory_order_acq_rel \n   order   -   the memory synchronization ordering for both operations \n\n"
    },
    "atomic_ref::is_always_lock_free": {
        "description": {
            "texte": "Equals true if this operations on this atomic_ref type is always lock-free and false if it is never or sometimes lock-free.The value of this constant is consistent with the result of member function is_lock_free."
        }
    },
    "atomic_ref::required_alignment": {
        "description": {
            "texte": "The value of required_alignment is the required alignment for an object to be referenced by an atomic reference, which is at least alignof(T)."
        }
    },
    "atomic_ref::fetch_add": {
        "description": {
            "texte": "Atomically replaces the current value of the referenced object with the result of arithmetic addition of the value and arg. This operation is a read-modify-write operation. Memory is affected according to the value of order.For signed integral types, arithmetic is defined to use two\u2019s complement representation. There are no undefined results.For floating-point types, the floating-point environment in effect may be different from the calling thread's floating-point environment. The operation need not be conform to the corresponding std::numeric_limits traits but is encouraged to do so. If the result is not a representable value for its type, the result is unspecified but the operation otherwise has no undefined behavior.For T* types, the result may be an undefined address, but the operation otherwise has no undefined behavior. The program is ill-formed if T is not an object type."
        },
        "parametres": "   arg   -   the other argument of arithmetic addition \n   order   -   memory order constraints to enforce \n\n"
    },
    "atomic_ref::fetch_sub": {
        "description": {
            "texte": "Atomically replaces the current value of the referenced object with the result of arithmetic subtraction of the value and arg. This operation is a read-modify-write operation. Memory is affected according to the value of order.For signed integral types, arithmetic is defined to use two\u2019s complement representation. There are no undefined results.For floating-point types, the floating-point environment in effect may be different from the calling thread's floating-point environment. The operation need not be conform to the corresponding std::numeric_limits traits but is encouraged to do so. If the result is not a representable value for its type, the result is unspecified but the operation otherwise has no undefined behavior.For T* types, the result may be an undefined address, but the operation otherwise has no undefined behavior. The program is ill-formed if T is not an object type."
        },
        "parametres": "   arg   -   the other argument of arithmetic subtraction \n   order   -   memory order constraints to enforce \n\n"
    },
    "atomic_ref::fetch_and": {
        "description": {
            "texte": "Atomically replaces the current value of the referenced object with the result of bitwise AND of the value and arg. This operation is a read-modify-write operation. Memory is affected according to the value of order."
        },
        "parametres": "   arg   -   the other argument of bitwise AND \n   order   -   memory order constraints to enforce \n\n"
    },
    "atomic_ref::fetch_or": {
        "description": {
            "texte": "Atomically replaces the current value of the referenced object with the result of bitwise OR of the value and arg. This operation is a read-modify-write operation. Memory is affected according to the value of order."
        },
        "parametres": "   arg   -   the other argument of bitwise OR \n   order   -   memory order constraints to enforce \n\n"
    },
    "atomic_ref::fetch_xor": {
        "description": {
            "texte": "Atomically replaces the current value of the referenced object with the result of bitwise XOR of the value and arg. This operation is a read-modify-write operation. Memory is affected according to the value of order."
        },
        "parametres": "   arg   -   the other argument of bitwise XOR \n   order   -   memory order constraints to enforce \n\n"
    },
    "atomic_ref::operator++,++(int),--,--(int)": {
        "description": {
            "texte": "Atomically increments or decrements the current value of the referenced object. These operations are read-modify-write operations.For signed Integral types, arithmetic is defined to use two\u2019s complement representation. There are no undefined results.For T* types, the result may be an undefined address, but the operations otherwise have no undefined behavior. The program is ill-formed if T is not an object type."
        }
    },
    "atomic_ref::operator+=,-=,&=,|=,^=": {
        "description": {
            "texte": "Atomically replaces the current value of the referenced object with the result of computation involving the previous value and arg. These operations are read-modify-write operations.For signed integral types, arithmetic is defined to use two\u2019s complement representation. There are no undefined results.For floating-point types, the floating-point environment in effect may be different from the calling thread's floating-point environment. The operation need not be conform to the corresponding std::numeric_limits traits but is encouraged to do so. If the result is not a representable value for its type, the result is unspecified but the operation otherwise has no undefined behavior.For T* types, the result may be an undefined address, but the operations otherwise have no undefined behavior. The program is ill-formed if T is not an object type."
        },
        "parametres": "   arg   -   the argument for the arithmetic operation \n\n"
    },
    "atomic_flag::atomic_flag": {
        "description": {
            "texte": "Constructs a new std::atomic_flag.1) Trivial default constructor, initializes std::atomic_flag to unspecified state.2) The copy constructor is deleted; std::atomic_flag is not copyable.In addition, std::atomic_flag can be value-initialized to clear state with the expression ATOMIC_FLAG_INIT. For an atomic_flag with static storage duration, this guarantees static initialization: the flag can be used in constructors of static objects."
        }
    },
    "atomic_flag::clear": {
        "description": {
            "texte": "Atomically changes the state of a std::atomic_flag to clear (false)."
        },
        "parametres": "   order   -   the memory synchronization ordering for this operation (cannot be std::memory_order_consume, std::memory_order_acquire, or std::memory_order_acq_rel) \n\n"
    },
    "atomic_flag::test_and_set": {
        "description": {
            "texte": "Atomically changes the state of a std::atomic_flag to set (true) and returns the value it held before."
        },
        "parametres": "   order   -   the memory synchronization ordering for this operation \n\n"
    },
    "mutex::mutex": {
        "description": {
            "texte": "(none)."
        }
    },
    "mutex::~mutex": {
        "description": {
            "texte": "Destroys the mutex.The behavior is undefined if the mutex is owned by any thread or if any thread terminates while holding any ownership of the mutex."
        }
    },
    "mutex::try_lock": {
        "description": {
            "texte": "Tries to lock the mutex. Returns immediately. On successful lock acquisition returns true, otherwise returns false.This function is allowed to fail spuriously and return false even if the mutex is not currently locked by any other thread.If try_lock is called by a thread that already owns the mutex, the behavior is undefined.Prior unlock() operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation if it returns true. Note that prior lock() does not synchronize with this operation if it returns false."
        },
        "exemple": {
            "input": "#include <chrono>\n#include <mutex>\n#include <thread>\n#include <iostream> // std::cout\n \nstd::chrono::milliseconds interval(100);\n \nstd::mutex mutex;\nint job_shared = 0; // both threads can modify 'job_shared',\n    // mutex will protect this variable\n \nint job_exclusive = 0; // only one thread can modify 'job_exclusive'\n    // no protection needed\n \n// this thread can modify both 'job_shared' and 'job_exclusive'\nvoid job_1() \n{\n    std::this_thread::sleep_for(interval); // let 'job_2' take a lock\n \n    while (true) {\n        // try to lock mutex to modify 'job_shared'\n        if (mutex.try_lock()) {\n            std::cout << \"job shared (\" << job_shared << \")\\n\";\n            mutex.unlock();\n            return;\n        } else {\n            // can't get lock to modify 'job_shared'\n            // but there is some other work to do\n            ++job_exclusive;\n            std::cout << \"job exclusive (\" << job_exclusive << \")\\n\";\n            std::this_thread::sleep_for(interval);\n        }\n    }\n}\n \n// this thread can modify only 'job_shared'\nvoid job_2() \n{\n    mutex.lock();\n    std::this_thread::sleep_for(5 * interval);\n    ++job_shared;\n    mutex.unlock();\n}\n \nint main() \n{\n    std::thread thread_1(job_1);\n    std::thread thread_2(job_2);\n \n    thread_1.join();\n    thread_2.join();\n}",
            "output": "job exclusive (1)\njob exclusive (2)\njob exclusive (3)\njob exclusive (4)\njob shared (1)"
        }
    },
    "mutex::native_handle": {
        "description": {
            "texte": "Returns the underlying implementation-defined native handle object."
        }
    },
    "recursive_mutex::recursive_mutex": {
        "description": {
            "texte": "(none)."
        }
    },
    "recursive_mutex::~recursive_mutex": {
        "description": {
            "texte": "Destroys the mutex.The behavior is undefined if the mutex is owned by any thread or if any thread terminates while holding any ownership of the mutex."
        }
    },
    "recursive_mutex::lock": {
        "description": {
            "texte": "Locks the mutex. If another thread has already locked the mutex, a call to lock will block execution until the lock is acquired.A thread may call lock on a recursive mutex repeatedly. Ownership will only be released after the thread makes a matching number of calls to unlock.The maximum number of levels of ownership is unspecified. An exception of type std::system_error will be thrown if this number is exceeded.Prior unlock() operations on the same mutex synchronize-with (as defined in std::memory_order) this operation."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n#include <thread>\n#include <mutex>\n \nint g_num = 0;  // protected by g_num_mutex\nstd::mutex g_num_mutex;\n \nvoid slow_increment(int id) \n{\n    for (int i = 0; i < 3; ++i) {\n        g_num_mutex.lock();\n        ++g_num;\n        std::cout << id << \" => \" << g_num << '\\n';\n        g_num_mutex.unlock();\n \n        std::this_thread::sleep_for(std::chrono::seconds(1));\n    }\n}\n \nint main()\n{\n    std::thread t1(slow_increment, 0);\n    std::thread t2(slow_increment, 1);\n    t1.join();\n    t2.join();\n}",
            "output": "0 => 1\n1 => 2\n0 => 3\n1 => 4\n0 => 5\n1 => 6"
        }
    },
    "recursive_mutex::try_lock": {
        "description": {
            "texte": "Tries to lock the mutex. Returns immediately. On successful lock acquisition returns true, otherwise returns false.This function is allowed to fail spuriously and return false even if the mutex is not currently locked by any other thread.A thread may call try_lock on a recursive mutex repeatedly. Successful calls to try_lock increment the ownsership count: the mutex will only be released after the thread makes a matching number of calls to unlock.The maximum number of levels of ownership is unspecified. A call to try_lock will return false if this number is exceeded.Prior unlock() operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation if it returns true. Note that prior lock() does not synchronize with this operation if it returns false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <mutex>\n \nint main()\n{\n    std::recursive_mutex test;\n    if (test.try_lock()==true) {\n        std::cout << \"lock acquired\" << std::endl;\n        test.unlock();        //now unlock the mutex    \n    } else {\n        std::cout << \"lock not acquired\" << std::endl;\n    }\n \n    test.lock();        //to lock it again\n    if (test.try_lock()) {  //true can be left out\n        std::cout << \"lock acquired\" << std::endl;\n    } else {\n        std::cout << \"lock not acquired\" << std::endl;\n    }\n    test.unlock(); \n}",
            "output": "lock acquired\nlock not acquired"
        }
    },
    "recursive_mutex::unlock": {
        "description": {
            "texte": "Unlocks the mutex if its level of ownership is 1 (there was exactly one more call to lock() than there were calls to unlock() made by this thread), reduces the level of ownership by 1 otherwise.The mutex must be locked by the current thread of execution, otherwise, the behavior is undefined.This operation synchronizes-with (as defined in std::memory_order) any subsequent lock operation that obtains ownership of the same mutex."
        }
    },
    "recursive_mutex::native_handle": {
        "description": {
            "texte": "Returns the underlying implementation-defined native handle object."
        }
    },
    "shared_mutex::shared_mutex": {
        "description": {
            "texte": "(none)."
        }
    },
    "shared_mutex::~shared_mutex": {
        "description": {
            "texte": "Destroys the mutex.The behavior is undefined if the mutex is owned by any thread or if any thread terminates while holding any ownership of the mutex."
        }
    },
    "shared_mutex::lock": {
        "description": {
            "texte": "Locks the mutex. If another thread has already locked the mutex, a call to lock will block execution until the lock is acquired.If lock is called by a thread that already owns the mutex in any mode (shared or exclusive), the behavior is undefined.Prior unlock() operations on the same mutex synchronize-with (as defined in std::memory_order) this operation."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n#include <thread>\n#include <mutex>\n \nint g_num = 0;  // protected by g_num_mutex\nstd::mutex g_num_mutex;\n \nvoid slow_increment(int id) \n{\n    for (int i = 0; i < 3; ++i) {\n        g_num_mutex.lock();\n        ++g_num;\n        std::cout << id << \" => \" << g_num << '\\n';\n        g_num_mutex.unlock();\n \n        std::this_thread::sleep_for(std::chrono::seconds(1));\n    }\n}\n \nint main()\n{\n    std::thread t1(slow_increment, 0);\n    std::thread t2(slow_increment, 1);\n    t1.join();\n    t2.join();\n}",
            "output": "0 => 1\n1 => 2\n0 => 3\n1 => 4\n0 => 5\n1 => 6"
        }
    },
    "shared_mutex::try_lock": {
        "description": {
            "texte": "Tries to lock the mutex. Returns immediately. On successful lock acquisition returns true, otherwise returns false.This function is allowed to fail spuriously and return false even if the mutex is not currently locked by any other thread.If try_lock is called by a thread that already owns the mutex in any mode (shared or exclusive), the behavior is undefined.Prior unlock() operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation if it returns true. Note that prior lock() does not synchronize with this operation if it returns false."
        }
    },
    "shared_mutex::unlock": {
        "description": {
            "texte": "Unlocks the mutex.The mutex must be locked by the current thread of execution, otherwise, the behavior is undefined.This operation synchronizes-with (as defined in std::memory_order) any subsequent lock operation that obtains ownership of the same mutex."
        }
    },
    "shared_mutex::lock_shared": {
        "description": {
            "texte": "Acquires shared ownership of the mutex. If another thread is holding the mutex in exclusive ownership, a call to lock_shared will block execution until shared ownership can be acquired.If lock_shared is called by a thread that already owns the mutex in any mode (exclusive or shared), the behavior is undefined.If more than the implementation-defined maximum number of shared owners already locked the mutex in shared mode, lock_shared blocks execution until the number of shared owners is reduced. The maximum number of owners is guaranteed to be at least 10000.Prior unlock() operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation."
        }
    },
    "shared_mutex::try_lock_shared": {
        "description": {
            "texte": "Tries to lock the mutex in shared mode. Returns immediately. On successful lock acquisition returns true, otherwise returns false.This function is allowed to fail spuriously and return false even if the mutex is not currenly exclusively locked by any other thread.Prior unlock() operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation if it returns true.The behavior is undefined if the calling thread already owns the mutex in any mode."
        }
    },
    "shared_mutex::unlock_shared": {
        "description": {
            "texte": "Releases the mutex from shared ownership by the calling thread.The mutex must be locked by the current thread of execution in shared mode, otherwise, the behavior is undefined.This operation synchronizes-with (as defined in std::memory_order) any subsequent lock() operation that obtains ownership of the same mutex."
        }
    },
    "shared_mutex::native_handle": {
        "description": {
            "texte": "Returns the underlying implementation-defined native handle object."
        }
    },
    "timed_mutex::timed_mutex": {
        "description": {
            "texte": "(none)."
        }
    },
    "timed_mutex::~timed_mutex": {
        "description": {
            "texte": "Destroys the mutex.The behavior is undefined if the mutex is owned by any thread or if any thread terminates while holding any ownership of the mutex."
        }
    },
    "timed_mutex::lock": {
        "description": {
            "texte": "Locks the mutex. If another thread has already locked the mutex, a call to lock will block execution until the lock is acquired.If lock is called by a thread that already owns the mutex, the behavior is undefined: for example, the program may deadlock. An implementation that can detect the invalid usage is encouraged to throw a std::system_error with error condition resource_deadlock_would_occur instead of deadlocking.Prior unlock() operations on the same mutex synchronize-with (as defined in std::memory_order) this operation."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n#include <thread>\n#include <mutex>\n \nint g_num = 0;  // protected by g_num_mutex\nstd::mutex g_num_mutex;\n \nvoid slow_increment(int id) \n{\n    for (int i = 0; i < 3; ++i) {\n        g_num_mutex.lock();\n        ++g_num;\n        std::cout << id << \" => \" << g_num << '\\n';\n        g_num_mutex.unlock();\n \n        std::this_thread::sleep_for(std::chrono::seconds(1));\n    }\n}\n \nint main()\n{\n    std::thread t1(slow_increment, 0);\n    std::thread t2(slow_increment, 1);\n    t1.join();\n    t2.join();\n}",
            "output": "0 => 1\n1 => 2\n0 => 3\n1 => 4\n0 => 5\n1 => 6"
        }
    },
    "timed_mutex::try_lock": {
        "description": {
            "texte": "Tries to lock the mutex. Returns immediately. On successful lock acquisition returns true, otherwise returns false.This function is allowed to fail spuriously and return false even if the mutex is not currently locked by any other thread.If try_lock is called by a thread that already owns the mutex, the behavior is undefined.Prior unlock() operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation if it returns true. Note that prior lock() does not synchronize with this operation if it returns false."
        }
    },
    "timed_mutex::try_lock_for": {
        "description": {
            "texte": "Tries to lock the mutex. Blocks until specified timeout_duration has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns true, otherwise returns false.If timeout_duration is less or equal timeout_duration.zero(), the function behaves like try_lock().This function may block for longer than timeout_duration due to scheduling or resource contention delays.The standard recommends that a steady_clock is used to measure the duration. If an implementation uses a system_clock instead, the wait time may also be sensitive to clock adjustments.As with try_lock(), this function is allowed to fail spuriously and return false even if the mutex was not locked by any other thread at some point during timeout_duration.Prior unlock() operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation if it returns true.If try_lock_for is called by a thread that already owns the mutex, the behavior is undefined."
        },
        "parametres": "   timeout_duration   -   minimum duration to block for \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <mutex>\n#include <thread>\n#include <vector>\n#include <sstream>\n \nstd::mutex cout_mutex; // control access to std::cout\nstd::timed_mutex mutex;\n \nvoid job(int id) \n{\n    using Ms = std::chrono::milliseconds;\n    std::ostringstream stream;\n \n    for (int i = 0; i < 3; ++i) {\n        if (mutex.try_lock_for(Ms(100))) {\n            stream << \"success \";\n            std::this_thread::sleep_for(Ms(100));\n            mutex.unlock();\n        } else {\n            stream << \"failed \";\n        }\n        std::this_thread::sleep_for(Ms(100));\n    }\n \n    std::lock_guard<std::mutex> lock(cout_mutex);\n    std::cout << \"[\" << id << \"] \" << stream.str() << \"\\n\";\n}\n \nint main() \n{\n    std::vector<std::thread> threads;\n    for (int i = 0; i < 4; ++i) {\n        threads.emplace_back(job, i);\n    }\n \n    for (auto& i: threads) {\n        i.join();\n    }\n}",
            "output": "[0] failed failed failed \n[3] failed failed success \n[2] failed success failed \n[1] success failed success"
        }
    },
    "timed_mutex::try_lock_until": {
        "description": {
            "texte": "Tries to lock the mutex. Blocks until specified timeout_time has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns true, otherwise returns false.If timeout_time has already passed, this function behaves like try_lock().The clock tied to timeout_time is used, which means that adjustments of the clock are taken into account. Thus, the maximum duration of the block might, but might not, be less or more than timeout_time - Clock::now() at the time of the call, depending on the direction of the adjustment. The function also may block for longer than until after timeout_time has been reached due to scheduling or resource contention delays.As with try_lock(), this function is allowed to fail spuriously and return false even if the mutex was not locked by any other thread at some point before timeout_time.Prior unlock() operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation if it returns true.If try_lock_until is called by a thread that already owns the mutex, the behavior is undefined."
        },
        "parametres": "   timeout_time   -   maximum time point to block until \n\n",
        "exemple": {
            "input": "#include <thread>\n#include <iostream>\n#include <chrono>\n#include <mutex>\n \nstd::timed_mutex test_mutex;\n \nvoid f()\n{\n    auto now=std::chrono::steady_clock::now();\n    test_mutex.try_lock_until(now + std::chrono::seconds(10));\n    std::cout << \"hello world\\n\";\n}\n \nint main()\n{\n    std::lock_guard<std::timed_mutex> l(test_mutex);\n    std::thread t(f);\n    t.join();\n}"
        }
    },
    "timed_mutex::unlock": {
        "description": {
            "texte": "Unlocks the mutex.The mutex must be locked by the current thread of execution, otherwise, the behavior is undefined.This operation synchronizes-with (as defined in std::memory_order) any subsequent lock operation that obtains ownership of the same mutex."
        }
    },
    "timed_mutex::native_handle": {
        "description": {
            "texte": "Returns the underlying implementation-defined native handle object."
        }
    },
    "recursive_timed_mutex::recursive_timed_mutex": {
        "description": {
            "texte": "(none)."
        }
    },
    "recursive_timed_mutex::~recursive_timed_mutex": {
        "description": {
            "texte": "Destroys the mutex.The behavior is undefined if the mutex is owned by any thread or if any thread terminates while holding any ownership of the mutex."
        }
    },
    "recursive_timed_mutex::lock": {
        "description": {
            "texte": "Locks the mutex. If another thread has already locked the mutex, a call to lock will block execution until the lock is acquired.A thread may call lock on a recursive mutex repeatedly. Ownership will only be released after the thread makes a matching number of calls to unlock.The maximum number of levels of ownership is unspecified. An exception of type std::system_error will be thrown if this number is exceeded.Prior unlock() operations on the same mutex synchronize-with (as defined in std::memory_order) this operation."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n#include <thread>\n#include <mutex>\n \nint g_num = 0;  // protected by g_num_mutex\nstd::mutex g_num_mutex;\n \nvoid slow_increment(int id) \n{\n    for (int i = 0; i < 3; ++i) {\n        g_num_mutex.lock();\n        ++g_num;\n        std::cout << id << \" => \" << g_num << '\\n';\n        g_num_mutex.unlock();\n \n        std::this_thread::sleep_for(std::chrono::seconds(1));\n    }\n}\n \nint main()\n{\n    std::thread t1(slow_increment, 0);\n    std::thread t2(slow_increment, 1);\n    t1.join();\n    t2.join();\n}",
            "output": "0 => 1\n1 => 2\n0 => 3\n1 => 4\n0 => 5\n1 => 6"
        }
    },
    "recursive_timed_mutex::try_lock": {
        "description": {
            "texte": "Tries to lock the mutex. Returns immediately. On successful lock acquisition returns true, otherwise returns false.This function is allowed to fail spuriously and return false even if the mutex is not currently locked by any other thread.A thread may call try_lock on a recursive mutex repeatedly. Successful calls to try_lock increment the ownsership count: the mutex will only be released after the thread makes a matching number of calls to unlock.The maximum number of levels of ownership is unspecified. A call to try_lock will return false if this number is exceeded.Prior unlock() operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation if it returns true. Note that prior lock() does not synchronize with this operation if it returns false."
        }
    },
    "recursive_timed_mutex::try_lock_for": {
        "description": {
            "texte": "Tries to lock the mutex. Blocks until specified timeout_duration has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns true, otherwise returns false.If timeout_duration is less or equal timeout_duration.zero(), the function behaves like try_lock().This function may block for longer than timeout_duration due to scheduling or resource contention delays.The standard recommends that a steady_clock is used to measure the duration. If an implementation uses a system_clock instead, the wait time may also be sensitive to clock adjustments.As with try_lock(), this function is allowed to fail spuriously and return false even if the mutex was not locked by any other thread at some point during timeout_duration.Prior unlock() operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation if it returns true.A thread may call try_lock_for on a recursive mutex repeatedly. Successful calls to try_lock_for increment the ownership count: the mutex will only be released after the thread makes a matching number of calls to unlock.The maximum number of levels of ownership is unspecified. A call to try_lock_for will return false if this number is exceeded."
        },
        "parametres": "   timeout_duration   -   minimum duration to block for \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <mutex>\n#include <thread>\n#include <vector>\n#include <sstream>\n \nstd::mutex cout_mutex; // control access to std::cout\nstd::timed_mutex mutex;\n \nvoid job(int id) \n{\n    using Ms = std::chrono::milliseconds;\n    std::ostringstream stream;\n \n    for (int i = 0; i < 3; ++i) {\n        if (mutex.try_lock_for(Ms(100))) {\n            stream << \"success \";\n            std::this_thread::sleep_for(Ms(100));\n            mutex.unlock();\n        } else {\n            stream << \"failed \";\n        }\n        std::this_thread::sleep_for(Ms(100));\n    }\n \n    std::lock_guard<std::mutex> lock(cout_mutex);\n    std::cout << \"[\" << id << \"] \" << stream.str() << \"\\n\";\n}\n \nint main() \n{\n    std::vector<std::thread> threads;\n    for (int i = 0; i < 4; ++i) {\n        threads.emplace_back(job, i);\n    }\n \n    for (auto& i: threads) {\n        i.join();\n    }\n}",
            "output": "[0] failed failed failed \n[3] failed failed success \n[2] failed success failed \n[1] success failed success"
        }
    },
    "recursive_timed_mutex::try_lock_until": {
        "description": {
            "texte": "Tries to lock the mutex. Blocks until specified timeout_time has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns true, otherwise returns false.If timeout_time has already passed, this function behaves like try_lock().The clock tied to timeout_time is used, which means that adjustments of the clock are taken into account. Thus, the maximum duration of the block might, but might not, be less or more than timeout_time - Clock::now() at the time of the call, depending on the direction of the adjustment. The function also may block for longer than until after timeout_time has been reached due to scheduling or resource contention delays.As with try_lock(), this function is allowed to fail spuriously and return false even if the mutex was not locked by any other thread at some point before timeout_time.Prior unlock() operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation if it returns true.A thread may call try_lock_until on a recursive mutex repeatedly. Successful calls to try_lock_until increment the ownership count: the mutex will only be released after the thread makes a matching number of calls to unlock.The maximum number of levels of ownership is unspecified. A call to try_lock_until will return false if this number is exceeded."
        },
        "parametres": "   timeout_time   -   maximum time point to block until \n\n",
        "exemple": {
            "input": "#include <thread>\n#include <iostream>\n#include <chrono>\n#include <mutex>\n \nstd::recursive_timed_mutex test_mutex;\n \nvoid f()\n{\n    auto now=std::chrono::steady_clock::now();\n    test_mutex.try_lock_until(now + std::chrono::seconds(10));\n    std::cout << \"hello world\\n\";\n}\n \nint main()\n{\n    std::lock_guard<std::recursive_timed_mutex> l(test_mutex);\n    std::thread t(f);\n    t.join();\n}"
        }
    },
    "recursive_timed_mutex::unlock": {
        "description": {
            "texte": "Unlocks the mutex if its level of ownership is 1 (there was exactly one more call to lock() than there were calls to unlock() made by this thread), reduces the level of ownership by 1 otherwise.The mutex must be locked by the current thread of execution, otherwise, the behavior is undefined.This operation synchronizes-with (as defined in std::memory_order) any subsequent lock operation that obtains ownership of the same mutex."
        }
    },
    "recursive_timed_mutex::native_handle": {
        "description": {
            "texte": "Returns the underlying implementation-defined native handle object."
        }
    },
    "shared_timed_mutex::shared_timed_mutex": {
        "description": {
            "texte": "(none)."
        }
    },
    "shared_timed_mutex::~shared_timed_mutex": {
        "description": {
            "texte": "Destroys the mutex.The behavior is undefined if the mutex is owned by any thread or if any thread terminates while holding any ownership of the mutex."
        }
    },
    "shared_timed_mutex::lock": {
        "description": {
            "texte": "Locks the mutex. If another thread has already locked the mutex, a call to lock will block execution until the lock is acquired.If lock is called by a thread that already owns the mutex in any mode (shared or exclusive), the behavior is undefined.Prior unlock() operations on the same mutex synchronize-with (as defined in std::memory_order) this operation."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <chrono>\n#include <thread>\n#include <mutex>\n \nint g_num = 0;  // protected by g_num_mutex\nstd::mutex g_num_mutex;\n \nvoid slow_increment(int id) \n{\n    for (int i = 0; i < 3; ++i) {\n        g_num_mutex.lock();\n        ++g_num;\n        std::cout << id << \" => \" << g_num << '\\n';\n        g_num_mutex.unlock();\n \n        std::this_thread::sleep_for(std::chrono::seconds(1));\n    }\n}\n \nint main()\n{\n    std::thread t1(slow_increment, 0);\n    std::thread t2(slow_increment, 1);\n    t1.join();\n    t2.join();\n}",
            "output": "0 => 1\n1 => 2\n0 => 3\n1 => 4\n0 => 5\n1 => 6"
        }
    },
    "shared_timed_mutex::try_lock": {
        "description": {
            "texte": "Tries to lock the mutex. Returns immediately. On successful lock acquisition returns true, otherwise returns false.This function is allowed to fail spuriously and return false even if the mutex is not currently locked by any other thread.If try_lock is called by a thread that already owns the mutex in any mode (shared or exclusive), the behavior is undefined.Prior unlock() operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation if it returns true. Note that prior lock() does not synchronize with this operation if it returns false."
        }
    },
    "shared_timed_mutex::try_lock_for": {
        "description": {
            "texte": "Tries to lock the mutex. Blocks until specified timeout_duration has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns true, otherwise returns false.If timeout_duration is less or equal timeout_duration.zero(), the function behaves like try_lock().This function may block for longer than timeout_duration due to scheduling or resource contention delays.The standard recommends that a steady_clock is used to measure the duration. If an implementation uses a system_clock instead, the wait time may also be sensitive to clock adjustments.As with try_lock(), this function is allowed to fail spuriously and return false even if the mutex was not locked by any other thread at some point during timeout_duration.Prior unlock() operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation if it returns true.If try_lock_for is called by a thread that already owns the mutex in any mode (shared or exclusive), the behavior is undefined."
        },
        "parametres": "   timeout_duration   -   minimum duration to block for \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <mutex>\n#include <thread>\n#include <vector>\n#include <sstream>\n \nstd::mutex cout_mutex; // control access to std::cout\nstd::timed_mutex mutex;\n \nvoid job(int id) \n{\n    using Ms = std::chrono::milliseconds;\n    std::ostringstream stream;\n \n    for (int i = 0; i < 3; ++i) {\n        if (mutex.try_lock_for(Ms(100))) {\n            stream << \"success \";\n            std::this_thread::sleep_for(Ms(100));\n            mutex.unlock();\n        } else {\n            stream << \"failed \";\n        }\n        std::this_thread::sleep_for(Ms(100));\n    }\n \n    std::lock_guard<std::mutex> lock(cout_mutex);\n    std::cout << \"[\" << id << \"] \" << stream.str() << \"\\n\";\n}\n \nint main() \n{\n    std::vector<std::thread> threads;\n    for (int i = 0; i < 4; ++i) {\n        threads.emplace_back(job, i);\n    }\n \n    for (auto& i: threads) {\n        i.join();\n    }\n}",
            "output": "[0] failed failed failed \n[3] failed failed success \n[2] failed success failed \n[1] success failed success"
        }
    },
    "shared_timed_mutex::try_lock_until": {
        "description": {
            "texte": "Tries to lock the mutex. Blocks until specified timeout_time has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns true, otherwise returns false.If timeout_time has already passed, this function behaves like try_lock().The clock tied to timeout_time is used, which means that adjustments of the clock are taken into account. Thus, the maximum duration of the block might, but might not, be less or more than timeout_time - Clock::now() at the time of the call, depending on the direction of the adjustment. The function also may block for longer than until after timeout_time has been reached due to scheduling or resource contention delays.As with try_lock(), this function is allowed to fail spuriously and return false even if the mutex was not locked by any other thread at some point before timeout_time.Prior unlock() operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation if it returns true.If try_lock_until is called by a thread that already owns the mutex in any mode (shared or exclusive), the behavior is undefined."
        },
        "parametres": "   timeout_time   -   maximum time point to block until \n\n",
        "exemple": {
            "input": "#include <thread>\n#include <iostream>\n#include <chrono>\n#include <mutex>\n \nstd::shared_timed_mutex test_mutex;\n \nvoid f()\n{\n    auto now=std::chrono::steady_clock::now();\n    test_mutex.try_lock_until(now + std::chrono::seconds(10));\n    std::cout << \"hello world\\n\";\n}\n \nint main()\n{\n    std::lock_guard<std::shared_timed_mutex> l(test_mutex);\n    std::thread t(f);\n    t.join();\n}"
        }
    },
    "shared_timed_mutex::unlock": {
        "description": {
            "texte": "Unlocks the mutex.The mutex must be locked by the current thread of execution, otherwise, the behavior is undefined.This operation synchronizes-with (as defined in std::memory_order) any subsequent lock operation that obtains ownership of the same mutex."
        }
    },
    "shared_timed_mutex::lock_shared": {
        "description": {
            "texte": "Acquires shared ownership of the mutex. If another thread is holding the mutex in exclusive ownership, a call to lock_shared will block execution until shared ownership can be acquired.If lock_shared is called by a thread that already owns the mutex in any mode (exclusive or shared), the behavior is undefined.If more than the implementation-defined maximum number of shared owners already locked the mutex in shared mode, lock_shared blocks execution until the number of shared owners is reduced. The maximum number of owners is guaranteed to be at least 10000.Prior unlock() operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation."
        }
    },
    "shared_timed_mutex::try_lock_shared": {
        "description": {
            "texte": "Tries to lock the mutex in shared mode. Returns immediately. On successful lock acquisition returns true, otherwise returns false.This function is allowed to fail spuriously and return false even if the mutex is not currenly exclusively locked by any other thread.Prior unlock() operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation if it returns true.The behavior is undefined if the calling thread already owns the mutex in any mode."
        }
    },
    "shared_timed_mutex::try_lock_shared_for": {
        "description": {
            "texte": "Tries to lock the mutex in shared mode. Blocks until specified timeout_duration has elapsed or the shared lock is acquired, whichever comes first. On successful lock acquisition returns true, otherwise returns false.If timeout_duration is less or equal timeout_duration.zero(), the function behaves like try_lock_shared().This function may block for longer than timeout_duration due to scheduling or resource contention delays.The standard recommends that a steady clock is used to measure the duration. If an implementation uses a system clock instead, the wait time may also be sensitive to clock adjustments.As with try_lock_shared(), this function is allowed to fail spuriously and return false even if the mutex was not locked by any other thread at some point during timeout_duration.Prior unlock() operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation if it returns true.If try_lock_shared_for is called by a thread that already owns the mutex in any mode (shared or exclusive), the behavior is undefined."
        },
        "parametres": "   timeout_duration   -   maximum duration to block for \n\n"
    },
    "shared_timed_mutex::try_lock_shared_until": {
        "description": {
            "texte": "Tries to lock the mutex in shared mode. Blocks until specified timeout_time has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns true, otherwise returns false.If timeout_time has already passed, this function behaves like try_lock_shared().The clock tied to timeout_time is used, which means that adjustments of the clock are taken into account. Thus, the maximum duration of the block might, but might not, be less or more than timeout_time - Clock::now() at the time of the call, depending on the direction of the adjustment. The function also may block for longer than until after timeout_time has been reached due to scheduling or resource contention delays.As with try_lock_shared(), this function is allowed to fail spuriously and return false even if the mutex was not locked by any other thread at some point before timeout_time.Prior unlock() operation on the same mutex synchronizes-with (as defined in std::memory_order) this operation if it returns true.If try_lock_shared_until is called by a thread that already owns the mutex in any mode (shared or exclusive), the behavior is undefined."
        },
        "parametres": "   timeout_time   -   maximum time point to block until \n\n"
    },
    "shared_timed_mutex::unlock_shared": {
        "description": {
            "texte": "Releases the mutex from shared ownership by the calling thread.The mutex must be locked by the current thread of execution in shared mode, otherwise, the behavior is undefined.This operation synchronizes-with (as defined in std::memory_order) any subsequent lock() operation that obtains ownership of the same mutex."
        }
    },
    "lock_guard::lock_guard": {
        "description": {
            "texte": "Acquires ownership of the given mutex m.The behavior is undefined if m is destroyed before the lock_guard object is."
        },
        "parametres": "   m   -   mutex to acquire ownership of \n   t   -   tag parameter used to select non-locking version of the constructor \n\n"
    },
    "scoped_lock::scoped_lock": {
        "description": {
            "texte": "Acquires ownership of the given mutexes m.The behavior is undefined if m is destroyed before the scoped_lock object is."
        },
        "parametres": "   m   -   mutexes to acquire ownership of \n\n"
    },
    "unique_lock::unique_lock": {
        "description": {
            "texte": "Constructs a unique_lock, optionally locking the supplied mutex."
        },
        "parametres": "   other   -   another unique_lock to initialize the state with \n   m   -   mutex to associate with the lock and optionally acquire ownership of \n   t   -   tag parameter used to select constructors with different locking strategies \n   timeout_duration   -   maximum duration to block for \n   timeout_time   -   maximum time point to block until \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <thread>\n#include <vector>\n#include <mutex>\nstd::mutex m_a, m_b, m_c;\nint a, b, c = 1;\nvoid update()\n{\n    {   // Note: std::lock_guard or atomic<int> can be used instead\n        std::unique_lock<std::mutex> lk(m_a);\n        a++;\n    }\n \n    { // Note: see std::lock and std::scoped_lock for details and alternatives\n      std::unique_lock<std::mutex> lk_b(m_b, std::defer_lock);\n      std::unique_lock<std::mutex> lk_c(m_c, std::defer_lock);\n      std::lock(lk_b, lk_c);\n      b = std::exchange(c, b+c);\n   }\n}\n \nint main()\n{\n  std::vector<std::thread> threads;\n  for (unsigned i = 0; i < 12; ++i)\n    threads.emplace_back(update);\n \n  for (auto& i: threads)\n    i.join();\n \n  std::cout << a << \"'th and \" << a+1 << \"'th Fibonacci numbers: \"\n            << b << \" and \" << c << '\\n';\n}",
            "output": "12'th and 13'th Fibonacci numbers: 144 and 233"
        }
    },
    "unique_lock::operator=": {
        "description": {
            "texte": "Move assignment operator. Replaces the contents with those of other using move semantics.If prior to the call *this has an associated mutex and has acquired ownership of it, the mutex is unlocked."
        },
        "parametres": "   other   -   another unique_lock to replace the state with \n\n"
    },
    "unique_lock::lock": {
        "description": {
            "texte": "Locks the associated mutex. Effectively calls mutex()->lock()."
        },
        "exemple": {
            "input": "#include <mutex>\n#include <thread>\n#include <iostream>\n#include <vector>\n#include <chrono>\n \nint main()\n{\n    int counter = 0;\n    std::mutex counter_mutex;\n    std::vector<std::thread> threads;\n \n    auto worker_task = [&](int id) {\n        std::unique_lock<std::mutex> lock(counter_mutex);\n        ++counter;\n        std::cout << id << \", initial counter: \" << counter << '\\n';\n        lock.unlock();\n \n        // don't hold the lock while we simulate an expensive operation\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n \n        lock.lock();\n        ++counter;\n        std::cout << id << \", final counter: \" << counter << '\\n';\n    };\n \n    for (int i = 0; i < 10; ++i) threads.emplace_back(worker_task, i);\n \n    for (auto &thread : threads) thread.join();\n}",
            "output": "0, initial counter: 1\n1, initial counter: 2\n2, initial counter: 3\n3, initial counter: 4\n4, initial counter: 5\n5, initial counter: 6\n6, initial counter: 7\n7, initial counter: 8\n8, initial counter: 9\n9, initial counter: 10\n6, final counter: 11\n3, final counter: 12\n4, final counter: 13\n2, final counter: 14\n5, final counter: 15\n0, final counter: 16\n1, final counter: 17\n7, final counter: 18\n9, final counter: 19\n8, final counter: 20"
        }
    },
    "unique_lock::try_lock": {
        "description": {
            "texte": "Tries to lock the associated mutex without blocking. Effectively calls mutex()->try_lock().std::system_error is thrown if there is no associated mutex or if the mutex is already locked by this std::unique_lock."
        }
    },
    "unique_lock::try_lock_for": {
        "description": {
            "texte": "Tries to lock the associated mutex. Blocks until specified timeout_duration has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns true, otherwise returns false. Effectively calls mutex()->try_lock_for(timeout_duration).This function may block for longer than timeout_duration due to scheduling or resource contention delays.The standard recommends that a steady clock is used to measure the duration. If an implementation uses a system clock instead, the wait time may also be sensitive to clock adjustments.std::system_error is thrown if there is no associated mutex or if the mutex is already locked by this std::unique_lock."
        },
        "parametres": "   timeout_duration   -   maximum duration to block for \n\n"
    },
    "unique_lock::try_lock_until": {
        "description": {
            "texte": "Tries to lock the associated mutex. Blocks until specified timeout_time has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns true, otherwise returns false. May block for longer than until timeout_time has been reached.Effectively calls mutex()->try_lock_until(timeout_time).std::system_error is thrown if there is no associated mutex or if the mutex is already locked."
        },
        "parametres": "   timeout_time   -   maximum time point to block until \n\n"
    },
    "unique_lock::unlock": {
        "description": {
            "texte": "Unlocks the associated mutex and releases ownership.std::system_error is thrown if there is no associated mutex or if the mutex is not locked."
        }
    },
    "unique_lock::swap": {
        "description": {
            "texte": "Exchanges the internal states of the lock objects."
        },
        "parametres": "   other   -   the lock to swap the state with \n\n"
    },
    "unique_lock::release": {
        "description": {
            "texte": "Breaks the association of the associated mutex, if any, and *this.No locks are unlocked. If the *this held ownership of the associated mutex prior to the call, the caller is now responsible to unlock the mutex."
        }
    },
    "unique_lock::mutex": {
        "description": {
            "texte": "Returns a pointer to the associated mutex, or a null pointer if there is no associated mutex."
        }
    },
    "unique_lock::owns_lock": {
        "description": {
            "texte": "Checks whether *this owns a locked mutex or not."
        }
    },
    "unique_lock::operator bool": {
        "description": {
            "texte": "Checks whether *this owns a locked mutex or not. Effectively calls owns_lock()."
        }
    },
    "shared_lock::shared_lock": {
        "description": {
            "texte": "Constructs a shared_lock, optionally locking the supplied mutex."
        },
        "parametres": "   other   -   another shared_lock to initialize the state with \n   m   -   mutex to associate with the lock and optionally acquire ownership of \n   t   -   tag parameter used to select constructors with different locking strategies \n   timeout_duration   -   maximum duration to block for \n   timeout_time   -   maximum time point to block until \n\n",
        "exemple": {
            "input": "#include <shared_mutex>\n#include <iostream>\n#include <thread>\n#include <chrono>\n \nstd::shared_timed_mutex m;\nint i = 10;\n \nvoid read()\n{\n   // both the threads get access to the integer i\n   std::shared_lock<std::shared_timed_mutex> slk(m);\n   std::cout << \"read i as \" << i << \"...\\n\"; // this is not synchronized\n   std::this_thread::sleep_for(std::chrono::milliseconds(10));\n   std::cout << \"woke up...\\n\";\n}\n \nint main()\n{\n   std::thread r1(read);\n   std::thread r2(read);\n \n   r1.join();\n   r2.join();\n   return 0;\n}"
        }
    },
    "shared_lock::operator=": {
        "description": {
            "texte": "Move assignment operator. Replaces the contents with those of other using move semantics.If, prior to this call, *this has an associated mutex ((mutex() returns a non-null pointer) and has acquired ownership of it (owns() returns true), the mutex is unlocked by calling unlock_shared().After this call, other has no associated mutex."
        },
        "parametres": "   other   -   another shared_lock to replace the state with \n\n"
    },
    "shared_lock::lock": {
        "description": {
            "texte": "Locks the associated mutex in shared mode. Effectively calls mutex()->lock_shared()."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <mutex>\n#include <string>\n#include <shared_mutex>\n#include <thread>\n \nstd::string file = \"Original content.\"; // Simulates a file\nstd::mutex output_mutex; // mutex that protects output operations.\nstd::shared_mutex file_mutex; // reader/writer mutex\n \nvoid read(int id)\n{\n    std::string content;\n    {\n        std::shared_lock lock(file_mutex, std::defer_lock); // Do not lock it first.\n        lock.lock(); // Lock it here.\n        content = file;\n    }\n    std::lock_guard lock(output_mutex);\n    std::cout << \"Contents read by reader #\" << id << \": \" << content << '\\n';\n}\n \nvoid write()\n{\n    {\n        std::lock_guard file_lock(file_mutex);\n        file = \"New content\";\n    }\n    std::lock_guard output_lock(output_mutex);\n    std::cout << \"New content saved.\\n\";\n}\n \nint main()\n{\n    std::cout << \"Two readers reading from file.\\n\"\n              << \"A writer competes with them.\\n\";\n    std::thread reader1(read, 1);\n    std::thread reader2(read, 2);\n    std::thread writer(write);\n    reader1.join();\n    reader2.join();\n    writer.join();\n    std::cout << \"The first few operations to file are done.\\n\";\n    reader1 = std::thread(read, 3);\n    reader1.join();\n}",
            "output": "Two readers reading from file.\nA writer competes with them.\nContents read by reader #1: Original content.\nContents read by reader #2: Original content.\nNew content saved.\nThe first few operations to file are done.\nContents read by reader #3: New content"
        }
    },
    "shared_lock::try_lock": {
        "description": {
            "texte": "Tries to lock the associated mutex in shared mode without blocking. Effectively calls mutex()->try_lock_shared().std::system_error is thrown if there is no associated mutex or if the mutex is already locked."
        }
    },
    "shared_lock::try_lock_for": {
        "description": {
            "texte": "Tries to lock the associated mutex in shared mode. Blocks until specified timeout_duration has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns true, otherwise returns false. Effectively calls mutex()->try_lock_shared_for(timeout_duration).This function may block for longer than timeout_duration due to scheduling or resource contention delays.The standard recommends that a steady clock is used to measure the duration. If an implementation uses a system clock instead, the wait time may also be sensitive to clock adjustments.std::system_error is thrown if there is no associated mutex or if the mutex is already locked."
        },
        "parametres": "   timeout_duration   -   maximum duration to block for \n\n"
    },
    "shared_lock::try_lock_until": {
        "description": {
            "texte": "Tries to lock the associated mutex in shared mode. Blocks until specified timeout_time has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns true, otherwise returns false. May block for longer than until timeout_time has been reached.Effectively calls mutex()->try_lock_shared_until(timeout_time).std::system_error is thrown if there is no associated mutex or if the mutex is already locked."
        },
        "parametres": "   timeout_time   -   maximum time point to block until \n\n"
    },
    "shared_lock::unlock": {
        "description": {
            "texte": "Unlocks the associated mutex from shared mode. Effectively calls mutex()->unlock_shared().std::system_error is thrown if there is no associated mutex or if the mutex is not locked."
        }
    },
    "shared_lock::swap": {
        "description": {
            "texte": "Exchanges the internal states of the lock objects."
        },
        "parametres": "   other   -   the lock to swap the state with \n\n"
    },
    "shared_lock::release": {
        "description": {
            "texte": "Breaks the association of the associated mutex, if any, and *this.No locks are unlocked. If the *this held ownership of the associated mutex prior to the call, the caller is now responsible to unlock the mutex."
        }
    },
    "shared_lock::mutex": {
        "description": {
            "texte": "Returns a pointer to the associated mutex, or a null pointer if there is no associated mutex."
        }
    },
    "shared_lock::owns_lock": {
        "description": {
            "texte": "Checks whether *this owns a locked mutex or not."
        }
    },
    "shared_lock::operator bool": {
        "description": {
            "texte": "Checks whether *this owns a locked mutex or not. Effectively calls owns_lock()."
        }
    },
    "condition_variable::condition_variable": {
        "description": {
            "texte": "1) Constructs an object of type std::condition_variable.2) Copy constructor is deleted."
        }
    },
    "condition_variable::~condition_variable": {
        "description": {
            "texte": "Destroys the object of type std::condition_variable.It is only safe to invoke the destructor if all threads have been notified. It is not required that they have exited their respective wait functions: some threads may still be waiting to reacquire the associated lock, or may be waiting to be scheduled to run after reacquiring it.The programmer must ensure that no threads attempt to wait on *this once the destructor has been started, especially when the waiting threads are calling the wait functions in a loop or are using the overloads of the wait functions that take a predicate."
        }
    },
    "condition_variable::notify_one": {
        "description": {
            "texte": "If any threads are waiting on *this, calling notify_one unblocks one of the waiting threads."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <condition_variable>\n#include <thread>\n#include <chrono>\n \nstd::condition_variable cv;\nstd::mutex cv_m;\nint i = 0;\nbool done = false;\n \nvoid waits()\n{\n    std::unique_lock<std::mutex> lk(cv_m);\n    std::cout << \"Waiting... \\n\";\n    cv.wait(lk, []{return i == 1;});\n    std::cout << \"...finished waiting. i == 1\\n\";\n    done = true;\n}\n \nvoid signals()\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    std::cout << \"Notifying falsely...\\n\";\n    cv.notify_one(); // waiting thread is notified with i == 0.\n                     // cv.wait wakes up, checks i, and goes back to waiting\n \n    std::unique_lock<std::mutex> lk(cv_m);\n    i = 1;\n    while (!done) \n    {\n        std::cout << \"Notifying true change...\\n\";\n        lk.unlock();\n        cv.notify_one(); // waiting thread is notified with i == 1, cv.wait returns\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n        lk.lock();\n    }\n}\n \nint main()\n{\n    std::thread t1(waits), t2(signals);\n    t1.join(); \n    t2.join();\n}",
            "output": "Waiting... \nNotifying falsely...\nNotifying true change...\n...finished waiting. i == 1"
        }
    },
    "condition_variable::notify_all": {
        "description": {
            "texte": "Unblocks all threads currently waiting for *this."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <condition_variable>\n#include <thread>\n#include <chrono>\n \nstd::condition_variable cv;\nstd::mutex cv_m; // This mutex is used for three purposes:\n                 // 1) to synchronize accesses to i\n                 // 2) to synchronize accesses to std::cerr\n                 // 3) for the condition variable cv\nint i = 0;\n \nvoid waits()\n{\n    std::unique_lock<std::mutex> lk(cv_m);\n    std::cerr << \"Waiting... \\n\";\n    cv.wait(lk, []{return i == 1;});\n    std::cerr << \"...finished waiting. i == 1\\n\";\n}\n \nvoid signals()\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    {\n        std::lock_guard<std::mutex> lk(cv_m);\n        std::cerr << \"Notifying...\\n\";\n    }\n    cv.notify_all();\n \n    std::this_thread::sleep_for(std::chrono::seconds(1));\n \n    {\n        std::lock_guard<std::mutex> lk(cv_m);\n        i = 1;\n        std::cerr << \"Notifying again...\\n\";\n    }\n    cv.notify_all();\n}\n \nint main()\n{\n    std::thread t1(waits), t2(waits), t3(waits), t4(signals);\n    t1.join(); \n    t2.join(); \n    t3.join();\n    t4.join();\n}",
            "output": "Waiting...\nWaiting...\nWaiting...\nNotifying...\nNotifying again...\n...finished waiting. i == 1\n...finished waiting. i == 1\n...finished waiting. i == 1"
        }
    },
    "condition_variable::wait": {
        "description": {
            "texte": "wait causes the current thread to block until the condition variable is notified or a spurious wakeup occurs, optionally looping until some predicate is satisfied."
        },
        "parametres": "   lock   -   an object of type std::unique_lock<std::mutex>, which must be locked by the current thread \n   pred   -   predicate which returns \u200bfalse if the waiting should be continued.  The signature of the predicate function should be equivalent to the following:\n bool pred();\u200b\n\n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <condition_variable>\n#include <thread>\n#include <chrono>\n \nstd::condition_variable cv;\nstd::mutex cv_m; // This mutex is used for three purposes:\n                 // 1) to synchronize accesses to i\n                 // 2) to synchronize accesses to std::cerr\n                 // 3) for the condition variable cv\nint i = 0;\n \nvoid waits()\n{\n    std::unique_lock<std::mutex> lk(cv_m);\n    std::cerr << \"Waiting... \\n\";\n    cv.wait(lk, []{return i == 1;});\n    std::cerr << \"...finished waiting. i == 1\\n\";\n}\n \nvoid signals()\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    {\n        std::lock_guard<std::mutex> lk(cv_m);\n        std::cerr << \"Notifying...\\n\";\n    }\n    cv.notify_all();\n \n    std::this_thread::sleep_for(std::chrono::seconds(1));\n \n    {\n        std::lock_guard<std::mutex> lk(cv_m);\n        i = 1;\n        std::cerr << \"Notifying again...\\n\";\n    }\n    cv.notify_all();\n}\n \nint main()\n{\n    std::thread t1(waits), t2(waits), t3(waits), t4(signals);\n    t1.join(); \n    t2.join(); \n    t3.join();\n    t4.join();\n}",
            "output": "Waiting...\nWaiting...\nWaiting...\nNotifying...\nNotifying again...\n...finished waiting. i == 1\n...finished waiting. i == 1\n...finished waiting. i == 1"
        }
    },
    "condition_variable::wait_for": {
        "description": {
            "texte": "A steady clock is used to measure the duration. This function may block for longer than timeout_duration due to scheduling or resource contention delays.Calling this function if lock.mutex() is not locked by the current thread is undefined behavior.Calling this function if lock.mutex() is not the same mutex as the one used by all other threads that are currently waiting on the same condition variable is undefined behavior."
        },
        "parametres": "   lock   -   an object of type std::unique_lock<std::mutex>, which must be locked by the current thread \n   rel_time   -   an object of type std::chrono::duration representing the maximum time to spend waiting. Note that rel_time must be small enough not to overflow when added to std::chrono::steady_clock::now(). \n   pred   -   predicate which returns \u200bfalse if the waiting should be continued.  The signature of the predicate function should be equivalent to the following:\n bool pred();\u200b\n\n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <atomic>\n#include <condition_variable>\n#include <thread>\n#include <chrono>\nusing namespace std::chrono_literals;\n \nstd::condition_variable cv;\nstd::mutex cv_m;\nint i;\n \nvoid waits(int idx)\n{\n    std::unique_lock<std::mutex> lk(cv_m);\n    if(cv.wait_for(lk, idx*100ms, []{return i == 1;})) \n        std::cerr << \"Thread \" << idx << \" finished waiting. i == \" << i << '\\n';\n    else\n        std::cerr << \"Thread \" << idx << \" timed out. i == \" << i << '\\n';\n}\n \nvoid signals()\n{\n    std::this_thread::sleep_for(120ms);\n    std::cerr << \"Notifying...\\n\";\n    cv.notify_all();\n    std::this_thread::sleep_for(100ms);\n    {\n        std::lock_guard<std::mutex> lk(cv_m);\n        i = 1;\n    }\n    std::cerr << \"Notifying again...\\n\";\n    cv.notify_all();\n}\n \nint main()\n{\n    std::thread t1(waits, 1), t2(waits, 2), t3(waits, 3), t4(signals);\n    t1.join();\n    t2.join();\n    t3.join();\n    t4.join();\n}",
            "output": "Thread 1 timed out. i == 0\nNotifying...\nThread 2 timed out. i == 0\nNotifying again...\nThread 3 finished waiting. i == 1"
        }
    },
    "condition_variable::wait_until": {
        "description": {
            "texte": "wait_until causes the current thread to block until the condition variable is notified, a specific time is reached, or a spurious wakeup occurs, optionally looping until some predicate is satisfied.Calling this function if lock.mutex() is not locked by the current thread is undefined behavior.Calling this function if lock.mutex() is not the same mutex as the one used by all other threads that are currently waiting on the same condition variable is undefined behavior.",
            "code": "while (!pred()) {\n    if (wait_until(lock, timeout_time) == std::cv_status::timeout) {\n        return pred();\n    }\n}\nreturn true;"
        },
        "parametres": "   lock   -   an object of type std::unique_lock<std::mutex>, which must be locked by the current thread \n   timeout_time   -   an object of type std::chrono::time_point representing the time when to stop waiting \n   pred   -   predicate which returns \u200bfalse if the waiting should be continued.  The signature of the predicate function should be equivalent to the following:\n bool pred();\u200b\n\n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <atomic>\n#include <condition_variable>\n#include <thread>\n#include <chrono>\nusing namespace std::chrono_literals;\n \nstd::condition_variable cv;\nstd::mutex cv_m;\nstd::atomic<int> i{0};\n \nvoid waits(int idx)\n{\n    std::unique_lock<std::mutex> lk(cv_m);\n    auto now = std::chrono::system_clock::now();\n    if(cv.wait_until(lk, now + idx*100ms, [](){return i == 1;}))\n        std::cerr << \"Thread \" << idx << \" finished waiting. i == \" << i << '\\n';\n    else\n        std::cerr << \"Thread \" << idx << \" timed out. i == \" << i << '\\n';\n}\n \nvoid signals()\n{\n    std::this_thread::sleep_for(120ms);\n    std::cerr << \"Notifying...\\n\";\n    cv.notify_all();\n    std::this_thread::sleep_for(100ms);\n    i = 1;\n    std::cerr << \"Notifying again...\\n\";\n    cv.notify_all();\n}\n \nint main()\n{\n    std::thread t1(waits, 1), t2(waits, 2), t3(waits, 3), t4(signals);\n    t1.join(); \n    t2.join();\n    t3.join();\n    t4.join();\n}",
            "output": "Thread 1 timed out. i == 0\nNotifying...\nThread 2 timed out. i == 0\nNotifying again...\nThread 3 finished waiting. i == 1"
        }
    },
    "condition_variable::native_handle": {
        "description": {
            "texte": "Accesses the native handle of *this.The meaning and the type of the result of this function is implementation-defined. On a POSIX system, this may be a value of type pthread_cond_t*. On a Windows system, this may be a PCONDITION_VARIABLE."
        }
    },
    "condition_variable_any::condition_variable_any": {
        "description": {
            "texte": "1) Constructs an object of type std::condition_variable_any.2) Copy constructor is deleted."
        }
    },
    "condition_variable_any::~condition_variable_any": {
        "description": {
            "texte": "Destroys the object of type std::condition_variable_any.It is only safe to invoke the destructor if all threads have been notified. It is not required that they have exited their respective wait functions: some threads may still be waiting to reacquire the associated lock, or may be waiting to be scheduled to run after reacquiring it.The programmer must ensure that no threads attempt to wait on *this once the destructor has been started, especially when the waiting threads are calling the wait functions in a loop or are using the overloads of the wait functions that take a predicate."
        }
    },
    "condition_variable_any::notify_one": {
        "description": {
            "texte": "If any threads are waiting on *this, calling notify_one unblocks one of the waiting threads."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <condition_variable>\n#include <thread>\n#include <chrono>\n \nstd::condition_variable_any cv;\nstd::mutex cv_m;\nint i = 0;\nbool done = false;\n \nvoid waits()\n{\n    std::unique_lock<std::mutex> lk(cv_m);\n    std::cout << \"Waiting... \\n\";\n    cv.wait(lk, []{return i == 1;});\n    std::cout << \"...finished waiting. i == 1\\n\";\n    done = true;\n}\n \nvoid signals()\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    std::cout << \"Notifying falsely...\\n\";\n    cv.notify_one(); // waiting thread is notified with i == 0.\n                     // cv.wait wakes up, checks i, and goes back to waiting\n \n    std::unique_lock<std::mutex> lk(cv_m);\n    i = 1;\n    while (!done) \n    {\n        std::cout << \"Notifying true change...\\n\";\n        lk.unlock();\n        cv.notify_one(); // waiting thread is notified with i == 1, cv.wait returns\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n        lk.lock();\n    }\n}\n \nint main()\n{\n    std::thread t1(waits), t2(signals);\n    t1.join(); \n    t2.join();\n}",
            "output": "Waiting... \nNotifying falsely...\nNotifying true change...\n...finished waiting. i == 1"
        }
    },
    "condition_variable_any::notify_all": {
        "description": {
            "texte": "Unblocks all threads currently waiting for *this."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <condition_variable>\n#include <thread>\n#include <chrono>\n \nstd::condition_variable_any cv;\nstd::mutex cv_m; // This mutex is used for three purposes:\n                 // 1) to synchronize accesses to i\n                 // 2) to synchronize accesses to std::cerr\n                 // 3) for the condition variable cv\nint i = 0;\n \nvoid waits()\n{\n    std::unique_lock<std::mutex> lk(cv_m);\n    std::cerr << \"Waiting... \\n\";\n    cv.wait(lk, []{return i == 1;});\n    std::cerr << \"...finished waiting. i == 1\\n\";\n}\n \nvoid signals()\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    {\n        std::lock_guard<std::mutex> lk(cv_m);\n        std::cerr << \"Notifying...\\n\";\n    }\n    cv.notify_all();\n \n    std::this_thread::sleep_for(std::chrono::seconds(1));\n \n    {\n        std::lock_guard<std::mutex> lk(cv_m);\n        i = 1;\n        std::cerr << \"Notifying again...\\n\";\n    }\n    cv.notify_all();\n}\n \nint main()\n{\n    std::thread t1(waits), t2(waits), t3(waits), t4(signals);\n    t1.join(); \n    t2.join(); \n    t3.join();\n    t4.join();\n}",
            "output": "Waiting...\nWaiting...\nWaiting...\nNotifying...\nNotifying again...\n...finished waiting. i == 1\n...finished waiting. i == 1\n...finished waiting. i == 1"
        }
    },
    "condition_variable_any::wait": {
        "description": {
            "texte": "wait causes the current thread to block until the condition variable is notified or a spurious wakeup occurs, optionally looping until some predicate is satisfied."
        },
        "parametres": "   lock   -   an object of type Lock that meets the BasicLockable requirements, which must be locked by the current thread \n   pred   -   predicate which returns \u200bfalse if the waiting should be continued.  The signature of the predicate function should be equivalent to the following:\n bool pred();\u200b\n\n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <condition_variable>\n#include <thread>\n#include <chrono>\n \nstd::condition_variable_any cv;\nstd::mutex cv_m; // This mutex is used for three purposes:\n                 // 1) to synchronize accesses to i\n                 // 2) to synchronize accesses to std::cerr\n                 // 3) for the condition variable cv\nint i = 0;\n \nvoid waits()\n{\n    std::unique_lock<std::mutex> lk(cv_m);\n    std::cerr << \"Waiting... \\n\";\n    cv.wait(lk, []{return i == 1;});\n    std::cerr << \"...finished waiting. i == 1\\n\";\n}\n \nvoid signals()\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    {\n        std::lock_guard<std::mutex> lk(cv_m);\n        std::cerr << \"Notifying...\\n\";\n    }\n    cv.notify_all();\n \n    std::this_thread::sleep_for(std::chrono::seconds(1));\n \n    {\n        std::lock_guard<std::mutex> lk(cv_m);\n        i = 1;\n        std::cerr << \"Notifying again...\\n\";\n    }\n    cv.notify_all();\n}\n \nint main()\n{\n    std::thread t1(waits), t2(waits), t3(waits), t4(signals);\n    t1.join(); \n    t2.join(); \n    t3.join();\n    t4.join();\n}",
            "output": "Waiting...\nWaiting...\nWaiting...\nNotifying...\nNotifying again...\n...finished waiting. i == 1\n...finished waiting. i == 1\n...finished waiting. i == 1"
        }
    },
    "condition_variable_any::wait_for": {
        "description": {
            "texte": "A steady clock is used to measure the duration. This function may block for longer than timeout_duration due to scheduling or resource contention delays."
        },
        "parametres": "   lock   -   an object of type Lock that meets the BasicLockable requirements, which must be locked by the current thread \n   rel_time   -   an object of type std::chrono::duration representing the maximum time to spend waiting. Note that rel_time must be small enough not to overflow when added to std::chrono::steady_clock::now(). \n   pred   -   predicate which returns \u200bfalse if the waiting should be continued.  The signature of the predicate function should be equivalent to the following:\n bool pred();\u200b\n\n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <atomic>\n#include <condition_variable>\n#include <thread>\n#include <chrono>\nusing namespace std::chrono_literals;\n \nstd::condition_variable_any cv;\nstd::mutex cv_m;\nint i;\n \nvoid waits(int idx)\n{\n    std::unique_lock<std::mutex> lk(cv_m);\n    if(cv.wait_for(lk, idx*100ms, []{return i == 1;})) \n        std::cerr << \"Thread \" << idx << \" finished waiting. i == \" << i << '\\n';\n    else\n        std::cerr << \"Thread \" << idx << \" timed out. i == \" << i << '\\n';\n}\n \nvoid signals()\n{\n    std::this_thread::sleep_for(120ms);\n    std::cerr << \"Notifying...\\n\";\n    cv.notify_all();\n    std::this_thread::sleep_for(100ms);\n    {\n        std::lock_guard<std::mutex> lk(cv_m);\n        i = 1;\n    }\n    std::cerr << \"Notifying again...\\n\";\n    cv.notify_all();\n}\n \nint main()\n{\n    std::thread t1(waits, 1), t2(waits, 2), t3(waits, 3), t4(signals);\n    t1.join();\n    t2.join();\n    t3.join();\n    t4.join();\n}",
            "output": "Thread 1 timed out. i == 0\nNotifying...\nThread 2 timed out. i == 0\nNotifying again...\nThread 3 finished waiting. i == 1"
        }
    },
    "condition_variable_any::wait_until": {
        "description": {
            "texte": "wait_until causes the current thread to block until the condition variable is notified, a specific time is reached, or a spurious wakeup occurs, optionally looping until some predicate is satisfied.",
            "code": "while (!pred()) {\n    if (wait_until(lock, timeout_time) == std::cv_status::timeout) {\n        return pred();\n    }\n}\nreturn true;"
        },
        "parametres": "   lock   -   an object of type Lock that meets the requirements of BasicLockable, which must be locked by the current thread \n   timeout_time   -   an object of type std::chrono::time_point representing the time when to stop waiting \n   pred   -   predicate which returns \u200bfalse if the waiting should be continued.  The signature of the predicate function should be equivalent to the following:\n bool pred();\u200b\n\n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <atomic>\n#include <condition_variable>\n#include <thread>\n#include <chrono>\nusing namespace std::chrono_literals;\n \nstd::condition_variable cv;\nstd::mutex cv_m;\nstd::atomic<int> i{0};\n \nvoid waits(int idx)\n{\n    std::unique_lock<std::mutex> lk(cv_m);\n    auto now = std::chrono::system_clock::now();\n    if(cv.wait_until(lk, now + idx*100ms, [](){return i == 1;}))\n        std::cerr << \"Thread \" << idx << \" finished waiting. i == \" << i << '\\n';\n    else\n        std::cerr << \"Thread \" << idx << \" timed out. i == \" << i << '\\n';\n}\n \nvoid signals()\n{\n    std::this_thread::sleep_for(120ms);\n    std::cerr << \"Notifying...\\n\";\n    cv.notify_all();\n    std::this_thread::sleep_for(100ms);\n    i = 1;\n    std::cerr << \"Notifying again...\\n\";\n    cv.notify_all();\n}\n \nint main()\n{\n    std::thread t1(waits, 1), t2(waits, 2), t3(waits, 3), t4(signals);\n    t1.join(); \n    t2.join();\n    t3.join();\n    t4.join();\n}",
            "output": "Thread 1 timed out. i == 0\nNotifying...\nThread 2 timed out. i == 0\nNotifying again...\nThread 3 finished waiting. i == 1"
        }
    },
    "promise::set_value_at_thread_exit": {
        "description": {
            "texte": "Stores the value into the shared state without making the state ready immediately. The state is made ready when the current thread exits, after all variables with thread-local storage duration have been destroyed.The operation behaves as though set_value, set_exception, set_value_at_thread_exit, and set_exception_at_thread_exit acquire a single mutex associated with the promise object while updating the promise object.An exception is thrown if there is no shared state or the shared state already stores a value or exception.Calls to this function do not introduce data races with calls to get_future (but they need not synchronize with each other)."
        },
        "parametres": "   value   -   value to store in the shared state \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <future>\n#include <thread>\n \nint main()\n{\n    using namespace std::chrono_literals;\n    std::promise<int> p;\n    std::future<int> f = p.get_future();\n    std::thread([&p] {\n          std::this_thread::sleep_for(1s);\n          p.set_value_at_thread_exit(9);\n    }).detach();\n \n    std::cout << \"Waiting...\" << std::flush;\n    f.wait();\n    std::cout << \"Done!\\nResult is: \" << f.get() << '\\n';\n}",
            "output": "Waiting...Done!\nResult is: 9"
        }
    },
    "packaged_task::make_ready_at_thread_exit": {
        "description": {
            "texte": "Calls the stored task with forwarded args as the arguments. The return value of the task or any exception thrown by it is stored in the shared state of *this.The shared state is only made ready after the current thread exits and all objects of thread local storage duration are destroyed."
        },
        "parametres": "   args   -   the parameters to pass on invocation of the stored task \n\n",
        "exemple": {
            "input": "#include <future>\n#include <iostream>\n#include <chrono>\n#include <thread>\n#include <functional>\n#include <utility>\n \nvoid worker(std::future<void>& output)\n{\n    std::packaged_task<void(bool&)> my_task{ [](bool& done) { done=true; } };\n \n    auto result = my_task.get_future();\n \n    bool done = false;\n \n    my_task.make_ready_at_thread_exit(done); // execute task right away\n \n    std::cout << \"worker: done = \" << std::boolalpha << done << std::endl;\n \n    auto status = result.wait_for(std::chrono::seconds(0));\n    if (status == std::future_status::timeout)\n        std::cout << \"worker: result is not ready yet\" << std::endl;\n \n    output = std::move(result);\n}\n \n \nint main()\n{\n    std::future<void> result;\n \n    std::thread{worker, std::ref(result)}.join();\n \n    auto status = result.wait_for(std::chrono::seconds(0));\n    if (status == std::future_status::ready)\n        std::cout << \"main: result is ready\" << std::endl;\n}",
            "output": "worker: done = true\nworker: result is not ready yet\nmain: result is ready"
        }
    },
    "promise::promise": {
        "description": {
            "texte": "Constructs a promise object."
        },
        "parametres": "   alloc   -   allocator to use to allocate the shared state \n   other   -   another promise to acquire the state from \n\n"
    },
    "promise::operator=": {
        "description": {
            "texte": "Assigns the contents."
        },
        "parametres": "   other   -   another promise to acquire the state from \n\n"
    },
    "promise::swap": {
        "description": {
            "texte": "Exchanges the shared states of two promise objects."
        },
        "parametres": "   other   -   the promise to swap with \n\n"
    },
    "promise::get_future": {
        "description": {
            "texte": "Returns a future object associated with the same shared state as *this.An exception is thrown if *this has no shared state or get_future has already been called. To get multiple \"pop\" ends of the promise-future communication channel, use std::future::share.Calls to this function do not introduce data races with calls to set_value, set_exception, set_value_at_thread_exit, or set_exception_at_thread_exit (but they need not synchronize with each other)."
        }
    },
    "promise::set_exception": {
        "description": {
            "texte": "Atomically stores the exception pointer p into the shared state and makes the state ready.The operation behaves as though set_value, set_exception, set_value_at_thread_exit, and set_exception_at_thread_exit acquire a single mutex associated with the promise object while updating the promise object.An exception is thrown if there is no shared state or the shared state already stores a value or exception.Calls to this function do not introduce data races with calls to get_future (but they need not synchronize with each other)."
        },
        "parametres": "   p   -   exception pointer to store. The behavior is undefined if p is null. \n\n",
        "exemple": {
            "input": "#include <thread>\n#include <iostream>\n#include <future>\n \nint main()\n{\n    std::promise<int> p;\n    std::future<int> f = p.get_future();\n \n    std::thread t([&p]{\n        try {\n            // code that may throw\n            throw std::runtime_error(\"Example\");\n        } catch(...) {\n            try {\n                // store anything thrown in the promise\n                p.set_exception(std::current_exception());\n            } catch(...) {} // set_exception() may throw too\n        }\n    });\n \n    try {\n        std::cout << f.get();\n    } catch(const std::exception& e) {\n        std::cout << \"Exception from the thread: \" << e.what() << '\\n';\n    }\n    t.join();\n}",
            "output": "Exception from the thread: Example"
        }
    },
    "promise::set_exception_at_thread_exit": {
        "description": {
            "texte": "Stores the exception pointer p into the shared state without making the state ready immediately. The state is made ready when the current thread exits, after all variables with thread-local storage duration have been destroyed.The operation behaves as though set_value, set_exception, set_value_at_thread_exit, and set_exception_at_thread_exit acquire a single mutex associated with the promise object while updating the promise object.An exception is thrown if there is no shared state or the shared state already stores a value or exception.Calls to this function do not introduce data races with calls to get_future (but they need not synchronize with each other)."
        },
        "parametres": "   p   -   exception pointer to store. The behavior is undefined if p is null. \n\n"
    },
    "shared_future::get": {
        "description": {
            "texte": "The get method waits until the shared_future has a valid result and (depending on which template is used) retrieves it. It effectively calls wait() in order to wait for the result.The generic template and two template specializations each contain a single version of get. The three versions of get differ only in the return type.The behavior is undefined if valid() is false before the call to this function."
        }
    },
    "shared_future::shared_future": {
        "description": {
            "texte": "Constructs a new shared_future."
        },
        "parametres": "   other   -   another future object to initialize with \n\n"
    },
    "shared_future::operator=": {
        "description": {
            "texte": "Assigns the contents of another shared_future."
        },
        "parametres": "   other   -   a std::shared_future that will transfer state to *this \n\n"
    },
    "shared_future::valid": {
        "description": {
            "texte": "Checks if the future refers to a shared state.This is the case only for futures that were not default-constructed or moved from. Unlike std::future, std::shared_future's shared state is not invalidated when get() is called.The behavior is undefined if any member function other than the destructor, the copy-assignment operator, the move-assignment operator, or valid is called on a shared_future  that does not refer to shared state (although implementations are encouraged to throw std::future_error indicating no_state in this case). It is valid to move or copy from a shared_future object for which valid() is false."
        }
    },
    "shared_future::wait": {
        "description": {
            "texte": "Blocks until the result becomes available. valid() == true after the call.The behavior is undefined if valid()== false before the call to this function."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <future>\n#include <thread>\n \nint fib(int n)\n{\n  if (n < 3) return 1;\n  else return fib(n-1) + fib(n-2);\n}\n \nint main()\n{\n    std::shared_future<int> f1 = std::async(std::launch::async, [](){\n        return fib(20);\n    });\n    std::shared_future<int> f2 = std::async(std::launch::async, [](){\n        return fib(25);\n    });\n \n    std::cout << \"waiting...\\n\";\n    f1.wait();\n    f2.wait();\n \n    std::cout << \"f1: \" << f1.get() << '\\n';\n    std::cout << \"f2: \" << f2.get() << '\\n';\n}",
            "output": "waiting...\nf1: 6765\nf2: 75025"
        }
    },
    "shared_future::wait_for": {
        "description": {
            "texte": "Waits for the result to become available. Blocks until specified timeout_duration has elapsed or the result becomes available, whichever comes first. Returns value identifies the state of the result.This function may block for longer than timeout_duration due to scheduling or resource contention delays.The standard recommends that a steady clock is used to measure the duration. If an implementation uses a system clock instead, the wait time may also be sensitive to clock adjustments.The behavior is undefined if valid()== false before the call to this function."
        },
        "parametres": "   timeout_duration   -   maximum duration to block for \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <future>\n#include <thread>\n#include <chrono>\n \nint main()\n{\n    std::shared_future<int> future = std::async(std::launch::async, [](){ \n        std::this_thread::sleep_for(std::chrono::seconds(3));\n        return 8;  \n    }); \n \n    std::cout << \"waiting...\\n\";\n    std::future_status status;\n    do {\n        status = future.wait_for(std::chrono::seconds(1));\n        if (status == std::future_status::deferred) {\n            std::cout << \"deferred\\n\";\n        } else if (status == std::future_status::timeout) {\n            std::cout << \"timeout\\n\";\n        } else if (status == std::future_status::ready) {\n            std::cout << \"ready!\\n\";\n        }\n    } while (status != std::future_status::ready); \n \n    std::cout << \"result is \" << future.get() << '\\n';\n}",
            "output": "waiting...\ntimeout\ntimeout\nready!\nresult is 8"
        }
    },
    "shared_future::wait_until": {
        "description": {
            "texte": "wait_until waits for a result to become available. It blocks until specified timeout_time has been reached or the result becomes available, whichever comes first. The return value indicates why wait_until returned.The behavior is undefined if valid()== false before the call to this function."
        },
        "parametres": "   timeout_time   -   maximum time point to block until \n\n"
    },
    "packaged_task::packaged_task": {
        "description": {
            "texte": "Constructs a new std::packaged_task object."
        },
        "parametres": "   f   -   the callable target (function, member function, lambda-expression, functor) to execute \n   a   -   the allocator to use when storing the task \n   rhs   -   the std::packaged_task to move from \n\n",
        "exemple": {
            "input": "#include <future>\n#include <iostream>\n#include <thread>\n \nint fib(int n)\n{\n    if (n < 3) return 1;\n    else return fib(n-1) + fib(n-2);\n}\n \nint main()\n{\n    std::packaged_task<int(int)> fib_task(&fib); \n \n    std::cout << \"starting task\\n\";\n    auto result = fib_task.get_future();\n    std::thread t(std::move(fib_task), 40);\n \n    std::cout << \"waiting for task to finish...\\n\";\n    std::cout << result.get() << '\\n';\n \n    std::cout << \"task complete\\n\";\n    t.join();\n}",
            "output": "starting task\nwaiting for task to finish...\n102334155\ntask complete"
        }
    },
    "packaged_task::~packaged_task": {
        "description": {
            "texte": "Abandons the shared state and destroys the stored task object.As with std::promise::~promise, if the shared state is abandoned before it was made ready, an std::future_error exception is stored with the error code std::future_errc::broken_promise)."
        }
    },
    "packaged_task::operator=": {
        "description": {
            "texte": "The following behavior-changing defect reports were applied retroactively to previously published C++ standards."
        },
        "parametres": "   rhs   -   the std::packaged_task to move from \n\n"
    },
    "packaged_task::valid": {
        "description": {
            "texte": "Checks whether *this has a shared state."
        }
    },
    "packaged_task::swap": {
        "description": {
            "texte": "Exchanges the shared states and stored tasks of *this and other."
        },
        "parametres": "   other   -   packaged task whose state to swap with \n\n"
    },
    "packaged_task::get_future": {
        "description": {
            "texte": "Returns a future which shares the same shared state as *this.get_future can be called only once for each packaged_task."
        }
    },
    "packaged_task::reset": {
        "description": {
            "texte": "Resets the state abandoning the results of previous executions. New shared state is constructed.Equivalent to *this = packaged_task(std::move(f)), where f is the stored task."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <cmath>\n#include <thread>\n#include <future>\n \nint main()\n{\n    std::packaged_task<int(int,int)> task([](int a, int b) {\n        return std::pow(a, b);\n    });\n    std::future<int> result = task.get_future();\n    task(2, 9);\n    std::cout << \"2^9 = \" << result.get() << '\\n';\n \n    task.reset();\n    result = task.get_future();\n    std::thread task_td(std::move(task), 2, 10);\n    task_td.join();\n    std::cout << \"2^10 = \" << result.get() << '\\n';\n}",
            "output": "2^9 = 512\n2^10 = 1024"
        }
    },
    "future_error::future_error": {
        "description": {
            "texte": "Constructs a new future error object containing the error code std::make_error_code(ec)."
        },
        "parametres": "   ec   -   error code \n\n"
    },
    "future_error::code": {
        "description": {
            "texte": "Returns the stored error code."
        }
    },
    "future_error::what": {
        "description": {
            "texte": "Returns the explanatory string."
        }
    },
    "make_error_code(std::future_errc)\n": {
        "description": {
            "texte": "Constructs an std::error_code object from a value of type std::future_errc as if by:std::error_code(static_cast<int>(e), std::future_category()).This function is called by the constructor of std::error_code when given an std::future_errc argument."
        },
        "parametres": "   e   -   error code number \n\n"
    },
    "make_error_condition(std::future_errc)\n": {
        "description": {
            "texte": "Constructs an std::error_condition object from a value of type std::future_errc as if by:std::error_condition(static_cast<int>(e), std::future_category())."
        },
        "parametres": "   e   -   error code number \n\n"
    },
    "filesystem::path::format": {
        "description": {
            "texte": "Determines how string representations of pathnames are interpreted by the constructors of std::filesystem::path that accept strings."
        }
    },
    "filesystem::path::path": {
        "description": {
            "texte": "Constructs a new path object."
        },
        "parametres": "   p   -   a path to copy \n   source   -   std::basic_string, std::basic_string_view, pointer to a null-terminated character string, or input iterator with a character value type that points to a null-terminated character sequence (the character type must be char for overload (6)) \n   first, last   -   pair of LegacyInputIterators that specify a character sequence \n   fmt   -   enumerator of type path::format which specifies how pathname format is to be interpreted \n   loc   -   locale that defines encoding conversion to use \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -The value type of InputIt must be one of the character types char, wchar_t, char8_t,  (since C++20)char16_t and char32_t to use the overload (5)) \n   -The value type of InputIt must be char to use the overload (7)) \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path p1 = \"/usr/lib/sendmail.cf\"; // portable format\n    fs::path p2 = \"C:\\\\users\\\\abcdef\\\\AppData\\\\Local\\\\Temp\\\\\"; // native format\n    fs::path p3 = L\"D:/\u732b.txt\"; // wide string\n \n    std::cout << \"p1 = \" << p1 << '\\n'\n              << \"p2 = \" << p2 << '\\n'\n              << \"p3 = \" << p3 << '\\n';\n}",
            "output": "p1 = \"/usr/lib/sendmail.cf\"\np2 = \"C:\\users\\abcdef\\AppData\\Local\\Temp\\\"\np3 = \"D:/\u732b.txt\""
        }
    },
    "filesystem::path::operator=": {
        "description": {
            "texte": "*this."
        },
        "parametres": "   p   -   a path to assign \n   source   -   a std::basic_string, std::basic_string_view, pointer to a null-terminated character/wide character string, or an input iterator that points to a null-terminated character/wide character sequence. The character type must be one of char, char8_t,  (since C++20)char16_t, char32_t, wchar_t \n\n",
        "exemple": {
            "input": "#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path p = \"C:/users/abcdef/AppData/Local\";\n    p = p / \"Temp\"; // move assignment\n    const wchar_t* wstr = L\"D:/\u732b.txt\";\n    p = wstr; // assignment from a source\n}"
        }
    },
    "filesystem::path::assign": {
        "description": {
            "texte": "Replaces the contents to the path object by a new pathname constructed from the given character sequence."
        },
        "parametres": "   source   -   a character range to use, represented as std::string, std::string_view, pointer to a null-terminated multibyte string, or as an input iterator with char value type that points to a null-terminated multibyte string \n   first, last   -   a character range to use \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -The value type of InputIt must be one of the encoded character types (char, wchar_t, char16_t and char32_t) \n\n"
    },
    "filesystem::path::append, std::filesystem::path::operator/=": {
        "description": {
            "texte": "*this."
        },
        "parametres": "   p   -   pathname to append \n   source   -   std::basic_string, std::basic_string_view, null-terminated multicharacter string, or an input iterator pointing to a null-terminated multicharacter sequence, which represents a path name (either in portable or in native format) \n   first, last   -   pair of LegacyInputIterators that specify a multicharacter sequence that represents a path name \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -The value type of InputIt must be one of the encoded character types (char, wchar_t, char16_t and char32_t) \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main() {\n    fs::path p1 = \"C:\";\n    p1 /= \"Users\"; // does not insert a separator\n    std::cout << \"\\\"C:\\\" / \\\"Users\\\" == \" << p1 << '\\n';\n    p1 /= \"batman\"; // inserts fs::path::preferred_separator, '\\' on Windows\n    std::cout << \"\\\"C:\\\" / \\\"Users\\\" / \\\"batman\\\" == \" << p1 << '\\n';\n}",
            "output": "\"C:\" / \"Users\" == \"C:Users\"\n\"C:\" / \"Users\" / \"batman\" == \"C:Users\\\\batman\""
        }
    },
    "filesystem::path::concat, std::filesystem::path::operator+=": {
        "description": {
            "texte": "Concatenates the current path and the argument."
        },
        "parametres": "   p   -   path to append \n   str   -   string or string view to append \n   ptr   -   pointer to the beginning of a null-terminated string to append \n   x   -   single character to append \n   source   -   std::basic_string, std::basic_string_view, null-terminated multicharacter string, or an input iterator pointing to a null-terminated multicharacter sequence, which represents a path name (either in portable or in native format) \n   first, last   -   pair of LegacyInputIterators that specify a multicharacter sequence that represents a path name \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n   -The value type of InputIt must be one of the encoded character types (char, wchar_t, char16_t and char32_t) \n   -CharT must be one of the encoded character types (char, wchar_t, char16_t and char32_t) \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main() {\n    fs::path p1; // empty path\n    p1 += \"var\"; // does not insert a separator\n    std::cout << \"\\\"\\\" + \\\"var\\\" == \" << p1 << '\\n';\n    p1 += \"lib\"; // does not insert a separator\n    std::cout << \"\\\"\\\" + \\\"var\\\" + \\\"lib\\\" == \" << p1 << '\\n';\n}",
            "output": "\"\" + \"var\" == \"var\"\n\"\" + \"var\" + \"lib\" == \"varlib\""
        }
    },
    "filesystem::path::clear": {
        "description": {
            "texte": "Clears the stored pathname. empty() is true after the call."
        }
    },
    "filesystem::path::make_preferred": {
        "description": {
            "texte": "Converts all directory separators in the generic-format view of the path to the preferred directory separator.For example, on Windows, where \\ is the preferred separator, the path foo/bar will be converted to foo\\bar."
        }
    },
    "filesystem::path::remove_filename": {
        "description": {
            "texte": "Removes a single generic-format filename component (as returned by filename) from the given generic-format path.After this function completes, has_filename returns false."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n \n    std::cout << fs::path(\"foo/bar\").remove_filename() << '\\n'\n              << fs::path(\"foo/\").remove_filename() << '\\n'\n              << fs::path(\"/foo\").remove_filename() << '\\n'\n              << fs::path(\"/\").remove_filename() << '\\n';\n}",
            "output": "\"foo/\"\n\"foo/\"\n\"/\"\n\"/\""
        }
    },
    "filesystem::path::replace_filename": {
        "description": {
            "texte": "Replaces a single filename component with replacement.Equivalent to the following:The behavior is undefined if the path has no filename component (has_filename returns false).",
            "code": "remove_filename();\noperator/=(replacement);"
        },
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n \n    std::cout << fs::path(\"/foo\").replace_filename(\"bar\") << '\\n'\n              << fs::path(\"/\").replace_filename(\"bar\") << '\\n';\n}",
            "output": "\"/bar\"\n\"bar\""
        }
    },
    "filesystem::path::replace_extension": {
        "description": {
            "texte": "Replaces the extension with replacement or removes it when the default value of replacement is used.Firstly, if this path has an extension(), it is removed from the generic-format view of the pathname.Then, a dot character is appended to the generic-format view of the pathname, if replacement is not empty or does not begin with a dot character.Then replacement is appended as if by operator+=(replacement)."
        },
        "parametres": "   replacement   -   the extension to replace with \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::path p = \"/foo/bar.jpeg\";\n    std::cout << \"Was: \" << p << '\\n';\n    p.replace_extension(\".jpg\");\n    std::cout << \"Now: \" << p << '\\n';\n}",
            "output": "Was: \"/foo/bar.jpeg\"\nNow: \"/foo/bar.jpg\""
        }
    },
    "filesystem::path::swap": {
        "description": {
            "texte": "Swaps the contents (both native and generic format) of *this and other."
        },
        "parametres": "   other   -   another path to exchange the contents with \n\n"
    },
    "filesystem::path::compare": {
        "description": {
            "texte": "Compares the lexical representations of the path and another path."
        },
        "parametres": "   p   -   a path to compare to \n   str   -   a string or string view representing path to compare to \n   s   -   a null-terminated string representing path to compare to \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nvoid demo(int rc, fs::path p1, fs::path p2) {\n    if(rc < 0) std::cout << p1 << \" < \" << p2 << '\\n';\n    else if(rc > 0) std::cout << p1 << \" > \"  << p2 << '\\n';\n    else if(rc == 0) std::cout << p1 << \"==\" << p2 << '\\n';\n}\nint main() {\n    fs::path p1 = \"/a/b/\"; // as if \"a/b/.\" for lexicographical iteration\n    fs::path p2 = \"/a/b/#\";\n    demo(p1.compare(p2), p1, p2);\n    demo(p1.compare(\"a/b/_\"), p1, \"a/b/_\");\n}",
            "output": "\"/a/b/\" > \"/a/b/#\"\n\"/a/b/\" < \"a/b/_\""
        }
    },
    "filesystem::path::begin, std::filesystem::path::end": {
        "description": {
            "texte": "The sequence denoted by this pair of iterators consists of the following:"
        },
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    fs::path p = \"C:\\\\users\\\\abcdef\\\\AppData\\\\Local\\\\Temp\\\\\";\n    std::cout << \"Examining the path \" << p << \" through iterators gives\\n\";\n    for(auto& e : p)\n        std::cout << e << '\\n';\n}",
            "output": "Examining the path \"C:\\users\\abcdef\\AppData\\Local\\Temp\\\" through iterators gives\n\"C:\"\n\"/\"\n\"users\"\n\"abcdef\"\n\"AppData\"\n\"Local\"\n\"Temp\"\n\"\""
        }
    },
    "filesystem::path::c_str, std::filesystem::path::native, std::filesystem::path::operator string_type()": {
        "description": {
            "texte": "Accesses the native path name as a character string."
        },
        "exemple": {
            "input": "#include <cstdio>\n#ifdef _MSC_VER\n#include <io.h>\n#include <fcntl.h>\n#else\n#include <locale>\n#include <clocale>\n#endif\n#include <fstream>\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n#ifdef _MSC_VER\n    _setmode(_fileno(stderr), _O_WTEXT);\n#else\n    std::setlocale(LC_ALL, \"\");\n    std::locale::global(std::locale(\"\"));\n    std::cout.imbue(std::locale());\n    std::wcerr.imbue(std::locale());\n#endif\n \n    fs::path p = fs::u8path(u8\"\u8981\u3089\u306a\u3044.txt\");\n    std::ofstream(p) << \"File contents\"; // Prior to LWG2676 uses operator string_type()\n                                         // on MSVC, where string_type is wstring, only\n                                         // works due to non-standard extension.\n                                         // Post-LWG2676 uses new fstream constructors\n \n    // native string representation can be used with OS APIs\n    if (std::FILE* f =\n#ifdef _MSC_VER\n                _wfopen(p.c_str(), L\"r\")\n#else\n                std::fopen(p.c_str(), \"r\")\n#endif\n        )\n    {\n        int ch;\n        while((ch=fgetc(f))!= EOF) putchar(ch);\n        std::fclose(f);\n    }\n \n    // multibyte and wide representation can be used for output\n    std::cout << \"\\nFile name in narrow multibyte encoding: \" << p.string() << '\\n';\n    std::wcerr << \"File name in wide encoding: \" << p.wstring() << '\\n';\n \n    fs::remove(p);\n}",
            "output": "File contents\nFile name in narrow multibyte encoding: \u8981\u3089\u306a\u3044.txt\nFile name in wide encoding: \u8981\u3089\u306a\u3044.txt"
        }
    },
    "filesystem::path::string, std::filesystem::path::wstring, std::filesystem::path::u8string, std::filesystem::path::u16string, std::filesystem::path::u32string": {
        "description": {
            "texte": "Returns the internal pathname in native pathname format, converted to specific string type. Conversion, if any, is performed as follows:"
        },
        "exemple": {
            "input": "#include <cstdio>\n#ifdef _MSC_VER\n#include <io.h>\n#include <fcntl.h>\n#else\n#include <locale>\n#include <clocale>\n#endif\n#include <fstream>\n#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n#ifdef _MSC_VER\n    _setmode(_fileno(stderr), _O_WTEXT);\n#else\n    std::setlocale(LC_ALL, \"\");\n    std::locale::global(std::locale(\"\"));\n    std::cout.imbue(std::locale());\n    std::wcerr.imbue(std::locale());\n#endif\n \n    fs::path p = fs::u8path(u8\"\u8981\u3089\u306a\u3044.txt\");\n    std::ofstream(p) << \"File contents\"; // Prior to LWG2676 uses operator string_type()\n                                         // on MSVC, where string_type is wstring, only\n                                         // works due to non-standard extension.\n                                         // Post-LWG2676 uses new fstream constructors\n \n    // native string representation can be used with OS APIs\n    if (std::FILE* f =\n#ifdef _MSC_VER\n                _wfopen(p.c_str(), L\"r\")\n#else\n                std::fopen(p.c_str(), \"r\")\n#endif\n        )\n    {\n        int ch;\n        while((ch=fgetc(f))!= EOF) putchar(ch);\n        std::fclose(f);\n    }\n \n    // multibyte and wide representation can be used for output\n    std::cout << \"\\nFile name in narrow multibyte encoding: \" << p.string() << '\\n';\n    std::wcerr << \"File name in wide encoding: \" << p.wstring() << '\\n';\n \n    fs::remove(p);\n}",
            "output": "File contents\nFile name in narrow multibyte encoding: \u8981\u3089\u306a\u3044.txt\nFile name in wide encoding: \u8981\u3089\u306a\u3044.txt"
        }
    },
    "filesystem::path::generic_string, std::filesystem::path::generic_wstring, std::filesystem::path::generic_u8string, std::filesystem::path::generic_u16string, std::filesystem::path::generic_u32string": {
        "description": {
            "texte": "Returns the internal pathname in generic pathname format, converted to specific string type. Conversion, if any, is specified as follows:The / character is used as the directory separator."
        },
        "parametres": "   a   -   allocator to construct the string with \n   Type requirements \n   -CharT must be one of the encoded character types (char, wchar_t, char16_t and char32_t) \n\n"
    },
    "filesystem::path::lexically_normal, std::filesystem::path::lexically_relative, std::filesystem::path::lexically_proximate": {
        "description": {
            "texte": "(none)."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\n#include <cassert>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    assert(fs::path(\"foo/./bar/..\").lexically_normal() == \"foo/\");\n    assert(fs::path(\"foo/.///bar/../\").lexically_normal() == \"foo/\");\n \n    assert(fs::path(\"/a/d\").lexically_relative(\"/a/b/c\") == \"../../d\");\n    assert(fs::path(\"/a/b/c\").lexically_relative(\"/a/d\") == \"../b/c\");\n    assert(fs::path(\"a/b/c\").lexically_relative(\"a\") == \"b/c\");\n    assert(fs::path(\"a/b/c\").lexically_relative(\"a/b/c/x/y\") == \"../..\");\n    assert(fs::path(\"a/b/c\").lexically_relative(\"a/b/c\") == \".\");\n    assert(fs::path(\"a/b\").lexically_relative(\"c/d\") == \"../../a/b\");\n}"
        }
    },
    "filesystem::path::root_name": {
        "description": {
            "texte": "Returns the root name of the generic-format path. If the path (in generic format) does not include root name, returns path()."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    std::cout << \"Current root name is: \" << fs::current_path().root_name() << '\\n';\n}",
            "output": "Current root name is: \"C:\""
        }
    },
    "filesystem::path::root_directory": {
        "description": {
            "texte": "Returns the root directory of the generic-format path. If the path (in generic format) does not include root directory, returns path()."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::path p = fs::current_path();\n \n    std::cout << \"The current path \" << p << \" decomposes into:\\n\"\n              << \"root name \" << p.root_name() << '\\n'\n              << \"root directory \" << p.root_directory() << '\\n'\n              << \"relative path \" << p.relative_path() << '\\n';\n}",
            "output": "The current path \"C:\\Users\\abcdef\\Local Settings\\temp\" decomposes into:\nroot name \"C:\"\nroot directory \"\\\"\nrelative path \"Users\\abcdef\\Local Settings\\temp\""
        }
    },
    "filesystem::path::root_path": {
        "description": {
            "texte": "Returns the root path of the path. If the path does not include root path, returns path().Effectively, returns the following: root_name() / root_directory()."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    std::cout << \"Current root path is: \" << fs::current_path().root_path() << '\\n';\n}",
            "output": "Current root path is: \"C:\\\""
        }
    },
    "filesystem::path::relative_path": {
        "description": {
            "texte": "Returns path relative to root-path, that is, a pathname composed of every generic-format component of *this after root-path. If *this is an empty path, returns an empty path."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::path p = fs::current_path();\n \n    std::cout << \"The current path \" << p << \" decomposes into:\\n\"\n              << \"root-path \" << p.root_path() << '\\n'\n              << \"relative path \" << p.relative_path() << '\\n';\n}",
            "output": "The current path \"C:\\Users\\abcdef\\Local Settings\\temp\" decomposes into:\nroot-path \"C:\\\"\nrelative path \"Users\\abcdef\\Local Settings\\temp\""
        }
    },
    "filesystem::path::parent_path": {
        "description": {
            "texte": "Returns the path to the parent directory.If has_relative_path() returns false, the result is a copy of *this Otherwise, the result is a path whose generic format pathname is the longest prefix of the generic format pathname of *this that produces one fewer element in its iteration."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main()\n{\n    for(fs::path p : {\"/var/tmp/example.txt\", \"/\", \"/var/tmp/.\"})\n        std::cout << \"The parent path of \" << p\n                  << \" is \" << p.parent_path() << '\\n';\n}",
            "output": "The parent path of \"/var/tmp/example.txt\" is \"/var/tmp\"\nThe parent path of \"/\" is \"/\"\nThe parent path of \"/var/tmp/.\" is \"/var/tmp\""
        }
    },
    "filesystem::path::filename": {
        "description": {
            "texte": "Returns the generic-format filename component of the path.Equivalent to relative_path().empty() ? path() : *--end()."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    std::cout << fs::path(\"/foo/bar.txt\").filename() << '\\n'\n              << fs::path(\"/foo/.bar\").filename() << '\\n'\n              << fs::path(\"/foo/bar/\").filename() << '\\n'\n              << fs::path(\"/foo/.\").filename() << '\\n'\n              << fs::path(\"/foo/..\").filename() << '\\n'\n              << fs::path(\".\").filename() << '\\n'\n              << fs::path(\"..\").filename() << '\\n'\n              << fs::path(\"/\").filename() << '\\n'\n              << fs::path(\"//host\").filename() << '\\n';\n}",
            "output": "\"bar.txt\"\n\".bar\"\n\"\"\n\".\"\n\"..\"\n\".\"\n\"..\"\n\"\"\n\"host\""
        }
    },
    "filesystem::path::stem": {
        "description": {
            "texte": "Returns the filename identified by the generic-format path stripped of its extension.Returns the substring from the beginning of filename() up to and not including the last period (.) character, with the following exceptions:If the first character in the filename is a period, that period is ignored (a filename like \".profile\" is not treated as an extension).If the filename is one of the special filesystem components dot or dot-dot, or if it has no periods, the function returns the entire filename()."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    std::cout << fs::path(\"/foo/bar.txt\").stem() << '\\n'\n              << fs::path(\"/foo/.bar\").stem() << '\\n';\n \n    for (fs::path p = \"foo.bar.baz.tar\"; !p.extension().empty(); p = p.stem())\n        std::cout << p.extension() << '\\n';\n}",
            "output": "\"bar\"\n\".bar\"\n\".tar\"\n\".baz\"\n\".bar\""
        }
    },
    "filesystem::path::extension": {
        "description": {
            "texte": "Returns the extension of the filename component of the generic-format view of *this.If the filename() component of the generic-format path contains a period (.), and is not one of the special filesystem elements dot or dot-dot, then the extension is the substring beginning at the rightmost period (including the period) and until the end of the pathname.If the first character in the filename is a period, that period is ignored (a filename like \".profile\" is not treated as an extension).If the pathname is either . or .., or if filename() does not contain the . character, then empty path is returned.Additional behavior may be defined by the implementations for file systems which append additional elements (such as alternate data streams or partitioned dataset names) to extensions."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    std::cout << fs::path(\"/foo/bar.txt\").extension() << '\\n'\n              << fs::path(\"/foo/bar.\").extension() << '\\n'\n              << fs::path(\"/foo/bar\").extension() << '\\n'\n              << fs::path(\"/foo/bar.txt/bar.cc\").extension() << '\\n'\n              << fs::path(\"/foo/bar.txt/bar.\").extension() << '\\n'\n              << fs::path(\"/foo/bar.txt/bar\").extension() << '\\n'\n              << fs::path(\"/foo/.\").extension() << '\\n'\n              << fs::path(\"/foo/..\").extension() << '\\n'\n              << fs::path(\"/foo/.hidden\").extension() << '\\n'\n              << fs::path(\"/foo/..bar\").extension() << '\\n';\n}",
            "output": "\".txt\"\n\".\"\n\"\"\n\".cc\"\n\".\"\n\"\"\n\"\"\n\"\"\n\"\"\n\".bar\""
        }
    },
    "filesystem::path::empty": {
        "description": {
            "texte": "Checks if the path in generic format is empty."
        }
    },
    "filesystem::path::has_root_path, std::filesystem::path::has_root_name, std::filesystem::path::has_root_directory, std::filesystem::path::has_relative_path, std::filesystem::path::has_parent_path, std::filesystem::path::has_filename, std::filesystem::path::has_stem, std::filesystem::path::has_extension": {
        "description": {
            "texte": "Checks whether the path contains the corresponding path element."
        }
    },
    "filesystem::path::is_absolute,is_relative": {
        "description": {
            "texte": "Checks whether the path is absolute or relative. An absolute path is a path that unambiguously identifies the location of a file without reference to an additional starting location. The first version returns true if the path, in native format, is absolute, false otherwise; the second version the other way round."
        }
    },
    "filesystem::hash_value": {
        "description": {
            "texte": "A hash value such that if for two paths, p1 == p2 then hash_value(p1) == hash_value(p2)."
        },
        "parametres": "   p   -   a std::filesystem::path object \n\n"
    },
    "operator==,!=,,>=(std::filesystem::path)": {
        "description": {
            "texte": "Compares two paths lexicographically.These functions are not visible to ordinary unqualified or qualified lookup , and can only be found by argument-dependent lookup when std::filesystem::path is an associated class of the arguments. This prevents undesirable conversions in the presence of a using namespace std::filesystem; using-directive."
        },
        "parametres": "   lhs, rhs   -   the paths to compare \n\n"
    },
    "filesystem::operator/(std::filesystem::path)": {
        "description": {
            "texte": "Concatenates two path components using the preferred directory separator if appropriate (see operator/= for details).Effectively returns path(lhs) /= rhs.This function is not visible to ordinary unqualified or qualified lookup, and can only be found by argument-dependent lookup when std::filesystem::path is an associated class of the arguments. This prevents undesirable conversions in the presence of a using namespace std::filesystem; using-directive."
        },
        "parametres": "   lhs, rhs   -   paths to concatenate \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nnamespace fs = std::filesystem;\nint main() {\n    fs::path p = \"C:\";\n    std::cout << \"\\\"C:\\\" / \\\"Users\\\" / \\\"batman\\\" == \"\n              << p / \"Users\" / \"batman\" << '\\n';\n}",
            "output": "\"C:\" / \"Users\" / \"batman\" == \"C:Users\\\\batman\""
        }
    },
    "operator>(std::filesystem::path)": {
        "description": {
            "texte": "Performs stream input or output on the path p. std::quoted is used so that spaces do not cause truncation when later read by stream input operator.These function templates are not visible to ordinary unqualified or qualified lookup , and can only be found by argument-dependent lookup when std::filesystem::path is an associated class of the arguments. This prevents undesirable conversions in the presence of a using namespace std::filesystem; using-directive."
        },
        "parametres": "   os   -   stream to perform output on \n   is   -   stream to perform input on \n   p   -   path to insert or extract \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <filesystem>\nint main()\n{\n        std::cout << std::filesystem::current_path() << '\\n';\n}",
            "output": "\"/home/user\""
        }
    },
    "filesystem::filesystem_error::filesystem_error": {
        "description": {
            "texte": "Constructs a new filesystem error object. The error code is set to ec and optionally, the paths that were involved in the operation that resulted in the error, are set to p1 and p2. what() after construction returns a string that contains what_arg."
        }
    },
    "filesystem::filesystem_error::path1, std::filesystem::filesystem_error::path2": {
        "description": {
            "texte": "Returns the paths that were stored in the exception object."
        }
    },
    "filesystem::filesystem_error::what": {
        "description": {
            "texte": "Returns an explanatory byte string. This explanatory string contains the explanatory string passed at the time of construction. Implementations are encouraged to include the pathnames of path1() and path2() in native format and the std::system_error::what() string inside the returned string as well."
        }
    },
    "filesystem::directory_entry::directory_entry": {
        "description": {
            "texte": "Constructs a new directory_entry object."
        },
        "parametres": "   p   -   path to the filesystem object to which the directory entry will refer \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n"
    },
    "filesystem::directory_entry::operator=": {
        "description": {
            "texte": "Replaces the contents of the directory entry (path and cached attributes, if any) with the contents of other.Both copy- and move-assignment operators for directory_entry are are defaulted."
        },
        "parametres": "   other   -   other directory_entry \n\n"
    },
    "filesystem::directory_entry::assign": {
        "description": {
            "texte": "Assigns new content to the directory entry object. Sets the path to p and calls refresh to update the cached attributes. If an error occurs, the values of the cached attributes are unspecified."
        },
        "parametres": "   p   -   path to the filesystem object to which the directory entry will refer \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n"
    },
    "filesystem::directory_entry::replace_filename": {
        "description": {
            "texte": "Changes the filename of the directory entry.Effectively modifies the path member by path.replace_filename(p) and calls refresh to update the cached attributes. If an error occurs, the values of the cached attributes are unspecified.This function does not commit any changes to the filesystem."
        },
        "parametres": "   p   -   the path to append to the parent path of the currently stored path \n   ec   -   out-parameter for error reporting in the non-throwing overload \n\n"
    },
    "filesystem::directory_entry::refresh": {
        "description": {
            "texte": "Examines the filesystem object referred to by this directory entry and stores its attributes for retrieval with status(), exists(), is_regular_file(), and other status accessors.If an error occurs, the value of any cached attributes is unspecified."
        },
        "parametres": "   ec   -   out-parameter for error reporting in the non-throwing overload \n\n"
    },
    "filesystem::directory_entry::path": {
        "description": {
            "texte": "Returns the full path the directory entry refers to."
        }
    },
    "filesystem::directory_entry::exists": {
        "description": {
            "texte": "Checks whether the pointed-to object exists. Effectively returns std::filesystem::exists(status()) or std::filesystem::exists(status(ec)), respectively."
        },
        "parametres": "   ec   -   out-parameter for error reporting in the non-throwing overload \n\n"
    },
    "filesystem::directory_entry::is_block_file": {
        "description": {
            "texte": "Checks whether the pointed-to object is a block device. Effectively returns std::filesystem::is_block_file(status()) or std::filesystem::is_block_file(status(ec)), respectively."
        },
        "parametres": "   ec   -   out-parameter for error reporting in the non-throwing overload \n\n"
    },
    "filesystem::directory_entry::is_character_file": {
        "description": {
            "texte": "Checks whether the pointed-to object is a character device. Effectively returns std::filesystem::is_character_file(status()) or std::filesystem::is_character_file(status(ec)), respectively."
        },
        "parametres": "   ec   -   out-parameter for error reporting in the non-throwing overload \n\n"
    },
    "filesystem::directory_entry::is_directory": {
        "description": {
            "texte": "Checks whether the pointed-to object is a directory. Effectively returns std::filesystem::is_directory(status()) or std::filesystem::is_directory(status(ec)), respectively."
        },
        "parametres": "   ec   -   out-parameter for error reporting in the non-throwing overload \n\n"
    },
    "filesystem::directory_entry::is_fifo": {
        "description": {
            "texte": "Checks whether the pointed-to object is a FIFO or pipe file. Effectively returns std::filesystem::is_fifo(status()) or std::filesystem::is_fifo(status(ec)), respectively."
        },
        "parametres": "   ec   -   out-parameter for error reporting in the non-throwing overload \n\n"
    },
    "filesystem::directory_entry::is_other": {
        "description": {
            "texte": "Checks whether the pointed-to object is an other file (not a regular file, directory or symlink). Effectively returns std::filesystem::is_other(status()) or std::filesystem::is_other(status(ec)), respectively."
        },
        "parametres": "   ec   -   out-parameter for error reporting in the non-throwing overload \n\n"
    },
    "filesystem::directory_entry::is_regular_file": {
        "description": {
            "texte": "Checks whether the pointed-to object is a regular file. Effectively returns std::filesystem::is_regular_file(status()) or std::filesystem::is_regular_file(status(ec)), respectively."
        },
        "parametres": "   ec   -   out-parameter for error reporting in the non-throwing overload \n\n"
    },
    "filesystem::directory_entry::is_socket": {
        "description": {
            "texte": "Checks whether the pointed-to object is a named socket. Effectively returns std::filesystem::is_socket(status()) or std::filesystem::is_socket(status(ec)), respectively."
        },
        "parametres": "   ec   -   out-parameter for error reporting in the non-throwing overload \n\n"
    },
    "filesystem::directory_entry::is_symlink": {
        "description": {
            "texte": "Checks whether the pointed-to object is a symlink. Effectively returns std::filesystem::is_symlink(symlink_status()) or std::filesystem::is_symlink(symlink_status(ec)), respectively."
        },
        "parametres": "   ec   -   out-parameter for error reporting in the non-throwing overload \n\n"
    },
    "filesystem::directory_entry::file_size": {
        "description": {
            "texte": "If the file size is cached in this directory_entry, returns the cached value. Otherwise, returns std::filesystem::file_size(path()) or std::filesystem::file_size(path(), ec), respectively."
        },
        "parametres": "   ec   -   out-parameter for error reporting in the non-throwing overload \n\n"
    },
    "filesystem::directory_entry::hard_link_count": {
        "description": {
            "texte": "If the number of hard links is cached in this directory_entry, returns the cached value. Otherwise, returns std::filesystem::hard_link_count(path()) or std::filesystem::hard_link_count(path(), ec), respectively."
        },
        "parametres": "   ec   -   out-parameter for error reporting in the non-throwing overload \n\n"
    },
    "filesystem::directory_entry::last_write_time": {
        "description": {
            "texte": "If the last modification time is cached in this directory_entry, returns the cached value. Otherwise, returns std::filesystem::last_write_time(path()) or std::filesystem::last_write_time(path(), ec), respectively."
        },
        "parametres": "   ec   -   out-parameter for error reporting in the non-throwing overload \n\n"
    },
    "filesystem::directory_entry::status, std::filesystem::directory_entry::symlink_status": {
        "description": {
            "texte": "The status of the file referred to by the entry."
        },
        "parametres": "   ec   -   out-parameter for error reporting in the non-throwing overload \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <filesystem>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n \nnamespace fs = std::filesystem;\n \nvoid demo_status(const fs::path& p, fs::file_status s)\n{\n    std::cout << p;\n    // alternative: switch(s.type()) { case fs::file_type::regular: ...}\n    if(fs::is_regular_file(s)) std::cout << \" is a regular file\\n\";\n    if(fs::is_directory(s)) std::cout << \" is a directory\\n\";\n    if(fs::is_block_file(s)) std::cout << \" is a block device\\n\";\n    if(fs::is_character_file(s)) std::cout << \" is a character device\\n\";\n    if(fs::is_fifo(s)) std::cout << \" is a named IPC pipe\\n\";\n    if(fs::is_socket(s)) std::cout << \" is a named IPC socket\\n\";\n    if(fs::is_symlink(s)) std::cout << \" is a symlink\\n\";\n    if(!fs::exists(s)) std::cout << \" does not exist\\n\";\n}\nint main()\n{\n    // create files of different kinds\n    fs::create_directory(\"sandbox\");\n    std::ofstream(\"sandbox/file\"); // create regular file\n    fs::create_directory(\"sandbox/dir\");\n    mkfifo(\"sandbox/pipe\", 0644);\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    std::strcpy(addr.sun_path, \"sandbox/sock\");\n    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n    bind(fd, (struct sockaddr*)&addr, sizeof addr);\n    fs::create_symlink(\"file\", \"sandbox/symlink\");\n \n    // demo different status accessors\n    for(auto it = fs::directory_iterator(\"sandbox\"); it != fs::directory_iterator(); ++it)\n        demo_status(*it, it->symlink_status()); // use cached status from directory entry\n    demo_status(\"dev/null\", fs::status(\"/dev/null\")); // direct calls to status\n    demo_status(\"dev/sda\", fs::status(\"/dev/sda\"));\n    demo_status(\"sandbox/no\", fs::status(\"/sandbox/no\"));\n \n    // cleanup\n    close(fd);\n    fs::remove_all(\"sandbox\");\n}",
            "output": "\"sandbox/file\" is a regular file\n\"sandbox/dir\" is a directory\n\"sandbox/pipe\" is a named IPC pipe\n\"sandbox/sock\" is a named IPC socket\n\"sandbox/symlink\" is a symlink\n\"dev/null\" is a character device\n\"dev/sda\" is a block device\n\"sandbox/no\" does not exist"
        }
    },
    "filesystem::directory_entry::operator==,!=,,>=": {
        "description": {
            "texte": "Compares the path with the directory entry rhs."
        },
        "parametres": "   rhs   -   directory_entry to compare \n\n"
    },
    "filesystem::directory_iterator::directory_iterator": {
        "description": {
            "texte": "Constructs a new directory iterator."
        }
    },
    "filesystem::directory_iterator::operator*, std::filesystem::directory_iterator::operator->": {
        "description": {
            "texte": "Accesses the pointed-to directory_entry.The result of operator* or operator-> on the end iterator is undefined behavior."
        }
    },
    "filesystem::directory_iterator::operator=": {
        "description": {
            "texte": "*this."
        }
    },
    "filesystem::directory_iterator::operator++, std::filesystem::directory_iterator::increment": {
        "description": {
            "texte": "Advances the iterator to the next entry. Invalidates all copies of the previous value of *this."
        },
        "parametres": "   ec   -   error code to store error status to \n\n"
    },
    "filesystem::recursive_directory_iterator::recursive_directory_iterator": {
        "description": {
            "texte": "Contructs new recursive directory iterator."
        }
    },
    "filesystem::recursive_directory_iterator::operator*, std::filesystem::recursive_directory_iterator::operator->": {
        "description": {
            "texte": "Accesses the pointed-to directory_entry.The result of operator* or operator-> on the end iterator is undefined behavior."
        }
    },
    "filesystem::recursive_directory_iterator::options": {
        "description": {
            "texte": "Returns the options that affect the directory iteration. The options can only be supplied when constructing the directory iterator.If the options argument was not supplied, returns options::none."
        }
    },
    "filesystem::recursive_directory_iterator::depth": {
        "description": {
            "texte": "Returns the number of directories from the starting directory to the currently iterated directory, i.e. the current depth of the directory hierarchy.The starting directory has depth of 0, its subdirectories have depth 1, etc.The behavior is undefined if *this is the end iterator."
        },
        "exemple": {
            "input": "#include <fstream>\n#include <iostream>\n#include <string>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::create_directories(\"sandbox/a/b/c\");\n    fs::create_directories(\"sandbox/a/b/d/e\");\n    std::ofstream(\"sandbox/a/b/file1.txt\");\n    fs::create_symlink(\"a\", \"sandbox/syma\");\n    for(auto i = fs::recursive_directory_iterator(\"sandbox\");\n             i != fs::recursive_directory_iterator();\n           ++i ) {\n        std::cout << std::string(i.depth(), ' ') << *i;\n        if(fs::is_symlink(i->symlink_status()))\n            std::cout << \" -> \" << fs::read_symlink(*i);\n        std::cout << '\\n';\n    }\n    fs::remove_all(\"sandbox\");\n}",
            "output": "\"sandbox/a\"\n \"sandbox/a/b\"\n  \"sandbox/a/b/c\"\n  \"sandbox/a/b/d\"\n   \"sandbox/a/b/d/e\"\n  \"sandbox/a/b/file1.txt\"\n\"sandbox/syma\" -> \"a\""
        }
    },
    "filesystem::recursive_directory_iterator::recursion_pending": {
        "description": {
            "texte": "Returns true if the next increment will cause the directory currently referred to by *this to be iterated into.This function returns true immediately after construction or an increment. Recursion can be disabled via disable_recursion_pending()."
        }
    },
    "filesystem::recursive_directory_iterator::operator=": {
        "description": {
            "texte": "Assigns a recursive directory iterator."
        },
        "parametres": "   other   -   another directory iterator to assign \n\n"
    },
    "filesystem::recursive_directory_iterator::operator++, std::filesystem::recursive_directory_iterator::increment": {
        "description": {
            "texte": "Advances the iterator to the next entry. Invalidates all copies of the previous value of *this.If there are no more entries left in the currently iterated directory, the iteration is resumed over the parent directory. The process is repeated if the parent directory has no sibling entries that can to be iterated on. If the parent of the directory hierarchy that has been recursively iterated on is reached (there are no candidate entries at depth() == 0), *this is set to an end iterator.Otherwise, if *this refers to a directory, it is iterated into if the following conditions are met:"
        },
        "parametres": "   ec   -   error code to store the error status to \n\n"
    },
    "filesystem::recursive_directory_iterator::pop": {
        "description": {
            "texte": "Moves the iterator one level up in the directory hierarchy. Invalidates all copies of the previous value of *this.If the parent directory is outside directory hierarchy that is iterated on (i.e. depth() == 0), sets *this to an end directory iterator."
        },
        "parametres": "   ec   -   error code to store the error status to \n\n"
    },
    "filesystem::recursive_directory_iterator::disable_recursion_pending": {
        "description": {
            "texte": "Disables recursion to the currently referred subdirectory, if any.The call modifies the pending recursion flag on the iterator in such a way that the next time increment is called, the iterator will advance within the current directly even if it is currently referring to a subdirectory that hasn't been visited.The status of the pending recursion flag can be queried with recursion_pending(), which is false after this call. It is reset back to true after increment, and its initial value is also true.The behavior is undefined if *this is the end iterator."
        },
        "exemple": {
            "input": "#include <fstream>\n#include <iostream>\n#include <string>\n#include <filesystem>\nnamespace fs = std::filesystem;\n \nint main()\n{\n    fs::create_directories(\"sandbox/a/b/c\");\n    fs::create_directories(\"sandbox/a/b/d/e\");\n    std::ofstream(\"sandbox/a/b/file1.txt\");\n    fs::create_symlink(\"a\", \"sandbox/syma\");\n    for(auto i = fs::recursive_directory_iterator(\"sandbox\");\n             i != fs::recursive_directory_iterator();\n           ++i ) {\n        std::cout << std::string(i.depth(), ' ') << *i;\n        if(fs::is_symlink(i->symlink_status()))\n            std::cout << \" -> \" << fs::read_symlink(*i);\n        std::cout << '\\n';\n \n        // do not descend into \"b\"\n        if(i->path().filename() == \"b\")\n            i.disable_recursion_pending();\n    }\n    fs::remove_all(\"sandbox\");\n}",
            "output": "\"sandbox/a\"\n \"sandbox/a/b\"\n\"sandbox/syma\" -> \"a\""
        }
    },
    "filesystem::file_status::file_status": {
        "description": {
            "texte": "Constructs a new file_status object."
        },
        "parametres": "   type   -   type of the file status \n   permissions   -   permissions of the file status \n\n"
    },
    "filesystem::file_status::operator=": {
        "description": {
            "texte": "Copy- or move-assigns another file status object."
        },
        "parametres": "   other   -   another file_status object to assign \n\n"
    },
    "filesystem::file_status::type": {
        "description": {
            "texte": "Accesses the file type information."
        },
        "parametres": "   type   -   file type to set to \n\n"
    },
    "filesystem::file_status::permissions": {
        "description": {
            "texte": "Accesses the file permissions information."
        },
        "parametres": "   perm   -   file permissions to set to \n\n"
    },
    "bad_array_new_length::bad_array_new_length": {
        "description": {
            "texte": "Constructs new bad_array_new_length object with in implementation-defined null-terminated byte string which is accessible through what()."
        }
    },
    "bad_typeid::bad_typeid": {
        "description": {
            "texte": "Constructs new std::bad_typeid object. The contents of the byte string returned by what() are implementation defined."
        }
    },
    "bad_cast::bad_cast": {
        "description": {
            "texte": "Constructs new std::bad_cast object. The contents of the byte string returned by what() are implementation defined."
        }
    },
    "pointer_traits::to_address": {
        "description": {
            "texte": "Constructs a raw pointer that references the same object as its pointer-like (\"fancy pointer\") argument.This function, if defined, is the inverse of pointer_to, and exists as the customization point to be called by std::to_address."
        },
        "parametres": "   p   -   fancy pointer/pointer-like object \n\n"
    },
    "allocator_traits::allocate": {
        "description": {
            "texte": "Uses the allocator a to allocate n*sizeof(Alloc::value_type) bytes of uninitialized storage."
        },
        "parametres": "   a   -   allocator to use \n   n   -   the number of objects to allocate storage for \n   hint   -   pointer to a nearby memory location \n\n"
    },
    "allocator_traits::deallocate": {
        "description": {
            "texte": "Uses the allocator a to deallocate the storage referenced by p, by calling a.deallocate(p, n)."
        },
        "parametres": "   a   -   allocator to use \n   p   -   pointer to the previously allocated storage \n   n   -   the number of objects the storage was allocated for \n\n"
    },
    "allocator_traits::destroy": {
        "description": {
            "texte": "Calls the destructor of the object pointed to by p. If possible, does so by calling a.destroy(p). If not possible (e.g. a does not have the member function destroy()), then calls the destructor of *p directly, as p->~T()."
        },
        "parametres": "   a   -   allocator to use for destruction \n   p   -   pointer to the object being destroyed \n\n"
    },
    "allocator_traits::max_size": {
        "description": {
            "texte": "If possible, obtains the maximum theoretically possible allocation size from the allocator a, by calling.a.max_size().If the above is not possible (e.g. a does not have the member function max_size()), then returns  std::numeric_limits<size_type>::max()  (until C++17)std::numeric_limits<size_type>::max() / sizeof(value_type) (since C++17)."
        }
    },
    "allocator_traits::select_on_container_copy_construction": {
        "description": {
            "texte": "If possible, obtains the copy-constructed version of the allocator a, by calling a.select_on_container_copy_construction(). If the above is not possible (e.g. a does not have the member function select_on_container_copy_construction(), then returns a, unmodified.This function is called by the copy constructors of all standard library containers. It allows the allocator used by the constructor's argument to become aware that the container is being copied and modify state if necessary."
        },
        "parametres": "   a   -   allocator used by a standard container passed as an argument to a container copy constructor \n\n"
    },
    "raw_storage_iterator::raw_storage_iterator": {
        "description": {
            "texte": "Initializes the iterator to point to the same value as it points."
        },
        "parametres": "   it   -   location to point to \n\n"
    },
    "raw_storage_iterator::base": {
        "description": {
            "texte": "Provides access to the iterator passed in the constructor of this raw_storage_iterator."
        }
    },
    "unique_ptr::~unique_ptr": {
        "description": {
            "texte": "If get() == nullptr there are no effects. Otherwise, the owned object is destroyed via get_deleter()(get()).Requires that get_deleter()(get()) does not throw exceptions."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nint main () \n{\n    auto deleter = [](int* ptr){\n        std::cout << \"[deleter called]\\n\";\n        delete ptr;\n    };\n \n    std::unique_ptr<int,decltype(deleter)> uniq(new int, deleter);\n    std::cout << (uniq ? \"not empty\\n\" : \"empty\\n\");\n    uniq.reset();\n    std::cout << (uniq ? \"not empty\\n\" : \"empty\\n\");\n}",
            "output": "not empty\n[deleter called]\nempty"
        }
    },
    "unique_ptr::release": {
        "description": {
            "texte": "Releases the ownership of the managed object if any. get() returns nullptr after the call."
        },
        "exemple": {
            "input": "#include <memory>\n#include <iostream>\n#include <cassert>\n \nstruct Foo {\n    Foo() { std::cout << \"Foo\\n\"; }\n    ~Foo() { std::cout << \"~Foo\\n\"; }\n};\n \nint main()\n{\n    std::cout << \"Creating new Foo...\\n\";\n    std::unique_ptr<Foo> up(new Foo());\n \n    std::cout << \"About to release Foo...\\n\";\n    Foo* fp = up.release();\n \n    assert (up.get() == nullptr);\n    std::cout << \"Foo is no longer owned by unique_ptr...\\n\";\n \n    delete fp;\n}",
            "output": "Creating new Foo...\nFoo\nAbout to release Foo...\nFoo is no longer owned by unique_ptr...\n~Foo"
        }
    },
    "unique_ptr::reset": {
        "description": {
            "texte": "Replaces the managed object."
        },
        "parametres": "   ptr   -   pointer to a new object to manage \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nstruct Foo {\n    Foo() { std::cout << \"Foo...\\n\"; }\n    ~Foo() { std::cout << \"~Foo...\\n\"; }\n};\n \nstruct D {\n    void operator() (Foo* p) {\n        std::cout << \"Calling delete for Foo object... \\n\";\n        delete p;\n    }\n};\n \nint main()\n{\n    std::cout << \"Creating new Foo...\\n\";\n    std::unique_ptr<Foo, D> up(new Foo(), D());  // up owns the Foo pointer (deleter D)\n \n    std::cout << \"Replace owned Foo with a new Foo...\\n\";\n    up.reset(new Foo());  // calls deleter for the old one\n \n    std::cout << \"Release and delete the owned Foo...\\n\";\n    up.reset(nullptr);      \n}",
            "output": "Creating new Foo...\nFoo...\nReplace owned Foo with a new Foo...\nFoo...\nCalling delete for Foo object...\n~Foo...\nRelease and delete the owned Foo...\nCalling delete for Foo object...\n~Foo..."
        }
    },
    "unique_ptr::swap": {
        "description": {
            "texte": "Swaps the managed objects and associated deleters of *this and another unique_ptr object other."
        },
        "parametres": "   other   -   another unique_ptr object to swap the managed object and the deleter with \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nstruct Foo {\n    Foo(int _val) : val(_val) { std::cout << \"Foo...\\n\"; }\n    ~Foo() { std::cout << \"~Foo...\\n\"; }\n    int val;\n};\n \nint main()\n{\n    std::unique_ptr<Foo> up1(new Foo(1));\n    std::unique_ptr<Foo> up2(new Foo(2));\n \n    up1.swap(up2);\n \n    std::cout << \"up1->val:\" << up1->val << std::endl;\n    std::cout << \"up2->val:\" << up2->val << std::endl;\n}",
            "output": "Foo...\nFoo...\nup1->val:2\nup2->val:1\n~Foo...\n~Foo..."
        }
    },
    "unique_ptr::get": {
        "description": {
            "texte": "Returns a pointer to the managed object or nullptr if no object is owned."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <string>\n#include <memory>\n \nint main()\n{\n    std::unique_ptr<std::string> s_p(new std::string(\"Hello, world!\"));\n    std::string *s = s_p.get();\n    std::cout << *s << '\\n';\n}",
            "output": "Hello, world!"
        }
    },
    "unique_ptr::get_deleter": {
        "description": {
            "texte": "Returns the deleter object which would be used for destruction of the managed object."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nstruct Foo\n{\n    Foo() { std::cout << \"Foo...\\n\"; }\n    ~Foo() { std::cout << \"~Foo...\\n\"; }\n};\n \nstruct D\n{\n    void bar() { std::cout << \"Call deleter D::bar()...\\n\"; }\n    void operator()(Foo* p) const\n    {\n        std::cout << \"Call delete for Foo object...\\n\";\n        delete p;\n    }\n};\n \nint main()\n{\n    std::unique_ptr<Foo, D> up(new Foo(), D());\n    D& del = up.get_deleter();\n    del.bar();\n}",
            "output": "Foo...\nCall deleter D::bar()...\nCall delete for Foo object...\n~Foo..."
        }
    },
    "unique_ptr::operator bool": {
        "description": {
            "texte": "Checks whether *this owns an object, i.e. whether get() != nullptr."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nint main()\n{\n    std::unique_ptr<int> ptr(new int(42));\n \n    if (ptr) std::cout << \"before reset, ptr is: \" << *ptr << '\\n';\n    ptr.reset();\n    if (ptr) std::cout << \"after reset, ptr is: \" << *ptr << '\\n';\n}",
            "output": "before reset, ptr is: 42"
        }
    },
    "unique_ptr::operator<<": {
        "description": {
            "texte": "Inserts the value of the pointer managed by p into the output stream os.Equivalent to os << p.get().This overload only participates in overload resolution if os << p.get() is a valid expression."
        },
        "parametres": "   os   -   a std::basic_ostream to insert p into \n   p   -   the pointer to be inserted into os \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nclass Foo {};\n \nint main()\n{\n    auto p = std::make_unique<Foo>();\n    std::cout << p << '\\n';\n    std::cout << p.get() << '\\n';\n}",
            "output": "0x6d9028\n0x6d9028"
        }
    },
    "weak_ptr::weak_ptr": {
        "description": {
            "texte": "Constructs new weak_ptr that potentially shares an object with r."
        },
        "parametres": "   r   -   a std::shared_ptr or std::weak_ptr that will be viewed by this std::weak_ptr \n\n",
        "exemple": {
            "input": "#include <memory>\n#include <iostream>\n \nstruct Foo {};\n \nint main()\n{\n   std::weak_ptr<Foo> w_ptr;\n \n   {\n      auto ptr = std::make_shared<Foo>();\n      w_ptr = ptr;\n      std::cout << \"w_ptr.use_count() inside scope: \" << w_ptr.use_count() << '\\n';\n   }\n \n   std::cout << \"w_ptr.use_count() out of scope: \" << w_ptr.use_count() << '\\n';\n   std::cout << \"w_ptr.expired() out of scope: \" << std::boolalpha << w_ptr.expired() << '\\n';\n}",
            "output": "w_ptr.use_count() inside scope: 1\nw_ptr.use_count() out of scope: 0\nw_ptr.expired() out of scope: true"
        }
    },
    "weak_ptr::operator=": {
        "description": {
            "texte": "Replaces the managed object with the one managed by r. The object is shared with r. If r manages no object, *this manages no object too."
        },
        "parametres": "   r   -   smart pointer to share an object with \n\n"
    },
    "weak_ptr::reset": {
        "description": {
            "texte": "Releases the reference to the managed object. After the call *this manages no object."
        }
    },
    "weak_ptr::swap": {
        "description": {
            "texte": "Exchanges the contents of *this and r."
        },
        "parametres": "   r   -   smart pointer to exchange the contents with \n\n"
    },
    "weak_ptr::use_count": {
        "description": {
            "texte": "Returns the number of shared_ptr instances that share ownership of the managed object, or \u200b0\u200b if the managed object has already been deleted, i.e. *this is empty."
        }
    },
    "weak_ptr::expired": {
        "description": {
            "texte": "Equivalent to use_count() == 0. The destructor for the managed object may not yet have been called, but this object's destruction is imminent (or may have already happened)."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nstd::weak_ptr<int> gw;\n \nvoid f()\n{\n    if (!gw.expired()) {\n        std::cout << \"gw is valid\\n\";\n    }\n    else {\n        std::cout << \"gw is expired\\n\";\n    }\n}\n \nint main()\n{\n    {\n        auto sp = std::make_shared<int>(42);\n        gw = sp;\n \n        f();\n    }\n \n    f();\n}",
            "output": "gw is valid\ngw is expired"
        }
    },
    "weak_ptr::lock": {
        "description": {
            "texte": "Creates a new std::shared_ptr that shares ownership of the managed object. If there is no managed object, i.e. *this is empty, then the returned shared_ptr also is empty.Effectively returns expired() ? shared_ptr<T>() : shared_ptr<T>(*this), executed atomically."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nvoid observe(std::weak_ptr<int> weak) \n{\n    if (auto observe = weak.lock()) {\n        std::cout << \"\\tobserve() able to lock weak_ptr<>, value=\" << *observe << \"\\n\";\n    } else {\n        std::cout << \"\\tobserve() unable to lock weak_ptr<>\\n\";\n    }\n}\n \nint main()\n{\n    std::weak_ptr<int> weak;\n    std::cout << \"weak_ptr<> not yet initialized\\n\";\n    observe(weak);\n \n    {\n        auto shared = std::make_shared<int>(42);\n        weak = shared;\n        std::cout << \"weak_ptr<> initialized with shared_ptr.\\n\";\n        observe(weak);\n    }\n \n    std::cout << \"shared_ptr<> has been destructed due to scope exit.\\n\";\n    observe(weak);\n}",
            "output": "weak_ptr<> not yet initialized\n        observe() unable to lock weak_ptr<>\nweak_ptr<> initialized with shared_ptr.\n        observe() able to lock weak_ptr<>, value=42\nshared_ptr<> has been destructed due to scope exit.\n        observe() unable to lock weak_ptr<>"
        }
    },
    "weak_ptr::owner_before": {
        "description": {
            "texte": "Checks whether this weak_ptr precedes other in implementation defined owner-based (as opposed to value-based) order. The order is such that two smart pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by get() are different (e.g. because they point at different subobjects within the same object).This ordering is used to make shared and weak pointers usable as keys in associative containers, typically through std::owner_less."
        },
        "parametres": "   other   -   the std::shared_ptr or std::weak_ptr to be compared \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nstruct Foo {\n    int n1;\n    int n2; \n    Foo(int a, int b) : n1(a), n2(b) {}\n};\nint main()\n{   \n    auto p1 = std::make_shared<Foo>(1, 2);\n    std::shared_ptr<int> p2(p1, &p1->n1);\n    std::shared_ptr<int> p3(p1, &p1->n2);\n \n    std::cout << std::boolalpha\n              << \"p2 < p3 \" << (p2 < p3) << '\\n'\n              << \"p3 < p2 \" << (p3 < p2) << '\\n'\n              << \"p2.owner_before(p3) \" << p2.owner_before(p3) << '\\n'\n              << \"p3.owner_before(p2) \" << p3.owner_before(p2) << '\\n';\n \n    std::weak_ptr<int> w2(p2);\n    std::weak_ptr<int> w3(p3);\n    std::cout \n//              << \"w2 < w3 \" << (w2 < w3) << '\\n'  // won't compile \n//              << \"w3 < w2 \" << (w3 < w2) << '\\n'  // won't compile\n              << \"w2.owner_before(w3) \" << w2.owner_before(w3) << '\\n'\n              << \"w3.owner_before(w2) \" << w3.owner_before(w2) << '\\n';\n \n}",
            "output": "p2 < p3 true\np3 < p2 false\np2.owner_before(p3) false\np3.owner_before(p2) false\nw2.owner_before(w3) false\nw3.owner_before(w2) false"
        }
    },
    "deduction guides for std::weak_ptr\n": {
        "description": {
            "texte": "One deduction guide is provided for std::weak_ptr to account for the edge case missed by the implicit deduction guides."
        },
        "exemple": {
            "input": "#include <memory>\n \nint main()\n{\n    auto p = std::make_shared<int>(42);\n    std::weak_ptr w{p};    // explicit deduction guide is used in this case\n}"
        }
    },
    "auto_ptr::auto_ptr": {
        "description": {
            "texte": "Constructs the auto_ptr from a pointer that refers to the object to manage."
        },
        "parametres": "   p   -   a pointer to an object to manage \n   r   -   another auto_ptr to transfer the ownership of the object from \n   m   -   an implementation-defined type that holds a reference to auto_ptr \n\n"
    },
    "auto_ptr::operator=": {
        "description": {
            "texte": "Replaces the managed object with the one managed by r."
        },
        "parametres": "   r   -   another auto_ptr to transfer the ownership of the object from \n   m   -   an implementation-defined type that holds a reference to auto_ptr \n\n"
    },
    "auto_ptr::get": {
        "description": {
            "texte": "Returns the pointer that is held by *this."
        }
    },
    "auto_ptr::release": {
        "description": {
            "texte": "Releases the held pointer. After the call *this holds the null pointer."
        }
    },
    "auto_ptr::reset": {
        "description": {
            "texte": "Replaces the held pointer by p. If the currently held pointer is not null pointer, delete get() is called."
        },
        "parametres": "   p   -   a pointer to an object to manage \n\n"
    },
    "enable_shared_from_this::enable_shared_from_this": {
        "description": {
            "texte": "Constructs a new enable_shared_from_this object. The private std::weak_ptr<T> member is value-initialized."
        },
        "parametres": "   obj   -   an enable_shared_from_this to copy \n\n",
        "exemple": {
            "input": "#include <memory>\n \nstruct Foo : public std::enable_shared_from_this<Foo> {\n    Foo() {}  // implicitly calls enable_shared_from_this constructor\n    std::shared_ptr<Foo> getFoo() { return shared_from_this(); }\n};\n \nint main() {\n    std::shared_ptr<Foo> pf1(new Foo);\n    auto pf2 = pf1->getFoo();  // shares ownership of object with pf1\n}"
        }
    },
    "enable_shared_from_this::~enable_shared_from_this": {
        "description": {
            "texte": "Destroys *this."
        }
    },
    "enable_shared_from_this::operator=": {
        "description": {
            "texte": "Does nothing; returns *this."
        },
        "parametres": "   obj   -   an enable_shared_from_this to assign to *this \n\n",
        "exemple": {
            "input": "#include <memory>\n#include <iostream>\n \nclass SharedInt : public std::enable_shared_from_this<SharedInt>\n{\npublic:\n    explicit SharedInt(int n) : mNumber(n) {}\n    SharedInt(const SharedInt&) = default;\n    SharedInt(SharedInt&&) = default;\n    ~SharedInt() = default;\n \n    // Both assignment operators use enable_shared_from_this::operator=\n    SharedInt& operator=(const SharedInt&) = default;\n    SharedInt& operator=(SharedInt&&) = default;\n \n    int number() const { return mNumber; }\n \nprivate:\n    int mNumber;\n};\n \nint main() {\n    std::shared_ptr<SharedInt> a = std::make_shared<SharedInt>(2);\n    std::shared_ptr<SharedInt> b = std::make_shared<SharedInt>(4);\n    *a = *b;\n \n    std::cout << a->number() << std::endl;\n}",
            "output": "4"
        }
    },
    "enable_shared_from_this::shared_from_this": {
        "description": {
            "texte": "Returns a std::shared_ptr<T> that shares ownership of *this with all existing std::shared_ptr that refer to *this.Effectively executes std::shared_ptr<T>(weak_this), where weak_this is the private mutable std::weak_ptr<T> member of enable_shared_from_this."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <memory>\n \nstruct Foo : public std::enable_shared_from_this<Foo> {\n    Foo() { std::cout << \"Foo::Foo\\n\"; }\n    ~Foo() { std::cout << \"Foo::~Foo\\n\"; } \n    std::shared_ptr<Foo> getFoo() { return shared_from_this(); }\n};\n \nint main() {\n    Foo *f = new Foo;\n    std::shared_ptr<Foo> pf1;\n \n    {\n        std::shared_ptr<Foo> pf2(f);\n        pf1 = pf2->getFoo();  // shares ownership of object with pf2\n    }\n \n    std::cout << \"pf2 is gone\\n\";   \n}",
            "output": "Foo::Foo\npf2 is gone\nFoo::~Foo"
        }
    },
    "enable_shared_from_this::weak_from_this": {
        "description": {
            "texte": "Returns a std::weak_ptr<T> that tracks ownership of *this by all existing std::shared_ptr that refer to *this."
        }
    },
    "pmr::polymorphic_allocator::polymorphic_allocator": {
        "description": {
            "texte": "Constructs a new polymorphic_allocator."
        },
        "parametres": "   other   -   another polymorphic_allocator to copy from \n   r   -   pointer to the memory resource to use. May not be null. \n\n"
    },
    "pmr::polymorphic_allocator::allocate": {
        "description": {
            "texte": "Allocates storage for n objects of type T using the underlying memory resource. Equivalent to return static_cast<T*>(resource()->allocate(n * sizeof(T), alignof(T)));."
        },
        "parametres": "   n   -   the number of objects to allocate storage for \n\n"
    },
    "pmr::polymorphic_allocator::deallocate": {
        "description": {
            "texte": "Deallocates the storage pointed to by p, which must have been allocated from a std::pmr::memory_resource x that compares equal to *resource() using x.allocate(n * sizeof(T), alignof(T)).Equivalent to this->resource()->deallocate(p, n * sizeof(T), alignof(T));"
        },
        "parametres": "   p   -   pointer to memory to deallocate \n   n   -   the number of objects originally allocated \n\n"
    },
    "pmr::polymorphic_allocator::construct": {
        "description": {
            "texte": "Constructs an object in allocated, but not initialized storage pointed to by p the provided constructor arguments. If the object is of type that itself uses allocators, or if it is std::pair, passes this->resource() down to the constructed object."
        },
        "parametres": "   p   -   pointer to allocated, but not initialized storage \n   args...   -   the constructor arguments to pass to the constructor of T \n   x   -   the constructor arguments to pass to the constructor of T1 \n   y   -   the constructor arguments to pass to the constructor of T2 \n   xy   -   the pair whose two members are the constructor arguments for T1 and T2 \n\n"
    },
    "pmr::polymorphic_allocator::destroy": {
        "description": {
            "texte": "Destroys the object pointed to by p, as if by calling p->~U()."
        },
        "parametres": "   p   -   pointer to the object being destroyed \n\n"
    },
    "pmr::polymorphic_allocator::allocate_bytes": {
        "description": {
            "texte": "Allocates nbytes bytes of storage at specified alignment alignment using the underlying memory resource. Equivalent to return resource()->allocate(nbytes, alignment);"
        },
        "parametres": "   nbytes   -   the number of bytes to allocate \n   alignment   -   the alignment to use \n\n"
    },
    "pmr::polymorphic_allocator::deallocate_bytes": {
        "description": {
            "texte": "Deallocates the storage pointed to by p, which must have been allocated from a std::pmr::memory_resource x that compares equal to *resource(). using x.allocate(nbytes, alignment), typically through a call to allocate_bytes(nbytes, alignment.Equivalent to resorce()->deallocate(p, nbytes, alignment);"
        },
        "parametres": "   p   -   pointer to memory to deallocate \n   nbytes   -   the number of bytes originally allocated \n   alignment   -   the alignment originally allocated \n\n"
    },
    "pmr::polymorphic_allocator::allocate_object": {
        "description": {
            "texte": "Allocates storage for n objects of type U using the underlying memory resource.If SIZE_MAX / sizeof(U) < n, throws std::length_error, otherwise equivalent to return static_cast<U*>(allocate_bytes(n * sizeof(U), alignof(U)) );"
        },
        "parametres": "   n   -   the number of objects to allocate storage for \n\n"
    },
    "pmr::polymorphic_allocator::deallocate_object": {
        "description": {
            "texte": "Destroys the object of type U and deallocates storage allocated for it.Equivalent to.",
            "code": "destroy(p);\ndeallocate_object(p);"
        },
        "parametres": "   p   -   pointer to the object to destroy and deallocate \n\n"
    },
    "pmr::polymorphic_allocator::new_object": {
        "description": {
            "texte": "Allocates and constructs an object of type U.Equivalent to.",
            "code": "U* p = allocate_object<U>();\ntry {\n  construct(p, std::forward<CtorArgs>(ctor_args)...);\n} catch (...) {\n  deallocate_object(p);\n  throw;\n}\nreturn p;"
        },
        "parametres": "   ctor_args   -   the arguments to forward to the the constructor of U \n\n"
    },
    "pmr::polymorphic_allocator:: select_on_container_copy_construction": {
        "description": {
            "texte": "Returns a default-constructed polymorphic_allocator object."
        }
    },
    "pmr::polymorphic_allocator::resource": {
        "description": {
            "texte": "Returns the memory resource pointer used by this polymorphic allocator."
        }
    },
    "pmr::synchronized_pool_resource::synchronized_pool_resource": {
        "description": {
            "texte": "Constructs a synchronized_pool_resource."
        },
        "parametres": "   opts   -   a std::pmr::pool_options struct containing the constructor options \n   upstream   -   the upstream memory resource to use \n\n"
    },
    "pmr::synchronized_pool_resource::~synchronized_pool_resource": {
        "description": {
            "texte": "Destroys a synchronized_pool_resource.Deallocates all memory owned by this resource by calling this->release()."
        }
    },
    "pmr::synchronized_pool_resource::release": {
        "description": {
            "texte": "Releases all memory owned by this resource by calling the deallocate function of the upstream memory resource as needed.Memory is released back to the upstream resource even if deallocate has not been called for some of the allocated blocks."
        }
    },
    "pmr::synchronized_pool_resource::upstream_resource": {
        "description": {
            "texte": "Returns a pointer to the upstream memory resource. This is the same value as the upstream argument passed to the constructor of this object."
        }
    },
    "pmr::synchronized_pool_resource::options": {
        "description": {
            "texte": "Returns the options that controls the pooling behavior of this resource.The values in the returned struct may differ from those supplied to the constructor in the following ways:"
        }
    },
    "pmr::synchronized_pool_resource::do_allocate": {
        "description": {
            "texte": "Allocates storage.If the pool selected for a block of size bytes is unable to satisfy the request from its internal data structures, calls allocate() on the upstream memory resource to obtain memory.If the size requested is larger than what the largest pool can handle, memory is allocated by calling allocate() on the upstream memory resource."
        }
    },
    "pmr::synchronized_pool_resource::do_deallocate": {
        "description": {
            "texte": "Returns the memory at p to the pool. It is unspecified if or under what circumstances this operation will result in a call to deallocate() on the upstream memory resource."
        }
    },
    "pmr::synchronized_pool_resource::do_is_equal": {
        "description": {
            "texte": "Compare *this with other for identity - memory allocated using a synchronized_pool_resource can only be deallocated using that same resource."
        }
    },
    "pmr::unsynchronized_pool_resource::unsynchronized_pool_resource": {
        "description": {
            "texte": "Constructs a unsynchronized_pool_resource."
        },
        "parametres": "   opts   -   a std::pmr::pool_options struct containing the constructor options \n   upstream   -   the upstream memory resource to use \n\n"
    },
    "pmr::unsynchronized_pool_resource::~unsynchronized_pool_resource": {
        "description": {
            "texte": "Destroys a unsynchronized_pool_resource.Deallocates all memory owned by this resource by calling this->release()."
        }
    },
    "pmr::unsynchronized_pool_resource::release": {
        "description": {
            "texte": "Releases all memory owned by this resource by calling the deallocate function of the upstream memory resource as needed.Memory is released back to the upstream resource even if deallocate has not been called for some of the allocated blocks."
        }
    },
    "pmr::unsynchronized_pool_resource::upstream_resource": {
        "description": {
            "texte": "Returns a pointer to the upstream memory resource. This is the same value as the upstream argument passed to the constructor of this object."
        }
    },
    "pmr::unsynchronized_pool_resource::options": {
        "description": {
            "texte": "Returns the options that controls the pooling behavior of this resource.The values in the returned struct may differ from those supplied to the constructor in the following ways:"
        }
    },
    "pmr::unsynchronized_pool_resource::do_allocate": {
        "description": {
            "texte": "Allocates storage.If the pool selected for a block of size bytes is unable to satisfy the request from its internal data structures, calls allocate() on the upstream memory resource to obtain memory.If the size requested is larger than what the largest pool can handle, memory is allocated by calling allocate() on the upstream memory resource."
        }
    },
    "pmr::unsynchronized_pool_resource::do_deallocate": {
        "description": {
            "texte": "Returns the memory at p to the pool. It is unspecified if or under what circumstances this operation will result in a call to deallocate() on the upstream memory resource."
        }
    },
    "pmr::unsynchronized_pool_resource::do_is_equal": {
        "description": {
            "texte": "Compare *this with other for identity - memory allocated using a unsynchronized_pool_resource can only be deallocated using that same resource."
        }
    },
    "pmr::monotonic_buffer_resource::monotonic_buffer_resource": {
        "description": {
            "texte": "Constructs a monotonic_buffer_resource. The constructors not taking a upstream memory resource pointer uses the return value of std::pmr::get_default_resource as the upstream memory resource."
        },
        "parametres": "   upstream   -   the upstream memory resource to use; must point to a valid memory resource \n   initial_size   -   the minimum size of the first buffer to allocate; must be greater than zero \n   buffer   -   the initial buffer to use \n   buffer_size   -   the size of the initial buffer; cannot be greater than the number of bytes in buffer \n\n"
    },
    "pmr::monotonic_buffer_resource::~monotonic_buffer_resource": {
        "description": {
            "texte": "Destroys a monotonic_buffer_resource.Deallocates all memory owned by this resource by calling this->release()."
        }
    },
    "pmr::monotonic_buffer_resource::release": {
        "description": {
            "texte": "Releases all allocated memory by calling the deallocate function on the upstream memory resource as necessary.Memory is released back to the upstream resource even if deallocate has not been called for some of the allocated blocks."
        }
    },
    "pmr::monotonic_buffer_resource::upstream_resource": {
        "description": {
            "texte": "Returns a pointer to the upstream memory resource. This is the same value as the upstream argument passed to the constructor of this object."
        }
    },
    "pmr::monotonic_buffer_resource::do_allocate": {
        "description": {
            "texte": "Allocates storage.If the current buffer has sufficient unused space to fit a block with the specified size and alignment, allocates the return block from the current buffer.Otherwise, this function allocates a new buffer by calling upstream_resource()->allocate(n, m), where n is not less than the greater of bytes and the next buffer size and m is not less than alignment. It sets the new buffer as the current buffer, increases the next buffer size by an implementation-defined growth factor (which is not necessarily integral), and then allocates the return block from the newly allocated buffer."
        }
    },
    "pmr::monotonic_buffer_resource::do_deallocate": {
        "description": {
            "texte": "This function has no effect. Memory used by a monotonic_buffer_resource, as its name indicates, increases monotonically until the resource is destroyed."
        }
    },
    "pmr::monotonic_buffer_resource::do_is_equal": {
        "description": {
            "texte": "Compare *this with other for identity - memory allocated using a monotonic_buffer_resource can only be deallocated using that same resource."
        }
    },
    "chrono::system_clock::now": {
        "description": {
            "texte": "Returns a time point representing the current point in time."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <chrono>\n \nvolatile int sink;\nint main()\n{\n    for (auto size = 1ull; size < 1000000000ull; size *= 100) {\n        // record start time\n        auto start = std::chrono::system_clock::now();\n        // do some work\n        std::vector<int> v(size, 42);\n        sink = std::accumulate(v.begin(), v.end(), 0u); // make sure it's a side effect\n        // record end time\n        auto end = std::chrono::system_clock::now();\n        std::chrono::duration<double> diff = end-start;\n        std::cout << \"Time to fill and iterate a vector of \" \n                  << size << \" ints : \" << diff.count() << \" s\\n\";\n    }\n}",
            "output": "Time to fill and iterate a vector of 1 ints : 2.43e-07 s\nTime to fill and iterate a vector of 100 ints : 4.1e-07 s\nTime to fill and iterate a vector of 10000 ints : 2.519e-05 s\nTime to fill and iterate a vector of 1000000 ints : 0.00207669 s\nTime to fill and iterate a vector of 100000000 ints : 0.423087 s"
        }
    },
    "chrono::system_clock::to_time_t": {
        "description": {
            "texte": "Converts t to a std::time_t type.If std::time_t has lower precision, it is implementation-defined whether the value is rounded or truncated."
        },
        "parametres": "   t   -   system clock time point to convert \n\n"
    },
    "chrono::system_clock::from_time_t": {
        "description": {
            "texte": "Converts t to a time point type, using the coarser precision of the two types.If time_point has lower precision, it is implementation defined whether the value is rounded or truncated."
        },
        "parametres": "   t   -   std::time_t value to convert \n\n"
    },
    "chrono::operator<< (std::chrono::sys_time)": {
        "description": {
            "texte": "Outputs tp into the stream os."
        }
    },
    "chrono::to_stream (std::chrono::sys_time)": {
        "description": {
            "texte": "Outputs tp to the stream os, formatted according to the null-terminated format string fmt. If %Z is used, it is replaced with \"UTC\" widened to CharT. If %z or a modified variant thereof is used, an offset of 0min will be formatted."
        }
    },
    "chrono::from_stream (std::chrono::sys_time)": {
        "description": {
            "texte": "Attempts to parse the input stream is into the time point tp according to the format string fmt.Behaves as an UnformattedInputFunction, except that it has an unspecified effect on is.gcount(). After constructing and checking the sentry object, attempts to parse the input stream is into tp according to the format string fmt. If the parse fails to decode a valid time point, is.setstate(std::ios_base::failbit) is called and tp is not modified.If the format specifier %Z is used and successfully parsed, the parsed value is assigned to *abbrev if abbrev is not null. If the format specifier %z or a modified variant is used and successfully parsed, the parsed value is assigned to *offset if offset is not null, and the parsed offset will be subtracted from the parsed timestamp before the difference is assigned to tp."
        }
    },
    "chrono::steady_clock::now": {
        "description": {
            "texte": "Returns a time point representing the current point in time."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <chrono>\n \nvolatile int sink;\nint main()\n{\n    for (auto size = 1ull; size < 1000000000ull; size *= 100) {\n        // record start time\n        auto start = std::chrono::steady_clock::now();\n        // do some work\n        std::vector<int> v(size, 42);\n        sink = std::accumulate(v.begin(), v.end(), 0u); // make sure it's a side effect\n        // record end time\n        auto end = std::chrono::steady_clock::now();\n        std::chrono::duration<double> diff = end-start;\n        std::cout << \"Time to fill and iterate a vector of \" \n                  << size << \" ints : \" << diff.count() << \" s\\n\";\n    }\n}",
            "output": "Time to fill and iterate a vector of 1 ints : 2.43e-07 s\nTime to fill and iterate a vector of 100 ints : 4.1e-07 s\nTime to fill and iterate a vector of 10000 ints : 2.519e-05 s\nTime to fill and iterate a vector of 1000000 ints : 0.00207669 s\nTime to fill and iterate a vector of 100000000 ints : 0.423087 s"
        }
    },
    "chrono::high_resolution_clock::now": {
        "description": {
            "texte": "Returns a time point representing the current point in time."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <chrono>\n \nvolatile int sink;\nint main()\n{\n    for (auto size = 1ull; size < 1000000000ull; size *= 100) {\n        // record start time\n        auto start = std::chrono::high_resolution_clock::now();\n        // do some work\n        std::vector<int> v(size, 42);\n        sink = std::accumulate(v.begin(), v.end(), 0u); // make sure it's a side effect\n        // record end time\n        auto end = std::chrono::high_resolution_clock::now();\n        std::chrono::duration<double> diff = end-start;\n        std::cout << \"Time to fill and iterate a vector of \" \n                  << size << \" ints : \" << diff.count() << \" s\\n\";\n    }\n}",
            "output": "Time to fill and iterate a vector of 1 ints : 2.43e-07 s\nTime to fill and iterate a vector of 100 ints : 4.1e-07 s\nTime to fill and iterate a vector of 10000 ints : 2.519e-05 s\nTime to fill and iterate a vector of 1000000 ints : 0.00207669 s\nTime to fill and iterate a vector of 100000000 ints : 0.423087 s"
        }
    },
    "chrono::duration_values::zero": {
        "description": {
            "texte": "Returns a zero-length representation."
        }
    },
    "chrono::duration_values::min": {
        "description": {
            "texte": "Returns the lowest possible representation."
        }
    },
    "chrono::duration_values::max": {
        "description": {
            "texte": "Returns the largest possible representation."
        }
    },
    "reference_wrapper::reference_wrapper": {
        "description": {
            "texte": "Constructs a new reference wrapper."
        },
        "parametres": "   x   -   an object to wrap \n   other   -   another reference wrapper \n\n"
    },
    "reference_wrapper::operator=": {
        "description": {
            "texte": "Copy assignment operator. Drops the current reference and stores a reference to other.get()."
        },
        "parametres": "   other   -   reference wrapper to copy \n\n"
    },
    "reference_wrapper::get, std::reference_wrapper::operator T&": {
        "description": {
            "texte": "Returns the stored reference."
        }
    },
    "deduction guides for std::reference_wrapper\n": {
        "description": {
            "texte": "One deduction guide is provided for std::reference_wrapper to support deduction of the sole class template parameter."
        }
    },
    "thread::id::id": {
        "description": {
            "texte": "Default-constructs a new thread identifier. The identifier does not represent a thread."
        }
    },
    "vector::flip": {
        "description": {
            "texte": "Toggles each bool in the vector (replaces with its opposite value)."
        }
    },
    "vector::reference": {
        "description": {
            "texte": "The std::vector<bool> specialization defines std::vector<bool>::reference as a publicly-accessible nested class. std::vector<bool>::reference proxies the behavior of references to a single bit in std::vector<bool>.The primary use of std::vector<bool>::reference is to provide an l-value that can be returned from operator[].Any reads or writes to a vector that happen via a std::vector<bool>::reference potentially read or write to the entire underlying vector."
        },
        "parametres": "   x   -   value to assign \n\n"
    },
    "linear_congruential_engine::linear_congruential_engine": {
        "description": {
            "texte": "Constructs the pseudo-random number engine.The overload (3) only participates in overload resolution if Sseq qualifies as a SeedSequence. In particular, it is excluded from the set of candidate functions if Sseq is convertible to result_type."
        },
        "parametres": "   value   -   seed value to use in the initialization of the internal state \n   s   -   seed sequence to use in the initialization of the internal state \n\n"
    },
    "linear_congruential_engine::seed": {
        "description": {
            "texte": "Reinitializes the internal state of the random-number engine using new seed value."
        },
        "parametres": "   value   -   seed value to use in the initialization of the internal state \n   seq   -   seed sequence to use in the initialization of the internal state \n\n"
    },
    "linear_congruential_engine::discard": {
        "description": {
            "texte": "Advances the internal state by z times. Equivalent to calling operator() z times and discarding the result."
        },
        "parametres": "   z   -   integer value specifying the number of times to advance the state by \n\n"
    },
    "linear_congruential_engine::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the random-number engine. This value is equal to 1u if increment is 0u, and is equal to 0u otherwise."
        }
    },
    "linear_congruential_engine::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the random-number engine. This value is one less than modulus."
        }
    },
    "mersenne_twister_engine::mersenne_twister_engine": {
        "description": {
            "texte": "Constructs the pseudo-random number engine.Note: initialization requirements are based on the 2002 version of Mersenne Twister, mt19937ar.c.The overload (3) only participates in overload resolution if Sseq qualifies as a SeedSequence. In particular, it is excluded from the set of candidate functions if Sseq is convertible to result_type."
        },
        "parametres": "   value   -   seed value to use in the initialization of the internal state \n   s   -   seed sequence to use in the initialization of the internal state \n\n"
    },
    "mersenne_twister_engine::seed": {
        "description": {
            "texte": "Reinitializes the internal state of the random-number engine using new seed value."
        },
        "parametres": "   value   -   seed value to use in the initialization of the internal state \n   seq   -   seed sequence to use in the initialization of the internal state \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <random>\n \nint main()\n{\n    std::mt19937 gen;\n \n    // Seed the engine with an unsigned int\n    gen.seed(1);\n    std::cout << \"after seed by 1: \" << gen() << '\\n';\n \n    // Seed the engine with two unsigned ints\n    std::seed_seq sseq{1, 2};\n    gen.seed(sseq);\n    std::cout << \"after seed by {1,2}: \" << gen() << '\\n';\n}",
            "output": "after seed by 1: 1791095845\nafter seed by {1,2}: 3127717181"
        }
    },
    "mersenne_twister_engine::operator()": {
        "description": {
            "texte": "Generates a pseudo-random value. The state of the engine is advanced by one position."
        }
    },
    "mersenne_twister_engine::discard": {
        "description": {
            "texte": "Advances the internal state by z times. Equivalent to calling operator() z times and discarding the result."
        },
        "parametres": "   z   -   integer value specifying the number of times to advance the state by \n\n"
    },
    "mersenne_twister_engine::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the random-number engine. This value is equal to 0u."
        }
    },
    "mersenne_twister_engine::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the random-number engine. This value is equal to 2w - 1, where w is the template parameter also accessible as static member word_size."
        }
    },
    "operator==,!=(std::mersenne_twister_engine)\n": {
        "description": {
            "texte": "Compares two pseudo-random number engines. Two engines are equal, if their internal states are equivalent, that is, if they would generate equivalent values for any number of calls of operator()."
        },
        "parametres": "   lhs, rhs   -   engines to compare \n\n"
    },
    "operator>(std::mersenne_twister_engine)\n": {
        "description": {
            "texte": "If a textual representation is written using os << x and that representation is restored into the same or a different object y of the same type using is >> y, then x==y.The textual representation is written with os.fmtflags set to ios_base::dec|ios_base::left and the fill character set to the space character. The textual representation of the engine's internal state is a set of decimal numbers separated by spaces."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   e   -   pseudo-random number engine \n\n"
    },
    "subtract_with_carry_engine::subtract_with_carry_engine": {
        "description": {
            "texte": "Constructs the pseudo-random number engine.The overload (3) only participates in overload resolution if Sseq qualifies as a SeedSequence. In particular, it is excluded from the set of candidate functions if Sseq is convertible to result_type."
        },
        "parametres": "   value   -   seed value to use in the initialization of the internal state \n   s   -   seed sequence to use in the initialization of the internal state \n\n"
    },
    "subtract_with_carry_engine::seed": {
        "description": {
            "texte": "Reinitializes the internal state of the random-number engine using new seed value."
        },
        "parametres": "   value   -   seed value to use in the initialization of the internal state \n   seq   -   seed sequence to use in the initialization of the internal state \n\n"
    },
    "subtract_with_carry_engine::operator()": {
        "description": {
            "texte": "Generates a pseudo-random value. The state of the engine is advanced by one position."
        }
    },
    "subtract_with_carry_engine::discard": {
        "description": {
            "texte": "Advances the internal state by z times. Equivalent to calling operator() z times and discarding the result."
        },
        "parametres": "   z   -   integer value specifying the number of times to advance the state by \n\n"
    },
    "subtract_with_carry_engine::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the random-number engine. This value is equal to 0u."
        }
    },
    "subtract_with_carry_engine::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the random-number engine. This value is equal to 2w - 1, where w is the template parameter also accessible as static member word_size."
        }
    },
    "operator==,!=(std::subtract_with_carry_engine)\n": {
        "description": {
            "texte": "Compares two pseudo-random number engines. Two engines are equal, if their internal states are equivalent, that is, if they would generate equivalent values for any number of calls of operator()."
        },
        "parametres": "   lhs, rhs   -   engines to compare \n\n"
    },
    "operator>(std::subtract_with_carry_engine)\n": {
        "description": {
            "texte": "If a textual representation is written using os << x and that representation is restored into the same or a different object y of the same type using is >> y, then x==y.The textual representation is written with os.fmtflags set to ios_base::dec|ios_base::left and the fill character set to the space character. The textual representation of the engine's internal state is a set of decimal numbers separated by spaces."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   e   -   pseudo-random number engine \n\n"
    },
    "discard_block_engine::discard_block_engine": {
        "description": {
            "texte": "Constructs new pseudo-random engine adaptor."
        },
        "parametres": "   s   -   integer value to construct the underlying engine with \n   seq   -   seed sequence to construct the underlying engine with \n   e   -   pseudo-random number engine to initialize with \n\n"
    },
    "discard_block_engine::seed": {
        "description": {
            "texte": "Reinitializes the internal state of the underlying engine using a new seed value."
        },
        "parametres": "   value   -   seed value to use in the initialization of the internal state of the underlying engine \n   seq   -   seed sequence to use in the initialization of the internal state of the underlying engine \n\n"
    },
    "discard_block_engine::base": {
        "description": {
            "texte": "Returns the underlying engine."
        }
    },
    "discard_block_engine::operator()": {
        "description": {
            "texte": "Generates a random value. The state of the underlying engine is advanced one or more times."
        }
    },
    "discard_block_engine::discard": {
        "description": {
            "texte": "Advances the internal state by z times. Equivalent to calling operator() z times and discarding the result. The state of the underlying engine may be advanced by more than z times."
        },
        "parametres": "   z   -   integer value specifying the number of times to advance the state by \n\n"
    },
    "discard_block_engine::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the engine adaptor. This value is equal to e.min() where e is the underlying engine."
        }
    },
    "discard_block_engine::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the engine adaptor. This value is equal to e.max() where e is the underlying engine."
        }
    },
    "operator==,!=(std::discard_block_engine)\n": {
        "description": {
            "texte": "Compares two pseudo-random number engine adaptors. Two engine adaptors are equal, if their underlying engines are equal and their internal state (if any) is equal, that is, if they would generate equivalent values for any number of calls of operator()."
        },
        "parametres": "   lhs, rhs   -   engine adaptors to compare \n\n"
    },
    "operator>(std::discard_block_engine)\n": {
        "description": {
            "texte": "If a textual representation is written using os << x and that representation is restored into the same or a different object y of the same type using is >> y, then x==y."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   e   -   engine adaptor to serialize or restore \n\n"
    },
    "independent_bits_engine::independent_bits_engine": {
        "description": {
            "texte": "Constructs new pseudo-random engine adaptor."
        },
        "parametres": "   s   -   integer value to construct the underlying engine with \n   seq   -   seed sequence to construct the underlying engine with \n   e   -   pseudo-random number engine to initialize with \n\n"
    },
    "independent_bits_engine::seed": {
        "description": {
            "texte": "Reinitializes the internal state of the underlying engine using a new seed value."
        },
        "parametres": "   value   -   seed value to use in the initialization of the internal state of the underlying engine \n   seq   -   seed sequence to use in the initialization of the internal state of the underlying engine \n\n"
    },
    "independent_bits_engine::base": {
        "description": {
            "texte": "Returns the underlying engine."
        }
    },
    "independent_bits_engine::operator()": {
        "description": {
            "texte": "Generates a random value. The state of the underlying engine is advanced one or more times."
        }
    },
    "independent_bits_engine::discard": {
        "description": {
            "texte": "Advances the internal state by z times. Equivalent to calling operator() z times and discarding the result. The state of the underlying engine may be advanced by more than z times."
        },
        "parametres": "   z   -   integer value specifying the number of times to advance the state by \n\n"
    },
    "independent_bits_engine::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the engine adaptor. This value is equal to 0u."
        }
    },
    "independent_bits_engine::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the engine adaptor. This value is equal to 2w-1."
        }
    },
    "operator==,!=(std::independent_bits_engine)\n": {
        "description": {
            "texte": "Compares two pseudo-random number engine adaptors. Two engine adaptors are equal, if their underlying engines are equal and their internal state (if any) is equal, that is, if they would generate equivalent values for any number of calls of operator()."
        },
        "parametres": "   lhs, rhs   -   engine adaptors to compare \n\n"
    },
    "operator>(std::independent_bits_engine)\n": {
        "description": {
            "texte": "If a textual representation is written using os << x and that representation is restored into the same or a different object y of the same type using is >> y, then x==y."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   e   -   engine adaptor to serialize or restore \n\n"
    },
    "shuffle_order_engine::shuffle_order_engine": {
        "description": {
            "texte": "Constructs new pseudo-random engine adaptor."
        },
        "parametres": "   s   -   integer value to construct the underlying engine with \n   seq   -   seed sequence to construct the underlying engine with \n   e   -   pseudo-random number engine to initialize with \n\n"
    },
    "shuffle_order_engine::seed": {
        "description": {
            "texte": "Reinitializes the internal state of the underlying engine using a new seed value."
        },
        "parametres": "   value   -   seed value to use in the initialization of the internal state of the underlying engine \n   seq   -   seed sequence to use in the initialization of the internal state of the underlying engine \n\n"
    },
    "shuffle_order_engine::base": {
        "description": {
            "texte": "Returns the underlying engine."
        }
    },
    "shuffle_order_engine::operator()": {
        "description": {
            "texte": "Generates a random value. The state of the underlying engine is advanced one or more times."
        }
    },
    "shuffle_order_engine::discard": {
        "description": {
            "texte": "Advances the internal state by z times. Equivalent to calling operator() z times and discarding the result. The state of the underlying engine may be advanced by more than z times."
        },
        "parametres": "   z   -   integer value specifying the number of times to advance the state by \n\n"
    },
    "shuffle_order_engine::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the engine adaptor. This value is equal to e.min() where e is the underlying engine."
        }
    },
    "shuffle_order_engine::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the engine adaptor. This value is equal to e.max() where e is the underlying engine."
        }
    },
    "operator==,!=(std::shuffle_order_engine)\n": {
        "description": {
            "texte": "Compares two pseudo-random number engine adaptors. Two engine adaptors are equal, if their underlying engines are equal and their internal state (if any) is equal, that is, if they would generate equivalent values for any number of calls of operator()."
        },
        "parametres": "   lhs, rhs   -   engine adaptors to compare \n\n"
    },
    "operator>(std::shuffle_order_engine)\n": {
        "description": {
            "texte": "If a textual representation is written using os << x and that representation is restored into the same or a different object y of the same type using is >> y, then x==y."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   e   -   engine adaptor to serialize or restore \n\n"
    },
    "random_device::random_device": {
        "description": {
            "texte": "Throws an implementation-defined exceptions derived from std::exception on failure."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <random>\n \nint main()\n{\n \n    std::uniform_int_distribution<int> d(0, 10);\n \n    std::random_device rd1; // uses RDRND or /dev/urandom\n    for(int n = 0; n < 10; ++n)\n        std::cout << d(rd1) << ' ';\n    std::cout << '\\n';\n \n    std::random_device rd2(\"/dev/random\"); // much slower on Linux\n    for(int n = 0; n < 10; ++n)\n        std::cout << d(rd2) << ' ';\n    std::cout << '\\n';\n}",
            "output": "7 10 7 0 4 4 6 9 4 7 \n2 4 10 6 3 2 0 6 3 7"
        }
    },
    "random_device::operator()": {
        "description": {
            "texte": "Generates a non-deterministic uniformly-distributed random value."
        }
    },
    "random_device::entropy": {
        "description": {
            "texte": "Obtains an estimate of the random number device entropy, which is a floating-point value between 0 and log2(max()+1) (which is equal to std::numeric_limits<unsigned int>::digits). If the device has n states whose individual probabilities are P0,...,Pn-1, the device entropy S is defined as.S = -\u03a3n-1i=0Pilog(Pi).A deterministic random number generator (e.g. a pseudo-random engine) has entropy zero."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::cout << rd.entropy() << '\\n';\n}",
            "output": "32"
        }
    },
    "random_device::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the random-number engine. This value is equal to 0u."
        }
    },
    "random_device::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the random-number engine. This value is equal to std::numeric_limits<unsigned int>::max()."
        }
    },
    "uniform_int_distribution::uniform_int_distribution": {
        "description": {
            "texte": "Constructs new distribution object. (2) uses a and b as the distribution parameters, (3) uses params as the distribution parameters.The behavior is undefined if a>b."
        },
        "parametres": "   a   -   the a distribution parameter (minimum value) \n   b   -   the b distribution parameter (maximum value) \n   params   -   the distribution parameter set \n\n"
    },
    "uniform_int_distribution::reset": {
        "description": {
            "texte": "Resets the internal state of the distribution object. After a call to this function, the next call to operator() on the distribution object will not be dependent on previous calls to operator()."
        }
    },
    "uniform_int_distribution::a, b": {
        "description": {
            "texte": "Returns the parameters the distribution has been constructed with."
        }
    },
    "uniform_int_distribution::param": {
        "description": {
            "texte": "Manages the associated distribution parameter set.1) Returns the associated parameter set.2) Sets the associated parameter set to params."
        },
        "parametres": "   params   -   new contents of the associated parameter set \n\n"
    },
    "uniform_int_distribution::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the distribution."
        }
    },
    "uniform_int_distribution::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the distribution."
        }
    },
    "operator==,!=(std::uniform_int_distribution)\n": {
        "description": {
            "texte": "Compares two distribution objects. Two distribution objects are equal when parameter values and internal state is the same.1) Compares two distribution objects for equality.2) Compares two distribution objects for inequality."
        },
        "parametres": "   lhs, rhs   -   distribution objects to compare \n\n"
    },
    "uniform_real_distribution::uniform_real_distribution": {
        "description": {
            "texte": "Constructs a new distribution object. (2) uses a and b as the distribution parameters, (3) uses params as the distribution parameters."
        },
        "parametres": "   a   -   the a distribution parameter (minimum value) \n   b   -   the b distribution parameter (maximum value) \n   params   -   the distribution parameter set \n\n"
    },
    "uniform_real_distribution::reset": {
        "description": {
            "texte": "Resets the internal state of the distribution object. After a call to this function, the next call to operator() on the distribution object will not be dependent on previous calls to operator()."
        }
    },
    "uniform_real_distribution::operator()": {
        "description": {
            "texte": "Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling g.operator().The first version uses the associated parameter set, the second version uses params. The associated parameter set is not modified."
        },
        "parametres": "   g   -   an uniform random bit generator object \n   params   -   distribution parameter set to use instead of the associated one \n   Type requirements \n   -Generator must meet the requirements of UniformRandomBitGenerator. \n\n"
    },
    "uniform_real_distribution::a, b": {
        "description": {
            "texte": "Returns the parameters the distribution has been constructed with."
        }
    },
    "uniform_real_distribution::param": {
        "description": {
            "texte": "Manages the associated distribution parameter set.1) Returns the associated parameter set.2) Sets the associated parameter set to params."
        },
        "parametres": "   params   -   new contents of the associated parameter set \n\n"
    },
    "uniform_real_distribution::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the distribution."
        }
    },
    "uniform_real_distribution::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the distribution."
        }
    },
    "operator==,!=(std::uniform_real_distribution)\n": {
        "description": {
            "texte": "Compares two distribution objects. Two distribution objects are equal when parameter values and internal state is the same.1) Compares two distribution objects for equality.2) Compares two distribution objects for inequality."
        },
        "parametres": "   lhs, rhs   -   distribution objects to compare \n\n"
    },
    "operator>(std::uniform_real_distribution)\n": {
        "description": {
            "texte": "Performs stream input and output operations on pseudo-random number distribution d."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   d   -   pseudo-random number distribution \n\n"
    },
    "bernoulli_distribution::bernoulli_distribution": {
        "description": {
            "texte": "Constructs new distribution object. (2) uses p as the distribution parameter. (3) uses params as the distribution parameter."
        },
        "parametres": "   p   -   the p distribution parameter (probability of generating true) \n   params   -   the distribution parameter set \n\n"
    },
    "bernoulli_distribution::reset": {
        "description": {
            "texte": "Resets the internal state of the distribution object. After a call to this function, the next call to operator() on the distribution object will not be dependent on previous calls to operator()."
        }
    },
    "bernoulli_distribution::operator()": {
        "description": {
            "texte": "Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling g.operator().The first version uses the associated parameter set, the second version uses params. The associated parameter set is not modified."
        },
        "parametres": "   g   -   an uniform random bit generator object \n   params   -   distribution parameter set to use instead of the associated one \n   Type requirements \n   -Generator must meet the requirements of UniformRandomBitGenerator. \n\n"
    },
    "bernoulli_distribution::param": {
        "description": {
            "texte": "Manages the associated distribution parameter set.1) Returns the associated parameter set.2) Sets the associated parameter set to params."
        },
        "parametres": "   params   -   new contents of the associated parameter set \n\n"
    },
    "bernoulli_distribution::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the distribution."
        }
    },
    "bernoulli_distribution::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the distribution."
        }
    },
    "operator==,!=(std::bernoulli_distribution)\n": {
        "description": {
            "texte": "Compares two distribution objects. Two distribution objects are equal when parameter values and internal state is the same.1) Compares two distribution objects for equality.2) Compares two distribution objects for inequality."
        },
        "parametres": "   lhs, rhs   -   distribution objects to compare \n\n"
    },
    "operator>(std::bernoulli_distribution)\n": {
        "description": {
            "texte": "Performs stream input and output operations on pseudo-random number distribution d."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   d   -   pseudo-random number distribution \n\n"
    },
    "bernoulli_distribution::p": {
        "description": {
            "texte": "Returns the p parameter the distribution was constructed with. It defines the probability of generating true. The default value is 0.5."
        }
    },
    "binomial_distribution::binomial_distribution": {
        "description": {
            "texte": "Constructs a new distribution object. (2) uses t and p as the distribution parameters. (3) uses params as the distribution parameters."
        },
        "parametres": "   t   -   the t distribution parameter (number of trials) \n   p   -   the p distribution parameter (probability of a trial generating true) \n   params   -   the distribution parameter set \n\n"
    },
    "binomial_distribution::reset": {
        "description": {
            "texte": "Resets the internal state of the distribution object. After a call to this function, the next call to operator() on the distribution object will not be dependent on previous calls to operator()."
        }
    },
    "binomial_distribution::operator()": {
        "description": {
            "texte": "Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling g.operator().The first version uses the associated parameter set, the second version uses params. The associated parameter set is not modified."
        },
        "parametres": "   g   -   an uniform random bit generator object \n   params   -   distribution parameter set to use instead of the associated one \n   Type requirements \n   -Generator must meet the requirements of UniformRandomBitGenerator. \n\n"
    },
    "binomial_distribution::p, t": {
        "description": {
            "texte": "Returns the parameters the distribution was constructed with."
        }
    },
    "binomial_distribution::param": {
        "description": {
            "texte": "Manages the associated distribution parameter set.1) Returns the associated parameter set.2) Sets the associated parameter set to params."
        },
        "parametres": "   params   -   new contents of the associated parameter set \n\n",
        "exemple": {
            "input": "#include <iostream>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    using BinomialDist = std::binomial_distribution<>;\n    BinomialDist bino_dis(1, 0.5);\n \n    std::cout << \"A sample of Binomial(  1, 0.5): \" << bino_dis(gen) << '\\n';\n \n    // Use another parameter set\n    bino_dis.param(BinomialDist::param_type(100,0.9));\n    std::cout << \"A sample of Binomial(100, 0.9): \" << bino_dis(gen) << '\\n';\n}",
            "output": "A sample of Binomial(  1, 0.5): 0\nA sample of Binomial(100, 0.9): 94"
        }
    },
    "binomial_distribution::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the distribution."
        }
    },
    "binomial_distribution::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the distribution."
        }
    },
    "operator==,!=(std::binomial_distribution)\n": {
        "description": {
            "texte": "Compares two distribution objects. Two distribution objects are equal when parameter values and internal state is the same.1) Compares two distribution objects for equality.2) Compares two distribution objects for inequality."
        },
        "parametres": "   lhs, rhs   -   distribution objects to compare \n\n"
    },
    "operator>(std::binomial_distribution)\n": {
        "description": {
            "texte": "Performs stream input and output operations on pseudo-random number distribution d."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   d   -   pseudo-random number distribution \n\n"
    },
    "negative_binomial_distribution::negative_binomial_distribution": {
        "description": {
            "texte": "Constructs a new distribution object. (2) uses k and p as the distribution parameters. (3) uses params as the distribution parameters."
        },
        "parametres": "   k   -   the k distribution parameter (number of trial successes) \n   p   -   the p distribution parameter (probability of a trial generating true) \n   params   -   the distribution parameter set \n\n"
    },
    "negative_binomial_distribution::reset": {
        "description": {
            "texte": "Resets the internal state of the distribution object. After a call to this function, the next call to operator() on the distribution object will not be dependent on previous calls to operator()."
        }
    },
    "negative_binomial_distribution::operator()": {
        "description": {
            "texte": "Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling g.operator().The first version uses the associated parameter set, the second version uses params. The associated parameter set is not modified."
        },
        "parametres": "   g   -   an uniform random bit generator object \n   params   -   distribution parameter set to use instead of the associated one \n   Type requirements \n   -Generator must meet the requirements of UniformRandomBitGenerator. \n\n"
    },
    "negative_binomial_distribution::p, k": {
        "description": {
            "texte": "Returns the parameters the distribution was constructed with."
        }
    },
    "negative_binomial_distribution::param": {
        "description": {
            "texte": "Manages the associated distribution parameter set.1) Returns the associated parameter set.2) Sets the associated parameter set to params."
        },
        "parametres": "   params   -   new contents of the associated parameter set \n\n"
    },
    "negative_binomial_distribution::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the distribution."
        }
    },
    "negative_binomial_distribution::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the distribution."
        }
    },
    "operator==,!=(std::negative_binomial_distribution)\n": {
        "description": {
            "texte": "Compares two distribution objects. Two distribution objects are equal when parameter values and internal state is the same.1) Compares two distribution objects for equality.2) Compares two distribution objects for inequality."
        },
        "parametres": "   lhs, rhs   -   distribution objects to compare \n\n"
    },
    "operator>(std::negative_binomial_distribution)\n": {
        "description": {
            "texte": "Performs stream input and output operations on pseudo-random number distribution d."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   d   -   pseudo-random number distribution \n\n"
    },
    "geometric_distribution::geometric_distribution": {
        "description": {
            "texte": "Constructs a new distribution object. (2) uses p as the distribution parameter. (3) uses params as the distribution parameter."
        },
        "parametres": "   p   -   the p distribution parameter (probability of a trial generating true) \n   params   -   the distribution parameter set \n\n"
    },
    "geometric_distribution::reset": {
        "description": {
            "texte": "Resets the internal state of the distribution object. After a call to this function, the next call to operator() on the distribution object will not be dependent on previous calls to operator()."
        }
    },
    "geometric_distribution::operator()": {
        "description": {
            "texte": "Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling g.operator().The first version uses the associated parameter set, the second version uses params. The associated parameter set is not modified."
        },
        "parametres": "   g   -   an uniform random bit generator object \n   params   -   distribution parameter set to use instead of the associated one \n   Type requirements \n   -Generator must meet the requirements of UniformRandomBitGenerator. \n\n"
    },
    "geometric_distribution::p": {
        "description": {
            "texte": "Returns the p distribution parameter the distribution was constructed with. The parameter defines the probability of a trial generating true. The default value is 0.5."
        }
    },
    "geometric_distribution::param": {
        "description": {
            "texte": "Manages the associated distribution parameter set.1) Returns the associated parameter set.2) Sets the associated parameter set to params."
        },
        "parametres": "   params   -   new contents of the associated parameter set \n\n"
    },
    "geometric_distribution::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the distribution."
        }
    },
    "geometric_distribution::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the distribution."
        }
    },
    "operator==,!=(std::geometric_distribution)\n": {
        "description": {
            "texte": "Compares two distribution objects. Two distribution objects are equal when parameter values and internal state is the same.1) Compares two distribution objects for equality.2) Compares two distribution objects for inequality."
        },
        "parametres": "   lhs, rhs   -   distribution objects to compare \n\n"
    },
    "operator>(std::geometric_distribution)\n": {
        "description": {
            "texte": "Performs stream input and output operations on pseudo-random number distribution d."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   d   -   pseudo-random number distribution \n\n"
    },
    "poisson_distribution::poisson_distribution": {
        "description": {
            "texte": "Constructs a new distribution object. (2) uses mean as the distribution parameter. (3) uses params as the distribution parameter."
        },
        "parametres": "   mean   -   the \u03bc distribution parameter (the mean of the distribution) \n   params   -   the distribution parameter set \n\n"
    },
    "poisson_distribution::reset": {
        "description": {
            "texte": "Resets the internal state of the distribution object. After a call to this function, the next call to operator() on the distribution object will not be dependent on previous calls to operator()."
        }
    },
    "poisson_distribution::operator()": {
        "description": {
            "texte": "Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling g.operator().The first version uses the associated parameter set, the second version uses params. The associated parameter set is not modified."
        },
        "parametres": "   g   -   an uniform random bit generator object \n   params   -   distribution parameter set to use instead of the associated one \n   Type requirements \n   -Generator must meet the requirements of UniformRandomBitGenerator. \n\n"
    },
    "poisson_distribution::mean": {
        "description": {
            "texte": "Returns the \u03bc parameter the distribution was constructed with. The parameter defines mean number of occurrences of the event. The default value is 1.0."
        }
    },
    "poisson_distribution::param": {
        "description": {
            "texte": "Manages the associated distribution parameter set.1) Returns the associated parameter set.2) Sets the associated parameter set to params."
        },
        "parametres": "   params   -   new contents of the associated parameter set \n\n"
    },
    "poisson_distribution::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the distribution."
        }
    },
    "poisson_distribution::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the distribution."
        }
    },
    "operator>(std::poisson_distribution)\n": {
        "description": {
            "texte": "Performs stream input and output operations on pseudo-random number distribution d."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   d   -   pseudo-random number distribution \n\n"
    },
    "exponential_distribution::exponential_distribution": {
        "description": {
            "texte": "Constructs a new distribution object. (2) uses lambda as the distribution parameter. (3) uses params as the distribution parameter."
        },
        "parametres": "   lambda   -   the \u03bb distribution parameter (the rate parameter) \n   params   -   the distribution parameter set \n\n"
    },
    "exponential_distribution::reset": {
        "description": {
            "texte": "Resets the internal state of the distribution object. After a call to this function, the next call to operator() on the distribution object will not be dependent on previous calls to operator()."
        }
    },
    "exponential_distribution::operator()": {
        "description": {
            "texte": "Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling g.operator().The first version uses the associated parameter set, the second version uses params. The associated parameter set is not modified."
        },
        "parametres": "   g   -   an uniform random bit generator object \n   params   -   distribution parameter set to use instead of the associated one \n   Type requirements \n   -Generator must meet the requirements of UniformRandomBitGenerator. \n\n"
    },
    "exponential_distribution::lambda": {
        "description": {
            "texte": "Returns the \u03bb distribution parameter the distribution was constructed with. The parameter defines the rate of events, per unit. The default value is 1.0."
        }
    },
    "exponential_distribution::param": {
        "description": {
            "texte": "Manages the associated distribution parameter set.1) Returns the associated parameter set.2) Sets the associated parameter set to params."
        },
        "parametres": "   params   -   new contents of the associated parameter set \n\n"
    },
    "exponential_distribution::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the distribution."
        }
    },
    "exponential_distribution::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the distribution."
        }
    },
    "operator==,!=(std::exponential_distribution)\n": {
        "description": {
            "texte": "Compares two distribution objects. Two distribution objects are equal when parameter values and internal state is the same.1) Compares two distribution objects for equality.2) Compares two distribution objects for inequality."
        },
        "parametres": "   lhs, rhs   -   distribution objects to compare \n\n"
    },
    "operator>(std::exponential_distribution)\n": {
        "description": {
            "texte": "Performs stream input and output operations on pseudo-random number distribution d."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   d   -   pseudo-random number distribution \n\n"
    },
    "gamma_distribution::gamma_distribution": {
        "description": {
            "texte": "Constructs a new distribution object. (2) uses alpha and beta as the distribution parameters. (3) uses params as the distribution parameters."
        },
        "parametres": "   alpha   -   the \u03b1 distribution parameter (shape) \n   beta   -   the \u03b2 distribution parameter (scale) \n   params   -   the distribution parameter set \n\n"
    },
    "gamma_distribution::reset": {
        "description": {
            "texte": "Resets the internal state of the distribution object. After a call to this function, the next call to operator() on the distribution object will not be dependent on previous calls to operator()."
        }
    },
    "gamma_distribution::operator()": {
        "description": {
            "texte": "Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling g.operator().The first version uses the associated parameter set, the second version uses params. The associated parameter set is not modified."
        },
        "parametres": "   g   -   an uniform random bit generator object \n   params   -   distribution parameter set to use instead of the associated one \n   Type requirements \n   -Generator must meet the requirements of UniformRandomBitGenerator. \n\n"
    },
    "gamma_distribution::alpha, beta": {
        "description": {
            "texte": "Returns the distribution parameters the distribution has been constructed with."
        }
    },
    "gamma_distribution::param": {
        "description": {
            "texte": "Manages the associated distribution parameter set.1) Returns the associated parameter set.2) Sets the associated parameter set to params."
        },
        "parametres": "   params   -   new contents of the associated parameter set \n\n"
    },
    "gamma_distribution::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the distribution."
        }
    },
    "gamma_distribution::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the distribution."
        }
    },
    "operator==,!=(std::gamma_distribution)\n": {
        "description": {
            "texte": "Compares two distribution objects. Two distribution objects are equal when parameter values and internal state is the same.1) Compares two distribution objects for equality.2) Compares two distribution objects for inequality."
        },
        "parametres": "   lhs, rhs   -   distribution objects to compare \n\n"
    },
    "operator>(std::gamma_distribution)\n": {
        "description": {
            "texte": "Performs stream input and output operations on pseudo-random number distribution d."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   d   -   pseudo-random number distribution \n\n"
    },
    "weibull_distribution::weibull_distribution": {
        "description": {
            "texte": "Constructs a new distribution object. (2) uses a and b as the distribution parameters. (3) uses params as the distribution parameters."
        },
        "parametres": "   a   -   the a distribution parameter (shape) \n   b   -   the b distribution parameter (scale) \n   params   -   the distribution parameter set \n\n"
    },
    "weibull_distribution::reset": {
        "description": {
            "texte": "Resets the internal state of the distribution object. After a call to this function, the next call to operator() on the distribution object will not be dependent on previous calls to operator()."
        }
    },
    "weibull_distribution::operator()": {
        "description": {
            "texte": "Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling g.operator().The first version uses the associated parameter set, the second version uses params. The associated parameter set is not modified."
        },
        "parametres": "   g   -   an uniform random bit generator object \n   params   -   distribution parameter set to use instead of the associated one \n   Type requirements \n   -Generator must meet the requirements of UniformRandomBitGenerator. \n\n"
    },
    "weibull_distribution::a, b": {
        "description": {
            "texte": "Returns the parameters the distribution was constructed with."
        }
    },
    "weibull_distribution::param": {
        "description": {
            "texte": "Manages the associated distribution parameter set.1) Returns the associated parameter set.2) Sets the associated parameter set to params."
        },
        "parametres": "   params   -   new contents of the associated parameter set \n\n"
    },
    "weibull_distribution::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the distribution."
        }
    },
    "weibull_distribution::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the distribution."
        }
    },
    "operator==,!=(std::weibull_distribution)\n": {
        "description": {
            "texte": "Compares two distribution objects. Two distribution objects are equal when parameter values and internal state is the same.1) Compares two distribution objects for equality.2) Compares two distribution objects for inequality."
        },
        "parametres": "   lhs, rhs   -   distribution objects to compare \n\n"
    },
    "operator>(std::weibull_distribution)\n": {
        "description": {
            "texte": "Performs stream input and output operations on pseudo-random number distribution d."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   d   -   pseudo-random number distribution \n\n"
    },
    "extreme_value_distribution::extreme_value_distribution": {
        "description": {
            "texte": "Constructs a new distribution object. (2) uses a and b as the distribution parameters. (3) uses params as the distribution parameters."
        },
        "parametres": "   a   -   the a distribution parameter (location) \n   b   -   the b distribution parameter (scale) \n   params   -   the distribution parameter set \n\n"
    },
    "extreme_value_distribution::reset": {
        "description": {
            "texte": "Resets the internal state of the distribution object. After a call to this function, the next call to operator() on the distribution object will not be dependent on previous calls to operator()."
        }
    },
    "extreme_value_distribution::operator()": {
        "description": {
            "texte": "Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling g.operator().The first version uses the associated parameter set, the second version uses params. The associated parameter set is not modified."
        },
        "parametres": "   g   -   an uniform random bit generator object \n   params   -   distribution parameter set to use instead of the associated one \n   Type requirements \n   -Generator must meet the requirements of UniformRandomBitGenerator. \n\n"
    },
    "extreme_value_distribution::a, b": {
        "description": {
            "texte": "Returns the parameters the distribution was constructed with."
        }
    },
    "extreme_value_distribution::param": {
        "description": {
            "texte": "Manages the associated distribution parameter set.1) Returns the associated parameter set.2) Sets the associated parameter set to params."
        },
        "parametres": "   params   -   new contents of the associated parameter set \n\n"
    },
    "extreme_value_distribution::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the distribution."
        }
    },
    "extreme_value_distribution::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the distribution."
        }
    },
    "operator==,!=(std::extreme_value_distribution)\n": {
        "description": {
            "texte": "Compares two distribution objects. Two distribution objects are equal when parameter values and internal state is the same.1) Compares two distribution objects for equality.2) Compares two distribution objects for inequality."
        },
        "parametres": "   lhs, rhs   -   distribution objects to compare \n\n"
    },
    "operator>(std::extreme_value_distribution)\n": {
        "description": {
            "texte": "Performs stream input and output operations on pseudo-random number distribution d."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   d   -   pseudo-random number distribution \n\n"
    },
    "normal_distribution::normal_distribution": {
        "description": {
            "texte": "Constructs a new distribution object. (2) uses mean and stddev as the distribution parameters. (3) uses params as the distribution parameters."
        },
        "parametres": "   mean   -   the \u03bc distribution parameter (mean) \n   stddev   -   the \u03c3 distribution parameter (standard deviation) \n   params   -   the distribution parameter set \n\n"
    },
    "normal_distribution::reset": {
        "description": {
            "texte": "Resets the internal state of the distribution object. After a call to this function, the next call to operator() on the distribution object will not be dependent on previous calls to operator()."
        }
    },
    "normal_distribution::operator()": {
        "description": {
            "texte": "Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling g.operator().The first version uses the associated parameter set, the second version uses params. The associated parameter set is not modified."
        },
        "parametres": "   g   -   an uniform random bit generator object \n   params   -   distribution parameter set to use instead of the associated one \n   Type requirements \n   -Generator must meet the requirements of UniformRandomBitGenerator. \n\n"
    },
    "normal_distribution::mean, stddev": {
        "description": {
            "texte": "Returns the parameters the distribution was constructed with."
        }
    },
    "normal_distribution::param": {
        "description": {
            "texte": "Manages the associated distribution parameter set.1) Returns the associated parameter set.2) Sets the associated parameter set to params."
        },
        "parametres": "   params   -   new contents of the associated parameter set \n\n"
    },
    "normal_distribution::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the distribution."
        }
    },
    "normal_distribution::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the distribution."
        }
    },
    "operator==,!=(std::normal_distribution)\n": {
        "description": {
            "texte": "Compares two distribution objects. Two distribution objects are equal when parameter values and internal state is the same.1) Compares two distribution objects for equality.2) Compares two distribution objects for inequality."
        },
        "parametres": "   lhs, rhs   -   distribution objects to compare \n\n"
    },
    "operator>(std::normal_distribution)\n": {
        "description": {
            "texte": "Performs stream input and output operations on pseudo-random number distribution d."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   d   -   pseudo-random number distribution \n\n"
    },
    "lognormal_distribution::lognormal_distribution": {
        "description": {
            "texte": "Constructs a new distribution object. (2) uses m and s as the distribution parameters. (3) uses params as the distribution parameters."
        },
        "parametres": "   m   -   the m distribution parameter (log-scale) \n   s   -   the s distribution parameter (shape) \n   params   -   the distribution parameter set \n\n"
    },
    "lognormal_distribution::reset": {
        "description": {
            "texte": "Resets the internal state of the distribution object. After a call to this function, the next call to operator() on the distribution object will not be dependent on previous calls to operator()."
        }
    },
    "lognormal_distribution::operator()": {
        "description": {
            "texte": "Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling g.operator().The first version uses the associated parameter set, the second version uses params. The associated parameter set is not modified."
        },
        "parametres": "   g   -   an uniform random bit generator object \n   params   -   distribution parameter set to use instead of the associated one \n   Type requirements \n   -Generator must meet the requirements of UniformRandomBitGenerator. \n\n"
    },
    "lognormal_distribution::m, s": {
        "description": {
            "texte": "Returns the parameters the distribution was constructed with."
        }
    },
    "lognormal_distribution::param": {
        "description": {
            "texte": "Manages the associated distribution parameter set.1) Returns the associated parameter set.2) Sets the associated parameter set to params."
        },
        "parametres": "   params   -   new contents of the associated parameter set \n\n"
    },
    "lognormal_distribution::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the distribution."
        }
    },
    "lognormal_distribution::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the distribution."
        }
    },
    "operator==,!=(std::lognormal_distribution)\n": {
        "description": {
            "texte": "Compares two distribution objects. Two distribution objects are equal when parameter values and internal state is the same.1) Compares two distribution objects for equality.2) Compares two distribution objects for inequality."
        },
        "parametres": "   lhs, rhs   -   distribution objects to compare \n\n"
    },
    "operator>(std::lognormal_distribution)\n": {
        "description": {
            "texte": "Performs stream input and output operations on pseudo-random number distribution d."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   d   -   pseudo-random number distribution \n\n"
    },
    "chi_squared_distribution::chi_squared_distribution": {
        "description": {
            "texte": "Constructs a new distribution object. (2) uses n as the distribution parameter. (3) uses params as the distribution parameter."
        },
        "parametres": "   n   -   the n distribution parameter (degrees of freedom) \n   params   -   the distribution parameter set \n\n"
    },
    "chi_squared_distribution::reset": {
        "description": {
            "texte": "Resets the internal state of the distribution object. After a call to this function, the next call to operator() on the distribution object will not be dependent on previous calls to operator()."
        }
    },
    "chi_squared_distribution::operator()": {
        "description": {
            "texte": "Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling g.operator().The first version uses the associated parameter set, the second version uses params. The associated parameter set is not modified."
        },
        "parametres": "   g   -   an uniform random bit generator object \n   params   -   distribution parameter set to use instead of the associated one \n   Type requirements \n   -Generator must meet the requirements of UniformRandomBitGenerator. \n\n"
    },
    "chi_squared_distribution::n": {
        "description": {
            "texte": "Returns the n parameter the distribution was constructed with. It specifies the degrees of freedom of the distribution. The default value is 1.0."
        }
    },
    "chi_squared_distribution::param": {
        "description": {
            "texte": "Manages the associated distribution parameter set.1) Returns the associated parameter set.2) Sets the associated parameter set to params."
        },
        "parametres": "   params   -   new contents of the associated parameter set \n\n"
    },
    "chi_squared_distribution::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the distribution."
        }
    },
    "chi_squared_distribution::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the distribution."
        }
    },
    "operator==,!=(std::chi_squared_distribution)\n": {
        "description": {
            "texte": "Compares two distribution objects. Two distribution objects are equal when parameter values and internal state is the same.1) Compares two distribution objects for equality.2) Compares two distribution objects for inequality."
        },
        "parametres": "   lhs, rhs   -   distribution objects to compare \n\n"
    },
    "operator>(std::chi_squared_distribution)\n": {
        "description": {
            "texte": "Performs stream input and output operations on pseudo-random number distribution d."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   d   -   pseudo-random number distribution \n\n"
    },
    "cauchy_distribution::cauchy_distribution": {
        "description": {
            "texte": "Constructs a new distribution object. (2) uses a and b as the distribution parameters. (3) uses params as the distribution parameters."
        },
        "parametres": "   a   -   the a distribution parameter (location) \n   b   -   the b distribution parameter (scale) \n   params   -   the distribution parameter set \n\n"
    },
    "cauchy_distribution::reset": {
        "description": {
            "texte": "Resets the internal state of the distribution object. After a call to this function, the next call to operator() on the distribution object will not be dependent on previous calls to operator()."
        }
    },
    "cauchy_distribution::operator()": {
        "description": {
            "texte": "Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling g.operator().The first version uses the associated parameter set, the second version uses params. The associated parameter set is not modified."
        },
        "parametres": "   g   -   an uniform random bit generator object \n   params   -   distribution parameter set to use instead of the associated one \n   Type requirements \n   -Generator must meet the requirements of UniformRandomBitGenerator. \n\n"
    },
    "cauchy_distribution::a, b": {
        "description": {
            "texte": "Returns the distribution parameters with which the distribution was constructed."
        }
    },
    "cauchy_distribution::param": {
        "description": {
            "texte": "Manages the associated distribution parameter set.1) Returns the associated parameter set.2) Sets the associated parameter set to params."
        },
        "parametres": "   params   -   new contents of the associated parameter set \n\n"
    },
    "cauchy_distribution::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the distribution."
        }
    },
    "cauchy_distribution::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the distribution."
        }
    },
    "operator==,!=(std::cauchy_distribution)\n": {
        "description": {
            "texte": "Compares two distribution objects. Two distribution objects are equal when parameter values and internal state is the same.1) Compares two distribution objects for equality.2) Compares two distribution objects for inequality."
        },
        "parametres": "   lhs, rhs   -   distribution objects to compare \n\n"
    },
    "operator>(std::cauchy_distribution)\n": {
        "description": {
            "texte": "Performs stream input and output operations on pseudo-random number distribution d."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   d   -   pseudo-random number distribution \n\n"
    },
    "fisher_f_distribution::fisher_f_distribution": {
        "description": {
            "texte": "Constructs a new distribution object. (2) uses m and n as the distribution parameters. (3) uses params as the distribution parameters."
        },
        "parametres": "   m   -   the m distribution parameter (degrees of freedom) \n   n   -   the n distribution parameter (degrees of freedom) \n   params   -   the distribution parameter set \n\n"
    },
    "fisher_f_distribution::reset": {
        "description": {
            "texte": "Resets the internal state of the distribution object. After a call to this function, the next call to operator() on the distribution object will not be dependent on previous calls to operator()."
        }
    },
    "fisher_f_distribution::operator()": {
        "description": {
            "texte": "Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling g.operator().The first version uses the associated parameter set, the second version uses params. The associated parameter set is not modified."
        },
        "parametres": "   g   -   an uniform random bit generator object \n   params   -   distribution parameter set to use instead of the associated one \n   Type requirements \n   -Generator must meet the requirements of UniformRandomBitGenerator. \n\n"
    },
    "fisher_f_distribution::m, n": {
        "description": {
            "texte": "Returns the parameters the distribution was constructed with."
        }
    },
    "fisher_f_distribution::param": {
        "description": {
            "texte": "Manages the associated distribution parameter set.1) Returns the associated parameter set.2) Sets the associated parameter set to params."
        },
        "parametres": "   params   -   new contents of the associated parameter set \n\n"
    },
    "fisher_f_distribution::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the distribution."
        }
    },
    "fisher_f_distribution::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the distribution."
        }
    },
    "operator==,!=(std::fisher_f_distribution)\n": {
        "description": {
            "texte": "Compares two distribution objects. Two distribution objects are equal when parameter values and internal state is the same.1) Compares two distribution objects for equality.2) Compares two distribution objects for inequality."
        },
        "parametres": "   lhs, rhs   -   distribution objects to compare \n\n"
    },
    "operator>(std::fisher_f_distribution)\n": {
        "description": {
            "texte": "Performs stream input and output operations on pseudo-random number distribution d."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   d   -   pseudo-random number distribution \n\n"
    },
    "student_t_distribution::student_t_distribution": {
        "description": {
            "texte": "Constructs a new distribution object. (2) uses n as the distribution parameter. (3) uses params as the distribution parameter."
        },
        "parametres": "   n   -   the n distribution parameter (degrees of freedom) \n   params   -   the distribution parameter set \n\n"
    },
    "student_t_distribution::reset": {
        "description": {
            "texte": "Resets the internal state of the distribution object. After a call to this function, the next call to operator() on the distribution object will not be dependent on previous calls to operator()."
        }
    },
    "student_t_distribution::operator()": {
        "description": {
            "texte": "Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling g.operator().The first version uses the associated parameter set, the second version uses params. The associated parameter set is not modified."
        },
        "parametres": "   g   -   an uniform random bit generator object \n   params   -   distribution parameter set to use instead of the associated one \n   Type requirements \n   -Generator must meet the requirements of UniformRandomBitGenerator. \n\n"
    },
    "student_t_distribution::n": {
        "description": {
            "texte": "Returns the n distribution parameter (number of the degrees of freedom) the distribution was constructed with. The default value is 1.0."
        }
    },
    "student_t_distribution::param": {
        "description": {
            "texte": "Manages the associated distribution parameter set.1) Returns the associated parameter set.2) Sets the associated parameter set to params."
        },
        "parametres": "   params   -   new contents of the associated parameter set \n\n"
    },
    "student_t_distribution::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the distribution."
        }
    },
    "student_t_distribution::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the distribution."
        }
    },
    "operator==,!=(std::student_t_distribution)\n": {
        "description": {
            "texte": "Compares two distribution objects. Two distribution objects are equal when parameter values and internal state is the same.1) Compares two distribution objects for equality.2) Compares two distribution objects for inequality."
        },
        "parametres": "   lhs, rhs   -   distribution objects to compare \n\n"
    },
    "operator>(std::student_t_distribution)\n": {
        "description": {
            "texte": "Performs stream input and output operations on pseudo-random number distribution d."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   d   -   pseudo-random number distribution \n\n"
    },
    "discrete_distribution::discrete_distribution": {
        "description": {
            "texte": "Constructs a new distribution object.1) Default constructor. Constructs the distribution with a single weight p={1}. This distribution will always generate \u200b0\u200b.2) Constructs the distribution with weights in the range [first, last). If first == last, the effects are the same as of the default constructor.3) Constructs the distribution with weights in weights. Effectively calls discrete_distribution(weights.begin(), weights.end()).  4) Constructs the distribution with count weights that are generated using function unary_op. Each of the weights is equal to w.5) Constructs the distribution with params as the distribution parameters."
        },
        "parametres": "   first, last   -   the range of elements defining the numbers to use as weights. The type of the elements referred by InputIterator must be convertible to double \n   weights   -   initializer list containing the weights \n   unary_op   -   unary operation function object that will be applied.  The signature of the function should be equivalent to the following:\n Ret fun(const Type &a);\nThe signature does not need to have const &. The type Type must be such that an object of type double can be dereferenced and then implicitly converted to Type. The type Ret must be such that an object of type double can be dereferenced and assigned a value of type Ret. \u200b\n\n   params   -   the distribution parameter set \n   Type requirements \n   -InputIt must meet the requirements of LegacyInputIterator. \n\n"
    },
    "discrete_distribution::reset": {
        "description": {
            "texte": "Resets the internal state of the distribution object. After a call to this function, the next call to operator() on the distribution object will not be dependent on previous calls to operator()."
        }
    },
    "discrete_distribution::operator()": {
        "description": {
            "texte": "Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling g.operator().The first version uses the associated parameter set, the second version uses params. The associated parameter set is not modified."
        },
        "parametres": "   g   -   an uniform random bit generator object \n   params   -   distribution parameter set to use instead of the associated one \n   Type requirements \n   -Generator must meet the requirements of UniformRandomBitGenerator. \n\n"
    },
    "discrete_distribution::probabilities": {
        "description": {
            "texte": "Obtains a std::vector<double> containing the individual probabilities of each integer that is generated by this distribution."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <random>\nint main()\n{\n    std::discrete_distribution<> d({40, 10, 10, 40});\n    std::vector<double> p = d.probabilities();\n    for(auto n : p)\n        std::cout << n << ' ';\n    std::cout << '\\n';\n}",
            "output": "0.4 0.1 0.1 0.4"
        }
    },
    "discrete_distribution::param": {
        "description": {
            "texte": "Manages the associated distribution parameter set.1) Returns the associated parameter set.2) Sets the associated parameter set to params."
        },
        "parametres": "   params   -   new contents of the associated parameter set \n\n"
    },
    "discrete_distribution::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the distribution."
        }
    },
    "discrete_distribution::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the distribution."
        }
    },
    "operator==,!=(std::discrete_distribution)\n": {
        "description": {
            "texte": "Compares two distribution objects. Two distribution objects are equal when parameter values and internal state is the same.1) Compares two distribution objects for equality.2) Compares two distribution objects for inequality."
        },
        "parametres": "   lhs, rhs   -   distribution objects to compare \n\n"
    },
    "operator>(std::discrete_distribution)\n": {
        "description": {
            "texte": "Performs stream input and output operations on pseudo-random number distribution d."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   d   -   pseudo-random number distribution \n\n"
    },
    "piecewise_constant_distribution::piecewise_constant_distribution": {
        "description": {
            "texte": "Constructs new piecewise constant distribution object."
        },
        "parametres": "   first_i   -   iterator initialized to the start of the interval sequence \n   last_i   -   iterator initialized to one-past-the-end of the interval sequence \n   first_w   -   iterator initialized to the start of the density (weight) sequence \n   ilist_i   -   initializer_list yielding the interval sequnce \n   fw   -   double(double) function yielding the densities \n   nw   -   the number of densities \n   xmin   -   the lower bound of the interval sequence \n   xmax   -   the upper bound of the interval sequence \n   parm   -   the distribution parameter set \n\n"
    },
    "piecewise_constant_distribution::reset": {
        "description": {
            "texte": "Resets the internal state of the distribution object. After a call to this function, the next call to operator() on the distribution object will not be dependent on previous calls to operator()."
        }
    },
    "piecewise_constant_distribution::operator()": {
        "description": {
            "texte": "Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling g.operator().The first version uses the associated parameter set, the second version uses params. The associated parameter set is not modified."
        },
        "parametres": "   g   -   an uniform random bit generator object \n   params   -   distribution parameter set to use instead of the associated one \n   Type requirements \n   -Generator must meet the requirements of UniformRandomBitGenerator. \n\n"
    },
    "piecewise_constant_distribution::intervals, densities": {
        "description": {
            "texte": "Returns the distribution parameters."
        }
    },
    "piecewise_constant_distribution::param": {
        "description": {
            "texte": "Manages the associated distribution parameter set.1) Returns the associated parameter set.2) Sets the associated parameter set to params."
        },
        "parametres": "   params   -   new contents of the associated parameter set \n\n"
    },
    "piecewise_constant_distribution::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the distribution."
        }
    },
    "piecewise_constant_distribution::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the distribution."
        }
    },
    "operator==,!=(std::piecewise_constant_distribution)\n": {
        "description": {
            "texte": "Compares two distribution objects. Two distribution objects are equal when parameter values and internal state is the same.1) Compares two distribution objects for equality.2) Compares two distribution objects for inequality."
        },
        "parametres": "   lhs, rhs   -   distribution objects to compare \n\n"
    },
    "operator>(std::piecewise_constant_distribution)\n": {
        "description": {
            "texte": "Performs stream input and output operations on pseudo-random number distribution d."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   d   -   pseudo-random number distribution \n\n"
    },
    "piecewise_linear_distribution::piecewise_linear_distribution": {
        "description": {
            "texte": "Constructs new piecewise linear distribution object."
        },
        "parametres": "   first_i   -   iterator initialized to the start of the interval sequence \n   last_i   -   iterator initialized to one-past-the-end of the interval sequence \n   first_w   -   iterator initialized to the start of the density (weight) sequence \n   ilist_i   -   initializer_list yielding the interval sequence \n   fw   -   double(double) function yielding the densities \n   nw   -   the number of densities \n   xmin   -   the lower bound of the interval sequence \n   xmax   -   the upper bound of the interval sequence \n   parm   -   the distribution parameter set \n\n"
    },
    "piecewise_linear_distribution::reset": {
        "description": {
            "texte": "Resets the internal state of the distribution object. After a call to this function, the next call to operator() on the distribution object will not be dependent on previous calls to operator()."
        }
    },
    "piecewise_linear_distribution::operator()": {
        "description": {
            "texte": "Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling g.operator().The first version uses the associated parameter set, the second version uses params. The associated parameter set is not modified."
        },
        "parametres": "   g   -   an uniform random bit generator object \n   params   -   distribution parameter set to use instead of the associated one \n   Type requirements \n   -Generator must meet the requirements of UniformRandomBitGenerator. \n\n"
    },
    "piecewise_linear_distribution::intervals, densities": {
        "description": {
            "texte": "Returns the distribution parameters."
        }
    },
    "piecewise_linear_distribution::param": {
        "description": {
            "texte": "Manages the associated distribution parameter set.1) Returns the associated parameter set.2) Sets the associated parameter set to params."
        },
        "parametres": "   params   -   new contents of the associated parameter set \n\n"
    },
    "piecewise_linear_distribution::min": {
        "description": {
            "texte": "Returns the minimum value potentially generated by the distribution."
        }
    },
    "piecewise_linear_distribution::max": {
        "description": {
            "texte": "Returns the maximum value potentially generated by the distribution."
        }
    },
    "operator==,!=(std::piecewise_linear_distribution)\n": {
        "description": {
            "texte": "Compares two distribution objects. Two distribution objects are equal when parameter values and internal state is the same.1) Compares two distribution objects for equality.2) Compares two distribution objects for inequality."
        },
        "parametres": "   lhs, rhs   -   distribution objects to compare \n\n"
    },
    "operator>(std::piecewise_linear_distribution)\n": {
        "description": {
            "texte": "Performs stream input and output operations on pseudo-random number distribution d."
        },
        "parametres": "   ost   -   output stream to insert the data to \n   ist   -   input stream to extract the data from \n   d   -   pseudo-random number distribution \n\n"
    },
    "seed_seq::generate": {
        "description": {
            "texte": "Fills the range [begin, end) with unsigned integer values i, 0 \u2264 i < 232, based on the data originally provided in the constructor of this seed_seq. The produced values are distributed over the entire 32-bit range even if the initial values were strongly biased.The following algorithm is used (adapted from the initialization sequence of the Mersenne Twister generator by Makoto Matsumoto and Takuji Nishimura, incorporating the improvements made by Mutsuo Saito in 2007).For k = 0,..., m-1.where m=max(s+1, n) and n=end-begin and s=v.size() and v is the private container holding the values originally provided by the constructor of this seed_seq object,where p=(n-t)/2 and q=p+t and t=(n >= 623) ? 11 : (n >= 68) ? 7 : (n >= 39) ? 5 : (n >= 7) ? 3 : (n - 1) / 2 and r1=1664525 * T(begin[k]^begin[k+p]^begin[k\u22121]) and T(x) = x ^ (x >> 27) and r2=r1+s if k==0, r2=r1 + k%n + v[k-1] if 0<k<=s, r2=r1 + k%n if k>s.For k = m,..., m+n-1,where r3 = 1566083941 * T(begin[k]+begin[k+p]+begin[k-1]) and r4=r3 - k%n.where all calculations are performed modulo 232 and where the indexing of the output range (begin[x]) is taken modulo n."
        },
        "parametres": "   begin, end   -   mutable random-access iterators whose std::iterator_traits<>::value_type is an unsigned integer type suitable for storing 32-bit values \n   Type requirements \n   -RandomIt must meet the requirements of LegacyRandomAccessIterator. \n\n",
        "exemple": {
            "input": "#include <random>\n#include <iostream>\n \nint main()\n{\n    std::seed_seq seq({1,2,3,4,5});\n    std::vector<std::uint32_t> seeds(10);\n    seq.generate(seeds.begin(), seeds.end());\n// Step 1: fill with 0x8b8b8b8b\n// seeds = {2341178251, 2341178251, 2341178251, 2341178251, 2341178251,\n//          2341178251, 2341178251, 2341178251, 2341178251, 2341178251 }\n//\n// Step 2: \n// n = 10, s = 5, t = 3, p = 3, q = 6, m = 10\n//\n// First iteration, k = 0; r1 = 1371501266, r2 = 1371501271\n//\n// seeds = {1371501271, 2341178251, 2341178251, 3712679517, 2341178251,\n//          2341178251, 3712679522, 2341178251, 2341178251, 2341178251 }\n//\n// Iterations from k = 1 to k = 5 (r2 = r1 + k%n + v[k-1])\n//\n// r1 = 2786190137, 3204727651, 4173325571, 1979226628, 401983366\n// r2 = 2786190139, 3204727655, 4173325577, 1979226636, 401983376\n//\n// seeds = {3350727907, 3188173515, 3204727655, 4173325577, 1979226636,\n//           401983376, 3591037797, 2811627722, 1652921976, 2219536532 } \n//\n// Iterations from k = 6 to k = 9 (r2 = r1 + k%n)\n//\n// r1 = 2718637909, 1378394210, 2297813071, 1608643617\n// r2 = 2718637915, 1378394217, 2297813079, 1608643626\n//\n// seeds = { 434154821, 1191019290, 3237041891, 1256752498, 4277039715,\n//          2010627002, 2718637915, 1378394217, 2297813079, 1608643626 } \n//\n// Step 3\n// iterations from k = 10 to k = 19, using ^= to modify the output\n//\n// r1 = 1615303485, 3210438310, 893477041, 2884072672, 1918321961,\n// r2 = 1615303485, 3210438309, 893477039, 2884072669, 1918321957\n//\n// seeds = { 303093272, 3210438309,  893477039, 2884072669, 1918321957,\n//          1117182731, 1772877958, 2669970405, 3182737656, 4094066935 }\n//\n// r1 =  423054846, 46783064, 3904109085, 1534123446, 1495905687\n// r2 =  423054841, 46783058, 3904109078, 1534123438, 1495905678\n//\n// seeds = { 4204997637, 4246533866, 1856049002, 1129615051, 690460811,\n//           1075771511,   46783058, 3904109078, 1534123438, 1495905678 }\n \n    for(std::uint32_t n : seeds)\n        std::cout << n << '\\n';\n}",
            "output": "4204997637\n4246533866\n1856049002\n1129615051\n690460811\n1075771511\n46783058\n3904109078\n1534123438\n1495905678"
        }
    },
    "seed_seq::size": {
        "description": {
            "texte": "Returns the size of the stored initial seed sequence."
        },
        "exemple": {
            "input": "#include <random>\n#include <iostream>\nint main()\n{\n    std::seed_seq s1 = {-1, 0, 1};\n    std::cout << s1.size() << '\\n';\n}",
            "output": "3"
        }
    },
    "seed_seq::param": {
        "description": {
            "texte": "Outputs the initial seed sequence that's stored in the std::seed_seq object."
        },
        "parametres": "   dest   -   output iterator such that the expression *dest=rt is valid for a value rt of result_type \n   Type requirements \n   -OutputIt must meet the requirements of LegacyOutputIterator. \n\n",
        "exemple": {
            "input": "#include <random>\n#include <iostream>\n#include <iterator>\nint main()\n{\n    std::seed_seq s1 = {-1, 0, 1};\n    s1.param(std::ostream_iterator<int>(std::cout, \" \"));\n}",
            "output": "-1 0 1"
        }
    },
    "slice_array::slice_array": {
        "description": {
            "texte": "Constructs a slice_array from another slice_array other.The default constructor is implicitly deleted."
        },
        "parametres": "   other   -   slice_array to initialize with \n\n"
    },
    "slice_array::operator=": {
        "description": {
            "texte": "Assigns values to all referred elements."
        },
        "parametres": "   value   -   a value to assign to all of the referred elements \n   val_arr   -   std::valarray to assign \n   sl_arr   -   std::slice_array to assign \n\n"
    },
    "slice_array::operator+=,-=,*=,/=,%=,&=,|=,^=,>=": {
        "description": {
            "texte": "Applies the corresponding operation to the referred elements and the elements of other."
        },
        "parametres": "   other   -   argument array to retrieve the values from \n\n"
    },
    "gslice_array::gslice_array": {
        "description": {
            "texte": "Constructs a gslice_array from another gslice_array other.The default constructor is implicitly deleted."
        },
        "parametres": "   other   -   gslice_array to initialize with \n\n"
    },
    "gslice_array::operator=": {
        "description": {
            "texte": "Assigns values to all referred elements."
        },
        "parametres": "   value   -   a value to assign to all of the referred elements \n   val_arr   -   std::valarray to assign \n   sl_arr   -   std::gslice_array to assign \n\n"
    },
    "gslice_array::operator+=,-=,*=,/=,%=,&=,|=,^=,>=": {
        "description": {
            "texte": "Applies the corresponding operation to the referred elements and the elements of other."
        },
        "parametres": "   other   -   argument array to retrieve the values from \n\n"
    },
    "mask_array::mask_array": {
        "description": {
            "texte": "Constructs a mask_array from another mask_array other.The default constructor is implicitly deleted."
        },
        "parametres": "   other   -   mask_array to initialize with \n\n"
    },
    "mask_array::operator=": {
        "description": {
            "texte": "Assigns values to all referred elements."
        },
        "parametres": "   value   -   a value to assign to all of the referred elements \n   val_arr   -   std::valarray to assign \n   sl_arr   -   std::mask_array to assign \n\n"
    },
    "mask_array::operator+=,-=,*=,/=,%=,&=,|=,^=,>=": {
        "description": {
            "texte": "Applies the corresponding operation to the referred elements and the elements of other."
        },
        "parametres": "   other   -   argument array to retrieve the values from \n\n"
    },
    "indirect_array::indirect_array": {
        "description": {
            "texte": "Constructs a indirect_array from another indirect_array other.The default constructor is implicitly deleted."
        },
        "parametres": "   other   -   indirect_array to initialize with \n\n"
    },
    "indirect_array::operator=": {
        "description": {
            "texte": "Assigns values to all referred elements."
        },
        "parametres": "   value   -   a value to assign to all of the referred elements \n   val_arr   -   std::valarray to assign \n   sl_arr   -   std::indirect_array to assign \n\n"
    },
    "indirect_array::operator+=,-=,*=,/=,%=,&=,|=,^=,>=": {
        "description": {
            "texte": "Applies the corresponding operation to the referred elements and the elements of other."
        },
        "parametres": "   other   -   argument array to retrieve the values from \n\n"
    },
    "chrono::time_of_day::hours, std::chrono::time_of_day::minutes, std::chrono::time_of_day::seconds, std::chrono::time_of_day::subseconds": {
        "description": {
            "texte": "Obtains the components of the stored \"broken down\" time."
        }
    },
    "chrono::time_of_day::operator precision, std::chrono::time_of_day::to_duration": {
        "description": {
            "texte": "Returns the stored duration."
        }
    },
    "chrono::time_of_day::make12, std::chrono::time_of_day::make24": {
        "description": {
            "texte": "Changes the output format."
        }
    },
    "chrono::operator<< (std::chrono::time_of_day)": {
        "description": {
            "texte": "Outputs t into the stream os, according to the format string specified by the table below.The meaning of the format specifiers are:"
        }
    },
    "chrono::utc_clock::to_sys": {
        "description": {
            "texte": "Converts a utc_time t to a sys_time representing the same point in time (if possible).If t represents a time point during a leap second insertion, the last representable value of sys_time prior to the insertion of the leap second is returned. In all other cases, utc_clock::from_sys(utc_clock::to_sys(t)) == t."
        }
    },
    "chrono::utc_clock::from_sys": {
        "description": {
            "texte": "Converts a sys_time t to a utc_time u that represents the same point in time.u.time_since_epoch() - t.time_since_epoch() is equal to the number of leap seconds that was inserted between t and 1 January 1970. If t is the exact date of a leap second insertion, that leap second is counted as inserted."
        }
    },
    "chrono::utc_clock::now": {
        "description": {
            "texte": "Returns a time point representing the current point in time. The result is calculated as if by std::chrono::utc_clock::from_sys(std::chrono::system_clock::now()). Implementations may use a more accurate value of UTC time."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <chrono>\n \nvolatile int sink;\nint main()\n{\n    for (auto size = 1ull; size < 1000000000ull; size *= 100) {\n        // record start time\n        auto start = std::chrono::utc_clock::now();\n        // do some work\n        std::vector<int> v(size, 42);\n        sink = std::accumulate(v.begin(), v.end(), 0u); // make sure it's a side effect\n        // record end time\n        auto end = std::chrono::utc_clock::now();\n        std::chrono::duration<double> diff = end-start;\n        std::cout << \"Time to fill and iterate a vector of \" \n                  << size << \" ints : \" << diff.count() << \" s\\n\";\n    }\n}",
            "output": "Time to fill and iterate a vector of 1 ints : 2.43e-07 s\nTime to fill and iterate a vector of 100 ints : 4.1e-07 s\nTime to fill and iterate a vector of 10000 ints : 2.519e-05 s\nTime to fill and iterate a vector of 1000000 ints : 0.00207669 s\nTime to fill and iterate a vector of 100000000 ints : 0.423087 s"
        }
    },
    "chrono::operator<< (std::chrono::utc_time)": {
        "description": {
            "texte": "Outputs tp into the stream os, as if by std::chrono::to_stream(os, fmt, tp), where fmt is a string containing \"%F %T\" widened to CharT."
        }
    },
    "chrono::to_stream (std::chrono::utc_time)": {
        "description": {
            "texte": "Outputs tp to the stream os, formatted according to the null-terminated format string fmt. If %Z is used, it is replaced with \"UTC\" widened to CharT. If %z or a modified variant thereof is used, an offset of 0min will be formatted. If tp represents a time during a leap second insertion and a seconds field is formatted, the integral portion of the field is \"60\" widened to CharT."
        }
    },
    "chrono::from_stream (std::chrono::utc_time)": {
        "description": {
            "texte": "Attempts to parse the input stream is into the time point tp according to the format string fmt.Behaves as an UnformattedInputFunction, except that it has an unspecified effect on is.gcount(). After constructing and checking the sentry object, attempts to parse the input stream is into tp according to the format string fmt. If the parse fails to decode a valid time point, is.setstate(std::ios_base::failbit) is called and tp is not modified.If the format specifier %Z is used and successfully parsed, the parsed value is assigned to *abbrev if abbrev is not null. If the format specifier %z or a modified variant is used and successfully parsed, the parsed value is assigned to *offset if offset is not null, and the parsed offset will be subtracted from the parsed timestamp before the difference is assigned to tp."
        }
    },
    "chrono::tai_clock::now": {
        "description": {
            "texte": "Returns a time point representing the current point in time. The result is calculated as if by std::chrono::tai_clock::from_utc(std::chrono::utc_clock::now()). Implementations may use a more accurate value of TAI time."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <chrono>\n \nvolatile int sink;\nint main()\n{\n    for (auto size = 1ull; size < 1000000000ull; size *= 100) {\n        // record start time\n        auto start = std::chrono::tai_clock::now();\n        // do some work\n        std::vector<int> v(size, 42);\n        sink = std::accumulate(v.begin(), v.end(), 0u); // make sure it's a side effect\n        // record end time\n        auto end = std::chrono::tai_clock::now();\n        std::chrono::duration<double> diff = end-start;\n        std::cout << \"Time to fill and iterate a vector of \" \n                  << size << \" ints : \" << diff.count() << \" s\\n\";\n    }\n}",
            "output": "Time to fill and iterate a vector of 1 ints : 2.43e-07 s\nTime to fill and iterate a vector of 100 ints : 4.1e-07 s\nTime to fill and iterate a vector of 10000 ints : 2.519e-05 s\nTime to fill and iterate a vector of 1000000 ints : 0.00207669 s\nTime to fill and iterate a vector of 100000000 ints : 0.423087 s"
        }
    },
    "chrono::tai_clock::to_utc": {
        "description": {
            "texte": "Converts the tai_time t to a utc_time representing the same point in time."
        }
    },
    "chrono::tai_clock::from_utc": {
        "description": {
            "texte": "Converts the utc_time t to a tai_time representing the same point in time."
        }
    },
    "chrono::operator<< (std::chrono::tai_time)": {
        "description": {
            "texte": "Outputs tp into the stream os, as if by std::chrono::to_stream(os, fmt, tp), where fmt is a string containing \"%F %T\" widened to CharT."
        }
    },
    "chrono::to_stream (std::chrono::tai_time)": {
        "description": {
            "texte": "Outputs tp to the stream os, formatted according to the null-terminated format string fmt. If %Z is used, it is replaced with \"TAI\" widened to CharT. If %z or a modified variant thereof is used, an offset of 0min will be formatted. The date and time formatted are equivalent to that formatted for a std::chrono::sys_time initialized with std::chrono::sys_time<Duration>(tp.time_since_epoch()) - std::chrono::days(4383)."
        }
    },
    "chrono::from_stream (std::chrono::tai_time)": {
        "description": {
            "texte": "Attempts to parse the input stream is into the time point tp according to the format string fmt.Behaves as an UnformattedInputFunction, except that it has an unspecified effect on is.gcount(). After constructing and checking the sentry object, attempts to parse the input stream is into tp according to the format string fmt. If the parse fails to decode a valid time point, is.setstate(std::ios_base::failbit) is called and tp is not modified.If the format specifier %Z is used and successfully parsed, the parsed value is assigned to *abbrev if abbrev is not null. If the format specifier %z or a modified variant is used and successfully parsed, the parsed value is assigned to *offset if offset is not null, and the parsed offset will be subtracted from the parsed timestamp before the difference is assigned to tp."
        }
    },
    "chrono::gps_clock::now": {
        "description": {
            "texte": "Returns a time point representing the current point in time. The result is calculated as if by std::chrono::gps_clock::from_utc(std::chrono::utc_clock::now()). Implementations may use a more accurate value of GPS time."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <chrono>\n \nvolatile int sink;\nint main()\n{\n    for (auto size = 1ull; size < 1000000000ull; size *= 100) {\n        // record start time\n        auto start = std::chrono::gps_clock::now();\n        // do some work\n        std::vector<int> v(size, 42);\n        sink = std::accumulate(v.begin(), v.end(), 0u); // make sure it's a side effect\n        // record end time\n        auto end = std::chrono::gps_clock::now();\n        std::chrono::duration<double> diff = end-start;\n        std::cout << \"Time to fill and iterate a vector of \" \n                  << size << \" ints : \" << diff.count() << \" s\\n\";\n    }\n}",
            "output": "Time to fill and iterate a vector of 1 ints : 2.43e-07 s\nTime to fill and iterate a vector of 100 ints : 4.1e-07 s\nTime to fill and iterate a vector of 10000 ints : 2.519e-05 s\nTime to fill and iterate a vector of 1000000 ints : 0.00207669 s\nTime to fill and iterate a vector of 100000000 ints : 0.423087 s"
        }
    },
    "chrono::gps_clock::to_utc": {
        "description": {
            "texte": "Converts the gps_time t to a utc_time representing the same point in time."
        }
    },
    "chrono::gps_clock::from_utc": {
        "description": {
            "texte": "Converts the utc_time t to a gps_time representing the same point in time."
        }
    },
    "chrono::operator<< (std::chrono::gps_time)": {
        "description": {
            "texte": "Outputs tp into the stream os, as if by std::chrono::to_stream(os, fmt, tp), where fmt is a string containing \"%F %T\" widened to CharT."
        }
    },
    "chrono::to_stream (std::chrono::gps_time)": {
        "description": {
            "texte": "Outputs tp to the stream os, formatted according to the null-terminated format string fmt. If %Z is used, it is replaced with \"GPS\" widened to CharT. If %z or a modified variant thereof is used, an offset of 0min will be formatted. The date and time formatted are equivalent to that formatted for a std::chrono::sys_time initialized with std::chrono::sys_time<Duration>(tp.time_since_epoch()) + std::chrono::days(3657)."
        }
    },
    "chrono::from_stream (std::chrono::gps_time)": {
        "description": {
            "texte": "Attempts to parse the input stream is into the time point tp according to the format string fmt.Behaves as an UnformattedInputFunction, except that it has an unspecified effect on is.gcount(). After constructing and checking the sentry object, attempts to parse the input stream is into tp according to the format string fmt. If the parse fails to decode a valid time point, is.setstate(std::ios_base::failbit) is called and tp is not modified.If the format specifier %Z is used and successfully parsed, the parsed value is assigned to *abbrev if abbrev is not null. If the format specifier %z or a modified variant is used and successfully parsed, the parsed value is assigned to *offset if offset is not null, and the parsed offset will be subtracted from the parsed timestamp before the difference is assigned to tp."
        }
    },
    "chrono::file_clock::now": {
        "description": {
            "texte": "Returns a time point representing the current point in time."
        },
        "exemple": {
            "input": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <chrono>\n \nvolatile int sink;\nint main()\n{\n    for (auto size = 1ull; size < 1000000000ull; size *= 100) {\n        // record start time\n        auto start = std::chrono::file_clock::now();\n        // do some work\n        std::vector<int> v(size, 42);\n        sink = std::accumulate(v.begin(), v.end(), 0u); // make sure it's a side effect\n        // record end time\n        auto end = std::chrono::file_clock::now();\n        std::chrono::duration<double> diff = end-start;\n        std::cout << \"Time to fill and iterate a vector of \" \n                  << size << \" ints : \" << diff.count() << \" s\\n\";\n    }\n}",
            "output": "Time to fill and iterate a vector of 1 ints : 2.43e-07 s\nTime to fill and iterate a vector of 100 ints : 4.1e-07 s\nTime to fill and iterate a vector of 10000 ints : 2.519e-05 s\nTime to fill and iterate a vector of 1000000 ints : 0.00207669 s\nTime to fill and iterate a vector of 100000000 ints : 0.423087 s"
        }
    },
    "chrono::file_clock::to_sys, std::chrono::file_clock::from_sys": {
        "description": {
            "texte": "The duration of the return type is computed from Duration in an unspecified manner.These function templates are optional: an implementation may choose to instead provide to_utc and from_utc."
        }
    },
    "chrono::file_clock::to_utc, std::chrono::file_clock::from_utc": {
        "description": {
            "texte": "The duration of the return type is computed from Duration in an unspecified manner.These function templates are optional: an implementation may choose to instead provide to_sys and from_sys."
        }
    },
    "chrono::operator<< (std::chrono::file_time)": {
        "description": {
            "texte": "Outputs tp into the stream os, as if by std::chrono::to_stream(os, fmt, tp), where fmt is a string containing \"%F %T\" widened to CharT."
        }
    },
    "chrono::to_stream (std::chrono::file_time)": {
        "description": {
            "texte": "Outputs tp to the stream os, formatted according to the null-terminated format string fmt. If %Z is used, it is replaced with \"UTC\" widened to CharT. If %z or a modified variant thereof is used, an offset of 0min will be formatted. The date and time formatted are equivalent to that formatted for std::chrono::clock_cast<std::chrono::system_clock>(tp) or std::chrono::clock_cast<std::chrono::utc_clock>(tp)."
        }
    },
    "chrono::from_stream (std::chrono::file_time)": {
        "description": {
            "texte": "Attempts to parse the input stream is into the time point tp according to the format string fmt.Behaves as an UnformattedInputFunction, except that it has an unspecified effect on is.gcount(). After constructing and checking the sentry object, attempts to parse the input stream is into tp according to the format string fmt. If the parse fails to decode a valid time point, is.setstate(std::ios_base::failbit) is called and tp is not modified.If the format specifier %Z is used and successfully parsed, the parsed value is assigned to *abbrev if abbrev is not null. If the format specifier %z or a modified variant is used and successfully parsed, the parsed value is assigned to *offset if offset is not null, and the parsed offset will be subtracted from the parsed timestamp before the difference is assigned to tp."
        }
    },
    "chrono::operator<< (std::chrono::local_time)": {
        "description": {
            "texte": "Outputs tp into the stream os, as if by os << std::chrono::sys_time<Duration>(tp.time_since_epoch());"
        }
    },
    "chrono::to_stream (std::chrono::local_time)": {
        "description": {
            "texte": "Outputs tp to the stream os, formatted according to the null-terminated format string fmt. If %Z is used, it is replaced with *abbrev widened to CharT if abbrev is not null; otherwise os.setstate(std::ios_base::failbit) is called. If %z or a modified variant thereof is used, an offset of *offset_sec will be formatted if offset_sec is not null; otherwise os.setstate(std::ios_base::failbit) is called."
        }
    },
    "chrono::from_stream (std::chrono::local_time)": {
        "description": {
            "texte": "Attempts to parse the input stream is into the time point tp according to the format string fmt.Behaves as an UnformattedInputFunction, except that it has an unspecified effect on is.gcount(). After constructing and checking the sentry object, attempts to parse the input stream is into tp according to the format string fmt. If the parse fails to decode a valid time point, is.setstate(std::ios_base::failbit) is called and tp is not modified.If the format specifier %Z is used and successfully parsed, the parsed value is assigned to *abbrev if abbrev is not null. If the format specifier %z or a modified variant is used and successfully parsed, the parsed value is assigned to *offset if offset is not null."
        }
    },
    "chrono::day::operator++, std::chrono::day::operator--": {
        "description": {
            "texte": "Adds or subtracts 1 from the day value."
        }
    },
    "chrono::day::operator+=, std::chrono::day::operator-=": {
        "description": {
            "texte": "Adds or subtracts d.count() days from the day value."
        }
    },
    "chrono::day::operator unsigned": {
        "description": {
            "texte": "Returns the day value stored in *this."
        }
    },
    "chrono::day::ok": {
        "description": {
            "texte": "Checks if the day value stored in *this is in the valid range, i.e., [1, 31]."
        }
    },
    "chrono::operator ==,!=,,>= (std::chrono::day)": {
        "description": {
            "texte": "Compare the two std::chrono::day x and y."
        }
    },
    "chrono::operator+, std::chrono::operator- (std::chrono::day)": {
        "description": {
            "texte": "For (1-3), if the result would be outside the range [0, 255], the actual stored value is unspecified."
        }
    },
    "chrono::operator<< (std::chrono::day)": {
        "description": {
            "texte": "Forms a std::basic_string<CharT> s consisting of the day value stored in d formatted as a decimal number, with a leading zero if the result would otherwise be a single decimal digit. Inserts that string into os. Then, if !d.ok(), inserts the string \" is not a valid day\" into os."
        }
    },
    "chrono::to_stream (std::chrono::day)": {
        "description": {
            "texte": "Outputs d to the stream os, formatted according to the null-terminated format string fmt."
        }
    },
    "chrono::from_stream (std::chrono::day)": {
        "description": {
            "texte": "Attempts to parse the input stream is into the std::chrono::day d according to the format string fmt.Behaves as an UnformattedInputFunction, except that it has an unspecified effect on is.gcount(). After constructing and checking the sentry object, attempts to parse the input stream is into d according to the format string fmt. If the parse fails to decode a valid day, is.setstate(std::ios_base::failbit) is called and d is not modified.If the format specifier %Z is used and successfully parsed, the parsed value is assigned to *abbrev if abbrev is not null. If the format specifier %z or a modified variant is used and successfully parsed, the parsed value is assigned to *offset if offset is not null."
        }
    },
    "chrono::month::operator++, std::chrono::month::operator--": {
        "description": {
            "texte": "Adds or subtracts 1 from the month value, reducing the result modulo 12 to an integer in the range [1, 12]."
        }
    },
    "chrono::month::operator+=, std::chrono::month::operator-=": {
        "description": {
            "texte": "Adds or subtracts m.count() from the month value, reducing the result modulo 12 to an integer in the range [1, 12]."
        }
    },
    "chrono::month::operator unsigned": {
        "description": {
            "texte": "Returns the month value stored in *this."
        }
    },
    "chrono::month::ok": {
        "description": {
            "texte": "Checks if the month value stored in *this is in the valid range, i.e., [1, 12]."
        }
    },
    "chrono::operator ==,!=,,>= (std::chrono::month)": {
        "description": {
            "texte": "Compare the two std::chrono::month x and y."
        }
    },
    "chrono::operator+, std::chrono::operator- (std::chrono::month)": {
        "description": {
            "texte": "As long as the computation doesn't overflow, (1-3) always return a valid month even if m.ok() is false.The result of subtracting two month values is a duration of type std::chrono::months. That duration unit represents the length of the average Gregorian month, and the resulting duration bears no relationship to the number of days in the particular months represented by the operands. For example, std::chrono::seconds(std::chrono::April - std::chrono::March) is not the number of seconds in March (2678400s), but 2629746s (30.436875 days)."
        }
    },
    "chrono::operator<< (std::chrono::month)": {
        "description": {
            "texte": "If !m.ok(), equivalent to os << unsigned(m) << \" is not a valid month\";. Otherwise, forms a std::basic_string<CharT> s consisting of the abbreviated month name for the month represented by m, determined using the locale associated with os, and inserts s into os."
        }
    },
    "chrono::to_stream (std::chrono::month)": {
        "description": {
            "texte": "Outputs m to the stream os, formatted according to the null-terminated format string fmt."
        }
    },
    "chrono::from_stream (std::chrono::month)": {
        "description": {
            "texte": "Attempts to parse the input stream is into the std::chrono::month m according to the format string fmt.Behaves as an UnformattedInputFunction, except that it has an unspecified effect on is.gcount(). After constructing and checking the sentry object, attempts to parse the input stream is into m according to the format string fmt. If the parse fails to decode a valid month, is.setstate(std::ios_base::failbit) is called and m is not modified.If the format specifier %Z is used and successfully parsed, the parsed value is assigned to *abbrev if abbrev is not null. If the format specifier %z or a modified variant is used and successfully parsed, the parsed value is assigned to *offset if offset is not null."
        }
    },
    "chrono::year::operator++, std::chrono::year::operator--": {
        "description": {
            "texte": "Adds or subtracts 1 from the year value."
        }
    },
    "chrono::year::operator+=, std::chrono::year::operator-=": {
        "description": {
            "texte": "Adds or subtracts y.count() years from the year value."
        }
    },
    "chrono::year::operator+, std::chrono::year::operator-": {
        "description": {
            "texte": "Applies the unary operators to the year value."
        }
    },
    "chrono::year::is_leap": {
        "description": {
            "texte": "Determines if *this represents a leap year in the proleptic Gregorian calendar.*this represents a leap year if the stored year value."
        }
    },
    "chrono::year::operator int": {
        "description": {
            "texte": "Returns the year value stored in *this."
        }
    },
    "chrono::year::ok": {
        "description": {
            "texte": "Checks if the year value stored in *this is in the valid range, i.e., [-32767, 32767]."
        }
    },
    "chrono::year::min": {
        "description": {
            "texte": "Returns the smallest possible year, that is, std::chrono::year(-32767)."
        }
    },
    "chrono::year::max": {
        "description": {
            "texte": "Returns the largest possible year, that is, std::chrono::year(32767)."
        }
    },
    "chrono::operator ==,!=,,>= (std::chrono::year)": {
        "description": {
            "texte": "Compare the two std::chrono::year x and y."
        }
    },
    "chrono::operator+, std::chrono::operator- (std::chrono::year)": {
        "description": {
            "texte": "If the resulting year value for (1-3) is outside the range [-32767,32767], the actual value stored is unspecified.The result of subtracting two year values is a duration of type std::chrono::years. This duration unit represents the length of the average Gregorian year, and the resulting duration bears no relationship to the number of days in the particular years represented by the operands. For example, the result of 2018y - 2017y is std::chrono::years(1), which represents 365.2425 days, not 365 days."
        }
    },
    "chrono::operator<< (std::chrono::year)": {
        "description": {
            "texte": "Forms a std::basic_string<CharT> s consisting of the year value stored in y formatted as a decimal number, left-padded with 0 to four digits if the result would otherwise be less than four digits. Inserts that string into os. Then, if !y.ok(), inserts the string \" is not a valid year\" into os."
        }
    },
    "chrono::to_stream (std::chrono::year)": {
        "description": {
            "texte": "Outputs y to the stream os, formatted according to the null-terminated format string fmt."
        }
    },
    "chrono::from_stream (std::chrono::year)": {
        "description": {
            "texte": "Attempts to parse the input stream is into the std::chrono::year y according to the format string fmt.Behaves as an UnformattedInputFunction, except that it has an unspecified effect on is.gcount(). After constructing and checking the sentry object, attempts to parse the input stream is into y according to the format string fmt. If the parse fails to decode a valid year, is.setstate(std::ios_base::failbit) is called and y is not modified.If the format specifier %Z is used and successfully parsed, the parsed value is assigned to *abbrev if abbrev is not null. If the format specifier %z or a modified variant is used and successfully parsed, the parsed value is assigned to *offset if offset is not null."
        }
    },
    "chrono::weekday::operator++, std::chrono::weekday::operator--": {
        "description": {
            "texte": "Adds or subtracts 1 from the weekday value, reducing the result modulo 7 to an integer in the range [0, 6]."
        }
    },
    "chrono::weekday::operator+=, std::chrono::weekday::operator-=": {
        "description": {
            "texte": "Adds or subtracts d.count() from the weekday value, reducing the result modulo 7 to an integer in the range [0, 6]."
        }
    },
    "chrono::weekday::operator unsigned": {
        "description": {
            "texte": "Returns the weekday value stored in *this."
        }
    },
    "chrono::weekday::ok": {
        "description": {
            "texte": "Checks if the weekday value stored in *this is in the valid range, i.e., [0, 6]."
        }
    },
    "chrono::operator ==,!= (std::chrono::weekday)": {
        "description": {
            "texte": "Compare the two std::chrono::weekday x and y."
        }
    },
    "chrono::operator+, std::chrono::operator- (std::chrono::weekday)": {
        "description": {
            "texte": "As long as the computation doesn't overflow, (1-3) always return a valid weekday even if wd.ok() is false."
        }
    },
    "chrono::operator<< (std::chrono::weekday)": {
        "description": {
            "texte": "If !wd.ok(), equivalent to os << unsigned(wd) << \" is not a valid weekday\";. Otherwise, forms a std::basic_string<CharT> s consisting of the abbreviated weekday name for the weekday represented by wd, determined using the locale associated with os, and inserts s into os."
        }
    },
    "chrono::to_stream (std::chrono::weekday)": {
        "description": {
            "texte": "Outputs wd to the stream os, formatted according to the null-terminated format string fmt."
        }
    },
    "chrono::from_stream (std::chrono::weekday)": {
        "description": {
            "texte": "Attempts to parse the input stream is into the std::chrono::weekday wd according to the format string fmt.Behaves as an UnformattedInputFunction, except that it has an unspecified effect on is.gcount(). After constructing and checking the sentry object, attempts to parse the input stream is into wd according to the format string fmt. If the parse fails to decode a valid weekday, is.setstate(std::ios_base::failbit) is called and wd is not modified.If the format specifier %Z is used and successfully parsed, the parsed value is assigned to *abbrev if abbrev is not null. If the format specifier %z or a modified variant is used and successfully parsed, the parsed value is assigned to *offset if offset is not null."
        }
    },
    "chrono::year_month_day::year_month_day": {
        "description": {
            "texte": "Constructs a year_month_day object.Constructors (3-4) define implicit conversions from std::chrono::year_month_day_last and std::chrono::sys_days, respectively.For any year_month_day object ymd representing a valid date (ymd.ok() == true), converting ymd to sys_days and back yields the same value."
        }
    },
    "chrono::year_month_day::operator+=, std::chrono::year_month_day::operator-=": {
        "description": {
            "texte": "Modifies the time point *this represents by the duration dy or dm."
        }
    },
    "chrono::year_month_day::year, std::chrono::year_month_day::month, std::chrono::year_month_day::day": {
        "description": {
            "texte": "Retrieves the year, month and day values stored in this year_month_day object."
        }
    },
    "chrono::year_month_day::operator sys_days, std::chrono::year_month_day::operator local_days": {
        "description": {
            "texte": "Converts *this to a std::chrono::time_point representing the same date as this year_month_day."
        }
    },
    "chrono::year_month_day::ok": {
        "description": {
            "texte": "Checks if this year_month_day object represents a valid calendar date."
        }
    },
    "chrono::operator ==,!=,,>= (std::chrono::year_month_day)": {
        "description": {
            "texte": "Compares the two year_month_day objects x and y. This is a lexicographical comparison: the year() is compared first, then month(), then day()."
        }
    },
    "chrono::operator<< (std::chrono::year_month_day)": {
        "description": {
            "texte": "Outputs a textual representation of ymd into the stream os. This first forms a std::basic_string<CharT> s consisting of a textual representation of the date in the format yyyy-mm-dd (same as the one output by to_stream with the %F specifier), and inserts it into os. Then, if !ymd.ok(), inserts \" is not a valid date\" into os."
        }
    },
    "chrono::to_stream (std::chrono::year_month_day)": {
        "description": {
            "texte": "Outputs ymd to the stream os, formatted according to the null-terminated format string fmt."
        }
    },
    "chrono::from_stream (std::chrono::year_month_day)": {
        "description": {
            "texte": "Attempts to parse the input stream is into the std::chrono::year_month_day ymd according to the format string fmt.Behaves as an UnformattedInputFunction, except that it has an unspecified effect on is.gcount(). After constructing and checking the sentry object, attempts to parse the input stream is into ymd according to the format string fmt. If the parse fails to decode a valid year_month_day, is.setstate(std::ios_base::failbit) is called and ymd is not modified.If the format specifier %Z is used and successfully parsed, the parsed value is assigned to *abbrev if abbrev is not null. If the format specifier %z or a modified variant is used and successfully parsed, the parsed value is assigned to *offset if offset is not null."
        }
    },
    "chrono::year_month_day_last::year_month_day_last": {
        "description": {
            "texte": "Constructs a year_month_day_last object storing the year y and the month mdl.month(). The constructed object represents the last day of that year and month."
        }
    },
    "chrono::year_month_day_last::operator+=, std::chrono::year_month_day_last::operator-=": {
        "description": {
            "texte": "Modifies the time point *this represents by the duration dy or dm."
        }
    },
    "chrono::year_month_day_last::year, std::chrono::year_month_day_last::month, std::chrono::year_month_day_last::day, std::chrono::year_month_day_last::month_day_last": {
        "description": {
            "texte": "Retrieves the field values stored in this year_month_day_last object."
        }
    },
    "chrono::year_month_day_last::operator sys_days, std::chrono::year_month_day_last::operator local_days": {
        "description": {
            "texte": "Converts *this to a std::chrono::time_point representing the same date as this year_month_day_last. This is equivalent to composing a year_month_day from year(), month() and day() and converting that year_month_day to the destination type."
        }
    },
    "chrono::year_month_day_last::ok": {
        "description": {
            "texte": "Checks if *this represents a valid date. Because a year_month_day_last represents the last day of a particular month, it represents a valid date as long as the year and month are valid."
        }
    },
    "chrono::operator ==,!=,,>= (std::chrono::year_month_day_last)": {
        "description": {
            "texte": "Compares the two year_month_day_last objects x and y. This is a lexicographical comparison: the year() is compared first, then month()."
        }
    },
    "chrono::operator<< (std::chrono::year_month_day_last)": {
        "description": {
            "texte": "Outputs a textual representation of ymdl into os, as if by os << ymdl.year() << '/' << ymdl.month_day_last();"
        }
    },
    "chrono::year_month_weekday::year_month_weekday": {
        "description": {
            "texte": "Constructs a year_month_weekday object."
        }
    },
    "chrono::year_month_weekday::operator+=, std::chrono::year_month_weekday::operator-=": {
        "description": {
            "texte": "Modifies the time point *this represents by the duration dy or dm."
        }
    },
    "chrono::year_month_weekday::year, std::chrono::year_month_weekday::month, std::chrono::year_month_weekday::weekday, std::chrono::year_month_weekday::index, std::chrono::year_month_weekday::weekday_indexed": {
        "description": {
            "texte": "Retrieves the field values stored in this year_month_weekday object."
        }
    },
    "chrono::year_month_weekday::ok": {
        "description": {
            "texte": "Checks if this year_month_weekday object represents a valid date."
        }
    },
    "chrono::operator ==,!= (std::chrono::year_month_weekday)": {
        "description": {
            "texte": "Compares the two year_month_weekday objects x and y."
        }
    },
    "chrono::operator<< (std::chrono::year_month_weekday)": {
        "description": {
            "texte": "Outputs a textual representation of ymwd into os, as if by os << ymwd.year() << '/' << ymwd.month() << '/' << ymwdl.weekday_indexed();"
        }
    },
    "chrono::year_month_weekday_last::year_month_weekday_last": {
        "description": {
            "texte": "Constructs a year_month_weekday_last object storing the year y, the month m, and the weekday wdl.weekday(). The constructed object represents the last weekday of that year and month."
        }
    },
    "chrono::year_month_weekday_last::operator+=, std::chrono::year_month_weekday_last::operator-=": {
        "description": {
            "texte": "Modifies the time point *this represents by the duration dy or dm."
        }
    },
    "chrono::year_month_weekday_last::year, std::chrono::year_month_weekday_last::month, std::chrono::year_month_weekday_last::weekday, std::chrono::year_month_weekday_last::weekday_last": {
        "description": {
            "texte": "Retrieves the field values stored in this year_month_weekday_last object."
        }
    },
    "chrono::year_month_weekday_last::ok": {
        "description": {
            "texte": "Checks if this object represents a valid date. Since a year_month_weekday_last represents the last weekday of a particular month, it is valid as long as the year, month and weekday are valid."
        }
    },
    "chrono::operator ==,!= (std::chrono::year_month_weekday_last)": {
        "description": {
            "texte": "Compares the two year_month_weekday_last objects x and y."
        }
    },
    "chrono::operator<< (std::chrono::year_month_weekday_last)": {
        "description": {
            "texte": "Outputs a textual representation of ymwdl into os, as if by os << ymwdl.year() << '/' << ymwdl.month() << '/' << ymwdl.weekday_last();"
        }
    },
    "chrono::weekday_last::weekday_last": {
        "description": {
            "texte": "Constructs a weekday_last object storing the weekday wd."
        }
    },
    "chrono::weekday_last::weekday": {
        "description": {
            "texte": "Retrieves a copy of the std::chrono::weekday object stored in *this."
        }
    },
    "chrono::weekday_last::ok": {
        "description": {
            "texte": "Checks if the weekday object stored in *this is valid."
        }
    },
    "chrono::operator ==,!= (std::chrono::weekday_last)": {
        "description": {
            "texte": "Compares the two weekday_last objects x and y."
        }
    },
    "chrono::operator<< (std::chrono::weekday_last)": {
        "description": {
            "texte": "Outputs a textual representation of wdl into the stream os, as if by os << wdl.weekday() << \"[last]\";."
        }
    },
    "chrono::month_day::month_day": {
        "description": {
            "texte": "Constructs a month_day."
        }
    },
    "chrono::month_day::month, std::chrono::month_day::day": {
        "description": {
            "texte": "Retrieves the month and day values stored in this month_day object."
        }
    },
    "chrono::month_day::ok": {
        "description": {
            "texte": "Determines whether this month_day stores a valid month-day combination.The combination is valid if month() represents a valid month (month().ok() == true), unsigned{day()} >= 1, and unsigned{day()} <= D, where D is the number of days in the month represented by month(). The number of days in February is considered to be 29."
        }
    },
    "chrono::operator ==,!=,,>= (std::chrono::month_day)": {
        "description": {
            "texte": "Compares two month_day objects."
        }
    },
    "chrono::operator<< (std::chrono::month_day)": {
        "description": {
            "texte": "Outputs a textual representation of md into the stream os, as if by os << md.month() << '/' << md.day()."
        }
    },
    "chrono::to_stream (std::chrono::month_day)": {
        "description": {
            "texte": "Outputs md to the stream os, formatted according to the null-terminated format string fmt."
        }
    },
    "chrono::from_stream (std::chrono::month_day)": {
        "description": {
            "texte": "Attempts to parse the input stream is into the std::chrono::month_day md according to the format string fmt.Behaves as an UnformattedInputFunction, except that it has an unspecified effect on is.gcount(). After constructing and checking the sentry object, attempts to parse the input stream is into md according to the format string fmt. If the parse fails to decode a valid month_day, is.setstate(std::ios_base::failbit) is called and md is not modified.If the format specifier %Z is used and successfully parsed, the parsed value is assigned to *abbrev if abbrev is not null. If the format specifier %z or a modified variant is used and successfully parsed, the parsed value is assigned to *offset if offset is not null."
        }
    },
    "chrono::month_day_last::month_day_last": {
        "description": {
            "texte": "Constructs a month_day_last object that represents the last day of the month m."
        }
    },
    "chrono::month_day_last::month": {
        "description": {
            "texte": "Retrieves a copy of the std::chrono::month object stored in *this."
        }
    },
    "chrono::month_day_last::ok": {
        "description": {
            "texte": "Checks if the month object stored in *this is valid."
        }
    },
    "chrono::operator ==,!=,,>= (std::chrono::month_day_last)": {
        "description": {
            "texte": "Compares the two month_day_last objects x and y."
        }
    },
    "chrono::operator<< (std::chrono::month_day_last)": {
        "description": {
            "texte": "Outputs a textual representation of mdl into os, as if by os << mdl.month() << \"/last\";"
        }
    },
    "chrono::month_weekday::month_weekday": {
        "description": {
            "texte": "Constructs a month_weekday object that stores the month m and the weekday_indexed wdi."
        }
    },
    "chrono::month_weekday::month, std::chrono::month_weekday::weekday_indexed": {
        "description": {
            "texte": "Retrieves a copy of the month and weekday_indexed objects stored in *this."
        }
    },
    "chrono::month_weekday::ok": {
        "description": {
            "texte": "Checks if the contained month and weekday_indexed objects are valid."
        }
    },
    "chrono::operator ==,!=,,>= (std::chrono::month_weekday)": {
        "description": {
            "texte": "Compares the two month_weekday objects x and y."
        }
    },
    "chrono::operator<< (std::chrono::month_weekday)": {
        "description": {
            "texte": "Outputs a textual representation of mwd into os, as if by os << mwd.month() << '/' << mwd.weekday_indexed();"
        }
    },
    "chrono::month_weekday_last::month_weekday_last": {
        "description": {
            "texte": "Constructs a month_weekday_last object that stores the month m and the weekday_last wdl."
        }
    },
    "chrono::month_weekday_last::month, std::chrono::month_weekday_last::weekday_last": {
        "description": {
            "texte": "Retrieves a copy of the month and weekday_last objects stored in *this."
        }
    },
    "chrono::month_weekday_last::ok": {
        "description": {
            "texte": "Checks if the contained month and weekday_last objects are valid."
        }
    },
    "chrono::operator ==,!=,,>= (std::chrono::month_weekday_last)": {
        "description": {
            "texte": "Compares the two month_weekday_last objects x and y."
        }
    },
    "chrono::operator<< (std::chrono::month_weekday_last)": {
        "description": {
            "texte": "Outputs a textual representation of mwdl into os, as if by os << mwdl.month() << '/' << mwdl.weekday_last();"
        }
    },
    "chrono::year_month::year_month": {
        "description": {
            "texte": "Constructs a year_month object."
        }
    },
    "chrono::year_month::year, std::chrono::year_month::month": {
        "description": {
            "texte": "Retrieves the year and month values stored in this year_month object."
        }
    },
    "chrono::year_month::operator+=, std::chrono::year_month::operator-=": {
        "description": {
            "texte": "Modifies the time point *this represents by the duration dy or dm."
        }
    },
    "chrono::year_month::ok": {
        "description": {
            "texte": "Checks if the year and month values stored in this object are valid."
        }
    },
    "chrono::operator ==,!=,,>= (std::chrono::year_month)": {
        "description": {
            "texte": "Compares the two year_month objects x and y."
        }
    },
    "chrono::operator+, std::chrono::operator- (std::chrono::year_month)": {
        "description": {
            "texte": "The result of subtracting two year_month values is a duration of type std::chrono::months. This duration unit represents the length of the average Gregorian month (30.436875 days), and the resulting duration bears no relationship to the actual number of days in the time period at issue. For example, the result of 2017y/3 - 2017y/2 is std::chrono::months(1), even though February 2017 only contains 28 days.Durations that are convertible to std::chrono::months, but not std::chrono::years, can be directly added to or subtracted from a year_month. Durations convertible to std::chrono::years cannot because such durations are also convertible to std::chrono::months, resulting in an ambiguity:",
            "code": "using namespace std::chrono;\n \nusing decades = duration<int, std::ratio_multiply<std::ratio<10>, years::period>>;\nusing kilomonths = duration<int, std::ratio_multiply<std::kilo, months::period>>;\n \nauto ym = 2001y/April;\nym = ym + decades{1}; // error, ambiguous\nym = ym + kilomonths{1}; // OK"
        }
    },
    "chrono::operator<< (std::chrono::year_month)": {
        "description": {
            "texte": "Outputs a textual representation of ym into the stream os, as if by os << ym.year() << '/' << ym.month()."
        }
    },
    "chrono::to_stream (std::chrono::year_month)": {
        "description": {
            "texte": "Outputs ym to the stream os, formatted according to the null-terminated format string fmt."
        }
    },
    "chrono::from_stream (std::chrono::year_month)": {
        "description": {
            "texte": "Attempts to parse the input stream is into the std::chrono::year_month ym according to the format string fmt.Behaves as an UnformattedInputFunction, except that it has an unspecified effect on is.gcount(). After constructing and checking the sentry object, attempts to parse the input stream is into ym according to the format string fmt. If the parse fails to decode a valid year_month, is.setstate(std::ios_base::failbit) is called and ym is not modified.If the format specifier %Z is used and successfully parsed, the parsed value is assigned to *abbrev if abbrev is not null. If the format specifier %z or a modified variant is used and successfully parsed, the parsed value is assigned to *offset if offset is not null."
        }
    },
    "chrono::tzdb::locate_zone": {
        "description": {
            "texte": "Obtains a pointer to a std::chrono::time_zone in this database that represents the time zone designated by tz_name. If p is the returned pointer, then either p->name() == tz_name or that there is a std::chrono::link l in this database such that p->name() == l.target() and l.name() == tz_name."
        }
    },
    "chrono::tzdb::current_zone": {
        "description": {
            "texte": "Obtains a pointer to a std::chrono::time_zone in this database that represents the local time zone of the computer."
        }
    },
    "chrono::tzdb_list::erase_after": {
        "description": {
            "texte": "Erases the std::chrono::tzdb referred to by the iterator following p. The behavior is undefined if that iterator is not dereferenceable. No pointers, references, or iterators are invalidated except for those referring to the erased element."
        }
    },
    "chrono::tzdb_list::begin": {
        "description": {
            "texte": "Returns an iterator referring to the first std::chrono::tzdb in the container."
        }
    },
    "chrono::tzdb_list::end, std::chrono::tzdb_list::cend": {
        "description": {
            "texte": "Returns the past-the-end iterator of the tzdb_list. Attempting to dereference this iterator results in undefined behavior."
        }
    },
    "chrono::time_zone::name": {
        "description": {
            "texte": "Obtains the name of this time zone."
        }
    },
    "chrono::time_zone::get_info": {
        "description": {
            "texte": "Obtains information about this time zone at the time point tp."
        }
    },
    "chrono::time_zone::to_sys": {
        "description": {
            "texte": "Converts the local_time tp in this time zone to the corresponding sys_time."
        }
    },
    "chrono::time_zone::to_local": {
        "description": {
            "texte": "Converts the sys_time tp to the corresponding local_time in this time zone."
        }
    },
    "chrono::operator ==,!=,,>= (std::chrono::time_zone)": {
        "description": {
            "texte": "Compares the two time_zone objects x and y by name."
        }
    },
    "chrono::zoned_time::zoned_time": {
        "description": {
            "texte": "Constructs a zoned_time object, initializing the stored time zone pointer and time point according to the following table, where traits is std::chrono::zoned_traits<TimeZonePtr>:The behavior is undefined if the time zone pointer (initialized as described above) does not refer to a time zone."
        }
    },
    "chrono::zoned_time::operator=": {
        "description": {
            "texte": "Assign the value of other to *this."
        }
    },
    "chrono::zoned_time::get_time_zone": {
        "description": {
            "texte": "Retrieves the stored time zone pointer."
        }
    },
    "chrono::zoned_time::operator sys_time, std::chrono::zoned_time::get_sys_time": {
        "description": {
            "texte": "Obtains a std::chrono::sys_time<duration> representing the same point in time as this zoned_time object."
        }
    },
    "chrono::zoned_time::operator local_time, std::chrono::zoned_time::get_local_time": {
        "description": {
            "texte": "Obtains a std::chrono::local_time<duration> representing the local time in the time zone corresponding to the time point *this represents."
        }
    },
    "chrono::zoned_time::get_info": {
        "description": {
            "texte": "Obtains the std::chrono::sys_info containing information about the time zone at the time point stored in *this."
        }
    },
    "chrono::operator ==,!= (std::chrono::zoned_time)": {
        "description": {
            "texte": "Compares the two zoned_time objects x and y. Two zoned_time objects compare equal if their time points and time zone pointers both compare equal according to operator==."
        }
    },
    "chrono::operator<< (std::chrono::zoned_time)": {
        "description": {
            "texte": "Outputs tp to the stream os, as if by std::chrono::to_stream(os, fmt, tp), where fmt is \"%F %T %Z\" widened to CharT."
        }
    },
    "chrono::to_stream (std::chrono::zoned_time)": {
        "description": {
            "texte": "The format string consists of zero or more conversion specifiers and ordinary characters. All ordinary characters, excluding the terminating null character, are written into the output stream without modification. Each unmodified conversion specifier begins with a % character followed by a character that determines the behavior of the specifier. Some conversion specifiers have a modified form in which an E or O modifier character is inserted after the % character. Each conversion specifier is replaced by appropriate characters in the output as described below.A character sequence in the format string that begins with a % but does not match one of the format specifiers below is interpreted as ordinary characters.The following format specifiers are available:"
        }
    },
    "chrono::link::name, std::chrono::link::target": {
        "description": {
            "texte": "Accesses the name and target of this link object."
        }
    },
    "chrono::operator ==,!=,,>= (std::chrono::link)": {
        "description": {
            "texte": "Compares the two link objects x and y by name."
        }
    },
    "chrono::leap::date": {
        "description": {
            "texte": "Obtains the date and time of the leap second insertion."
        }
    },
    "chrono::operator ==,!=,,>= (std::chrono::leap)": {
        "description": {
            "texte": "Compares the date and time represented by the objects x and y."
        }
    },
    "chrono::operator<< (std::chrono::sys_info)": {
        "description": {
            "texte": "Inserts a textual representation of r into os. The exact format is unspecified."
        }
    },
    "chrono::operator<< (std::chrono::local_info)": {
        "description": {
            "texte": "Inserts a textual representation of r into os. The exact format is unspecified."
        }
    },
    "locale::id::id": {
        "description": {
            "texte": "1) default constructor: creates an object of type std::locale::id with implementation-specific content.2) copy constructor is deleted; std::locale::id is not copyable."
        }
    }
}