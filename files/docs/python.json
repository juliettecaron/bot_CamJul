{
    "dir": {
        "description": {
            "texte": "Without arguments, return the list of names in the current local scope. With an argument, attempt to return a list of valid attributes for that object.If the object has a method named __dir__(), this method will be called and must return the list of attributes. This allows objects that implement a custom __getattr__() or __getattribute__() function to customize the way dir() reports their attributes.The default dir() mechanism behaves differently with different types of objects, as it attempts to produce the most relevant, rather than complete, information:The resulting list is sorted alphabetically. For example:",
            "code": ">>> import struct\n>>> dir()   # show the names in the module namespace  \n['__builtins__', '__name__', 'struct']\n>>> dir(struct)   # show the names in the struct module \n['Struct', '__all__', '__builtins__', '__cached__', '__doc__', '__file__',\n '__initializing__', '__loader__', '__name__', '__package__',\n '_clearcache', 'calcsize', 'error', 'pack', 'pack_into',\n 'unpack', 'unpack_from']\n>>> class Shape:\n...     def __dir__(self):\n...         return ['area', 'perimeter', 'location']\n>>> s = Shape()\n>>> dir(s)\n['area', 'location', 'perimeter']\n"
        },
        "parametres": [
            "[object]\t"
        ],
        "exemple": ">>> import struct\n>>> dir()   # show the names in the module namespace  \n['__builtins__', '__name__', 'struct']\n>>> dir(struct)   # show the names in the struct module \n['Struct', '__all__', '__builtins__', '__cached__', '__doc__', '__file__',\n '__initializing__', '__loader__', '__name__', '__package__',\n '_clearcache', 'calcsize', 'error', 'pack', 'pack_into',\n 'unpack', 'unpack_from']\n>>> class Shape:\n...     def __dir__(self):\n...         return ['area', 'perimeter', 'location']\n>>> s = Shape()\n>>> dir(s)\n['area', 'location', 'perimeter']\n"
    },
    "float": {
        "description": {
            "texte": "Return a floating point number constructed from a number or string x.If the argument is a string, it should contain a decimal number, optionally preceded by a sign, and optionally embedded in whitespace. The optional sign may be '+' or '-'; a '+' sign has no effect on the value produced. The argument may also be a string representing a NaN (not-a-number), or a positive or negative infinity. More precisely, the input must conform to the following grammar after leading and trailing whitespace characters are removed:",
            "code": "\nsign           ::=  \"+\" | \"-\"\ninfinity       ::=  \"Infinity\" | \"inf\"\nnan            ::=  \"nan\"\nnumeric_value  ::=  floatnumber | infinity | nan\nnumeric_string ::=  [sign] numeric_value\n"
        },
        "parametres": [
            "[x]\t"
        ],
        "exemple": "\nsign           ::=  \"+\" | \"-\"\ninfinity       ::=  \"Infinity\" | \"inf\"\nnan            ::=  \"nan\"\nnumeric_value  ::=  floatnumber | infinity | nan\nnumeric_string ::=  [sign] numeric_value\n"
    },
    "pow": {
        "description": {
            "texte": "Return base to the power exp; if mod is present, return base to the power exp, modulo mod (computed more efficiently than pow(base, exp) % mod). The two-argument form pow(base, exp) is equivalent to using the power operator: base**exp.The arguments must have numeric types. With mixed operand types, the coercion rules for binary arithmetic operators apply. For int operands, the result has the same type as the operands (after coercion) unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, 10**2 returns 100, but 10**-2 returns 0.01.Here\u2019s an example of computing an inverse for 38 modulo 97:",
            "code": ">>> pow(38, -1, mod=97)\n23\n>>> 23 * 38 % 97 == 1\nTrue\n"
        },
        "parametres": [
            "base\tReturn base to the power exp; if mod is present, return base to the power exp, modulo mod (computed more efficiently than pow(base, exp) % mod). The two-argument form pow(base, exp) is equivalent to using the power operator: base**exp",
            " exp[\t",
            " mod]\t"
        ],
        "exemple": ">>> pow(38, -1, mod=97)\n23\n>>> 23 * 38 % 97 == 1\nTrue\n"
    },
    "property": {
        "description": {
            "texte": "Return a property attribute.fget is a function for getting an attribute value. fset is a function for setting an attribute value. fdel is a function for deleting an attribute value. And doc creates a docstring for the attribute.If given, doc will be the docstring of the property attribute. Otherwise, the property will copy fget\u2019s docstring (if it exists). This makes it possible to create read-only properties easily using property() as a decorator:",
            "code": "class Parrot:\n    def __init__(self):\n        self._voltage = 100000\n\n    @property\n    def voltage(self):\n        \"\"\"Get the current voltage.\"\"\"\n        return self._voltage\n"
        },
        "parametres": [
            "fget=None\t",
            " fset=None\t",
            " fdel=None\t",
            " doc=None\t"
        ],
        "exemple": "class C:\n    def __init__(self):\n        self._x = None\n\n    def getx(self):\n        return self._x\n\n    def setx(self, value):\n        self._x = value\n\n    def delx(self):\n        del self._x\n\n    x = property(getx, setx, delx, \"I'm the 'x' property.\")\n"
    },
    "super": {
        "description": {
            "texte": "Return a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class.The object-or-type determines the method resolution order to be searched. The search starts from the class right after the type.The __mro__ attribute of the object-or-type lists the method resolution search order used by both getattr() and super(). The attribute is dynamic and can change whenever the inheritance hierarchy is updated.There are two typical use cases for super. In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages.For both use cases, a typical superclass call looks like this:",
            "code": "class C(B):\n    def method(self, arg):\n        super().method(arg)    # This does the same thing as:\n                               # super(C, self).method(arg)\n"
        },
        "parametres": [
            "[type[\t",
            " object-or-type]]\t"
        ],
        "exemple": "class C(B):\n    def method(self, arg):\n        super().method(arg)    # This does the same thing as:\n                               # super(C, self).method(arg)\n"
    },
    "zip": {
        "description": {
            "texte": "Make an iterator that aggregates elements from each of the iterables.Returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables. The iterator stops when the shortest input iterable is exhausted. With a single iterable argument, it returns an iterator of 1-tuples. With no arguments, it returns an empty iterator. Equivalent to:",
            "code": "def zip(*iterables):\n    # zip('ABCD', 'xy') --> Ax By\n    sentinel = object()\n    iterators = [iter(it) for it in iterables]\n    while iterators:\n        result = []\n        for it in iterators:\n            elem = next(it, sentinel)\n            if elem is sentinel:\n                return\n            result.append(elem)\n        yield tuple(result)\n"
        },
        "parametres": [
            "*iterables\t"
        ],
        "exemple": "def zip(*iterables):\n    # zip('ABCD', 'xy') --> Ax By\n    sentinel = object()\n    iterators = [iter(it) for it in iterables]\n    while iterators:\n        result = []\n        for it in iterators:\n            elem = next(it, sentinel)\n            if elem is sentinel:\n                return\n            result.append(elem)\n        yield tuple(result)\n"
    },
    "__import__": {
        "description": {
            "texte": "This function is invoked by the import statement. It can be replaced (by importing the builtins module and assigning to builtins.__import__) in order to change semantics of the import statement, but doing so is strongly discouraged as it is usually simpler to use import hooks (see PEP 302) to attain the same goals and does not cause issues with code which assumes the default import implementation is in use. Direct use of __import__() is also discouraged in favor of importlib.import_module().The function imports the module name, potentially using the given globals and locals to determine how to interpret the name in a package context. The fromlist gives the names of objects or submodules that should be imported from the module given by name. The standard implementation does not use its locals argument at all, and uses its globals only to determine the package context of the import statement.When the name variable is of the form package.module, normally, the top-level package (the name up till the first dot) is returned, not the module named by name. However, when a non-empty fromlist argument is given, the module named by name is returned.On the other hand, the statement from spam.ham import eggs, sausage as\nsaus results in",
            "code": "_temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], 0)\neggs = _temp.eggs\nsaus = _temp.sausage\n"
        },
        "parametres": [
            "name\tThe function imports the module name, potentially using the given globals and locals to determine how to interpret the name in a package context. The fromlist gives the names of objects or submodules that should be imported from the module given by name.When the name variable is of the form package.module, normally, the top-level package (the name up till the first dot) is returned, not the module named by name. However, when a non-empty fromlist argument is given, the module named by name is returned",
            " globals=None\t",
            " locals=None\t",
            " fromlist=(\t"
        ],
        "exemple": "spam = __import__('spam', globals(), locals(), [], 0)\n"
    },
    "int.bit_length": {
        "description": {
            "texte": "Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros:Equivalent to:",
            "code": "def bit_length(self):\n    s = bin(self)       # binary representation:  bin(-37) --> '-0b100101'\n    s = s.lstrip('-0b') # remove leading zeros and minus sign\n    return len(s)       # len('100101') --> 6\n"
        },
        "parametres": [
            "\tReturn the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros:Equivalent to:"
        ],
        "exemple": ">>> n = -37\n>>> bin(n)\n'-0b100101'\n>>> n.bit_length()\n6\n"
    },
    "range": {
        "description": {
            "texte": "The arguments to the range constructor must be integers (either built-in int or any object that implements the __index__ special method). If the step argument is omitted, it defaults to 1. If the start argument is omitted, it defaults to 0. If step is zero, ValueError is raised.For a positive step, the contents of a range r are determined by the formula r[i] = start + step*i where i >= 0 and r[i] < stop.A range object will be empty if r[0] does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices.Range examples:",
            "code": ">>> list(range(10))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> list(range(1, 11))\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>> list(range(0, 30, 5))\n[0, 5, 10, 15, 20, 25]\n>>> list(range(0, 10, 3))\n[0, 3, 6, 9]\n>>> list(range(0, -10, -1))\n[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\n>>> list(range(0))\n[]\n>>> list(range(1, 0))\n[]\n"
        },
        "parametres": [
            "stop\tFor a positive step, the contents of a range r are determined by the formula r[i] = start + step*i where i >= 0 and r[i] < stop"
        ],
        "exemple": ">>> list(range(10))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> list(range(1, 11))\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>> list(range(0, 30, 5))\n[0, 5, 10, 15, 20, 25]\n>>> list(range(0, 10, 3))\n[0, 3, 6, 9]\n>>> list(range(0, -10, -1))\n[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\n>>> list(range(0))\n[]\n>>> list(range(1, 0))\n[]\n"
    },
    "str": {
        "description": {
            "texte": "Return a string version of object. If object is not provided, returns the empty string. Otherwise, the behavior of str() depends on whether encoding or errors is given, as follows.If neither encoding nor errors is given, str(object) returns object.__str__(), which is the \u201cinformal\u201d or nicely printable string representation of object. For string objects, this is the string itself. If object does not have a __str__() method, then str() falls back to returning repr(object).Passing a bytes object to str() without the encoding or errors arguments falls under the first case of returning the informal string representation (see also the -b command-line option to Python). For example:",
            "code": ">>> str(b'Zoot!')\n\"b'Zoot!'\"\n"
        },
        "parametres": [
            "object=''\t"
        ],
        "exemple": ">>> str(b'Zoot!')\n\"b'Zoot!'\"\n"
    },
    "str.split": {
        "description": {
            "texte": "Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made).If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']). The sep argument may consist of multiple characters (for example, '1<>2<>3'.split('<>') returns ['1', '2', '3']). Splitting an empty string with a specified separator returns [''].For example:",
            "code": ">>> '1 2 3'.split()\n['1', '2', '3']\n>>> '1 2 3'.split(maxsplit=1)\n['1', '2 3']\n>>> '   1   2   3   '.split()\n['1', '2', '3']\n"
        },
        "parametres": [
            "sep=None\t",
            " maxsplit=-1\t"
        ],
        "exemple": ">>> '1,2,3'.split(',')\n['1', '2', '3']\n>>> '1,2,3'.split(',', maxsplit=1)\n['1', '2,3']\n>>> '1,2,,3,'.split(',')\n['1', '2', '', '3', '']\n"
    },
    "str.title": {
        "description": {
            "texte": "Return a titlecased version of the string where words start with an uppercase character and the remaining characters are lowercase.For example:",
            "code": ">>> 'Hello world'.title()\n'Hello World'\n"
        },
        "parametres": [
            "\tReturn a titlecased version of the string where words start with an uppercase character and the remaining characters are lowercase.For example:"
        ],
        "exemple": ">>> 'Hello world'.title()\n'Hello World'\n"
    },
    "str.zfill": {
        "description": {
            "texte": "Return a copy of the string left filled with ASCII '0' digits to make a string of length width. A leading sign prefix ('+'/'-') is handled by inserting the padding after the sign character rather than before. The original string is returned if width is less than or equal to len(s).For example:",
            "code": ">>> \"42\".zfill(5)\n'00042'\n>>> \"-42\".zfill(5)\n'-0042'\n"
        },
        "parametres": [
            "width\tReturn a copy of the string left filled with ASCII '0' digits to make a string of length width. The original string is returned if width is less than or equal to len(s)"
        ],
        "exemple": ">>> \"42\".zfill(5)\n'00042'\n>>> \"-42\".zfill(5)\n'-0042'\n"
    },
    "bytes.split": {
        "description": {
            "texte": "Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1, then there is no limit on the number of splits (all possible splits are made).If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2']). The sep argument may consist of a multibyte sequence (for example, b'1<>2<>3'.split(b'<>') returns [b'1', b'2', b'3']). Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. The sep argument may be any bytes-like object.For example:",
            "code": ">>> b'1 2 3'.split()\n[b'1', b'2', b'3']\n>>> b'1 2 3'.split(maxsplit=1)\n[b'1', b'2 3']\n>>> b'   1   2   3   '.split()\n[b'1', b'2', b'3']\n"
        },
        "parametres": [
            "sep=None\t",
            " maxsplit=-1\t"
        ],
        "exemple": ">>> b'1,2,3'.split(b',')\n[b'1', b'2', b'3']\n>>> b'1,2,3'.split(b',', maxsplit=1)\n[b'1', b'2,3']\n>>> b'1,2,,3,'.split(b',')\n[b'1', b'2', b'', b'3', b'']\n"
    },
    "bytearray.split": {
        "description": {
            "texte": "Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1, then there is no limit on the number of splits (all possible splits are made).If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2']). The sep argument may consist of a multibyte sequence (for example, b'1<>2<>3'.split(b'<>') returns [b'1', b'2', b'3']). Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. The sep argument may be any bytes-like object.For example:",
            "code": ">>> b'1 2 3'.split()\n[b'1', b'2', b'3']\n>>> b'1 2 3'.split(maxsplit=1)\n[b'1', b'2 3']\n>>> b'   1   2   3   '.split()\n[b'1', b'2', b'3']\n"
        },
        "parametres": [
            "sep=None\t",
            " maxsplit=-1\t"
        ],
        "exemple": ">>> b'1,2,3'.split(b',')\n[b'1', b'2', b'3']\n>>> b'1,2,3'.split(b',', maxsplit=1)\n[b'1', b'2,3']\n>>> b'1,2,,3,'.split(b',')\n[b'1', b'2', b'', b'3', b'']\n"
    },
    "bytes.isalnum": {
        "description": {
            "texte": "Return True if all bytes in the sequence are alphabetical ASCII characters or ASCII decimal digits and the sequence is not empty, False otherwise. Alphabetic ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'. ASCII decimal digits are those byte values in the sequence b'0123456789'.For example:",
            "code": ">>> b'ABCabc1'.isalnum()\nTrue\n>>> b'ABC abc1'.isalnum()\nFalse\n"
        },
        "parametres": [
            "\tReturn True if all bytes in the sequence are alphabetical ASCII characters or ASCII decimal digits and the sequence is not empty, False otherwise. Alphabetic ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'. ASCII decimal digits are those byte values in the sequence b'0123456789'.For example:"
        ],
        "exemple": ">>> b'ABCabc1'.isalnum()\nTrue\n>>> b'ABC abc1'.isalnum()\nFalse\n"
    },
    "bytearray.isalnum": {
        "description": {
            "texte": "Return True if all bytes in the sequence are alphabetical ASCII characters or ASCII decimal digits and the sequence is not empty, False otherwise. Alphabetic ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'. ASCII decimal digits are those byte values in the sequence b'0123456789'.For example:",
            "code": ">>> b'ABCabc1'.isalnum()\nTrue\n>>> b'ABC abc1'.isalnum()\nFalse\n"
        },
        "parametres": [
            "\tReturn True if all bytes in the sequence are alphabetical ASCII characters or ASCII decimal digits and the sequence is not empty, False otherwise. Alphabetic ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'. ASCII decimal digits are those byte values in the sequence b'0123456789'.For example:"
        ],
        "exemple": ">>> b'ABCabc1'.isalnum()\nTrue\n>>> b'ABC abc1'.isalnum()\nFalse\n"
    },
    "bytes.isalpha": {
        "description": {
            "texte": "Return True if all bytes in the sequence are alphabetic ASCII characters and the sequence is not empty, False otherwise. Alphabetic ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.For example:",
            "code": ">>> b'ABCabc'.isalpha()\nTrue\n>>> b'ABCabc1'.isalpha()\nFalse\n"
        },
        "parametres": [
            "\tReturn True if all bytes in the sequence are alphabetic ASCII characters and the sequence is not empty, False otherwise. Alphabetic ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.For example:"
        ],
        "exemple": ">>> b'ABCabc'.isalpha()\nTrue\n>>> b'ABCabc1'.isalpha()\nFalse\n"
    },
    "bytearray.isalpha": {
        "description": {
            "texte": "Return True if all bytes in the sequence are alphabetic ASCII characters and the sequence is not empty, False otherwise. Alphabetic ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.For example:",
            "code": ">>> b'ABCabc'.isalpha()\nTrue\n>>> b'ABCabc1'.isalpha()\nFalse\n"
        },
        "parametres": [
            "\tReturn True if all bytes in the sequence are alphabetic ASCII characters and the sequence is not empty, False otherwise. Alphabetic ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.For example:"
        ],
        "exemple": ">>> b'ABCabc'.isalpha()\nTrue\n>>> b'ABCabc1'.isalpha()\nFalse\n"
    },
    "bytes.isdigit": {
        "description": {
            "texte": "Return True if all bytes in the sequence are ASCII decimal digits and the sequence is not empty, False otherwise. ASCII decimal digits are those byte values in the sequence b'0123456789'.For example:",
            "code": ">>> b'1234'.isdigit()\nTrue\n>>> b'1.23'.isdigit()\nFalse\n"
        },
        "parametres": [
            "\tReturn True if all bytes in the sequence are ASCII decimal digits and the sequence is not empty, False otherwise. ASCII decimal digits are those byte values in the sequence b'0123456789'.For example:"
        ],
        "exemple": ">>> b'1234'.isdigit()\nTrue\n>>> b'1.23'.isdigit()\nFalse\n"
    },
    "bytearray.isdigit": {
        "description": {
            "texte": "Return True if all bytes in the sequence are ASCII decimal digits and the sequence is not empty, False otherwise. ASCII decimal digits are those byte values in the sequence b'0123456789'.For example:",
            "code": ">>> b'1234'.isdigit()\nTrue\n>>> b'1.23'.isdigit()\nFalse\n"
        },
        "parametres": [
            "\tReturn True if all bytes in the sequence are ASCII decimal digits and the sequence is not empty, False otherwise. ASCII decimal digits are those byte values in the sequence b'0123456789'.For example:"
        ],
        "exemple": ">>> b'1234'.isdigit()\nTrue\n>>> b'1.23'.isdigit()\nFalse\n"
    },
    "bytes.islower": {
        "description": {
            "texte": "Return True if there is at least one lowercase ASCII character in the sequence and no uppercase ASCII characters, False otherwise.For example:",
            "code": ">>> b'hello world'.islower()\nTrue\n>>> b'Hello world'.islower()\nFalse\n"
        },
        "parametres": [
            "\tReturn True if there is at least one lowercase ASCII character in the sequence and no uppercase ASCII characters, False otherwise.For example:"
        ],
        "exemple": ">>> b'hello world'.islower()\nTrue\n>>> b'Hello world'.islower()\nFalse\n"
    },
    "bytearray.islower": {
        "description": {
            "texte": "Return True if there is at least one lowercase ASCII character in the sequence and no uppercase ASCII characters, False otherwise.For example:",
            "code": ">>> b'hello world'.islower()\nTrue\n>>> b'Hello world'.islower()\nFalse\n"
        },
        "parametres": [
            "\tReturn True if there is at least one lowercase ASCII character in the sequence and no uppercase ASCII characters, False otherwise.For example:"
        ],
        "exemple": ">>> b'hello world'.islower()\nTrue\n>>> b'Hello world'.islower()\nFalse\n"
    },
    "bytes.istitle": {
        "description": {
            "texte": "Return True if the sequence is ASCII titlecase and the sequence is not empty, False otherwise. See bytes.title() for more details on the definition of \u201ctitlecase\u201d.For example:",
            "code": ">>> b'Hello World'.istitle()\nTrue\n>>> b'Hello world'.istitle()\nFalse\n"
        },
        "parametres": [
            "\tReturn True if the sequence is ASCII titlecase and the sequence is not empty, False otherwise. See bytes.title() for more details on the definition of \u201ctitlecase\u201d.For example:"
        ],
        "exemple": ">>> b'Hello World'.istitle()\nTrue\n>>> b'Hello world'.istitle()\nFalse\n"
    },
    "bytearray.istitle": {
        "description": {
            "texte": "Return True if the sequence is ASCII titlecase and the sequence is not empty, False otherwise. See bytes.title() for more details on the definition of \u201ctitlecase\u201d.For example:",
            "code": ">>> b'Hello World'.istitle()\nTrue\n>>> b'Hello world'.istitle()\nFalse\n"
        },
        "parametres": [
            "\tReturn True if the sequence is ASCII titlecase and the sequence is not empty, False otherwise. See bytes.title() for more details on the definition of \u201ctitlecase\u201d.For example:"
        ],
        "exemple": ">>> b'Hello World'.istitle()\nTrue\n>>> b'Hello world'.istitle()\nFalse\n"
    },
    "bytes.isupper": {
        "description": {
            "texte": "Return True if there is at least one uppercase alphabetic ASCII character in the sequence and no lowercase ASCII characters, False otherwise.For example:",
            "code": ">>> b'HELLO WORLD'.isupper()\nTrue\n>>> b'Hello world'.isupper()\nFalse\n"
        },
        "parametres": [
            "\tReturn True if there is at least one uppercase alphabetic ASCII character in the sequence and no lowercase ASCII characters, False otherwise.For example:"
        ],
        "exemple": ">>> b'HELLO WORLD'.isupper()\nTrue\n>>> b'Hello world'.isupper()\nFalse\n"
    },
    "bytearray.isupper": {
        "description": {
            "texte": "Return True if there is at least one uppercase alphabetic ASCII character in the sequence and no lowercase ASCII characters, False otherwise.For example:",
            "code": ">>> b'HELLO WORLD'.isupper()\nTrue\n>>> b'Hello world'.isupper()\nFalse\n"
        },
        "parametres": [
            "\tReturn True if there is at least one uppercase alphabetic ASCII character in the sequence and no lowercase ASCII characters, False otherwise.For example:"
        ],
        "exemple": ">>> b'HELLO WORLD'.isupper()\nTrue\n>>> b'Hello world'.isupper()\nFalse\n"
    },
    "bytes.lower": {
        "description": {
            "texte": "Return a copy of the sequence with all the uppercase ASCII characters converted to their corresponding lowercase counterpart.For example:",
            "code": ">>> b'Hello World'.lower()\nb'hello world'\n"
        },
        "parametres": [
            "\tReturn a copy of the sequence with all the uppercase ASCII characters converted to their corresponding lowercase counterpart.For example:"
        ],
        "exemple": ">>> b'Hello World'.lower()\nb'hello world'\n"
    },
    "bytearray.lower": {
        "description": {
            "texte": "Return a copy of the sequence with all the uppercase ASCII characters converted to their corresponding lowercase counterpart.For example:",
            "code": ">>> b'Hello World'.lower()\nb'hello world'\n"
        },
        "parametres": [
            "\tReturn a copy of the sequence with all the uppercase ASCII characters converted to their corresponding lowercase counterpart.For example:"
        ],
        "exemple": ">>> b'Hello World'.lower()\nb'hello world'\n"
    },
    "bytes.splitlines": {
        "description": {
            "texte": "Return a list of the lines in the binary sequence, breaking at ASCII line boundaries. This method uses the universal newlines approach to splitting lines. Line breaks are not included in the resulting list unless keepends is given and true.For example:",
            "code": ">>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n[b'ab c', b'', b'de fg', b'kl']\n>>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n[b'ab c\\n', b'\\n', b'de fg\\r', b'kl\\r\\n']\n"
        },
        "parametres": [
            "keepends=False\t"
        ],
        "exemple": ">>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n[b'ab c', b'', b'de fg', b'kl']\n>>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n[b'ab c\\n', b'\\n', b'de fg\\r', b'kl\\r\\n']\n"
    },
    "bytearray.splitlines": {
        "description": {
            "texte": "Return a list of the lines in the binary sequence, breaking at ASCII line boundaries. This method uses the universal newlines approach to splitting lines. Line breaks are not included in the resulting list unless keepends is given and true.For example:",
            "code": ">>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n[b'ab c', b'', b'de fg', b'kl']\n>>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n[b'ab c\\n', b'\\n', b'de fg\\r', b'kl\\r\\n']\n"
        },
        "parametres": [
            "keepends=False\t"
        ],
        "exemple": ">>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n[b'ab c', b'', b'de fg', b'kl']\n>>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n[b'ab c\\n', b'\\n', b'de fg\\r', b'kl\\r\\n']\n"
    },
    "bytes.swapcase": {
        "description": {
            "texte": "Return a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart and vice-versa.For example:",
            "code": ">>> b'Hello World'.swapcase()\nb'hELLO wORLD'\n"
        },
        "parametres": [
            "\tReturn a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart and vice-versa.For example:"
        ],
        "exemple": ">>> b'Hello World'.swapcase()\nb'hELLO wORLD'\n"
    },
    "bytearray.swapcase": {
        "description": {
            "texte": "Return a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart and vice-versa.For example:",
            "code": ">>> b'Hello World'.swapcase()\nb'hELLO wORLD'\n"
        },
        "parametres": [
            "\tReturn a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart and vice-versa.For example:"
        ],
        "exemple": ">>> b'Hello World'.swapcase()\nb'hELLO wORLD'\n"
    },
    "bytes.title": {
        "description": {
            "texte": "Return a titlecased version of the binary sequence where words start with an uppercase ASCII character and the remaining characters are lowercase. Uncased byte values are left unmodified.For example:",
            "code": ">>> b'Hello world'.title()\nb'Hello World'\n"
        },
        "parametres": [
            "\tReturn a titlecased version of the binary sequence where words start with an uppercase ASCII character and the remaining characters are lowercase. Uncased byte values are left unmodified.For example:"
        ],
        "exemple": ">>> b'Hello world'.title()\nb'Hello World'\n"
    },
    "bytearray.title": {
        "description": {
            "texte": "Return a titlecased version of the binary sequence where words start with an uppercase ASCII character and the remaining characters are lowercase. Uncased byte values are left unmodified.For example:",
            "code": ">>> b'Hello world'.title()\nb'Hello World'\n"
        },
        "parametres": [
            "\tReturn a titlecased version of the binary sequence where words start with an uppercase ASCII character and the remaining characters are lowercase. Uncased byte values are left unmodified.For example:"
        ],
        "exemple": ">>> b'Hello world'.title()\nb'Hello World'\n"
    },
    "bytes.upper": {
        "description": {
            "texte": "Return a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart.For example:",
            "code": ">>> b'Hello World'.upper()\nb'HELLO WORLD'\n"
        },
        "parametres": [
            "\tReturn a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart.For example:"
        ],
        "exemple": ">>> b'Hello World'.upper()\nb'HELLO WORLD'\n"
    },
    "bytearray.upper": {
        "description": {
            "texte": "Return a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart.For example:",
            "code": ">>> b'Hello World'.upper()\nb'HELLO WORLD'\n"
        },
        "parametres": [
            "\tReturn a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart.For example:"
        ],
        "exemple": ">>> b'Hello World'.upper()\nb'HELLO WORLD'\n"
    },
    "bytes.zfill": {
        "description": {
            "texte": "Return a copy of the sequence left filled with ASCII b'0' digits to make a sequence of length width. A leading sign prefix (b'+'/ b'-') is handled by inserting the padding after the sign character rather than before. For bytes objects, the original sequence is returned if width is less than or equal to len(seq).For example:",
            "code": ">>> b\"42\".zfill(5)\nb'00042'\n>>> b\"-42\".zfill(5)\nb'-0042'\n"
        },
        "parametres": [
            "width\tReturn a copy of the sequence left filled with ASCII b'0' digits to make a sequence of length width. For bytes objects, the original sequence is returned if width is less than or equal to len(seq)"
        ],
        "exemple": ">>> b\"42\".zfill(5)\nb'00042'\n>>> b\"-42\".zfill(5)\nb'-0042'\n"
    },
    "bytearray.zfill": {
        "description": {
            "texte": "Return a copy of the sequence left filled with ASCII b'0' digits to make a sequence of length width. A leading sign prefix (b'+'/ b'-') is handled by inserting the padding after the sign character rather than before. For bytes objects, the original sequence is returned if width is less than or equal to len(seq).For example:",
            "code": ">>> b\"42\".zfill(5)\nb'00042'\n>>> b\"-42\".zfill(5)\nb'-0042'\n"
        },
        "parametres": [
            "width\tReturn a copy of the sequence left filled with ASCII b'0' digits to make a sequence of length width. For bytes objects, the original sequence is returned if width is less than or equal to len(seq)"
        ],
        "exemple": ">>> b\"42\".zfill(5)\nb'00042'\n>>> b\"-42\".zfill(5)\nb'-0042'\n"
    },
    "memoryview": {
        "description": {
            "texte": "Create a memoryview that references obj. obj must support the buffer protocol. Built-in objects that support the buffer protocol include bytes and bytearray.A memoryview has the notion of an element, which is the atomic memory unit handled by the originating object obj. For many simple types such as bytes and bytearray, an element is a single byte, but other types such as array.array may have bigger elements.A memoryview supports slicing and indexing to expose its data. One-dimensional slicing will result in a subview:",
            "code": ">>> v = memoryview(b'abcefg')\n>>> v[1]\n98\n>>> v[-1]\n103\n>>> v[1:4]\n<memory at 0x7f3ddc9f4350>\n>>> bytes(v[1:4])\nb'bce'\n"
        },
        "parametres": [
            "obj\tCreate a memoryview that references obj. obj must support the buffer protocol. Built-in objects that support the buffer protocol include bytes and bytearray.A memoryview has the notion of an element, which is the atomic memory unit handled by the originating object obj"
        ],
        "exemple": ">>> v = memoryview(b'abcefg')\n>>> v[1]\n98\n>>> v[-1]\n103\n>>> v[1:4]\n<memory at 0x7f3ddc9f4350>\n>>> bytes(v[1:4])\nb'bce'\n"
    },
    "memoryview.__eq__": {
        "description": {
            "texte": "A memoryview and a PEP 3118 exporter are equal if their shapes are equivalent and if all corresponding values are equal when the operands\u2019 respective format codes are interpreted using struct syntax.For the subset of struct format strings currently supported by tolist(), v and w are equal if v.tolist() == w.tolist():",
            "code": ">>> import array\n>>> a = array.array('I', [1, 2, 3, 4, 5])\n>>> b = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0])\n>>> c = array.array('b', [5, 3, 1])\n>>> x = memoryview(a)\n>>> y = memoryview(b)\n>>> x == a == y == b\nTrue\n>>> x.tolist() == a.tolist() == y.tolist() == b.tolist()\nTrue\n>>> z = y[::-2]\n>>> z == c\nTrue\n>>> z.tolist() == c.tolist()\nTrue\n"
        },
        "parametres": [
            "exporter\tA memoryview and a PEP 3118 exporter are equal if their shapes are equivalent and if all corresponding values are equal when the operands\u2019 respective format codes are interpreted using struct syntax"
        ],
        "exemple": ">>> import array\n>>> a = array.array('I', [1, 2, 3, 4, 5])\n>>> b = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0])\n>>> c = array.array('b', [5, 3, 1])\n>>> x = memoryview(a)\n>>> y = memoryview(b)\n>>> x == a == y == b\nTrue\n>>> x.tolist() == a.tolist() == y.tolist() == b.tolist()\nTrue\n>>> z = y[::-2]\n>>> z == c\nTrue\n>>> z.tolist() == c.tolist()\nTrue\n"
    },
    "memoryview.release": {
        "description": {
            "texte": "Release the underlying buffer exposed by the memoryview object. Many objects take special actions when a view is held on them (for example, a bytearray would temporarily forbid resizing); therefore, calling release() is handy to remove these restrictions (and free any dangling resources) as soon as possible.After this method has been called, any further operation on the view raises a ValueError (except release() itself which can be called multiple times):",
            "code": ">>> m = memoryview(b'abc')\n>>> m.release()\n>>> m[0]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: operation forbidden on released memoryview object\n"
        },
        "parametres": [
            "\tRelease the underlying buffer exposed by the memoryview object. Many objects take special actions when a view is held on them (for example, a bytearray would temporarily forbid resizing); therefore, calling release() is handy to remove these restrictions (and free any dangling resources) as soon as possible.After this method has been called, any further operation on the view raises a ValueError (except release() itself which can be called multiple times):"
        ],
        "exemple": ">>> m = memoryview(b'abc')\n>>> m.release()\n>>> m[0]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: operation forbidden on released memoryview object\n"
    },
    "dict": {
        "description": {
            "texte": "Return a new dictionary initialized from an optional positional argument and a possibly empty set of keyword arguments.Dictionaries can be created by several means:If no positional argument is given, an empty dictionary is created. If a positional argument is given and it is a mapping object, a dictionary is created with the same key-value pairs as the mapping object. Otherwise, the positional argument must be an iterable object. Each item in the iterable must itself be an iterable with exactly two objects. The first object of each item becomes a key in the new dictionary, and the second object the corresponding value. If a key occurs more than once, the last value for that key becomes the corresponding value in the new dictionary.To illustrate, the following examples all return a dictionary equal to {\"one\": 1, \"two\": 2, \"three\": 3}:",
            "code": ">>> a = dict(one=1, two=2, three=3)\n>>> b = {'one': 1, 'two': 2, 'three': 3}\n>>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))\n>>> d = dict([('two', 2), ('one', 1), ('three', 3)])\n>>> e = dict({'three': 3, 'one': 1, 'two': 2})\n>>> f = dict({'one': 1, 'three': 3}, two=2)\n>>> a == b == c == d == e == f\nTrue\n"
        },
        "parametres": [
            "**kwarg\t"
        ],
        "exemple": ">>> a = dict(one=1, two=2, three=3)\n>>> b = {'one': 1, 'two': 2, 'three': 3}\n>>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))\n>>> d = dict([('two', 2), ('one', 1), ('three', 3)])\n>>> e = dict({'three': 3, 'one': 1, 'two': 2})\n>>> f = dict({'one': 1, 'three': 3}, two=2)\n>>> a == b == c == d == e == f\nTrue\n"
    },
    "dict.values": {
        "description": {
            "texte": "Return a new view of the dictionary\u2019s values. See the documentation of view objects.An equality comparison between one dict.values() view and another will always return False. This also applies when comparing dict.values() to itself:",
            "code": ">>> d = {'a': 1}\n>>> d.values() == d.values()\nFalse\n"
        },
        "parametres": [
            "\tReturn a new view of the dictionary\u2019s values. See the documentation of view objects.An equality comparison between one dict.values() view and another will always return False. This also applies when comparing dict.values() to itself:"
        ],
        "exemple": ">>> d = {'a': 1}\n>>> d.values() == d.values()\nFalse\n"
    },
    "re.split": {
        "description": {
            "texte": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list.Empty matches for the pattern split the string only when not adjacent to a previous empty match.",
            "code": ">>> re.split(r'\\b', 'Words, words, words.')\n['', 'Words', ', ', 'words', ', ', 'words', '.']\n>>> re.split(r'\\W*', '...words...')\n['', '', 'w', 'o', 'r', 'd', 's', '', '']\n>>> re.split(r'(\\W*)', '...words...')\n['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', '']\n"
        },
        "parametres": [
            "pattern\tSplit string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list.Empty matches for the pattern split the string only when not adjacent to a previous empty match",
            " string\tSplit string by the occurrences of pattern. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list.Empty matches for the pattern split the string only when not adjacent to a previous empty match",
            " maxsplit=0\t",
            " flags=0\t"
        ],
        "exemple": ">>> re.split(r'\\W+', 'Words, words, words.')\n['Words', 'words', 'words', '']\n>>> re.split(r'(\\W+)', 'Words, words, words.')\n['Words', ', ', 'words', ', ', 'words', '.', '']\n>>> re.split(r'\\W+', 'Words, words, words.', 1)\n['Words', 'words, words.']\n>>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE)\n['0', '3', '9']\n"
    },
    "re.pattern.match": {
        "description": {
            "texte": "If zero or more characters at the beginning of string match this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match.The optional pos and endpos parameters have the same meaning as for the search() method.",
            "code": ">>> pattern = re.compile(\"o\")\n>>> pattern.match(\"dog\")      # No match as \"o\" is not at the start of \"dog\".\n>>> pattern.match(\"dog\", 1)   # Match as \"o\" is the 2nd character of \"dog\".\n<re.Match object; span=(1, 2), match='o'>\n"
        },
        "parametres": [
            "string[\t",
            " pos[\t",
            " endpos]]\t"
        ],
        "exemple": ">>> pattern = re.compile(\"o\")\n>>> pattern.match(\"dog\")      # No match as \"o\" is not at the start of \"dog\".\n>>> pattern.match(\"dog\", 1)   # Match as \"o\" is the 2nd character of \"dog\".\n<re.Match object; span=(1, 2), match='o'>\n"
    },
    "re.pattern.fullmatch": {
        "description": {
            "texte": "If the whole string matches this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match.The optional pos and endpos parameters have the same meaning as for the search() method.",
            "code": ">>> pattern = re.compile(\"o[gh]\")\n>>> pattern.fullmatch(\"dog\")      # No match as \"o\" is not at the start of \"dog\".\n>>> pattern.fullmatch(\"ogre\")     # No match as not the full string matches.\n>>> pattern.fullmatch(\"doggie\", 1, 3)   # Matches within given limits.\n<re.Match object; span=(1, 3), match='og'>\n"
        },
        "parametres": [
            "string[\t",
            " pos[\t",
            " endpos]]\t"
        ],
        "exemple": ">>> pattern = re.compile(\"o[gh]\")\n>>> pattern.fullmatch(\"dog\")      # No match as \"o\" is not at the start of \"dog\".\n>>> pattern.fullmatch(\"ogre\")     # No match as not the full string matches.\n>>> pattern.fullmatch(\"doggie\", 1, 3)   # Matches within given limits.\n<re.Match object; span=(1, 3), match='og'>\n"
    },
    "re.match.group": {
        "description": {
            "texte": "Returns one or more subgroups of the match. If there is a single argument, the result is a single string; if there are multiple arguments, the result is a tuple with one item per argument. Without arguments, group1 defaults to zero (the whole match is returned). If a groupN argument is zero, the corresponding return value is the entire matching string; if it is in the inclusive range [1..99], it is the string matching the corresponding parenthesized group. If a group number is negative or larger than the number of groups defined in the pattern, an IndexError exception is raised. If a group is contained in a part of the pattern that did not match, the corresponding result is None. If a group is contained in a part of the pattern that matched multiple times, the last match is returned.A moderately complicated example:",
            "code": ">>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Malcolm Reynolds\")\n>>> m.group('first_name')\n'Malcolm'\n>>> m.group('last_name')\n'Reynolds'\n"
        },
        "parametres": [
            "[group1\t",
            " ...]\t"
        ],
        "exemple": ">>> m = re.match(r\"(\\w+) (\\w+)\", \"Isaac Newton, physicist\")\n>>> m.group(0)       # The entire match\n'Isaac Newton'\n>>> m.group(1)       # The first parenthesized subgroup.\n'Isaac'\n>>> m.group(2)       # The second parenthesized subgroup.\n'Newton'\n>>> m.group(1, 2)    # Multiple arguments give us a tuple.\n('Isaac', 'Newton')\n"
    },
    "re.match.groups": {
        "description": {
            "texte": "Return a tuple containing all the subgroups of the match, from 1 up to however many groups are in the pattern. The default argument is used for groups that did not participate in the match; it defaults to None.For example:",
            "code": ">>> m = re.match(r\"(\\d+)\\.(\\d+)\", \"24.1632\")\n>>> m.groups()\n('24', '1632')\n"
        },
        "parametres": [
            "default=None\t"
        ],
        "exemple": ">>> m = re.match(r\"(\\d+)\\.(\\d+)\", \"24.1632\")\n>>> m.groups()\n('24', '1632')\n"
    },
    "re.match.start": {
        "description": {
            "texte": "Return the indices of the start and end of the substring matched by group; group defaults to zero (meaning the whole matched substring). Return -1 if group exists but did not contribute to the match. For a match object m, and a group g that did contribute to the match, the substring matched by group g (equivalent to m.group(g)) isAn example that will remove remove_this from email addresses:",
            "code": ">>> email = \"tony@tiremove_thisger.net\"\n>>> m = re.search(\"remove_this\", email)\n>>> email[:m.start()] + email[m.end():]\n'tony@tiger.net'\n"
        },
        "parametres": [
            "[group]\t"
        ],
        "exemple": "m.string[m.start(g):m.end(g)]\n"
    },
    "re.match.end": {
        "description": {
            "texte": "Return the indices of the start and end of the substring matched by group; group defaults to zero (meaning the whole matched substring). Return -1 if group exists but did not contribute to the match. For a match object m, and a group g that did contribute to the match, the substring matched by group g (equivalent to m.group(g)) isAn example that will remove remove_this from email addresses:",
            "code": ">>> email = \"tony@tiremove_thisger.net\"\n>>> m = re.search(\"remove_this\", email)\n>>> email[:m.start()] + email[m.end():]\n'tony@tiger.net'\n"
        },
        "parametres": [
            "[group]\t"
        ],
        "exemple": "m.string[m.start(g):m.end(g)]\n"
    },
    "difflib.get_close_matches": {
        "description": {
            "texte": "Return a list of the best \u201cgood enough\u201d matches. word is a sequence for which close matches are desired (typically a string), and possibilities is a list of sequences against which to match word (typically a list of strings).Optional argument n (default 3) is the maximum number of close matches to return; n must be greater than 0.The best (no more than n) matches among the possibilities are returned in a list, sorted by similarity score, most similar first.",
            "code": ">>> get_close_matches('appel', ['ape', 'apple', 'peach', 'puppy'])\n['apple', 'ape']\n>>> import keyword\n>>> get_close_matches('wheel', keyword.kwlist)\n['while']\n>>> get_close_matches('pineapple', keyword.kwlist)\n[]\n>>> get_close_matches('accept', keyword.kwlist)\n['except']\n"
        },
        "parametres": [
            "word\t word is a sequence for which close matches are desired (typically a string), and possibilities is a list of sequences against which to match word (typically a list of strings)",
            " possibilities\t word is a sequence for which close matches are desired (typically a string), and possibilities is a list of sequences against which to match word (typically a list of strings).The best (no more than n) matches among the possibilities are returned in a list, sorted by similarity score, most similar first",
            " n=3\t",
            " cutoff=0.6\t"
        ],
        "exemple": ">>> get_close_matches('appel', ['ape', 'apple', 'peach', 'puppy'])\n['apple', 'ape']\n>>> import keyword\n>>> get_close_matches('wheel', keyword.kwlist)\n['while']\n>>> get_close_matches('pineapple', keyword.kwlist)\n[]\n>>> get_close_matches('accept', keyword.kwlist)\n['except']\n"
    },
    "difflib.sequencematcher.find_longest_match": {
        "description": {
            "texte": "Find longest matching block in a[alo:ahi] and b[blo:bhi].If isjunk was omitted or None, find_longest_match() returns (i, j, k) such that a[i:i+k] is equal to b[j:j+k], where alo\n<= i <= i+k <= ahi and blo <= j <= j+k <= bhi. For all (i', j',\nk') meeting those conditions, the additional conditions k >= k', i\n<= i', and if i == i', j <= j' are also met. In other words, of all maximal matching blocks, return one that starts earliest in a, and of all those maximal matching blocks that start earliest in a, return the one that starts earliest in b.",
            "code": ">>> s = SequenceMatcher(None, \" abcd\", \"abcd abcd\")\n>>> s.find_longest_match(0, 5, 0, 9)\nMatch(a=0, b=4, size=5)\n"
        },
        "parametres": [
            "alo=0\t",
            " ahi=None\t",
            " blo=0\t",
            " bhi=None\t"
        ],
        "exemple": ">>> s = SequenceMatcher(None, \" abcd\", \"abcd abcd\")\n>>> s.find_longest_match(0, 5, 0, 9)\nMatch(a=0, b=4, size=5)\n"
    },
    "difflib.sequencematcher.get_matching_blocks": {
        "description": {
            "texte": "Return list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j.The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks.",
            "code": ">>> s = SequenceMatcher(None, \"abxcd\", \"abcd\")\n>>> s.get_matching_blocks()\n[Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]\n"
        },
        "parametres": [
            "\tReturn list of triples describing non-overlapping matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j.The last triple is a dummy, and has the value (len(a), len(b), 0). It is the only triple with n == 0. If (i, j, n) and (i', j', n') are adjacent triples in the list, and the second is not the last triple in the list, then i+n < i' or j+n < j'; in other words, adjacent triples always describe non-adjacent equal blocks."
        ],
        "exemple": ">>> s = SequenceMatcher(None, \"abxcd\", \"abcd\")\n>>> s.get_matching_blocks()\n[Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]\n"
    },
    "difflib.sequencematcher.get_opcodes": {
        "description": {
            "texte": "Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 ==\n0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2.The tag values are strings, with these meanings:For example:",
            "code": ">>> a = \"qabxcd\"\n>>> b = \"abycdf\"\n>>> s = SequenceMatcher(None, a, b)\n>>> for tag, i1, i2, j1, j2 in s.get_opcodes():\n...     print('{:7}   a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format(\n...         tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2]))\ndelete    a[0:1] --> b[0:0]      'q' --> ''\nequal     a[1:3] --> b[0:2]     'ab' --> 'ab'\nreplace   a[3:4] --> b[2:3]      'x' --> 'y'\nequal     a[4:6] --> b[3:5]     'cd' --> 'cd'\ninsert    a[6:6] --> b[5:6]       '' --> 'f'\n"
        },
        "parametres": [
            "\tReturn list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 ==\n0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2.The tag values are strings, with these meanings:For example:"
        ],
        "exemple": ">>> a = \"qabxcd\"\n>>> b = \"abycdf\"\n>>> s = SequenceMatcher(None, a, b)\n>>> for tag, i1, i2, j1, j2 in s.get_opcodes():\n...     print('{:7}   a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format(\n...         tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2]))\ndelete    a[0:1] --> b[0:0]      'q' --> ''\nequal     a[1:3] --> b[0:2]     'ab' --> 'ab'\nreplace   a[3:4] --> b[2:3]      'x' --> 'y'\nequal     a[4:6] --> b[3:5]     'cd' --> 'cd'\ninsert    a[6:6] --> b[5:6]       '' --> 'f'\n"
    },
    "textwrap.shorten": {
        "description": {
            "texte": "Collapse and truncate the given text to fit in the given width.First the whitespace in text is collapsed (all whitespace is replaced by single spaces). If the result fits in the width, it is returned. Otherwise, enough words are dropped from the end so that the remaining words plus the placeholder fit within width:",
            "code": ">>> textwrap.shorten(\"Hello  world!\", width=12)\n'Hello world!'\n>>> textwrap.shorten(\"Hello  world!\", width=11)\n'Hello [...]'\n>>> textwrap.shorten(\"Hello world\", width=10, placeholder=\"...\")\n'Hello...'\n"
        },
        "parametres": [
            "text\tCollapse and truncate the given text to fit in the given width.First the whitespace in text is collapsed (all whitespace is replaced by single spaces)",
            " width\tCollapse and truncate the given text to fit in the given width. If the result fits in the width, it is returned. Otherwise, enough words are dropped from the end so that the remaining words plus the placeholder fit within width:",
            " **kwargs\t"
        ],
        "exemple": ">>> textwrap.shorten(\"Hello  world!\", width=12)\n'Hello world!'\n>>> textwrap.shorten(\"Hello  world!\", width=11)\n'Hello [...]'\n>>> textwrap.shorten(\"Hello world\", width=10, placeholder=\"...\")\n'Hello...'\n"
    },
    "textwrap.indent": {
        "description": {
            "texte": "Add prefix to the beginning of selected lines in text.Lines are separated by calling text.splitlines(True).For example:",
            "code": ">>> s = 'hello\\n\\n \\nworld'\n>>> indent(s, '  ')\n'  hello\\n\\n \\n  world'\n"
        },
        "parametres": [
            "text\tAdd prefix to the beginning of selected lines in text.Lines are separated by calling text",
            " prefix\tAdd prefix to the beginning of selected lines in text",
            " predicate=None\t"
        ],
        "exemple": ">>> s = 'hello\\n\\n \\nworld'\n>>> indent(s, '  ')\n'  hello\\n\\n \\n  world'\n"
    },
    "datetime.timedelta": {
        "description": {
            "texte": "All arguments are optional and default to 0. Arguments may be integers or floats, and may be positive or negative.Only days, seconds and microseconds are stored internally. Arguments are converted to those units:and days, seconds and microseconds are then normalized so that the representation is unique, withThe following example illustrates how any arguments besides days, seconds and microseconds are \u201cmerged\u201d and normalized into those three resulting attributes:",
            "code": ">>> from datetime import timedelta\n>>> delta = timedelta(\n...     days=50,\n...     seconds=27,\n...     microseconds=10,\n...     milliseconds=29000,\n...     minutes=5,\n...     hours=8,\n...     weeks=2\n... )\n>>> # Only days, seconds, and microseconds remain\n>>> delta\ndatetime.timedelta(days=64, seconds=29156, microseconds=10)\n"
        },
        "parametres": [
            "days=0\t",
            " seconds=0\t",
            " microseconds=0\t",
            " milliseconds=0\t",
            " minutes=0\t",
            " hours=0\t",
            " weeks=0\t"
        ],
        "exemple": ">>> from datetime import timedelta\n>>> delta = timedelta(\n...     days=50,\n...     seconds=27,\n...     microseconds=10,\n...     milliseconds=29000,\n...     minutes=5,\n...     hours=8,\n...     weeks=2\n... )\n>>> # Only days, seconds, and microseconds remain\n>>> delta\ndatetime.timedelta(days=64, seconds=29156, microseconds=10)\n"
    },
    "datetime.date.replace": {
        "description": {
            "texte": "Return a date with the same value, except for those parameters given new values by whichever keyword arguments are specified.Example:",
            "code": ">>> from datetime import date\n>>> d = date(2002, 12, 31)\n>>> d.replace(day=26)\ndatetime.date(2002, 12, 26)\n"
        },
        "parametres": [
            "year=self.year\t",
            " month=self.month\t",
            " day=self.day\t"
        ],
        "exemple": ">>> from datetime import date\n>>> d = date(2002, 12, 31)\n>>> d.replace(day=26)\ndatetime.date(2002, 12, 26)\n"
    },
    "datetime.date.isocalendar": {
        "description": {
            "texte": "Return a named tuple object with three components: year, week and weekday.The ISO calendar is a widely used variant of the Gregorian calendar. 3For example, 2004 begins on a Thursday, so the first week of ISO year 2004 begins on Monday, 29 Dec 2003 and ends on Sunday, 4 Jan 2004:",
            "code": ">>> from datetime import date\n>>> date(2003, 12, 29).isocalendar()\ndatetime.IsoCalendarDate(year=2004, week=1, weekday=1)\n>>> date(2004, 1, 4).isocalendar()\ndatetime.IsoCalendarDate(year=2004, week=1, weekday=7)\n"
        },
        "parametres": [
            "\tReturn a named tuple object with three components: year, week and weekday.The ISO calendar is a widely used variant of the Gregorian calendar. 3For example, 2004 begins on a Thursday, so the first week of ISO year 2004 begins on Monday, 29 Dec 2003 and ends on Sunday, 4 Jan 2004:"
        ],
        "exemple": ">>> from datetime import date\n>>> date(2003, 12, 29).isocalendar()\ndatetime.IsoCalendarDate(year=2004, week=1, weekday=1)\n>>> date(2004, 1, 4).isocalendar()\ndatetime.IsoCalendarDate(year=2004, week=1, weekday=7)\n"
    },
    "datetime.datetime.today": {
        "description": {
            "texte": "Return the current local datetime, with tzinfo None.Equivalent to:",
            "code": "datetime.fromtimestamp(time.time())\n"
        },
        "parametres": [
            "\tReturn the current local datetime, with tzinfo None.Equivalent to:"
        ],
        "exemple": "datetime.fromtimestamp(time.time())\n"
    },
    "datetime.datetime.fromisoformat": {
        "description": {
            "texte": "Return a datetime corresponding to a date_string in one of the formats emitted by date.isoformat() and datetime.isoformat().Specifically, this function supports strings in the format:",
            "code": "YYYY-MM-DD[*HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]]\n"
        },
        "parametres": [
            "date_string\tReturn a datetime corresponding to a date_string in one of the formats emitted by date"
        ],
        "exemple": "YYYY-MM-DD[*HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]]\n"
    },
    "datetime.datetime.strptime": {
        "description": {
            "texte": "Return a datetime corresponding to date_string, parsed according to format.This is equivalent to:",
            "code": "datetime(*(time.strptime(date_string, format)[0:6]))\n"
        },
        "parametres": [
            "date_string\tReturn a datetime corresponding to date_string, parsed according to format",
            " format\tReturn a datetime corresponding to date_string, parsed according to format"
        ],
        "exemple": "datetime(*(time.strptime(date_string, format)[0:6]))\n"
    },
    "datetime.datetime.astimezone": {
        "description": {
            "texte": "Return a datetime object with new tzinfo attribute tz, adjusting the date and time data so the result is the same UTC time as self, but in tz\u2019s local time.If provided, tz must be an instance of a tzinfo subclass, and its utcoffset() and dst() methods must not return None. If self is naive, it is presumed to represent time in the system timezone.If self.tzinfo is tz, self.astimezone(tz) is equal to self: no adjustment of date or time data is performed. Else the result is local time in the timezone tz, representing the same UTC time as self: after astz = dt.astimezone(tz), astz - astz.utcoffset() will have the same date and time data as dt - dt.utcoffset().Note that the default tzinfo.fromutc() method can be overridden in a tzinfo subclass to affect the result returned by astimezone(). Ignoring error cases, astimezone() acts like:",
            "code": "def astimezone(self, tz):\n    if self.tzinfo is tz:\n        return self\n    # Convert self to UTC, and attach the new time zone object.\n    utc = (self - self.utcoffset()).replace(tzinfo=tz)\n    # Convert from UTC to tz's local time.\n    return tz.fromutc(utc)\n"
        },
        "parametres": [
            "tz=None\t"
        ],
        "exemple": "def astimezone(self, tz):\n    if self.tzinfo is tz:\n        return self\n    # Convert self to UTC, and attach the new time zone object.\n    utc = (self - self.utcoffset()).replace(tzinfo=tz)\n    # Convert from UTC to tz's local time.\n    return tz.fromutc(utc)\n"
    },
    "datetime.datetime.timetuple": {
        "description": {
            "texte": "Return a time.struct_time such as returned by time.localtime().d.timetuple() is equivalent to:",
            "code": "time.struct_time((d.year, d.month, d.day,\n                  d.hour, d.minute, d.second,\n                  d.weekday(), yday, dst))\n"
        },
        "parametres": [
            "\tReturn a time.struct_time such as returned by time.localtime().d.timetuple() is equivalent to:"
        ],
        "exemple": "time.struct_time((d.year, d.month, d.day,\n                  d.hour, d.minute, d.second,\n                  d.weekday(), yday, dst))\n"
    },
    "datetime.datetime.isoformat": {
        "description": {
            "texte": "Return a string representing the date and time in ISO 8601 format:ValueError will be raised on an invalid timespec argument:",
            "code": ">>> from datetime import datetime\n>>> datetime.now().isoformat(timespec='minutes')   \n'2002-12-25T00:00'\n>>> dt = datetime(2015, 1, 1, 12, 30, 59, 0)\n>>> dt.isoformat(timespec='microseconds')\n'2015-01-01T12:30:59.000000'\n"
        },
        "parametres": [
            "sep='T'\t",
            " timespec='auto'\t"
        ],
        "exemple": ">>> from datetime import datetime, timezone\n>>> datetime(2019, 5, 18, 15, 17, 8, 132263).isoformat()\n'2019-05-18T15:17:08.132263'\n>>> datetime(2019, 5, 18, 15, 17, tzinfo=timezone.utc).isoformat()\n'2019-05-18T15:17:00+00:00'\n"
    },
    "datetime.datetime.ctime": {
        "description": {
            "texte": "Return a string representing the date and time:d.ctime() is equivalent to:",
            "code": "time.ctime(time.mktime(d.timetuple()))\n"
        },
        "parametres": [
            "\tReturn a string representing the date and time:d.ctime() is equivalent to:"
        ],
        "exemple": ">>> from datetime import datetime\n>>> datetime(2002, 12, 4, 20, 30, 40).ctime()\n'Wed Dec  4 20:30:40 2002'\n"
    },
    "datetime.time.fromisoformat": {
        "description": {
            "texte": "Return a time corresponding to a time_string in one of the formats emitted by time.isoformat(). Specifically, this function supports strings in the format:Examples:",
            "code": ">>> from datetime import time\n>>> time.fromisoformat('04:23:01')\ndatetime.time(4, 23, 1)\n>>> time.fromisoformat('04:23:01.000384')\ndatetime.time(4, 23, 1, 384)\n>>> time.fromisoformat('04:23:01+04:00')\ndatetime.time(4, 23, 1, tzinfo=datetime.timezone(datetime.timedelta(seconds=14400)))\n"
        },
        "parametres": [
            "time_string\tReturn a time corresponding to a time_string in one of the formats emitted by time"
        ],
        "exemple": "HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]\n"
    },
    "datetime.tzinfo.utcoffset": {
        "description": {
            "texte": "Return offset of local time from UTC, as a timedelta object that is positive east of UTC. If local time is west of UTC, this should be negative.This represents the total offset from UTC; for example, if a tzinfo object represents both time zone and DST adjustments, utcoffset() should return their sum. If the UTC offset isn\u2019t known, return None. Else the value returned must be a timedelta object strictly between -timedelta(hours=24) and timedelta(hours=24) (the magnitude of the offset must be less than one day). Most implementations of utcoffset() will probably look like one of these two:",
            "code": "return CONSTANT                 # fixed-offset class\nreturn CONSTANT + self.dst(dt)  # daylight-aware class\n"
        },
        "parametres": [
            "dt\t"
        ],
        "exemple": "return CONSTANT                 # fixed-offset class\nreturn CONSTANT + self.dst(dt)  # daylight-aware class\n"
    },
    "datetime.tzinfo.dst": {
        "description": {
            "texte": "Return the daylight saving time (DST) adjustment, as a timedelta object or None if DST information isn\u2019t known.Return timedelta(0) if DST is not in effect. If DST is in effect, return the offset as a timedelta object (see utcoffset() for details). Note that DST offset, if applicable, has already been added to the UTC offset returned by utcoffset(), so there\u2019s no need to consult dst() unless you\u2019re interested in obtaining DST info separately. For example, datetime.timetuple() calls its tzinfo attribute\u2019s dst() method to determine how the tm_isdst flag should be set, and tzinfo.fromutc() calls dst() to account for DST changes when crossing time zones.tz.utcoffset(dt) - tz.dst(dt)Most implementations of dst() will probably look like one of these two:",
            "code": "def dst(self, dt):\n    # a fixed-offset class:  doesn't account for DST\n    return timedelta(0)\n"
        },
        "parametres": [
            "dt\tutcoffset(dt) - tz.dst(dt)Most implementations of dst() will probably look like one of these two:"
        ],
        "exemple": "def dst(self, dt):\n    # a fixed-offset class:  doesn't account for DST\n    return timedelta(0)\n"
    },
    "calendar.htmlcalendar": {
        "description": {
            "texte": "This class can be used to generate HTML calendars.HTMLCalendar instances have the following methods:HTMLCalendar has the following attributes you can override to customize the CSS classes used by the calendar:Note that although the naming for the above described class attributes is singular (e.g. cssclass_month cssclass_noday), one can replace the single CSS class with a space separated list of CSS classes, for example:",
            "code": "\"text-bold text-red\"\n"
        },
        "parametres": [
            "firstweekday=0\t"
        ],
        "exemple": "\"text-bold text-red\"\n"
    },
    "collections.counter": {
        "description": {
            "texte": "A Counter is a dict subclass for counting hashable objects. It is a collection where elements are stored as dictionary keys and their counts are stored as dictionary values. Counts are allowed to be any integer value including zero or negative counts. The Counter class is similar to bags or multisets in other languages.Elements are counted from an iterable or initialized from another mapping (or counter):",
            "code": ">>> c = Counter()                           # a new, empty counter\n>>> c = Counter('gallahad')                 # a new counter from an iterable\n>>> c = Counter({'red': 4, 'blue': 2})      # a new counter from a mapping\n>>> c = Counter(cats=4, dogs=8)             # a new counter from keyword args\n"
        },
        "parametres": [
            "[iterable-or-mapping]\t"
        ],
        "exemple": ">>> c = Counter()                           # a new, empty counter\n>>> c = Counter('gallahad')                 # a new counter from an iterable\n>>> c = Counter({'red': 4, 'blue': 2})      # a new counter from a mapping\n>>> c = Counter(cats=4, dogs=8)             # a new counter from keyword args\n"
    },
    "types.genericalias": {
        "description": {
            "texte": "The type of parameterized generics such as list[int].t_origin should be a non-parameterized generic class, such as list, tuple or dict. t_args should be a tuple (possibly of length 1) of types which parameterize t_origin:",
            "code": ">>> from types import GenericAlias\n\n>>> list[int] == GenericAlias(list, (int,))\nTrue\n>>> dict[str, int] == GenericAlias(dict, (str, int))\nTrue\n"
        },
        "parametres": [
            "t_origin\tt_origin should be a non-parameterized generic class, such as list, tuple or dict. t_args should be a tuple (possibly of length 1) of types which parameterize t_origin:",
            " t_args\t t_args should be a tuple (possibly of length 1) of types which parameterize t_origin:"
        ],
        "exemple": ">>> from types import GenericAlias\n\n>>> list[int] == GenericAlias(list, (int,))\nTrue\n>>> dict[str, int] == GenericAlias(dict, (str, int))\nTrue\n"
    },
    "graphlib.topologicalsorter": {
        "description": {
            "texte": "Provides functionality to topologically sort a graph of hashable nodes.A topological order is a linear ordering of the vertices in a graph such that for every directed edge u -> v from vertex u to vertex v, vertex u comes before vertex v in the ordering. For instance, the vertices of the graph may represent tasks to be performed, and the edges may represent constraints that one task must be performed before another; in this example, a topological ordering is just a valid sequence for the tasks. A complete topological ordering is possible if and only if the graph has no directed cycles, that is, if it is a directed acyclic graph.In the general case, the steps required to perform the sorting of a given graph are as follows:In case just an immediate sorting of the nodes in the graph is required and no parallelism is involved, the convenience method TopologicalSorter.static_order() can be used directly:",
            "code": ">>> graph = {\"D\": {\"B\", \"C\"}, \"C\": {\"A\"}, \"B\": {\"A\"}}\n>>> ts = TopologicalSorter(graph)\n>>> tuple(ts.static_order())\n('A', 'C', 'B', 'D')\n"
        },
        "parametres": [
            "graph=None\t"
        ],
        "exemple": ">>> graph = {\"D\": {\"B\", \"C\"}, \"C\": {\"A\"}, \"B\": {\"A\"}}\n>>> ts = TopologicalSorter(graph)\n>>> tuple(ts.static_order())\n('A', 'C', 'B', 'D')\n"
    },
    "graphlib.topologicalsorter.is_active": {
        "description": {
            "texte": "Returns True if more progress can be made and False otherwise. Progress can be made if cycles do not block the resolution and either there are still nodes ready that haven\u2019t yet been returned by TopologicalSorter.get_ready() or the number of nodes marked TopologicalSorter.done() is less than the number that have been returned by TopologicalSorter.get_ready().The __bool__() method of this class defers to this function, so instead of:",
            "code": "if ts.is_active():\n    ...\n"
        },
        "parametres": [
            "\tReturns True if more progress can be made and False otherwise. Progress can be made if cycles do not block the resolution and either there are still nodes ready that haven\u2019t yet been returned by TopologicalSorter.get_ready() or the number of nodes marked TopologicalSorter.done() is less than the number that have been returned by TopologicalSorter.get_ready().The __bool__() method of this class defers to this function, so instead of:"
        ],
        "exemple": "if ts.is_active():\n    ...\n"
    },
    "math.dist": {
        "description": {
            "texte": "Return the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension.Roughly equivalent to:",
            "code": "sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q)))\n"
        },
        "parametres": [
            "p\tReturn the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension",
            " q\tReturn the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates"
        ],
        "exemple": "sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q)))\n"
    },
    "math.erf": {
        "description": {
            "texte": "Return the error function at x.The erf() function can be used to compute traditional statistical functions such as the cumulative standard normal distribution:",
            "code": "def phi(x):\n    'Cumulative distribution function for the standard normal distribution'\n    return (1.0 + erf(x / sqrt(2.0))) / 2.0\n"
        },
        "parametres": [
            "x\tReturn the error function at x"
        ],
        "exemple": "def phi(x):\n    'Cumulative distribution function for the standard normal distribution'\n    return (1.0 + erf(x / sqrt(2.0))) / 2.0\n"
    },
    "decimal.decimal": {
        "description": {
            "texte": "Construct a new Decimal object based from value.value can be an integer, string, tuple, float, or another Decimal object. If no value is given, returns Decimal('0'). If value is a string, it should conform to the decimal numeric string syntax after leading and trailing whitespace characters, as well as underscores throughout, are removed:",
            "code": "sign           ::=  '+' | '-'\ndigit          ::=  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\nindicator      ::=  'e' | 'E'\ndigits         ::=  digit [digit]...\ndecimal-part   ::=  digits '.' [digits] | ['.'] digits\nexponent-part  ::=  indicator [sign] digits\ninfinity       ::=  'Infinity' | 'Inf'\nnan            ::=  'NaN' [digits] | 'sNaN' [digits]\nnumeric-value  ::=  decimal-part [exponent-part] | infinity\nnumeric-string ::=  [sign] numeric-value | [sign] nan\n"
        },
        "parametres": [
            "value=\"0\"\t",
            " context=None\t"
        ],
        "exemple": "sign           ::=  '+' | '-'\ndigit          ::=  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\nindicator      ::=  'e' | 'E'\ndigits         ::=  digit [digit]...\ndecimal-part   ::=  digits '.' [digits] | ['.'] digits\nexponent-part  ::=  indicator [sign] digits\ninfinity       ::=  'Infinity' | 'Inf'\nnan            ::=  'NaN' [digits] | 'sNaN' [digits]\nnumeric-value  ::=  decimal-part [exponent-part] | infinity\nnumeric-string ::=  [sign] numeric-value | [sign] nan\n"
    },
    "decimal.decimal.remainder_near": {
        "description": {
            "texte": "Return the remainder from dividing self by other. This differs from self % other in that the sign of the remainder is chosen so as to minimize its absolute value. More precisely, the return value is self - n * other where n is the integer nearest to the exact value of self / other, and if two integers are equally near then the even one is chosen.If the result is zero then its sign will be the sign of self.",
            "code": ">>> Decimal(18).remainder_near(Decimal(10))\nDecimal('-2')\n>>> Decimal(25).remainder_near(Decimal(10))\nDecimal('5')\n>>> Decimal(35).remainder_near(Decimal(10))\nDecimal('-5')\n"
        },
        "parametres": [
            "other\tReturn the remainder from dividing self by other. This differs from self % other in that the sign of the remainder is chosen so as to minimize its absolute value. More precisely, the return value is self - n * other where n is the integer nearest to the exact value of self / other, and if two integers are equally near then the even one is chosen",
            " context=None\t"
        ],
        "exemple": ">>> Decimal(18).remainder_near(Decimal(10))\nDecimal('-2')\n>>> Decimal(25).remainder_near(Decimal(10))\nDecimal('5')\n>>> Decimal(35).remainder_near(Decimal(10))\nDecimal('-5')\n"
    },
    "decimal.localcontext": {
        "description": {
            "texte": "Return a context manager that will set the current context for the active thread to a copy of ctx on entry to the with-statement and restore the previous context when exiting the with-statement. If no context is specified, a copy of the current context is used.For example, the following code sets the current decimal precision to 42 places, performs a calculation, and then automatically restores the previous context:",
            "code": "from decimal import localcontext\n\nwith localcontext() as ctx:\n    ctx.prec = 42   # Perform a high precision calculation\n    s = calculate_something()\ns = +s  # Round the final result back to the default precision\n"
        },
        "parametres": [
            "ctx=None\t"
        ],
        "exemple": "from decimal import localcontext\n\nwith localcontext() as ctx:\n    ctx.prec = 42   # Perform a high precision calculation\n    s = calculate_something()\ns = +s  # Round the final result back to the default precision\n"
    },
    "decimal.context.create_decimal": {
        "description": {
            "texte": "Creates a new Decimal instance from num but using self as context. Unlike the Decimal constructor, the context precision, rounding method, flags, and traps are applied to the conversion.This is useful because constants are often given to a greater precision than is needed by the application. Another benefit is that rounding immediately eliminates unintended effects from digits beyond the current precision. In the following example, using unrounded inputs means that adding zero to a sum can change the result:",
            "code": ">>> getcontext().prec = 3\n>>> Decimal('3.4445') + Decimal('1.0023')\nDecimal('4.45')\n>>> Decimal('3.4445') + Decimal(0) + Decimal('1.0023')\nDecimal('4.44')\n"
        },
        "parametres": [
            "num\tCreates a new Decimal instance from num but using self as context"
        ],
        "exemple": ">>> getcontext().prec = 3\n>>> Decimal('3.4445') + Decimal('1.0023')\nDecimal('4.45')\n>>> Decimal('3.4445') + Decimal(0) + Decimal('1.0023')\nDecimal('4.44')\n"
    },
    "random.gammavariate": {
        "description": {
            "texte": "Gamma distribution. (Not the gamma function!) Conditions on the parameters are alpha > 0 and beta > 0.The probability distribution function is:",
            "code": "          x ** (alpha - 1) * math.exp(-x / beta)\npdf(x) =  --------------------------------------\n            math.gamma(alpha) * beta ** alpha\n"
        },
        "parametres": [
            "alpha\t (Not the gamma function!) Conditions on the parameters are alpha > 0 and beta > 0",
            " beta\t (Not the gamma function!) Conditions on the parameters are alpha > 0 and beta > 0"
        ],
        "exemple": "          x ** (alpha - 1) * math.exp(-x / beta)\npdf(x) =  --------------------------------------\n            math.gamma(alpha) * beta ** alpha\n"
    },
    "statistics.mean": {
        "description": {
            "texte": "Return the sample arithmetic mean of data which can be a sequence or iterable.The arithmetic mean is the sum of the data divided by the number of data points. It is commonly called \u201cthe average\u201d, although it is only one of many different mathematical averages. It is a measure of the central location of the data.Some examples of use:",
            "code": ">>> mean([1, 2, 3, 4, 4])\n2.8\n>>> mean([-1.0, 2.5, 3.25, 5.75])\n2.625\n\n>>> from fractions import Fraction as F\n>>> mean([F(3, 7), F(1, 21), F(5, 3), F(1, 3)])\nFraction(13, 21)\n\n>>> from decimal import Decimal as D\n>>> mean([D(\"0.5\"), D(\"0.75\"), D(\"0.625\"), D(\"0.375\")])\nDecimal('0.5625')\n"
        },
        "parametres": [
            "data\tReturn the sample arithmetic mean of data which can be a sequence or iterable.The arithmetic mean is the sum of the data divided by the number of data points. It is a measure of the central location of the data"
        ],
        "exemple": ">>> mean([1, 2, 3, 4, 4])\n2.8\n>>> mean([-1.0, 2.5, 3.25, 5.75])\n2.625\n\n>>> from fractions import Fraction as F\n>>> mean([F(3, 7), F(1, 21), F(5, 3), F(1, 3)])\nFraction(13, 21)\n\n>>> from decimal import Decimal as D\n>>> mean([D(\"0.5\"), D(\"0.75\"), D(\"0.625\"), D(\"0.375\")])\nDecimal('0.5625')\n"
    },
    "statistics.fmean": {
        "description": {
            "texte": "Convert data to floats and compute the arithmetic mean.This runs faster than the mean() function and it always returns a float. The data may be a sequence or iterable. If the input dataset is empty, raises a StatisticsError.",
            "code": ">>> fmean([3.5, 4.0, 5.25])\n4.25\n"
        },
        "parametres": [
            "data\tConvert data to floats and compute the arithmetic mean. The data may be a sequence or iterable. If the input dataset is empty, raises a StatisticsError"
        ],
        "exemple": ">>> fmean([3.5, 4.0, 5.25])\n4.25\n"
    },
    "statistics.geometric_mean": {
        "description": {
            "texte": "Convert data to floats and compute the geometric mean.The geometric mean indicates the central tendency or typical value of the data using the product of the values (as opposed to the arithmetic mean which uses their sum).No special efforts are made to achieve exact results. (However, this may change in the future.)",
            "code": ">>> round(geometric_mean([54, 24, 36]), 1)\n36.0\n"
        },
        "parametres": [
            "data\tConvert data to floats and compute the geometric mean.The geometric mean indicates the central tendency or typical value of the data using the product of the values (as opposed to the arithmetic mean which uses their sum)"
        ],
        "exemple": ">>> round(geometric_mean([54, 24, 36]), 1)\n36.0\n"
    },
    "statistics.harmonic_mean": {
        "description": {
            "texte": "Return the harmonic mean of data, a sequence or iterable of real-valued numbers.The harmonic mean, sometimes called the subcontrary mean, is the reciprocal of the arithmetic mean() of the reciprocals of the data. For example, the harmonic mean of three values a, b and c will be equivalent to 3/(1/a + 1/b + 1/c). If one of the values is zero, the result will be zero.Suppose a car travels 10 km at 40 km/hr, then another 10 km at 60 km/hr. What is the average speed?",
            "code": ">>> harmonic_mean([40, 60])\n48.0\n"
        },
        "parametres": [
            "data\tReturn the harmonic mean of data, a sequence or iterable of real-valued numbers.The harmonic mean, sometimes called the subcontrary mean, is the reciprocal of the arithmetic mean() of the reciprocals of the data"
        ],
        "exemple": ">>> harmonic_mean([40, 60])\n48.0\n"
    },
    "statistics.median": {
        "description": {
            "texte": "Return the median (middle value) of numeric data, using the common \u201cmean of middle two\u201d method. If data is empty, StatisticsError is raised. data can be a sequence or iterable.The median is a robust measure of central location and is less affected by the presence of outliers. When the number of data points is odd, the middle data point is returned:",
            "code": ">>> median([1, 3, 5])\n3\n"
        },
        "parametres": [
            "data\tReturn the median (middle value) of numeric data, using the common \u201cmean of middle two\u201d method. If data is empty, StatisticsError is raised. data can be a sequence or iterable. When the number of data points is odd, the middle data point is returned:"
        ],
        "exemple": ">>> median([1, 3, 5])\n3\n"
    },
    "statistics.median_low": {
        "description": {
            "texte": "Return the low median of numeric data. If data is empty, StatisticsError is raised. data can be a sequence or iterable.The low median is always a member of the data set. When the number of data points is odd, the middle value is returned. When it is even, the smaller of the two middle values is returned.",
            "code": ">>> median_low([1, 3, 5])\n3\n>>> median_low([1, 3, 5, 7])\n3\n"
        },
        "parametres": [
            "data\tReturn the low median of numeric data. If data is empty, StatisticsError is raised. data can be a sequence or iterable.The low median is always a member of the data set. When the number of data points is odd, the middle value is returned"
        ],
        "exemple": ">>> median_low([1, 3, 5])\n3\n>>> median_low([1, 3, 5, 7])\n3\n"
    },
    "statistics.median_high": {
        "description": {
            "texte": "Return the high median of data. If data is empty, StatisticsError is raised. data can be a sequence or iterable.The high median is always a member of the data set. When the number of data points is odd, the middle value is returned. When it is even, the larger of the two middle values is returned.",
            "code": ">>> median_high([1, 3, 5])\n3\n>>> median_high([1, 3, 5, 7])\n5\n"
        },
        "parametres": [
            "data\tReturn the high median of data. If data is empty, StatisticsError is raised. data can be a sequence or iterable.The high median is always a member of the data set. When the number of data points is odd, the middle value is returned"
        ],
        "exemple": ">>> median_high([1, 3, 5])\n3\n>>> median_high([1, 3, 5, 7])\n5\n"
    },
    "statistics.variance": {
        "description": {
            "texte": "Return the sample variance of data, an iterable of at least two real-valued numbers. Variance, or second moment about the mean, is a measure of the variability (spread or dispersion) of data. A large variance indicates that the data is spread out; a small variance indicates it is clustered closely around the mean.If the optional second argument xbar is given, it should be the mean of data. If it is missing or None (the default), the mean is automatically calculated.Raises StatisticsError if data has fewer than two values.Decimal and Fraction values are supported:",
            "code": ">>> from decimal import Decimal as D\n>>> variance([D(\"27.5\"), D(\"30.25\"), D(\"30.25\"), D(\"34.5\"), D(\"41.75\")])\nDecimal('31.01875')\n\n>>> from fractions import Fraction as F\n>>> variance([F(1, 6), F(1, 2), F(5, 3)])\nFraction(67, 108)\n"
        },
        "parametres": [
            "data\tReturn the sample variance of data, an iterable of at least two real-valued numbers. Variance, or second moment about the mean, is a measure of the variability (spread or dispersion) of data. A large variance indicates that the data is spread out; a small variance indicates it is clustered closely around the mean.If the optional second argument xbar is given, it should be the mean of data.Raises StatisticsError if data has fewer than two values",
            " xbar=None\t"
        ],
        "exemple": ">>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]\n>>> variance(data)\n1.3720238095238095\n"
    },
    "statistics.normaldist": {
        "description": {
            "texte": "Returns a new NormalDist object where mu represents the arithmetic mean and sigma represents the standard deviation.If sigma is negative, raises StatisticsError.Instances of NormalDist support addition, subtraction, multiplication and division by a constant. These operations are used for translation and scaling. For example:",
            "code": ">>> temperature_february = NormalDist(5, 2.5)             # Celsius\n>>> temperature_february * (9/5) + 32                     # Fahrenheit\nNormalDist(mu=41.0, sigma=4.5)\n"
        },
        "parametres": [
            "mu=0.0\t",
            " sigma=1.0\t"
        ],
        "exemple": ">>> temperature_february = NormalDist(5, 2.5)             # Celsius\n>>> temperature_february * (9/5) + 32                     # Fahrenheit\nNormalDist(mu=41.0, sigma=4.5)\n"
    },
    "itertools.accumulate": {
        "description": {
            "texte": "Make an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument).If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func. (For example, with the default operation of addition, elements may be any addable type including Decimal or Fraction.)Roughly equivalent to:",
            "code": "def accumulate(iterable, func=operator.add, *, initial=None):\n    'Return running totals'\n    # accumulate([1,2,3,4,5]) --> 1 3 6 10 15\n    # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115\n    # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120\n    it = iter(iterable)\n    total = initial\n    if initial is None:\n        try:\n            total = next(it)\n        except StopIteration:\n            return\n    yield total\n    for element in it:\n        total = func(total, element)\n        yield total\n"
        },
        "parametres": [
            "iterable[\t",
            " func\tMake an iterator that returns accumulated sums, or accumulated results of other binary functions (specified via the optional func argument).If func is supplied, it should be a function of two arguments. Elements of the input iterable may be any type that can be accepted as arguments to func",
            " *\t",
            " initial=None]\t"
        ],
        "exemple": "def accumulate(iterable, func=operator.add, *, initial=None):\n    'Return running totals'\n    # accumulate([1,2,3,4,5]) --> 1 3 6 10 15\n    # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115\n    # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120\n    it = iter(iterable)\n    total = initial\n    if initial is None:\n        try:\n            total = next(it)\n        except StopIteration:\n            return\n    yield total\n    for element in it:\n        total = func(total, element)\n        yield total\n"
    },
    "itertools.combinations": {
        "description": {
            "texte": "Return r length subsequences of elements from the input iterable.The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order.Roughly equivalent to:",
            "code": "def combinations(iterable, r):\n    # combinations('ABCD', 2) --> AB AC AD BC BD CD\n    # combinations(range(4), 3) --> 012 013 023 123\n    pool = tuple(iterable)\n    n = len(pool)\n    if r > n:\n        return\n    indices = list(range(r))\n    yield tuple(pool[i] for i in indices)\n    while True:\n        for i in reversed(range(r)):\n            if indices[i] != i + n - r:\n                break\n        else:\n            return\n        indices[i] += 1\n        for j in range(i+1, r):\n            indices[j] = indices[j-1] + 1\n        yield tuple(pool[i] for i in indices)\n"
        },
        "parametres": [
            "iterable\tReturn r length subsequences of elements from the input iterable.The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order",
            " r\tReturn r length subsequences of elements from the input iterable"
        ],
        "exemple": "def combinations(iterable, r):\n    # combinations('ABCD', 2) --> AB AC AD BC BD CD\n    # combinations(range(4), 3) --> 012 013 023 123\n    pool = tuple(iterable)\n    n = len(pool)\n    if r > n:\n        return\n    indices = list(range(r))\n    yield tuple(pool[i] for i in indices)\n    while True:\n        for i in reversed(range(r)):\n            if indices[i] != i + n - r:\n                break\n        else:\n            return\n        indices[i] += 1\n        for j in range(i+1, r):\n            indices[j] = indices[j-1] + 1\n        yield tuple(pool[i] for i in indices)\n"
    },
    "itertools.combinations_with_replacement": {
        "description": {
            "texte": "Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once.The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order.Roughly equivalent to:",
            "code": "def combinations_with_replacement(iterable, r):\n    # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC\n    pool = tuple(iterable)\n    n = len(pool)\n    if not n and r:\n        return\n    indices = [0] * r\n    yield tuple(pool[i] for i in indices)\n    while True:\n        for i in reversed(range(r)):\n            if indices[i] != n - 1:\n                break\n        else:\n            return\n        indices[i:] = [indices[i] + 1] * (r - i)\n        yield tuple(pool[i] for i in indices)\n"
        },
        "parametres": [
            "iterable\tReturn r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once.The combination tuples are emitted in lexicographic ordering according to the order of the input iterable. So, if the input iterable is sorted, the combination tuples will be produced in sorted order",
            " r\tReturn r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once"
        ],
        "exemple": "def combinations_with_replacement(iterable, r):\n    # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC\n    pool = tuple(iterable)\n    n = len(pool)\n    if not n and r:\n        return\n    indices = [0] * r\n    yield tuple(pool[i] for i in indices)\n    while True:\n        for i in reversed(range(r)):\n            if indices[i] != n - 1:\n                break\n        else:\n            return\n        indices[i:] = [indices[i] + 1] * (r - i)\n        yield tuple(pool[i] for i in indices)\n"
    },
    "itertools.repeat": {
        "description": {
            "texte": "Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for invariant parameters to the called function. Also used with zip() to create an invariant part of a tuple record.Roughly equivalent to:",
            "code": "def repeat(object, times=None):\n    # repeat(10, 3) --> 10 10 10\n    if times is None:\n        while True:\n            yield object\n    else:\n        for i in range(times):\n            yield object\n"
        },
        "parametres": [
            "object[\t",
            " times]\t"
        ],
        "exemple": "def repeat(object, times=None):\n    # repeat(10, 3) --> 10 10 10\n    if times is None:\n        while True:\n            yield object\n    else:\n        for i in range(times):\n            yield object\n"
    },
    "functools.cached_property": {
        "description": {
            "texte": "Transform a method of a class into a property whose value is computed once and then cached as a normal attribute for the life of the instance. Similar to property(), with the addition of caching. Useful for expensive computed properties of instances that are otherwise effectively immutable.Example:",
            "code": "class DataSet:\n    def __init__(self, sequence_of_numbers):\n        self._data = sequence_of_numbers\n\n    @cached_property\n    def stdev(self):\n        return statistics.stdev(self._data)\n\n    @cached_property\n    def variance(self):\n        return statistics.variance(self._data)\n"
        },
        "parametres": [
            "func\t"
        ],
        "exemple": "class DataSet:\n    def __init__(self, sequence_of_numbers):\n        self._data = sequence_of_numbers\n\n    @cached_property\n    def stdev(self):\n        return statistics.stdev(self._data)\n\n    @cached_property\n    def variance(self):\n        return statistics.variance(self._data)\n"
    },
    "functools.lru_cache": {
        "description": {
            "texte": "Decorator to wrap a function with a memoizing callable that saves up to the maxsize most recent calls. It can save time when an expensive or I/O bound function is periodically called with the same arguments.Since a dictionary is used to cache results, the positional and keyword arguments to the function must be hashable.If user_function is specified, it must be a callable. This allows the lru_cache decorator to be applied directly to a user function, leaving the maxsize at its default value of 128:",
            "code": "@lru_cache\ndef count_vowels(sentence):\n    sentence = sentence.casefold()\n    return sum(sentence.count(vowel) for vowel in 'aeiou')\n"
        },
        "parametres": [
            "user_function\tIf user_function is specified, it must be a callable"
        ],
        "exemple": "@lru_cache\ndef count_vowels(sentence):\n    sentence = sentence.casefold()\n    return sum(sentence.count(vowel) for vowel in 'aeiou')\n"
    },
    "functools.reduce": {
        "description": {
            "texte": "Apply function of two arguments cumulatively to the items of iterable, from left to right, so as to reduce the iterable to a single value. For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates ((((1+2)+3)+4)+5). The left argument, x, is the accumulated value and the right argument, y, is the update value from the iterable. If the optional initializer is present, it is placed before the items of the iterable in the calculation, and serves as a default when the iterable is empty. If initializer is not given and iterable contains only one item, the first item is returned.Roughly equivalent to:",
            "code": "def reduce(function, iterable, initializer=None):\n    it = iter(iterable)\n    if initializer is None:\n        value = next(it)\n    else:\n        value = initializer\n    for element in it:\n        value = function(value, element)\n    return value\n"
        },
        "parametres": [
            "function\tApply function of two arguments cumulatively to the items of iterable, from left to right, so as to reduce the iterable to a single value",
            " iterable[\t",
            " initializer]\t"
        ],
        "exemple": "def reduce(function, iterable, initializer=None):\n    it = iter(iterable)\n    if initializer is None:\n        value = next(it)\n    else:\n        value = initializer\n    for element in it:\n        value = function(value, element)\n    return value\n"
    },
    "functools.singledispatchmethod": {
        "description": {
            "texte": "Transform a method into a single-dispatch generic function.To define a generic method, decorate it with the @singledispatchmethod decorator. Note that the dispatch happens on the type of the first non-self or non-cls argument, create your function accordingly:",
            "code": "class Negator:\n    @singledispatchmethod\n    def neg(self, arg):\n        raise NotImplementedError(\"Cannot negate a\")\n\n    @neg.register\n    def _(self, arg: int):\n        return -arg\n\n    @neg.register\n    def _(self, arg: bool):\n        return not arg\n"
        },
        "parametres": [
            "func\tTransform a method into a single-dispatch generic function. Note that the dispatch happens on the type of the first non-self or non-cls argument, create your function accordingly:"
        ],
        "exemple": "class Negator:\n    @singledispatchmethod\n    def neg(self, arg):\n        raise NotImplementedError(\"Cannot negate a\")\n\n    @neg.register\n    def _(self, arg: int):\n        return -arg\n\n    @neg.register\n    def _(self, arg: bool):\n        return not arg\n"
    },
    "operator.itemgetter": {
        "description": {
            "texte": "Return a callable object that fetches item from its operand using the operand\u2019s __getitem__() method. If multiple items are specified, returns a tuple of lookup values. For example:",
            "code": ">>> soldier = dict(rank='captain', name='dotterbart')\n>>> itemgetter('rank')(soldier)\n'captain'\n"
        },
        "parametres": [
            "item\tReturn a callable object that fetches item from its operand using the operand\u2019s __getitem__() method. If multiple items are specified, returns a tuple of lookup values"
        ],
        "exemple": "def itemgetter(*items):\n    if len(items) == 1:\n        item = items[0]\n        def g(obj):\n            return obj[item]\n    else:\n        def g(obj):\n            return tuple(obj[item] for item in items)\n    return g\n"
    },
    "pathlib.purepath.match": {
        "description": {
            "texte": "Match this path against the provided glob-style pattern. Return True if matching is successful, False otherwise.If pattern is relative, the path can be either relative or absolute, and matching is done from the right:",
            "code": ">>> PurePath('a/b.py').match('*.py')\nTrue\n>>> PurePath('/a/b/c.py').match('b/*.py')\nTrue\n>>> PurePath('/a/b/c.py').match('a/*.py')\nFalse\n"
        },
        "parametres": [
            "pattern\tMatch this path against the provided glob-style pattern.If pattern is relative, the path can be either relative or absolute, and matching is done from the right:"
        ],
        "exemple": ">>> PurePath('a/b.py').match('*.py')\nTrue\n>>> PurePath('/a/b/c.py').match('b/*.py')\nTrue\n>>> PurePath('/a/b/c.py').match('a/*.py')\nFalse\n"
    },
    "pathlib.path.samefile": {
        "description": {
            "texte": "Return whether this path points to the same file as other_path, which can be either a Path object, or a string. The semantics are similar to os.path.samefile() and os.path.samestat().An OSError can be raised if either file cannot be accessed for some reason.",
            "code": ">>> p = Path('spam')\n>>> q = Path('eggs')\n>>> p.samefile(q)\nFalse\n>>> p.samefile('spam')\nTrue\n"
        },
        "parametres": [
            "other_path\tReturn whether this path points to the same file as other_path, which can be either a Path object, or a string"
        ],
        "exemple": ">>> p = Path('spam')\n>>> q = Path('eggs')\n>>> p.samefile(q)\nFalse\n>>> p.samefile('spam')\nTrue\n"
    },
    "fileinput.input": {
        "description": {
            "texte": "Create an instance of the FileInput class. The instance will be used as global state for the functions of this module, and is also returned to use during iteration. The parameters to this function will be passed along to the constructor of the FileInput class.The FileInput instance can be used as a context manager in the with statement. In this example, input is closed after the with statement is exited, even if an exception occurs:",
            "code": "with fileinput.input(files=('spam.txt', 'eggs.txt')) as f:\n    for line in f:\n        process(line)\n"
        },
        "parametres": [
            "files=None\t",
            " inplace=False\t",
            " backup=''\t",
            " *\t",
            " mode='r'\t",
            " openhook=None\t"
        ],
        "exemple": "with fileinput.input(files=('spam.txt', 'eggs.txt')) as f:\n    for line in f:\n        process(line)\n"
    },
    "fileinput.fileinput": {
        "description": {
            "texte": "Class FileInput is the implementation; its methods filename(), fileno(), lineno(), filelineno(), isfirstline(), isstdin(), nextfile() and close() correspond to the functions of the same name in the module. In addition it has a readline() method which returns the next input line, and a __getitem__() method which implements the sequence behavior. The sequence must be accessed in strictly sequential order; random access and readline() cannot be mixed.With mode you can specify which file mode will be passed to open(). It must be one of 'r', 'rU', 'U' and 'rb'.A FileInput instance can be used as a context manager in the with statement. In this example, input is closed after the with statement is exited, even if an exception occurs:",
            "code": "with FileInput(files=('spam.txt', 'eggs.txt')) as input:\n    process(input)\n"
        },
        "parametres": [
            "files=None\t",
            " inplace=False\t",
            " backup=''\t",
            " *\t",
            " mode='r'\t",
            " openhook=None\t"
        ],
        "exemple": "with FileInput(files=('spam.txt', 'eggs.txt')) as input:\n    process(input)\n"
    },
    "fnmatch.fnmatch": {
        "description": {
            "texte": "Test whether the filename string matches the pattern string, returning True or False. Both parameters are case-normalized using os.path.normcase(). fnmatchcase() can be used to perform a case-sensitive comparison, regardless of whether that\u2019s standard for the operating system.This example will print all file names in the current directory with the extension .txt:",
            "code": "import fnmatch\nimport os\n\nfor file in os.listdir('.'):\n    if fnmatch.fnmatch(file, '*.txt'):\n        print(file)\n"
        },
        "parametres": [
            "filename\tTest whether the filename string matches the pattern string, returning True or False",
            " pattern\tTest whether the filename string matches the pattern string, returning True or False"
        ],
        "exemple": "import fnmatch\nimport os\n\nfor file in os.listdir('.'):\n    if fnmatch.fnmatch(file, '*.txt'):\n        print(file)\n"
    },
    "fnmatch.translate": {
        "description": {
            "texte": "Return the shell-style pattern converted to a regular expression for using with re.match().Example:",
            "code": ">>> import fnmatch, re\n>>>\n>>> regex = fnmatch.translate('*.txt')\n>>> regex\n'(?s:.*\\\\.txt)\\\\Z'\n>>> reobj = re.compile(regex)\n>>> reobj.match('foobar.txt')\n<re.Match object; span=(0, 10), match='foobar.txt'>\n"
        },
        "parametres": [
            "pattern\tReturn the shell-style pattern converted to a regular expression for using with re"
        ],
        "exemple": ">>> import fnmatch, re\n>>>\n>>> regex = fnmatch.translate('*.txt')\n>>> regex\n'(?s:.*\\\\.txt)\\\\Z'\n>>> reobj = re.compile(regex)\n>>> reobj.match('foobar.txt')\n<re.Match object; span=(0, 10), match='foobar.txt'>\n"
    },
    "shutil.which": {
        "description": {
            "texte": "Return the path to an executable which would be run if the given cmd was called. If no cmd would be called, return None.mode is a permission mask passed to os.access(), by default determining if the file exists and executable.On Windows, the current directory is always prepended to the path whether or not you use the default or provide your own, which is the behavior the command shell uses when finding executables. Additionally, when finding the cmd in the path, the PATHEXT environment variable is checked. For example, if you call shutil.which(\"python\"), which() will search PATHEXT to know that it should look for python.exe within the path directories. For example, on Windows:",
            "code": ">>> shutil.which(\"python\")\n'C:\\\\Python33\\\\python.EXE'\n"
        },
        "parametres": [
            "cmd\tReturn the path to an executable which would be run if the given cmd was called. If no cmd would be called, return None. Additionally, when finding the cmd in the path, the PATHEXT environment variable is checked",
            " mode=os.F_OK | os.X_OK\t",
            " path=None\t"
        ],
        "exemple": ">>> shutil.which(\"python\")\n'C:\\\\Python33\\\\python.EXE'\n"
    },
    "sqlite3.complete_statement": {
        "description": {
            "texte": "Returns True if the string sql contains one or more complete SQL statements terminated by semicolons. It does not verify that the SQL is syntactically correct, only that there are no unclosed string literals and the statement is terminated by a semicolon.This can be used to build a shell for SQLite, as in the following example:",
            "code": "# A minimal SQLite shell for experiments\n\nimport sqlite3\n\ncon = sqlite3.connect(\":memory:\")\ncon.isolation_level = None\ncur = con.cursor()\n\nbuffer = \"\"\n\nprint(\"Enter your SQL commands to execute in sqlite3.\")\nprint(\"Enter a blank line to exit.\")\n\nwhile True:\n    line = input()\n    if line == \"\":\n        break\n    buffer += line\n    if sqlite3.complete_statement(buffer):\n        try:\n            buffer = buffer.strip()\n            cur.execute(buffer)\n\n            if buffer.lstrip().upper().startswith(\"SELECT\"):\n                print(cur.fetchall())\n        except sqlite3.Error as e:\n            print(\"An error occurred:\", e.args[0])\n        buffer = \"\"\n\ncon.close()\n"
        },
        "parametres": [
            "sql\tReturns True if the string sql contains one or more complete SQL statements terminated by semicolons"
        ],
        "exemple": "# A minimal SQLite shell for experiments\n\nimport sqlite3\n\ncon = sqlite3.connect(\":memory:\")\ncon.isolation_level = None\ncur = con.cursor()\n\nbuffer = \"\"\n\nprint(\"Enter your SQL commands to execute in sqlite3.\")\nprint(\"Enter a blank line to exit.\")\n\nwhile True:\n    line = input()\n    if line == \"\":\n        break\n    buffer += line\n    if sqlite3.complete_statement(buffer):\n        try:\n            buffer = buffer.strip()\n            cur.execute(buffer)\n\n            if buffer.lstrip().upper().startswith(\"SELECT\"):\n                print(cur.fetchall())\n        except sqlite3.Error as e:\n            print(\"An error occurred:\", e.args[0])\n        buffer = \"\"\n\ncon.close()\n"
    },
    "sqlite3.connection.create_function": {
        "description": {
            "texte": "Creates a user-defined function that you can later use from within SQL statements under the function name name. num_params is the number of parameters the function accepts (if num_params is -1, the function may take any number of arguments), and func is a Python callable that is called as the SQL function. If deterministic is true, the created function is marked as deterministic, which allows SQLite to perform additional optimizations. This flag is supported by SQLite 3.8.3 or higher, NotSupportedError will be raised if used with older versions.The function can return any of the types supported by SQLite: bytes, str, int, float and None.Example:",
            "code": "import sqlite3\nimport hashlib\n\ndef md5sum(t):\n    return hashlib.md5(t).hexdigest()\n\ncon = sqlite3.connect(\":memory:\")\ncon.create_function(\"md5\", 1, md5sum)\ncur = con.cursor()\ncur.execute(\"select md5(?)\", (b\"foo\",))\nprint(cur.fetchone()[0])\n\ncon.close()\n"
        },
        "parametres": [
            "name\tCreates a user-defined function that you can later use from within SQL statements under the function name name",
            " num_params\t num_params is the number of parameters the function accepts (if num_params is -1, the function may take any number of arguments), and func is a Python callable that is called as the SQL function",
            " func\tCreates a user-defined function that you can later use from within SQL statements under the function name name. num_params is the number of parameters the function accepts (if num_params is -1, the function may take any number of arguments), and func is a Python callable that is called as the SQL function. If deterministic is true, the created function is marked as deterministic, which allows SQLite to perform additional optimizations.The function can return any of the types supported by SQLite: bytes, str, int, float and None",
            " *\t",
            " deterministic=False\t"
        ],
        "exemple": "import sqlite3\nimport hashlib\n\ndef md5sum(t):\n    return hashlib.md5(t).hexdigest()\n\ncon = sqlite3.connect(\":memory:\")\ncon.create_function(\"md5\", 1, md5sum)\ncur = con.cursor()\ncur.execute(\"select md5(?)\", (b\"foo\",))\nprint(cur.fetchone()[0])\n\ncon.close()\n"
    },
    "sqlite3.connection.create_aggregate": {
        "description": {
            "texte": "Creates a user-defined aggregate function.The aggregate class must implement a step method, which accepts the number of parameters num_params (if num_params is -1, the function may take any number of arguments), and a finalize method which will return the final result of the aggregate.Example:",
            "code": "import sqlite3\n\nclass MySum:\n    def __init__(self):\n        self.count = 0\n\n    def step(self, value):\n        self.count += value\n\n    def finalize(self):\n        return self.count\n\ncon = sqlite3.connect(\":memory:\")\ncon.create_aggregate(\"mysum\", 1, MySum)\ncur = con.cursor()\ncur.execute(\"create table test(i)\")\ncur.execute(\"insert into test(i) values (1)\")\ncur.execute(\"insert into test(i) values (2)\")\ncur.execute(\"select mysum(i) from test\")\nprint(cur.fetchone()[0])\n\ncon.close()\n"
        },
        "parametres": [
            "name\t",
            " num_params\tThe aggregate class must implement a step method, which accepts the number of parameters num_params (if num_params is -1, the function may take any number of arguments), and a finalize method which will return the final result of the aggregate",
            " aggregate_class\t"
        ],
        "exemple": "import sqlite3\n\nclass MySum:\n    def __init__(self):\n        self.count = 0\n\n    def step(self, value):\n        self.count += value\n\n    def finalize(self):\n        return self.count\n\ncon = sqlite3.connect(\":memory:\")\ncon.create_aggregate(\"mysum\", 1, MySum)\ncur = con.cursor()\ncur.execute(\"create table test(i)\")\ncur.execute(\"insert into test(i) values (1)\")\ncur.execute(\"insert into test(i) values (2)\")\ncur.execute(\"select mysum(i) from test\")\nprint(cur.fetchone()[0])\n\ncon.close()\n"
    },
    "sqlite3.connection.iterdump": {
        "description": {
            "texte": "Returns an iterator to dump the database in an SQL text format. Useful when saving an in-memory database for later restoration. This function provides the same capabilities as the .dump command in the sqlite3 shell.Example:",
            "code": "# Convert file existing_db.db to SQL dump file dump.sql\nimport sqlite3\n\ncon = sqlite3.connect('existing_db.db')\nwith open('dump.sql', 'w') as f:\n    for line in con.iterdump():\n        f.write('%s\\n' % line)\ncon.close()\n"
        },
        "parametres": [
            "\tReturns an iterator to dump the database in an SQL text format. Useful when saving an in-memory database for later restoration. This function provides the same capabilities as the .dump command in the sqlite3 shell.Example:"
        ],
        "exemple": "# Convert file existing_db.db to SQL dump file dump.sql\nimport sqlite3\n\ncon = sqlite3.connect('existing_db.db')\nwith open('dump.sql', 'w') as f:\n    for line in con.iterdump():\n        f.write('%s\\n' % line)\ncon.close()\n"
    },
    "sqlite3.connection.backup": {
        "description": {
            "texte": "This method makes a backup of a SQLite database even while it\u2019s being accessed by other clients, or concurrently by the same connection. The copy will be written into the mandatory argument target, that must be another Connection instance.By default, or when pages is either 0 or a negative integer, the entire database is copied in a single step; otherwise the method performs a loop copying up to pages pages at a time.The name argument specifies the database name that will be copied: it must be a string containing either \"main\", the default, to indicate the main database, \"temp\" to indicate the temporary database or the name specified after the AS keyword in an ATTACH DATABASE statement for an attached database.Example 1, copy an existing database into another:",
            "code": "import sqlite3\n\ndef progress(status, remaining, total):\n    print(f'Copied {total-remaining} of {total} pages...')\n\ncon = sqlite3.connect('existing_db.db')\nbck = sqlite3.connect('backup.db')\nwith bck:\n    con.backup(bck, pages=1, progress=progress)\nbck.close()\ncon.close()\n"
        },
        "parametres": [
            "target\t The copy will be written into the mandatory argument target, that must be another Connection instance",
            " *\t",
            " pages=0\t",
            " progress=None\t",
            " name=\"main\"\t",
            " sleep=0.250\t"
        ],
        "exemple": "import sqlite3\n\ndef progress(status, remaining, total):\n    print(f'Copied {total-remaining} of {total} pages...')\n\ncon = sqlite3.connect('existing_db.db')\nbck = sqlite3.connect('backup.db')\nwith bck:\n    con.backup(bck, pages=1, progress=progress)\nbck.close()\ncon.close()\n"
    },
    "sqlite3.cursor.execute": {
        "description": {
            "texte": "Executes an SQL statement. The SQL statement may be parameterized (i. e. placeholders instead of SQL literals). The sqlite3 module supports two kinds of placeholders: question marks (qmark style) and named placeholders (named style).Here\u2019s an example of both styles:",
            "code": "import sqlite3\n\ncon = sqlite3.connect(\":memory:\")\ncur = con.cursor()\ncur.execute(\"create table people (name_last, age)\")\n\nwho = \"Yeltsin\"\nage = 72\n\n# This is the qmark style:\ncur.execute(\"insert into people values (?, ?)\", (who, age))\n\n# And this is the named style:\ncur.execute(\"select * from people where name_last=:who and age=:age\", {\"who\": who, \"age\": age})\n\nprint(cur.fetchone())\n\ncon.close()\n"
        },
        "parametres": [
            "sql[\t",
            " parameters]\t"
        ],
        "exemple": "import sqlite3\n\ncon = sqlite3.connect(\":memory:\")\ncur = con.cursor()\ncur.execute(\"create table people (name_last, age)\")\n\nwho = \"Yeltsin\"\nage = 72\n\n# This is the qmark style:\ncur.execute(\"insert into people values (?, ?)\", (who, age))\n\n# And this is the named style:\ncur.execute(\"select * from people where name_last=:who and age=:age\", {\"who\": who, \"age\": age})\n\nprint(cur.fetchone())\n\ncon.close()\n"
    },
    "zipfile.zipfile": {
        "description": {
            "texte": "Open a ZIP file, where file can be a path to a file (a string), a file-like object or a path-like object.The mode parameter should be 'r' to read an existing file, 'w' to truncate and write a new file, 'a' to append to an existing file, or 'x' to exclusively create and write a new file. If mode is 'x' and file refers to an existing file, a FileExistsError will be raised. If mode is 'a' and file refers to an existing ZIP file, then additional files are added to it. If file does not refer to a ZIP file, then a new ZIP archive is appended to the file. This is meant for adding a ZIP archive to another file (such as python.exe). If mode is 'a' and the file does not exist at all, it is created. If mode is 'r' or 'a', the file should be seekable.If allowZip64 is True (the default) zipfile will create ZIP files that use the ZIP64 extensions when the zipfile is larger than 4 GiB. If it is false zipfile will raise an exception when the ZIP file would require ZIP64 extensions.The strict_timestamps argument, when set to False, allows to zip files older than 1980-01-01 at the cost of setting the timestamp to 1980-01-01. Similar behavior occurs with files newer than 2107-12-31, the timestamp is also set to the limit.ZipFile is also a context manager and therefore supports the with statement. In the example, myzip is closed after the with statement\u2019s suite is finished\u2014even if an exception occurs:",
            "code": "with ZipFile('spam.zip', 'w') as myzip:\n    myzip.write('eggs.txt')\n"
        },
        "parametres": [
            "file\tOpen a ZIP file, where file can be a path to a file (a string), a file-like object or a path-like object.The mode parameter should be 'r' to read an existing file, 'w' to truncate and write a new file, 'a' to append to an existing file, or 'x' to exclusively create and write a new file. If mode is 'x' and file refers to an existing file, a FileExistsError will be raised. If mode is 'a' and file refers to an existing ZIP file, then additional files are added to it. If file does not refer to a ZIP file, then a new ZIP archive is appended to the file. This is meant for adding a ZIP archive to another file (such as python. If mode is 'a' and the file does not exist at all, it is created. If mode is 'r' or 'a', the file should be seekable.If allowZip64 is True (the default) zipfile will create ZIP files that use the ZIP64 extensions when the zipfile is larger than 4 GiB. If it is false zipfile will raise an exception when the ZIP file would require ZIP64 extensions.The strict_timestamps argument, when set to False, allows to zip files older than 1980-01-01 at the cost of setting the timestamp to 1980-01-01. Similar behavior occurs with files newer than 2107-12-31, the timestamp is also set to the limit",
            " mode='r'\t",
            " compression=ZIP_STORED\t",
            " allowZip64=True\t",
            " compresslevel=None\t",
            " *\t",
            " strict_timestamps=True\t"
        ],
        "exemple": "with ZipFile('spam.zip', 'w') as myzip:\n    myzip.write('eggs.txt')\n"
    },
    "zipfile.zipfile.open": {
        "description": {
            "texte": "Access a member of the archive as a binary file-like object. name can be either the name of a file within the archive or a ZipInfo object. The mode parameter, if included, must be 'r' (the default) or 'w'. pwd is the password used to decrypt encrypted ZIP files.open() is also a context manager and therefore supports the with statement:",
            "code": "with ZipFile('spam.zip') as myzip:\n    with myzip.open('eggs.txt') as myfile:\n        print(myfile.read())\n"
        },
        "parametres": [
            "name\t name can be either the name of a file within the archive or a ZipInfo object",
            " mode='r'\t",
            " pwd=None\t",
            " *\t",
            " force_zip64=False\t"
        ],
        "exemple": "with ZipFile('spam.zip') as myzip:\n    with myzip.open('eggs.txt') as myfile:\n        print(myfile.read())\n"
    },
    "zipfile.pyzipfile.writepy": {
        "description": {
            "texte": "Search for files *.py and add the corresponding file to the archive.If the optimize parameter to PyZipFile was not given or -1, the corresponding file is a *.pyc file, compiling if necessary.If pathname is a file, the filename must end with .py, and just the (corresponding *.pyc) file is added at the top level (no path information). If pathname is a file that does not end with .py, a RuntimeError will be raised. If it is a directory, and the directory is not a package directory, then all the files *.pyc are added at the top level. If the directory is a package directory, then all *.pyc are added under the package name as a file path, and if any subdirectories are package directories, all of these are added recursively in sorted order.filterfunc, if given, must be a function taking a single string argument. It will be passed each path (including each individual full file path) before it is added to the archive. If filterfunc returns a false value, the path will not be added, and if it is a directory its contents will be ignored. For example, if our test files are all either in test directories or start with the string test_, we can use a filterfunc to exclude them:",
            "code": ">>> zf = PyZipFile('myprog.zip')\n>>> def notests(s):\n...     fn = os.path.basename(s)\n...     return (not (fn == 'test' or fn.startswith('test_')))\n>>> zf.writepy('myprog', filterfunc=notests)\n"
        },
        "parametres": [
            "pathname\tIf pathname is a file, the filename must end with . If pathname is a file that does not end with ",
            " basename=''\t",
            " filterfunc=None\t"
        ],
        "exemple": ">>> zf = PyZipFile('myprog.zip')\n>>> def notests(s):\n...     fn = os.path.basename(s)\n...     return (not (fn == 'test' or fn.startswith('test_')))\n>>> zf.writepy('myprog', filterfunc=notests)\n"
    },
    "csv.writer": {
        "description": {
            "texte": "Return a writer object responsible for converting the user\u2019s data into delimited strings on the given file-like object. csvfile can be any object with a write() method. If csvfile is a file object, it should be opened with newline='' 1. An optional dialect parameter can be given which is used to define a set of parameters specific to a particular CSV dialect. It may be an instance of a subclass of the Dialect class or one of the strings returned by the list_dialects() function. The other optional fmtparams keyword arguments can be given to override individual formatting parameters in the current dialect. For full details about the dialect and formatting parameters, see section Dialects and Formatting Parameters. To make it as easy as possible to interface with modules which implement the DB API, the value None is written as the empty string. While this isn\u2019t a reversible transformation, it makes it easier to dump SQL NULL data values to CSV files without preprocessing the data returned from a cursor.fetch* call. All other non-string data are stringified with str() before being written.A short usage example:",
            "code": "import csv\nwith open('eggs.csv', 'w', newline='') as csvfile:\n    spamwriter = csv.writer(csvfile, delimiter=' ',\n                            quotechar='|', quoting=csv.QUOTE_MINIMAL)\n    spamwriter.writerow(['Spam'] * 5 + ['Baked Beans'])\n    spamwriter.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam'])\n"
        },
        "parametres": [
            "csvfile\t csvfile can be any object with a write() method. If csvfile is a file object, it should be opened with newline='' 1",
            " dialect='excel'\t",
            " **fmtparams\t"
        ],
        "exemple": "import csv\nwith open('eggs.csv', 'w', newline='') as csvfile:\n    spamwriter = csv.writer(csvfile, delimiter=' ',\n                            quotechar='|', quoting=csv.QUOTE_MINIMAL)\n    spamwriter.writerow(['Spam'] * 5 + ['Baked Beans'])\n    spamwriter.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam'])\n"
    },
    "configparser.configparser.optionxform": {
        "description": {
            "texte": "Transforms the option name option as found in an input file or as passed in by client code to the form that should be used in the internal structures. The default implementation returns a lower-case version of option; subclasses may override this or client code can set an attribute of this name on instances to affect this behavior.You don\u2019t need to subclass the parser to use this method, you can also set it on an instance, to a function that takes a string argument and returns a string. Setting it to str, for example, would make option names case sensitive:",
            "code": "cfgparser = ConfigParser()\ncfgparser.optionxform = str\n"
        },
        "parametres": [
            "option\tTransforms the option name option as found in an input file or as passed in by client code to the form that should be used in the internal structures. The default implementation returns a lower-case version of option; subclasses may override this or client code can set an attribute of this name on instances to affect this behavior. Setting it to str, for example, would make option names case sensitive:"
        ],
        "exemple": "cfgparser = ConfigParser()\ncfgparser.optionxform = str\n"
    },
    "xdrlib.packer.pack_list": {
        "description": {
            "texte": "Packs a list of homogeneous items. This method is useful for lists with an indeterminate size; i.e. the size is not available until the entire list has been walked. For each item in the list, an unsigned integer 1 is packed first, followed by the data value from the list. pack_item is the function that is called to pack the individual item. At the end of the list, an unsigned integer 0 is packed.For example, to pack a list of integers, the code might appear like this:",
            "code": "import xdrlib\np = xdrlib.Packer()\np.pack_list([1, 2, 3], p.pack_int)\n"
        },
        "parametres": [
            "list\tPacks a list of homogeneous items. This method is useful for lists with an indeterminate size; i. the size is not available until the entire list has been walked. For each item in the list, an unsigned integer 1 is packed first, followed by the data value from the list. At the end of the list, an unsigned integer 0 is packed.For example, to pack a list of integers, the code might appear like this:",
            " pack_item\t pack_item is the function that is called to pack the individual item"
        ],
        "exemple": "import xdrlib\np = xdrlib.Packer()\np.pack_list([1, 2, 3], p.pack_int)\n"
    },
    "hashlib.pbkdf2_hmac": {
        "description": {
            "texte": "The function provides PKCS#5 password-based key derivation function 2. It uses HMAC as pseudorandom function.The string hash_name is the desired name of the hash digest algorithm for HMAC, e.g. \u2018sha1\u2019 or \u2018sha256\u2019. password and salt are interpreted as buffers of bytes. Applications and libraries should limit password to a sensible length (e.g. 1024). salt should be about 16 or more bytes from a proper source, e.g. os.urandom().dklen is the length of the derived key. If dklen is None then the digest size of the hash algorithm hash_name is used, e.g. 64 for SHA-512.",
            "code": ">>> import hashlib\n>>> dk = hashlib.pbkdf2_hmac('sha256', b'password', b'salt', 100000)\n>>> dk.hex()\n'0394a2ede332c9a13eb82e9b24631604c31df978b4e2f0fbd2c549944f9d79a5'\n"
        },
        "parametres": [
            "hash_name\tThe string hash_name is the desired name of the hash digest algorithm for HMAC, e. If dklen is None then the digest size of the hash algorithm hash_name is used, e",
            " password\tThe function provides PKCS#5 password-based key derivation function 2. password and salt are interpreted as buffers of bytes. Applications and libraries should limit password to a sensible length (e",
            " salt\t password and salt are interpreted as buffers of bytes. salt should be about 16 or more bytes from a proper source, e",
            " iterations\t",
            " dklen=None\t"
        ],
        "exemple": ">>> import hashlib\n>>> dk = hashlib.pbkdf2_hmac('sha256', b'password', b'salt', 100000)\n>>> dk.hex()\n'0394a2ede332c9a13eb82e9b24631604c31df978b4e2f0fbd2c549944f9d79a5'\n"
    },
    "os.scandir": {
        "description": {
            "texte": "Return an iterator of os.DirEntry objects corresponding to the entries in the directory given by path. The entries are yielded in arbitrary order, and the special entries '.' and '..' are not included. If a file is removed from or added to the directory after creating the iterator, whether an entry for that file be included is unspecified.Using scandir() instead of listdir() can significantly increase the performance of code that also needs file type or file attribute information, because os.DirEntry objects expose this information if the operating system provides it when scanning a directory. All os.DirEntry methods may perform a system call, but is_dir() and is_file() usually only require a system call for symbolic links; os.DirEntry.stat() always requires a system call on Unix but only requires one for symbolic links on Windows.This function can also support specifying a file descriptor; the file descriptor must refer to a directory.The scandir() iterator supports the context manager protocol and has the following method:The following example shows a simple use of scandir() to display all the files (excluding directories) in the given path that don\u2019t start with '.'. The entry.is_file() call will generally not make an additional system call:",
            "code": "with os.scandir(path) as it:\n    for entry in it:\n        if not entry.name.startswith('.') and entry.is_file():\n            print(entry.name)\n"
        },
        "parametres": [
            "path='.'\t"
        ],
        "exemple": "with os.scandir(path) as it:\n    for entry in it:\n        if not entry.name.startswith('.') and entry.is_file():\n            print(entry.name)\n"
    },
    "os.spawnl": {
        "description": {
            "texte": "Execute the program path in a new process.(Note that the subprocess module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using these functions. Check especially the Replacing Older Functions with the subprocess Module section.)Note on VxWorks, this function doesn\u2019t return -signal when the new process is killed. Instead it raises OSError exception.The variants which include a second \u201cp\u201d near the end (spawnlp(), spawnlpe(), spawnvp(), and spawnvpe()) will use the PATH environment variable to locate the program file. When the environment is being replaced (using one of the spawn*e variants, discussed in the next paragraph), the new environment is used as the source of the PATH variable. The other variants, spawnl(), spawnle(), spawnv(), and spawnve(), will not use the PATH variable to locate the executable; path must contain an appropriate absolute or relative path.As an example, the following calls to spawnlp() and spawnvpe() are equivalent:",
            "code": "import os\nos.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')\n\nL = ['cp', 'index.html', '/dev/null']\nos.spawnvpe(os.P_WAIT, 'cp', L, os.environ)\n"
        },
        "parametres": [
            "mode\t",
            " path\tExecute the program path in a new process. The other variants, spawnl(), spawnle(), spawnv(), and spawnve(), will not use the PATH variable to locate the executable; path must contain an appropriate absolute or relative path",
            " ...\t"
        ],
        "exemple": "import os\nos.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')\n\nL = ['cp', 'index.html', '/dev/null']\nos.spawnvpe(os.P_WAIT, 'cp', L, os.environ)\n"
    },
    "os.spawnle": {
        "description": {
            "texte": "Execute the program path in a new process.(Note that the subprocess module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using these functions. Check especially the Replacing Older Functions with the subprocess Module section.)Note on VxWorks, this function doesn\u2019t return -signal when the new process is killed. Instead it raises OSError exception.The variants which include a second \u201cp\u201d near the end (spawnlp(), spawnlpe(), spawnvp(), and spawnvpe()) will use the PATH environment variable to locate the program file. When the environment is being replaced (using one of the spawn*e variants, discussed in the next paragraph), the new environment is used as the source of the PATH variable. The other variants, spawnl(), spawnle(), spawnv(), and spawnve(), will not use the PATH variable to locate the executable; path must contain an appropriate absolute or relative path.As an example, the following calls to spawnlp() and spawnvpe() are equivalent:",
            "code": "import os\nos.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')\n\nL = ['cp', 'index.html', '/dev/null']\nos.spawnvpe(os.P_WAIT, 'cp', L, os.environ)\n"
        },
        "parametres": [
            "mode\t",
            " path\tExecute the program path in a new process. The other variants, spawnl(), spawnle(), spawnv(), and spawnve(), will not use the PATH variable to locate the executable; path must contain an appropriate absolute or relative path",
            " ...\t",
            " env\tThe variants which include a second \u201cp\u201d near the end (spawnlp(), spawnlpe(), spawnvp(), and spawnvpe()) will use the PATH environment variable to locate the program file. When the environment is being replaced (using one of the spawn*e variants, discussed in the next paragraph), the new environment is used as the source of the PATH variable"
        ],
        "exemple": "import os\nos.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')\n\nL = ['cp', 'index.html', '/dev/null']\nos.spawnvpe(os.P_WAIT, 'cp', L, os.environ)\n"
    },
    "os.spawnlp": {
        "description": {
            "texte": "Execute the program path in a new process.(Note that the subprocess module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using these functions. Check especially the Replacing Older Functions with the subprocess Module section.)Note on VxWorks, this function doesn\u2019t return -signal when the new process is killed. Instead it raises OSError exception.The variants which include a second \u201cp\u201d near the end (spawnlp(), spawnlpe(), spawnvp(), and spawnvpe()) will use the PATH environment variable to locate the program file. When the environment is being replaced (using one of the spawn*e variants, discussed in the next paragraph), the new environment is used as the source of the PATH variable. The other variants, spawnl(), spawnle(), spawnv(), and spawnve(), will not use the PATH variable to locate the executable; path must contain an appropriate absolute or relative path.As an example, the following calls to spawnlp() and spawnvpe() are equivalent:",
            "code": "import os\nos.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')\n\nL = ['cp', 'index.html', '/dev/null']\nos.spawnvpe(os.P_WAIT, 'cp', L, os.environ)\n"
        },
        "parametres": [
            "mode\t",
            " file\tThe variants which include a second \u201cp\u201d near the end (spawnlp(), spawnlpe(), spawnvp(), and spawnvpe()) will use the PATH environment variable to locate the program file",
            " ...\t"
        ],
        "exemple": "import os\nos.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')\n\nL = ['cp', 'index.html', '/dev/null']\nos.spawnvpe(os.P_WAIT, 'cp', L, os.environ)\n"
    },
    "os.spawnlpe": {
        "description": {
            "texte": "Execute the program path in a new process.(Note that the subprocess module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using these functions. Check especially the Replacing Older Functions with the subprocess Module section.)Note on VxWorks, this function doesn\u2019t return -signal when the new process is killed. Instead it raises OSError exception.The variants which include a second \u201cp\u201d near the end (spawnlp(), spawnlpe(), spawnvp(), and spawnvpe()) will use the PATH environment variable to locate the program file. When the environment is being replaced (using one of the spawn*e variants, discussed in the next paragraph), the new environment is used as the source of the PATH variable. The other variants, spawnl(), spawnle(), spawnv(), and spawnve(), will not use the PATH variable to locate the executable; path must contain an appropriate absolute or relative path.As an example, the following calls to spawnlp() and spawnvpe() are equivalent:",
            "code": "import os\nos.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')\n\nL = ['cp', 'index.html', '/dev/null']\nos.spawnvpe(os.P_WAIT, 'cp', L, os.environ)\n"
        },
        "parametres": [
            "mode\t",
            " file\tThe variants which include a second \u201cp\u201d near the end (spawnlp(), spawnlpe(), spawnvp(), and spawnvpe()) will use the PATH environment variable to locate the program file",
            " ...\t",
            " env\tThe variants which include a second \u201cp\u201d near the end (spawnlp(), spawnlpe(), spawnvp(), and spawnvpe()) will use the PATH environment variable to locate the program file. When the environment is being replaced (using one of the spawn*e variants, discussed in the next paragraph), the new environment is used as the source of the PATH variable"
        ],
        "exemple": "import os\nos.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')\n\nL = ['cp', 'index.html', '/dev/null']\nos.spawnvpe(os.P_WAIT, 'cp', L, os.environ)\n"
    },
    "os.spawnv": {
        "description": {
            "texte": "Execute the program path in a new process.(Note that the subprocess module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using these functions. Check especially the Replacing Older Functions with the subprocess Module section.)Note on VxWorks, this function doesn\u2019t return -signal when the new process is killed. Instead it raises OSError exception.The variants which include a second \u201cp\u201d near the end (spawnlp(), spawnlpe(), spawnvp(), and spawnvpe()) will use the PATH environment variable to locate the program file. When the environment is being replaced (using one of the spawn*e variants, discussed in the next paragraph), the new environment is used as the source of the PATH variable. The other variants, spawnl(), spawnle(), spawnv(), and spawnve(), will not use the PATH variable to locate the executable; path must contain an appropriate absolute or relative path.As an example, the following calls to spawnlp() and spawnvpe() are equivalent:",
            "code": "import os\nos.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')\n\nL = ['cp', 'index.html', '/dev/null']\nos.spawnvpe(os.P_WAIT, 'cp', L, os.environ)\n"
        },
        "parametres": [
            "mode\t",
            " path\tExecute the program path in a new process. The other variants, spawnl(), spawnle(), spawnv(), and spawnve(), will not use the PATH variable to locate the executable; path must contain an appropriate absolute or relative path",
            " args\t"
        ],
        "exemple": "import os\nos.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')\n\nL = ['cp', 'index.html', '/dev/null']\nos.spawnvpe(os.P_WAIT, 'cp', L, os.environ)\n"
    },
    "os.spawnve": {
        "description": {
            "texte": "Execute the program path in a new process.(Note that the subprocess module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using these functions. Check especially the Replacing Older Functions with the subprocess Module section.)Note on VxWorks, this function doesn\u2019t return -signal when the new process is killed. Instead it raises OSError exception.The variants which include a second \u201cp\u201d near the end (spawnlp(), spawnlpe(), spawnvp(), and spawnvpe()) will use the PATH environment variable to locate the program file. When the environment is being replaced (using one of the spawn*e variants, discussed in the next paragraph), the new environment is used as the source of the PATH variable. The other variants, spawnl(), spawnle(), spawnv(), and spawnve(), will not use the PATH variable to locate the executable; path must contain an appropriate absolute or relative path.As an example, the following calls to spawnlp() and spawnvpe() are equivalent:",
            "code": "import os\nos.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')\n\nL = ['cp', 'index.html', '/dev/null']\nos.spawnvpe(os.P_WAIT, 'cp', L, os.environ)\n"
        },
        "parametres": [
            "mode\t",
            " path\tExecute the program path in a new process. The other variants, spawnl(), spawnle(), spawnv(), and spawnve(), will not use the PATH variable to locate the executable; path must contain an appropriate absolute or relative path",
            " args\t",
            " env\tThe variants which include a second \u201cp\u201d near the end (spawnlp(), spawnlpe(), spawnvp(), and spawnvpe()) will use the PATH environment variable to locate the program file. When the environment is being replaced (using one of the spawn*e variants, discussed in the next paragraph), the new environment is used as the source of the PATH variable"
        ],
        "exemple": "import os\nos.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')\n\nL = ['cp', 'index.html', '/dev/null']\nos.spawnvpe(os.P_WAIT, 'cp', L, os.environ)\n"
    },
    "os.spawnvp": {
        "description": {
            "texte": "Execute the program path in a new process.(Note that the subprocess module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using these functions. Check especially the Replacing Older Functions with the subprocess Module section.)Note on VxWorks, this function doesn\u2019t return -signal when the new process is killed. Instead it raises OSError exception.The variants which include a second \u201cp\u201d near the end (spawnlp(), spawnlpe(), spawnvp(), and spawnvpe()) will use the PATH environment variable to locate the program file. When the environment is being replaced (using one of the spawn*e variants, discussed in the next paragraph), the new environment is used as the source of the PATH variable. The other variants, spawnl(), spawnle(), spawnv(), and spawnve(), will not use the PATH variable to locate the executable; path must contain an appropriate absolute or relative path.As an example, the following calls to spawnlp() and spawnvpe() are equivalent:",
            "code": "import os\nos.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')\n\nL = ['cp', 'index.html', '/dev/null']\nos.spawnvpe(os.P_WAIT, 'cp', L, os.environ)\n"
        },
        "parametres": [
            "mode\t",
            " file\tThe variants which include a second \u201cp\u201d near the end (spawnlp(), spawnlpe(), spawnvp(), and spawnvpe()) will use the PATH environment variable to locate the program file",
            " args\t"
        ],
        "exemple": "import os\nos.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')\n\nL = ['cp', 'index.html', '/dev/null']\nos.spawnvpe(os.P_WAIT, 'cp', L, os.environ)\n"
    },
    "os.spawnvpe": {
        "description": {
            "texte": "Execute the program path in a new process.(Note that the subprocess module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using these functions. Check especially the Replacing Older Functions with the subprocess Module section.)Note on VxWorks, this function doesn\u2019t return -signal when the new process is killed. Instead it raises OSError exception.The variants which include a second \u201cp\u201d near the end (spawnlp(), spawnlpe(), spawnvp(), and spawnvpe()) will use the PATH environment variable to locate the program file. When the environment is being replaced (using one of the spawn*e variants, discussed in the next paragraph), the new environment is used as the source of the PATH variable. The other variants, spawnl(), spawnle(), spawnv(), and spawnve(), will not use the PATH variable to locate the executable; path must contain an appropriate absolute or relative path.As an example, the following calls to spawnlp() and spawnvpe() are equivalent:",
            "code": "import os\nos.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')\n\nL = ['cp', 'index.html', '/dev/null']\nos.spawnvpe(os.P_WAIT, 'cp', L, os.environ)\n"
        },
        "parametres": [
            "mode\t",
            " file\tThe variants which include a second \u201cp\u201d near the end (spawnlp(), spawnlpe(), spawnvp(), and spawnvpe()) will use the PATH environment variable to locate the program file",
            " args\t",
            " env\tThe variants which include a second \u201cp\u201d near the end (spawnlp(), spawnlpe(), spawnvp(), and spawnvpe()) will use the PATH environment variable to locate the program file. When the environment is being replaced (using one of the spawn*e variants, discussed in the next paragraph), the new environment is used as the source of the PATH variable"
        ],
        "exemple": "import os\nos.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')\n\nL = ['cp', 'index.html', '/dev/null']\nos.spawnvpe(os.P_WAIT, 'cp', L, os.environ)\n"
    },
    "time.tzset": {
        "description": {
            "texte": "Reset the time conversion rules used by the library routines. The environment variable TZ specifies how this is done. It will also set the variables tzname (from the TZ environment variable), timezone (non-DST seconds West of UTC), altzone (DST seconds west of UTC) and daylight (to 0 if this timezone does not have any daylight saving time rules, or to nonzero if there is a time, past, present or future when daylight saving time applies).Availability: Unix.The standard format of the TZ environment variable is (whitespace added for clarity):",
            "code": "std offset [dst [offset [,start[/time], end[/time]]]]\n"
        },
        "parametres": [
            "\tReset the time conversion rules used by the library routines. The environment variable TZ specifies how this is done. It will also set the variables tzname (from the TZ environment variable), timezone (non-DST seconds West of UTC), altzone (DST seconds west of UTC) and daylight (to 0 if this timezone does not have any daylight saving time rules, or to nonzero if there is a time, past, present or future when daylight saving time applies).Availability: Unix.The standard format of the TZ environment variable is (whitespace added for clarity):"
        ],
        "exemple": "std offset [dst [offset [,start[/time], end[/time]]]]\n"
    },
    "argparse.argumentparser.add_subparsers": {
        "description": {
            "texte": "Many programs split up their functionality into a number of sub-commands, for example, the svn program can invoke sub-commands like svn\ncheckout, svn update, and svn commit. Splitting up functionality this way can be a particularly good idea when a program performs several different functions which require different kinds of command-line arguments. ArgumentParser supports the creation of such sub-commands with the add_subparsers() method. The add_subparsers() method is normally called with no arguments and returns a special action object. This object has a single method, add_parser(), which takes a command name and any ArgumentParser constructor arguments, and returns an ArgumentParser object that can be modified as usual.Description of parameters:Some example usage:",
            "code": ">>> # create the top-level parser\n>>> parser = argparse.ArgumentParser(prog='PROG')\n>>> parser.add_argument('--foo', action='store_true', help='foo help')\n>>> subparsers = parser.add_subparsers(help='sub-command help')\n>>>\n>>> # create the parser for the \"a\" command\n>>> parser_a = subparsers.add_parser('a', help='a help')\n>>> parser_a.add_argument('bar', type=int, help='bar help')\n>>>\n>>> # create the parser for the \"b\" command\n>>> parser_b = subparsers.add_parser('b', help='b help')\n>>> parser_b.add_argument('--baz', choices='XYZ', help='baz help')\n>>>\n>>> # parse some argument lists\n>>> parser.parse_args(['a', '12'])\nNamespace(bar=12, foo=False)\n>>> parser.parse_args(['--foo', 'b', '--baz', 'Z'])\nNamespace(baz='Z', foo=True)\n"
        },
        "parametres": [
            "[title][\t",
            " description][\t",
            " prog][\t",
            " parser_class][\t",
            " action][\t",
            " option_string][\t",
            " dest][\t",
            " required][\t",
            " help][\t",
            " metavar]\t"
        ],
        "exemple": ">>> # create the top-level parser\n>>> parser = argparse.ArgumentParser(prog='PROG')\n>>> parser.add_argument('--foo', action='store_true', help='foo help')\n>>> subparsers = parser.add_subparsers(help='sub-command help')\n>>>\n>>> # create the parser for the \"a\" command\n>>> parser_a = subparsers.add_parser('a', help='a help')\n>>> parser_a.add_argument('bar', type=int, help='bar help')\n>>>\n>>> # create the parser for the \"b\" command\n>>> parser_b = subparsers.add_parser('b', help='b help')\n>>> parser_b.add_argument('--baz', choices='XYZ', help='baz help')\n>>>\n>>> # parse some argument lists\n>>> parser.parse_args(['a', '12'])\nNamespace(bar=12, foo=False)\n>>> parser.parse_args(['--foo', 'b', '--baz', 'Z'])\nNamespace(baz='Z', foo=True)\n"
    },
    "logging.logrecord": {
        "description": {
            "texte": "Contains all the information pertinent to the event being logged.The primary information is passed in msg and args, which are combined using msg % args to create the message field of the record.This functionality can be used to inject your own values into a LogRecord at creation time. You can use the following pattern:",
            "code": "old_factory = logging.getLogRecordFactory()\n\ndef record_factory(*args, **kwargs):\n    record = old_factory(*args, **kwargs)\n    record.custom_attribute = 0xdecafbad\n    return record\n\nlogging.setLogRecordFactory(record_factory)\n"
        },
        "parametres": [
            "name\t",
            " level\t",
            " pathname\t",
            " lineno\t",
            " msg\tThe primary information is passed in msg and args, which are combined using msg % args to create the message field of the record",
            " args\tThe primary information is passed in msg and args, which are combined using msg % args to create the message field of the record",
            " exc_info\t",
            " func=None\t",
            " sinfo=None\t"
        ],
        "exemple": "old_factory = logging.getLogRecordFactory()\n\ndef record_factory(*args, **kwargs):\n    record = old_factory(*args, **kwargs)\n    record.custom_attribute = 0xdecafbad\n    return record\n\nlogging.setLogRecordFactory(record_factory)\n"
    },
    "logging.debug": {
        "description": {
            "texte": "Logs a message with level DEBUG on the root logger. The msg is the message format string, and the args are the arguments which are merged into msg using the string formatting operator. (Note that this means that you can use keywords in the format string, together with a single dictionary argument.)There are three keyword arguments in kwargs which are inspected: exc_info which, if it does not evaluate as false, causes exception information to be added to the logging message. If an exception tuple (in the format returned by sys.exc_info()) or an exception instance is provided, it is used; otherwise, sys.exc_info() is called to get the exception information.You can specify stack_info independently of exc_info, e.g. to just show how you got to a certain point in your code, even when no exceptions were raised. The stack frames are printed following a header line which says:",
            "code": "Stack (most recent call last):\n"
        },
        "parametres": [
            "msg\t The msg is the message format string, and the args are the arguments which are merged into msg using the string formatting operator",
            " *args\t",
            " **kwargs\t"
        ],
        "exemple": "Stack (most recent call last):\n"
    },
    "ctypes.byref": {
        "description": {
            "texte": "Returns a light-weight pointer to obj, which must be an instance of a ctypes type. offset defaults to zero, and must be an integer that will be added to the internal pointer value.byref(obj, offset) corresponds to this C code:",
            "code": "(((char *)&obj) + offset)\n"
        },
        "parametres": [
            "obj[\t",
            " offset]\t"
        ],
        "exemple": "(((char *)&obj) + offset)\n"
    },
    "threading.barrier.wait": {
        "description": {
            "texte": "Pass the barrier. When all the threads party to the barrier have called this function, they are all released simultaneously. If a timeout is provided, it is used in preference to any that was supplied to the class constructor.The return value is an integer in the range 0 to parties \u2013 1, different for each thread. This can be used to select a thread to do some special housekeeping, e.g.:",
            "code": "i = barrier.wait()\nif i == 0:\n    # Only one thread needs to print this\n    print(\"passed the barrier\")\n"
        },
        "parametres": [
            "timeout=None\t"
        ],
        "exemple": "i = barrier.wait()\nif i == 0:\n    # Only one thread needs to print this\n    print(\"passed the barrier\")\n"
    },
    "multiprocessing.freeze_support": {
        "description": {
            "texte": "Add support for when a program which uses multiprocessing has been frozen to produce a Windows executable. (Has been tested with py2exe, PyInstaller and cx_Freeze.)One needs to call this function straight after the if __name__ ==\n'__main__' line of the main module. For example:",
            "code": "from multiprocessing import Process, freeze_support\n\ndef f():\n    print('hello world!')\n\nif __name__ == '__main__':\n    freeze_support()\n    Process(target=f).start()\n"
        },
        "parametres": [
            "\tAdd support for when a program which uses multiprocessing has been frozen to produce a Windows executable. (Has been tested with py2exe, PyInstaller and cx_Freeze.)One needs to call this function straight after the if __name__ ==\n'__main__' line of the main module. For example:"
        ],
        "exemple": "from multiprocessing import Process, freeze_support\n\ndef f():\n    print('hello world!')\n\nif __name__ == '__main__':\n    freeze_support()\n    Process(target=f).start()\n"
    },
    "multiprocessing.value": {
        "description": {
            "texte": "Return a ctypes object allocated from shared memory. By default the return value is actually a synchronized wrapper for the object. The object itself can be accessed via the value attribute of a Value.typecode_or_type determines the type of the returned object: it is either a ctypes type or a one character typecode of the kind used by the array module. *args is passed on to the constructor for the type.Operations like += which involve a read and write are not atomic. So if, for instance, you want to atomically increment a shared value it is insufficient to just do",
            "code": "counter.value += 1\n"
        },
        "parametres": [
            "typecode_or_type\ttypecode_or_type determines the type of the returned object: it is either a ctypes type or a one character typecode of the kind used by the array module",
            " *args\t *args is passed on to the constructor for the type",
            " lock=True\t"
        ],
        "exemple": "counter.value += 1\n"
    },
    "multiprocessing.managers.baseproxy._callmethod": {
        "description": {
            "texte": "Call and return the result of a method of the proxy\u2019s referent.If proxy is a proxy whose referent is obj then the expression",
            "code": "proxy._callmethod(methodname, args, kwds)\n"
        },
        "parametres": [
            "methodname[\t",
            " args[\t",
            " kwds]]\t"
        ],
        "exemple": "proxy._callmethod(methodname, args, kwds)\n"
    },
    "subprocess.call": {
        "description": {
            "texte": "Run the command described by args. Wait for command to complete, then return the returncode attribute.Code needing to capture stdout or stderr should use run() instead:",
            "code": "run(...).returncode\n"
        },
        "parametres": [
            "args\tRun the command described by args",
            " *\t",
            " stdin=None\t",
            " stdout=None\t",
            " stderr=None\t",
            " shell=False\t",
            " cwd=None\t",
            " timeout=None\t",
            " **other_popen_kwargs\t"
        ],
        "exemple": "run(...).returncode\n"
    },
    "subprocess.check_call": {
        "description": {
            "texte": "Run command with arguments. Wait for command to complete. If the return code was zero then return, otherwise raise CalledProcessError. The CalledProcessError object will have the return code in the returncode attribute.Code needing to capture stdout or stderr should use run() instead:",
            "code": "run(..., check=True)\n"
        },
        "parametres": [
            "args\t",
            " *\t",
            " stdin=None\t",
            " stdout=None\t",
            " stderr=None\t",
            " shell=False\t",
            " cwd=None\t",
            " timeout=None\t",
            " **other_popen_kwargs\t"
        ],
        "exemple": "run(..., check=True)\n"
    },
    "subprocess.check_output": {
        "description": {
            "texte": "Run command with arguments and return its output.If the return code was non-zero it raises a CalledProcessError. The CalledProcessError object will have the return code in the returncode attribute and any output in the output attribute.By default, this function will return the data as encoded bytes. The actual encoding of the output data may depend on the command being invoked, so the decoding to text will often need to be handled at the application level.To also capture standard error in the result, use stderr=subprocess.STDOUT:",
            "code": ">>> subprocess.check_output(\n...     \"ls non_existent_file; exit 0\",\n...     stderr=subprocess.STDOUT,\n...     shell=True)\n'ls: non_existent_file: No such file or directory\\n'\n"
        },
        "parametres": [
            "args\t",
            " *\t",
            " stdin=None\t",
            " stderr=None\t",
            " shell=False\t",
            " cwd=None\t",
            " encoding=None\t",
            " errors=None\t",
            " universal_newlines=None\t",
            " timeout=None\t",
            " text=None\t",
            " **other_popen_kwargs\t"
        ],
        "exemple": "run(..., check=True, stdout=PIPE).stdout\n"
    },
    "subprocess.getoutput": {
        "description": {
            "texte": "Return output (stdout and stderr) of executing cmd in a shell.Like getstatusoutput(), except the exit code is ignored and the return value is a string containing the command\u2019s output. Example:",
            "code": ">>> subprocess.getoutput('ls /bin/ls')\n'/bin/ls'\n"
        },
        "parametres": [
            "cmd\tReturn output (stdout and stderr) of executing cmd in a shell"
        ],
        "exemple": ">>> subprocess.getoutput('ls /bin/ls')\n'/bin/ls'\n"
    },
    "contextvars.contextvar.reset": {
        "description": {
            "texte": "Reset the context variable to the value it had before the ContextVar.set() that created the token was used.For example:",
            "code": "var = ContextVar('var')\n\ntoken = var.set('new value')\n# code that uses 'var'; var.get() returns 'new value'.\nvar.reset(token)\n\n# After the reset call the var has no value again, so\n# var.get() would raise a LookupError.\n"
        },
        "parametres": [
            "token\tset() that created the token was used"
        ],
        "exemple": "var = ContextVar('var')\n\ntoken = var.set('new value')\n# code that uses 'var'; var.get() returns 'new value'.\nvar.reset(token)\n\n# After the reset call the var has no value again, so\n# var.get() would raise a LookupError.\n"
    },
    "contextvars.copy_context": {
        "description": {
            "texte": "Returns a copy of the current Context object.The following snippet gets a copy of the current context and prints all variables and their values that are set in it:",
            "code": "ctx: Context = copy_context()\nprint(list(ctx.items()))\n"
        },
        "parametres": [
            "\tReturns a copy of the current Context object.The following snippet gets a copy of the current context and prints all variables and their values that are set in it:"
        ],
        "exemple": "ctx: Context = copy_context()\nprint(list(ctx.items()))\n"
    },
    "contextvars.context.run": {
        "description": {
            "texte": "Execute callable(*args, **kwargs) code in the context object the run method is called on. Return the result of the execution or propagate an exception if one occurred.Any changes to any context variables that callable makes will be contained in the context object:",
            "code": "var = ContextVar('var')\nvar.set('spam')\n\ndef main():\n    # 'var' was set to 'spam' before\n    # calling 'copy_context()' and 'ctx.run(main)', so:\n    # var.get() == ctx[var] == 'spam'\n\n    var.set('ham')\n\n    # Now, after setting 'var' to 'ham':\n    # var.get() == ctx[var] == 'ham'\n\nctx = copy_context()\n\n# Any changes that the 'main' function makes to 'var'\n# will be contained in 'ctx'.\nctx.run(main)\n\n# The 'main()' function was run in the 'ctx' context,\n# so changes to 'var' are contained in it:\n# ctx[var] == 'ham'\n\n# However, outside of 'ctx', 'var' is still set to 'spam':\n# var.get() == 'spam'\n"
        },
        "parametres": [
            "callable\tExecute callable(*args, **kwargs) code in the context object the run method is called on.Any changes to any context variables that callable makes will be contained in the context object:",
            " *args\t",
            " **kwargs\tExecute callable(*args, **kwargs) code in the context object the run method is called on"
        ],
        "exemple": "var = ContextVar('var')\nvar.set('spam')\n\ndef main():\n    # 'var' was set to 'spam' before\n    # calling 'copy_context()' and 'ctx.run(main)', so:\n    # var.get() == ctx[var] == 'spam'\n\n    var.set('ham')\n\n    # Now, after setting 'var' to 'ham':\n    # var.get() == ctx[var] == 'ham'\n\nctx = copy_context()\n\n# Any changes that the 'main' function makes to 'var'\n# will be contained in 'ctx'.\nctx.run(main)\n\n# The 'main()' function was run in the 'ctx' context,\n# so changes to 'var' are contained in it:\n# ctx[var] == 'ham'\n\n# However, outside of 'ctx', 'var' is still set to 'spam':\n# var.get() == 'spam'\n"
    },
    "socket.socket.sendmsg": {
        "description": {
            "texte": "Send normal and ancillary data to the socket, gathering the non-ancillary data from a series of buffers and concatenating it into a single message. The buffers argument specifies the non-ancillary data as an iterable of bytes-like objects (e.g. bytes objects); the operating system may set a limit (sysconf() value SC_IOV_MAX) on the number of buffers that can be used. The ancdata argument specifies the ancillary data (control messages) as an iterable of zero or more tuples (cmsg_level, cmsg_type, cmsg_data), where cmsg_level and cmsg_type are integers specifying the protocol level and protocol-specific type respectively, and cmsg_data is a bytes-like object holding the associated data. Note that some systems (in particular, systems without CMSG_SPACE()) might support sending only one control message per call. The flags argument defaults to 0 and has the same meaning as for send(). If address is supplied and not None, it sets a destination address for the message. The return value is the number of bytes of non-ancillary data sent.The following function sends the list of file descriptors fds over an AF_UNIX socket, on systems which support the SCM_RIGHTS mechanism. See also recvmsg().",
            "code": "import socket, array\n\ndef send_fds(sock, msg, fds):\n    return sock.sendmsg([msg], [(socket.SOL_SOCKET, socket.SCM_RIGHTS, array.array(\"i\", fds))])\n"
        },
        "parametres": [
            "buffers[\t",
            " ancdata[\t",
            " flags[\t",
            " address]]]\t"
        ],
        "exemple": "import socket, array\n\ndef send_fds(sock, msg, fds):\n    return sock.sendmsg([msg], [(socket.SOL_SOCKET, socket.SCM_RIGHTS, array.array(\"i\", fds))])\n"
    },
    "ssl.match_hostname": {
        "description": {
            "texte": "Verify that cert (in decoded format as returned by SSLSocket.getpeercert()) matches the given hostname. The rules applied are those for checking the identity of HTTPS servers as outlined in RFC 2818, RFC 5280 and RFC 6125. In addition to HTTPS, this function should be suitable for checking the identity of servers in various SSL-based protocols such as FTPS, IMAPS, POPS and others.CertificateError is raised on failure. On success, the function returns nothing:",
            "code": ">>> cert = {'subject': ((('commonName', 'example.com'),),)}\n>>> ssl.match_hostname(cert, \"example.com\")\n>>> ssl.match_hostname(cert, \"example.org\")\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/home/py3k/Lib/ssl.py\", line 130, in match_hostname\nssl.CertificateError: hostname 'example.org' doesn't match 'example.com'\n"
        },
        "parametres": [
            "cert\tVerify that cert (in decoded format as returned by SSLSocket.getpeercert()) matches the given hostname",
            " hostname\tgetpeercert()) matches the given hostname"
        ],
        "exemple": ">>> cert = {'subject': ((('commonName', 'example.com'),),)}\n>>> ssl.match_hostname(cert, \"example.com\")\n>>> ssl.match_hostname(cert, \"example.org\")\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/home/py3k/Lib/ssl.py\", line 130, in match_hostname\nssl.CertificateError: hostname 'example.org' doesn't match 'example.com'\n"
    },
    "ssl.cert_time_to_seconds": {
        "description": {
            "texte": "Return the time in seconds since the Epoch, given the cert_time string representing the \u201cnotBefore\u201d or \u201cnotAfter\u201d date from a certificate in \"%b %d %H:%M:%S %Y %Z\" strptime format (C locale).Here\u2019s an example:",
            "code": ">>> import ssl\n>>> timestamp = ssl.cert_time_to_seconds(\"Jan  5 09:34:43 2018 GMT\")\n>>> timestamp  \n1515144883\n>>> from datetime import datetime\n>>> print(datetime.utcfromtimestamp(timestamp))  \n2018-01-05 09:34:43\n"
        },
        "parametres": [
            "cert_time\tReturn the time in seconds since the Epoch, given the cert_time string representing the \u201cnotBefore\u201d or \u201cnotAfter\u201d date from a certificate in \"%b %d %H:%M:%S %Y %Z\" strptime format (C locale)"
        ],
        "exemple": ">>> import ssl\n>>> timestamp = ssl.cert_time_to_seconds(\"Jan  5 09:34:43 2018 GMT\")\n>>> timestamp  \n1515144883\n>>> from datetime import datetime\n>>> print(datetime.utcfromtimestamp(timestamp))  \n2018-01-05 09:34:43\n"
    },
    "ssl.sslcontext.cert_store_stats": {
        "description": {
            "texte": "Get statistics about quantities of loaded X.509 certificates, count of X.509 certificates flagged as CA certificates and certificate revocation lists as dictionary.Example for a context with one CA cert and one other cert:",
            "code": ">>> context.cert_store_stats()\n{'crl': 0, 'x509_ca': 1, 'x509': 2}\n"
        },
        "parametres": [
            "\tGet statistics about quantities of loaded X.509 certificates, count of X.509 certificates flagged as CA certificates and certificate revocation lists as dictionary.Example for a context with one CA cert and one other cert:"
        ],
        "exemple": ">>> context.cert_store_stats()\n{'crl': 0, 'x509_ca': 1, 'x509': 2}\n"
    },
    "ssl.sslcontext.get_ciphers": {
        "description": {
            "texte": "Get a list of enabled ciphers. The list is in order of cipher priority. See SSLContext.set_ciphers().Example:",
            "code": ">>> ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n>>> ctx.set_ciphers('ECDHE+AESGCM:!ECDSA')\n>>> ctx.get_ciphers()  # OpenSSL 1.0.x\n[{'alg_bits': 256,\n  'description': 'ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  '\n                 'Enc=AESGCM(256) Mac=AEAD',\n  'id': 50380848,\n  'name': 'ECDHE-RSA-AES256-GCM-SHA384',\n  'protocol': 'TLSv1/SSLv3',\n  'strength_bits': 256},\n {'alg_bits': 128,\n  'description': 'ECDHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH     Au=RSA  '\n                 'Enc=AESGCM(128) Mac=AEAD',\n  'id': 50380847,\n  'name': 'ECDHE-RSA-AES128-GCM-SHA256',\n  'protocol': 'TLSv1/SSLv3',\n  'strength_bits': 128}]\n"
        },
        "parametres": [
            "\tGet a list of enabled ciphers. The list is in order of cipher priority. See SSLContext.set_ciphers().Example:"
        ],
        "exemple": ">>> ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n>>> ctx.set_ciphers('ECDHE+AESGCM:!ECDSA')\n>>> ctx.get_ciphers()  # OpenSSL 1.0.x\n[{'alg_bits': 256,\n  'description': 'ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  '\n                 'Enc=AESGCM(256) Mac=AEAD',\n  'id': 50380848,\n  'name': 'ECDHE-RSA-AES256-GCM-SHA384',\n  'protocol': 'TLSv1/SSLv3',\n  'strength_bits': 256},\n {'alg_bits': 128,\n  'description': 'ECDHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH     Au=RSA  '\n                 'Enc=AESGCM(128) Mac=AEAD',\n  'id': 50380847,\n  'name': 'ECDHE-RSA-AES128-GCM-SHA256',\n  'protocol': 'TLSv1/SSLv3',\n  'strength_bits': 128}]\n"
    },
    "json.jsonencoder.default": {
        "description": {
            "texte": "Implement this method in a subclass such that it returns a serializable object for o, or calls the base implementation (to raise a TypeError).For example, to support arbitrary iterators, you could implement default like this:",
            "code": "def default(self, o):\n   try:\n       iterable = iter(o)\n   except TypeError:\n       pass\n   else:\n       return list(iterable)\n   # Let the base class default method raise the TypeError\n   return json.JSONEncoder.default(self, o)\n"
        },
        "parametres": [
            "o\tImplement this method in a subclass such that it returns a serializable object for o, or calls the base implementation (to raise a TypeError).For example, to support arbitrary iterators, you could implement default like this:"
        ],
        "exemple": "def default(self, o):\n   try:\n       iterable = iter(o)\n   except TypeError:\n       pass\n   else:\n       return list(iterable)\n   # Let the base class default method raise the TypeError\n   return json.JSONEncoder.default(self, o)\n"
    },
    "xml.etree.elementtree.canonicalize": {
        "description": {
            "texte": "C14N 2.0 transformation function.Canonicalization is a way to normalise XML output in a way that allows byte-by-byte comparisons and digital signatures. It reduced the freedom that XML serializers have and instead generates a more constrained XML representation. The main restrictions regard the placement of namespace declarations, the ordering of attributes, and ignorable whitespace.Typical uses:",
            "code": "xml_data = \"<root>...</root>\"\nprint(canonicalize(xml_data))\n\nwith open(\"c14n_output.xml\", mode='w', encoding='utf-8') as out_file:\n    canonicalize(xml_data, out=out_file)\n\nwith open(\"c14n_output.xml\", mode='w', encoding='utf-8') as out_file:\n    canonicalize(from_file=\"inputfile.xml\", out=out_file)\n"
        },
        "parametres": [
            "xml_data=None\t",
            " *\t",
            " out=None\t",
            " from_file=None\t",
            " **options\t"
        ],
        "exemple": "xml_data = \"<root>...</root>\"\nprint(canonicalize(xml_data))\n\nwith open(\"c14n_output.xml\", mode='w', encoding='utf-8') as out_file:\n    canonicalize(xml_data, out=out_file)\n\nwith open(\"c14n_output.xml\", mode='w', encoding='utf-8') as out_file:\n    canonicalize(from_file=\"inputfile.xml\", out=out_file)\n"
    },
    "xml.dom.minidom.node.unlink": {
        "description": {
            "texte": "Break internal references within the DOM so that it will be garbage collected on versions of Python without cyclic GC. Even when cyclic GC is available, using this can make large amounts of memory available sooner, so calling this on DOM objects as soon as they are no longer needed is good practice. This only needs to be called on the Document object, but may be called on child nodes to discard children of that node.You can avoid calling this method explicitly by using the with statement. The following code will automatically unlink dom when the with block is exited:",
            "code": "with xml.dom.minidom.parse(datasource) as dom:\n    ... # Work with dom.\n"
        },
        "parametres": [
            "\tBreak internal references within the DOM so that it will be garbage collected on versions of Python without cyclic GC. Even when cyclic GC is available, using this can make large amounts of memory available sooner, so calling this on DOM objects as soon as they are no longer needed is good practice. This only needs to be called on the Document object, but may be called on child nodes to discard children of that node.You can avoid calling this method explicitly by using the with statement. The following code will automatically unlink dom when the with block is exited:"
        ],
        "exemple": "with xml.dom.minidom.parse(datasource) as dom:\n    ... # Work with dom.\n"
    },
    "wsgiref.util.setup_testing_defaults": {
        "description": {
            "texte": "Update environ with trivial defaults for testing purposes.This routine adds various parameters required for WSGI, including HTTP_HOST, SERVER_NAME, SERVER_PORT, REQUEST_METHOD, SCRIPT_NAME, PATH_INFO, and all of the PEP 3333-defined wsgi.* variables. It only supplies default values, and does not replace any existing settings for these variables.Example usage:",
            "code": "from wsgiref.util import setup_testing_defaults\nfrom wsgiref.simple_server import make_server\n\n# A relatively simple WSGI application. It's going to print out the\n# environment dictionary after being updated by setup_testing_defaults\ndef simple_app(environ, start_response):\n    setup_testing_defaults(environ)\n\n    status = '200 OK'\n    headers = [('Content-type', 'text/plain; charset=utf-8')]\n\n    start_response(status, headers)\n\n    ret = [(\"%s: %s\\n\" % (key, value)).encode(\"utf-8\")\n           for key, value in environ.items()]\n    return ret\n\nwith make_server('', 8000, simple_app) as httpd:\n    print(\"Serving on port 8000...\")\n    httpd.serve_forever()\n"
        },
        "parametres": [
            "environ\tUpdate environ with trivial defaults for testing purposes"
        ],
        "exemple": "from wsgiref.util import setup_testing_defaults\nfrom wsgiref.simple_server import make_server\n\n# A relatively simple WSGI application. It's going to print out the\n# environment dictionary after being updated by setup_testing_defaults\ndef simple_app(environ, start_response):\n    setup_testing_defaults(environ)\n\n    status = '200 OK'\n    headers = [('Content-type', 'text/plain; charset=utf-8')]\n\n    start_response(status, headers)\n\n    ret = [(\"%s: %s\\n\" % (key, value)).encode(\"utf-8\")\n           for key, value in environ.items()]\n    return ret\n\nwith make_server('', 8000, simple_app) as httpd:\n    print(\"Serving on port 8000...\")\n    httpd.serve_forever()\n"
    },
    "wsgiref.headers.headers.add_header": {
        "description": {
            "texte": "Add a (possibly multi-valued) header, with optional MIME parameters specified via keyword arguments.name is the header field to add. Keyword arguments can be used to set MIME parameters for the header field. Each parameter must be a string or None. Underscores in parameter names are converted to dashes, since dashes are illegal in Python identifiers, but many MIME parameter names include dashes. If the parameter value is a string, it is added to the header value parameters in the form name=\"value\". If it is None, only the parameter name is added. (This is used for MIME parameters without a value.) Example usage:",
            "code": "h.add_header('content-disposition', 'attachment', filename='bud.gif')\n"
        },
        "parametres": [
            "name\tname is the header field to add. Underscores in parameter names are converted to dashes, since dashes are illegal in Python identifiers, but many MIME parameter names include dashes. If the parameter value is a string, it is added to the header value parameters in the form name=\"value\". If it is None, only the parameter name is added",
            " value\t If the parameter value is a string, it is added to the header value parameters in the form name=\"value\". (This is used for MIME parameters without a value",
            " **_params\t"
        ],
        "exemple": "h.add_header('content-disposition', 'attachment', filename='bud.gif')\n"
    },
    "wsgiref.simple_server.make_server": {
        "description": {
            "texte": "Create a new WSGI server listening on host and port, accepting connections for app. The return value is an instance of the supplied server_class, and will process requests using the specified handler_class. app must be a WSGI application object, as defined by PEP 3333.Example usage:",
            "code": "from wsgiref.simple_server import make_server, demo_app\n\nwith make_server('', 8000, demo_app) as httpd:\n    print(\"Serving HTTP on port 8000...\")\n\n    # Respond to requests until process is killed\n    httpd.serve_forever()\n\n    # Alternative: serve one request, then exit\n    httpd.handle_request()\n"
        },
        "parametres": [
            "host\tCreate a new WSGI server listening on host and port, accepting connections for app",
            " port\tCreate a new WSGI server listening on host and port, accepting connections for app",
            " app\tCreate a new WSGI server listening on host and port, accepting connections for app. app must be a WSGI application object, as defined by PEP 3333",
            " server_class=WSGIServer\t",
            " handler_class=WSGIRequestHandler\t"
        ],
        "exemple": "from wsgiref.simple_server import make_server, demo_app\n\nwith make_server('', 8000, demo_app) as httpd:\n    print(\"Serving HTTP on port 8000...\")\n\n    # Respond to requests until process is killed\n    httpd.serve_forever()\n\n    # Alternative: serve one request, then exit\n    httpd.handle_request()\n"
    },
    "wsgiref.validate.validator": {
        "description": {
            "texte": "Wrap application and return a new WSGI application object. The returned application will forward all requests to the original application, and will check that both the application and the server invoking it are conforming to the WSGI specification and to RFC 2616.Any detected nonconformance results in an AssertionError being raised; note, however, that how these errors are handled is server-dependent. For example, wsgiref.simple_server and other servers based on wsgiref.handlers (that don\u2019t override the error handling methods to do something else) will simply output a message that an error has occurred, and dump the traceback to sys.stderr or some other error stream.Example usage:",
            "code": "from wsgiref.validate import validator\nfrom wsgiref.simple_server import make_server\n\n# Our callable object which is intentionally not compliant to the\n# standard, so the validator is going to break\ndef simple_app(environ, start_response):\n    status = '200 OK'  # HTTP Status\n    headers = [('Content-type', 'text/plain')]  # HTTP Headers\n    start_response(status, headers)\n\n    # This is going to break because we need to return a list, and\n    # the validator is going to inform us\n    return b\"Hello World\"\n\n# This is the application wrapped in a validator\nvalidator_app = validator(simple_app)\n\nwith make_server('', 8000, validator_app) as httpd:\n    print(\"Listening on port 8000....\")\n    httpd.serve_forever()\n"
        },
        "parametres": [
            "application\tWrap application and return a new WSGI application object. The returned application will forward all requests to the original application, and will check that both the application and the server invoking it are conforming to the WSGI specification and to RFC 2616"
        ],
        "exemple": "from wsgiref.validate import validator\nfrom wsgiref.simple_server import make_server\n\n# Our callable object which is intentionally not compliant to the\n# standard, so the validator is going to break\ndef simple_app(environ, start_response):\n    status = '200 OK'  # HTTP Status\n    headers = [('Content-type', 'text/plain')]  # HTTP Headers\n    start_response(status, headers)\n\n    # This is going to break because we need to return a list, and\n    # the validator is going to inform us\n    return b\"Hello World\"\n\n# This is the application wrapped in a validator\nvalidator_app = validator(simple_app)\n\nwith make_server('', 8000, validator_app) as httpd:\n    print(\"Listening on port 8000....\")\n    httpd.serve_forever()\n"
    },
    "urllib.parse.urlparse": {
        "description": {
            "texte": "Parse a URL into six components, returning a 6-item named tuple. This corresponds to the general structure of a URL: scheme://netloc/path;parameters?query#fragment. Each tuple item is a string, possibly empty. The components are not broken up into smaller parts (for example, the network location is a single string), and % escapes are not expanded. The delimiters as shown above are not part of the result, except for a leading slash in the path component, which is retained if present. For example:If the allow_fragments argument is false, fragment identifiers are not recognized. Instead, they are parsed as part of the path, parameters or query component, and fragment is set to the empty string in the return value.Unmatched square brackets in the netloc attribute will raise a ValueError.As is the case with all named tuples, the subclass has a few additional methods and attributes that are particularly useful. One such method is _replace(). The _replace() method will return a new ParseResult object replacing specified fields with new values.",
            "code": ">>> from urllib.parse import urlparse\n>>> u = urlparse('//www.cwi.nl:80/%7Eguido/Python.html')\n>>> u\nParseResult(scheme='', netloc='www.cwi.nl:80', path='/%7Eguido/Python.html',\n            params='', query='', fragment='')\n>>> u._replace(scheme='http')\nParseResult(scheme='http', netloc='www.cwi.nl:80', path='/%7Eguido/Python.html',\n            params='', query='', fragment='')\n"
        },
        "parametres": [
            "urlstring\t",
            " scheme=''\t",
            " allow_fragments=True\t"
        ],
        "exemple": ">>> from urllib.parse import urlparse\n>>> o = urlparse('http://www.cwi.nl:80/%7Eguido/Python.html')\n>>> o   \nParseResult(scheme='http', netloc='www.cwi.nl:80', path='/%7Eguido/Python.html',\n            params='', query='', fragment='')\n>>> o.scheme\n'http'\n>>> o.port\n80\n>>> o.geturl()\n'http://www.cwi.nl:80/%7Eguido/Python.html'\n"
    },
    "http.client.httpconnection": {
        "description": {
            "texte": "An HTTPConnection instance represents one transaction with an HTTP server. It should be instantiated passing it a host and optional port number. If no port number is passed, the port is extracted from the host string if it has the form host:port, else the default HTTP port (80) is used. If the optional timeout parameter is given, blocking operations (like connection attempts) will timeout after that many seconds (if it is not given, the global default timeout setting is used). The optional source_address parameter may be a tuple of a (host, port) to use as the source address the HTTP connection is made from. The optional blocksize parameter sets the buffer size in bytes for sending a file-like message body.For example, the following calls all create instances that connect to the server at the same host and port:",
            "code": ">>> h1 = http.client.HTTPConnection('www.python.org')\n>>> h2 = http.client.HTTPConnection('www.python.org:80')\n>>> h3 = http.client.HTTPConnection('www.python.org', 80)\n>>> h4 = http.client.HTTPConnection('www.python.org', 80, timeout=10)\n"
        },
        "parametres": [
            "host\t It should be instantiated passing it a host and optional port number. If no port number is passed, the port is extracted from the host string if it has the form host:port, else the default HTTP port (80) is used. The optional source_address parameter may be a tuple of a (host, port) to use as the source address the HTTP connection is made from.For example, the following calls all create instances that connect to the server at the same host and port:",
            " port=None\t",
            " [timeout\t",
            " ]source_address=None\t",
            " blocksize=8192\t"
        ],
        "exemple": ">>> h1 = http.client.HTTPConnection('www.python.org')\n>>> h2 = http.client.HTTPConnection('www.python.org:80')\n>>> h3 = http.client.HTTPConnection('www.python.org', 80)\n>>> h4 = http.client.HTTPConnection('www.python.org', 80, timeout=10)\n"
    },
    "http.client.httpconnection.set_tunnel": {
        "description": {
            "texte": "Set the host and the port for HTTP Connect Tunnelling. This allows running the connection through a proxy server.The host and port arguments specify the endpoint of the tunneled connection (i.e. the address included in the CONNECT request, not the address of the proxy server).For example, to tunnel through a HTTPS proxy server running locally on port 8080, we would pass the address of the proxy to the HTTPSConnection constructor, and the address of the host that we eventually want to reach to the set_tunnel() method:",
            "code": ">>> import http.client\n>>> conn = http.client.HTTPSConnection(\"localhost\", 8080)\n>>> conn.set_tunnel(\"www.python.org\")\n>>> conn.request(\"HEAD\",\"/index.html\")\n"
        },
        "parametres": [
            "host\tSet the host and the port for HTTP Connect Tunnelling.The host and port arguments specify the endpoint of the tunneled connection (i.For example, to tunnel through a HTTPS proxy server running locally on port 8080, we would pass the address of the proxy to the HTTPSConnection constructor, and the address of the host that we eventually want to reach to the set_tunnel() method:",
            " port=None\t",
            " headers=None\t"
        ],
        "exemple": ">>> import http.client\n>>> conn = http.client.HTTPSConnection(\"localhost\", 8080)\n>>> conn.set_tunnel(\"www.python.org\")\n>>> conn.request(\"HEAD\",\"/index.html\")\n"
    },
    "ftplib.ftp": {
        "description": {
            "texte": "Return a new instance of the FTP class. When host is given, the method call connect(host) is made. When user is given, additionally the method call login(user, passwd, acct) is made (where passwd and acct default to the empty string when not given). The optional timeout parameter specifies a timeout in seconds for blocking operations like the connection attempt (if is not specified, the global default timeout setting will be used). source_address is a 2-tuple (host, port) for the socket to bind to as its source address before connecting. The encoding parameter specifies the encoding for directories and filenames.The FTP class supports the with statement, e.g.:",
            "code": ">>> from ftplib import FTP\n>>> with FTP(\"ftp1.at.proftpd.org\") as ftp:\n...     ftp.login()\n...     ftp.dir()\n... \n'230 Anonymous login ok, restrictions apply.'\ndr-xr-xr-x   9 ftp      ftp           154 May  6 10:43 .\ndr-xr-xr-x   9 ftp      ftp           154 May  6 10:43 ..\ndr-xr-xr-x   5 ftp      ftp          4096 May  6 10:43 CentOS\ndr-xr-xr-x   3 ftp      ftp            18 Jul 10  2008 Fedora\n>>>\n"
        },
        "parametres": [
            "host=''\t",
            " user=''\t",
            " passwd=''\t",
            " acct=''\t",
            " timeout=None\t",
            " source_address=None\t",
            " *\t",
            " encoding='utf-8'\t"
        ],
        "exemple": ">>> from ftplib import FTP\n>>> with FTP(\"ftp1.at.proftpd.org\") as ftp:\n...     ftp.login()\n...     ftp.dir()\n... \n'230 Anonymous login ok, restrictions apply.'\ndr-xr-xr-x   9 ftp      ftp           154 May  6 10:43 .\ndr-xr-xr-x   9 ftp      ftp           154 May  6 10:43 ..\ndr-xr-xr-x   5 ftp      ftp          4096 May  6 10:43 CentOS\ndr-xr-xr-x   3 ftp      ftp            18 Jul 10  2008 Fedora\n>>>\n"
    },
    "ftplib.ftp_tls": {
        "description": {
            "texte": "A FTP subclass which adds TLS support to FTP as described in RFC 4217. Connect as usual to port 21 implicitly securing the FTP control connection before authenticating. Securing the data connection requires the user to explicitly ask for it by calling the prot_p() method. context is a ssl.SSLContext object which allows bundling SSL configuration options, certificates and private keys into a single (potentially long-lived) structure. Please read Security considerations for best practices.keyfile and certfile are a legacy alternative to context \u2013 they can point to PEM-formatted private key and certificate chain files (respectively) for the SSL connection.Here\u2019s a sample session using the FTP_TLS class:",
            "code": ">>> ftps = FTP_TLS('ftp.pureftpd.org')\n>>> ftps.login()\n'230 Anonymous user logged in'\n>>> ftps.prot_p()\n'200 Data protection level set to \"private\"'\n>>> ftps.nlst()\n['6jack', 'OpenBSD', 'antilink', 'blogbench', 'bsdcam', 'clockspeed', 'djbdns-jedi', 'docs', 'eaccelerator-jedi', 'favicon.ico', 'francotone', 'fugu', 'ignore', 'libpuzzle', 'metalog', 'minidentd', 'misc', 'mysql-udf-global-user-variables', 'php-jenkins-hash', 'php-skein-hash', 'php-webdav', 'phpaudit', 'phpbench', 'pincaster', 'ping', 'posto', 'pub', 'public', 'public_keys', 'pure-ftpd', 'qscan', 'qtc', 'sharedance', 'skycache', 'sound', 'tmp', 'ucarp']\n"
        },
        "parametres": [
            "host=''\t",
            " user=''\t",
            " passwd=''\t",
            " acct=''\t",
            " keyfile=None\t",
            " certfile=None\t",
            " context=None\t",
            " timeout=None\t",
            " source_address=None\t",
            " *\t",
            " encoding='utf-8'\t"
        ],
        "exemple": ">>> ftps = FTP_TLS('ftp.pureftpd.org')\n>>> ftps.login()\n'230 Anonymous user logged in'\n>>> ftps.prot_p()\n'200 Data protection level set to \"private\"'\n>>> ftps.nlst()\n['6jack', 'OpenBSD', 'antilink', 'blogbench', 'bsdcam', 'clockspeed', 'djbdns-jedi', 'docs', 'eaccelerator-jedi', 'favicon.ico', 'francotone', 'fugu', 'ignore', 'libpuzzle', 'metalog', 'minidentd', 'misc', 'mysql-udf-global-user-variables', 'php-jenkins-hash', 'php-skein-hash', 'php-webdav', 'phpaudit', 'phpbench', 'pincaster', 'ping', 'posto', 'pub', 'public', 'public_keys', 'pure-ftpd', 'qscan', 'qtc', 'sharedance', 'skycache', 'sound', 'tmp', 'ucarp']\n"
    },
    "imaplib.imap4": {
        "description": {
            "texte": "This class implements the actual IMAP4 protocol. The connection is created and protocol version (IMAP4 or IMAP4rev1) is determined when the instance is initialized. If host is not specified, '' (the local host) is used. If port is omitted, the standard IMAP4 port (143) is used. The optional timeout parameter specifies a timeout in seconds for the connection attempt. If timeout is not given or is None, the global default socket timeout is used.The IMAP4 class supports the with statement. When used like this, the IMAP4 LOGOUT command is issued automatically when the with statement exits. E.g.:",
            "code": ">>> from imaplib import IMAP4\n>>> with IMAP4(\"domain.org\") as M:\n...     M.noop()\n...\n('OK', [b'Nothing Accomplished. d25if65hy903weo.87'])\n"
        },
        "parametres": [
            "host=''\t",
            " port=IMAP4_PORT\t",
            " timeout=None\t"
        ],
        "exemple": ">>> from imaplib import IMAP4\n>>> with IMAP4(\"domain.org\") as M:\n...     M.noop()\n...\n('OK', [b'Nothing Accomplished. d25if65hy903weo.87'])\n"
    },
    "imaplib.imap4.search": {
        "description": {
            "texte": "Search mailbox for matching messages. charset may be None, in which case no CHARSET will be specified in the request to the server. The IMAP protocol requires that at least one criterion be specified; an exception will be raised when the server returns an error. charset must be None if the UTF8=ACCEPT capability was enabled using the enable() command.Example:",
            "code": "# M is a connected IMAP4 instance...\ntyp, msgnums = M.search(None, 'FROM', '\"LDJ\"')\n\n# or:\ntyp, msgnums = M.search(None, '(FROM \"LDJ\")')\n"
        },
        "parametres": [
            "charset\t charset may be None, in which case no CHARSET will be specified in the request to the server. charset must be None if the UTF8=ACCEPT capability was enabled using the enable() command",
            " criterion[\t",
            " ...]\t"
        ],
        "exemple": "# M is a connected IMAP4 instance...\ntyp, msgnums = M.search(None, 'FROM', '\"LDJ\"')\n\n# or:\ntyp, msgnums = M.search(None, '(FROM \"LDJ\")')\n"
    },
    "imaplib.imap4.store": {
        "description": {
            "texte": "Alters flag dispositions for messages in mailbox. command is specified by section 6.4.6 of RFC 2060 as being one of \u201cFLAGS\u201d, \u201c+FLAGS\u201d, or \u201c-FLAGS\u201d, optionally with a suffix of \u201c.SILENT\u201d.For example, to set the delete flag on all messages:",
            "code": "typ, data = M.search(None, 'ALL')\nfor num in data[0].split():\n   M.store(num, '+FLAGS', '\\\\Deleted')\nM.expunge()\n"
        },
        "parametres": [
            "message_set\t",
            " command\t command is specified by section 6",
            " flag_list\t"
        ],
        "exemple": "typ, data = M.search(None, 'ALL')\nfor num in data[0].split():\n   M.store(num, '+FLAGS', '\\\\Deleted')\nM.expunge()\n"
    },
    "telnetlib.telnet": {
        "description": {
            "texte": "Telnet represents a connection to a Telnet server. The instance is initially not connected by default; the open() method must be used to establish a connection. Alternatively, the host name and optional port number can be passed to the constructor too, in which case the connection to the server will be established before the constructor returns. The optional timeout parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used).Do not reopen an already connected instance.A Telnet object is a context manager and can be used in a with statement. When the with block ends, the close() method is called:",
            "code": ">>> from telnetlib import Telnet\n>>> with Telnet('localhost', 23) as tn:\n...     tn.interact()\n...\n"
        },
        "parametres": [
            "host=None\t",
            " port=0[\t",
            " timeout]\t"
        ],
        "exemple": ">>> from telnetlib import Telnet\n>>> with Telnet('localhost', 23) as tn:\n...     tn.interact()\n...\n"
    },
    "ossaudiodev.oss_audio_device.setparameters": {
        "description": {
            "texte": "Set the key audio sampling parameters\u2014sample format, number of channels, and sampling rate\u2014in one method call. format, nchannels, and samplerate should be as specified in the setfmt(), channels(), and speed() methods. If strict is true, setparameters() checks to see if each parameter was actually set to the requested value, and raises OSSAudioError if not. Returns a tuple (format, nchannels, samplerate) indicating the parameter values that were actually set by the device driver (i.e., the same as the return values of setfmt(), channels(), and speed()).For example,",
            "code": "(fmt, channels, rate) = dsp.setparameters(fmt, channels, rate)\n"
        },
        "parametres": [
            "format\tSet the key audio sampling parameters\u2014sample format, number of channels, and sampling rate\u2014in one method call. format, nchannels, and samplerate should be as specified in the setfmt(), channels(), and speed() methods. Returns a tuple (format, nchannels, samplerate) indicating the parameter values that were actually set by the device driver (i",
            " nchannels\t format, nchannels, and samplerate should be as specified in the setfmt(), channels(), and speed() methods. Returns a tuple (format, nchannels, samplerate) indicating the parameter values that were actually set by the device driver (i",
            " samplerate[\t",
            " strict=False]\t"
        ],
        "exemple": "(fmt, channels, rate) = dsp.setparameters(fmt, channels, rate)\n"
    },
    "turtle.goto": {
        "description": {
            "texte": "If y is None, x must be a pair of coordinates or a Vec2D (e.g. as returned by pos()).Move turtle to an absolute position. If the pen is down, draw line. Do not change the turtle\u2019s orientation.",
            "code": " >>> tp = turtle.pos()\n >>> tp\n (0.00,0.00)\n >>> turtle.setpos(60,30)\n >>> turtle.pos()\n (60.00,30.00)\n >>> turtle.setpos((20,80))\n >>> turtle.pos()\n (20.00,80.00)\n >>> turtle.setpos(tp)\n >>> turtle.pos()\n (0.00,0.00)\n"
        },
        "parametres": [
            "x\tIf y is None, x must be a pair of coordinates or a Vec2D (e",
            " y=None\t"
        ],
        "exemple": " >>> tp = turtle.pos()\n >>> tp\n (0.00,0.00)\n >>> turtle.setpos(60,30)\n >>> turtle.pos()\n (60.00,30.00)\n >>> turtle.setpos((20,80))\n >>> turtle.pos()\n (20.00,80.00)\n >>> turtle.setpos(tp)\n >>> turtle.pos()\n (0.00,0.00)\n"
    },
    "turtle.setpos": {
        "description": {
            "texte": "If y is None, x must be a pair of coordinates or a Vec2D (e.g. as returned by pos()).Move turtle to an absolute position. If the pen is down, draw line. Do not change the turtle\u2019s orientation.",
            "code": " >>> tp = turtle.pos()\n >>> tp\n (0.00,0.00)\n >>> turtle.setpos(60,30)\n >>> turtle.pos()\n (60.00,30.00)\n >>> turtle.setpos((20,80))\n >>> turtle.pos()\n (20.00,80.00)\n >>> turtle.setpos(tp)\n >>> turtle.pos()\n (0.00,0.00)\n"
        },
        "parametres": [
            "x\tIf y is None, x must be a pair of coordinates or a Vec2D (e",
            " y=None\t"
        ],
        "exemple": " >>> tp = turtle.pos()\n >>> tp\n (0.00,0.00)\n >>> turtle.setpos(60,30)\n >>> turtle.pos()\n (60.00,30.00)\n >>> turtle.setpos((20,80))\n >>> turtle.pos()\n (20.00,80.00)\n >>> turtle.setpos(tp)\n >>> turtle.pos()\n (0.00,0.00)\n"
    },
    "turtle.setposition": {
        "description": {
            "texte": "If y is None, x must be a pair of coordinates or a Vec2D (e.g. as returned by pos()).Move turtle to an absolute position. If the pen is down, draw line. Do not change the turtle\u2019s orientation.",
            "code": " >>> tp = turtle.pos()\n >>> tp\n (0.00,0.00)\n >>> turtle.setpos(60,30)\n >>> turtle.pos()\n (60.00,30.00)\n >>> turtle.setpos((20,80))\n >>> turtle.pos()\n (20.00,80.00)\n >>> turtle.setpos(tp)\n >>> turtle.pos()\n (0.00,0.00)\n"
        },
        "parametres": [
            "x\tIf y is None, x must be a pair of coordinates or a Vec2D (e",
            " y=None\t"
        ],
        "exemple": " >>> tp = turtle.pos()\n >>> tp\n (0.00,0.00)\n >>> turtle.setpos(60,30)\n >>> turtle.pos()\n (60.00,30.00)\n >>> turtle.setpos((20,80))\n >>> turtle.pos()\n (20.00,80.00)\n >>> turtle.setpos(tp)\n >>> turtle.pos()\n (0.00,0.00)\n"
    },
    "turtle.setheading": {
        "description": {
            "texte": "Set the orientation of the turtle to to_angle. Here are some common directions in degrees:",
            "code": ">>> turtle.setheading(90)\n>>> turtle.heading()\n90.0\n"
        },
        "parametres": [
            "to_angle\tSet the orientation of the turtle to to_angle"
        ],
        "exemple": ">>> turtle.setheading(90)\n>>> turtle.heading()\n90.0\n"
    },
    "turtle.seth": {
        "description": {
            "texte": "Set the orientation of the turtle to to_angle. Here are some common directions in degrees:",
            "code": ">>> turtle.setheading(90)\n>>> turtle.heading()\n90.0\n"
        },
        "parametres": [
            "to_angle\tSet the orientation of the turtle to to_angle"
        ],
        "exemple": ">>> turtle.setheading(90)\n>>> turtle.heading()\n90.0\n"
    },
    "turtle.circle": {
        "description": {
            "texte": "Draw a circle with given radius. The center is radius units left of the turtle; extent \u2013 an angle \u2013 determines which part of the circle is drawn. If extent is not given, draw the entire circle. If extent is not a full circle, one endpoint of the arc is the current pen position. Draw the arc in counterclockwise direction if radius is positive, otherwise in clockwise direction. Finally the direction of the turtle is changed by the amount of extent.As the circle is approximated by an inscribed regular polygon, steps determines the number of steps to use. If not given, it will be calculated automatically. May be used to draw regular polygons.",
            "code": ">>> turtle.home()\n>>> turtle.position()\n(0.00,0.00)\n>>> turtle.heading()\n0.0\n>>> turtle.circle(50)\n>>> turtle.position()\n(-0.00,0.00)\n>>> turtle.heading()\n0.0\n>>> turtle.circle(120, 180)  # draw a semicircle\n>>> turtle.position()\n(0.00,240.00)\n>>> turtle.heading()\n180.0\n"
        },
        "parametres": [
            "radius\tDraw a circle with given radius. The center is radius units left of the turtle; extent \u2013 an angle \u2013 determines which part of the circle is drawn. Draw the arc in counterclockwise direction if radius is positive, otherwise in clockwise direction",
            " extent=None\t",
            " steps=None\t"
        ],
        "exemple": ">>> turtle.home()\n>>> turtle.position()\n(0.00,0.00)\n>>> turtle.heading()\n0.0\n>>> turtle.circle(50)\n>>> turtle.position()\n(-0.00,0.00)\n>>> turtle.heading()\n0.0\n>>> turtle.circle(120, 180)  # draw a semicircle\n>>> turtle.position()\n(0.00,240.00)\n>>> turtle.heading()\n180.0\n"
    },
    "turtle.end_fill": {
        "description": {
            "texte": "Fill the shape drawn after the last call to begin_fill().Whether or not overlap regions for self-intersecting polygons or multiple shapes are filled depends on the operating system graphics, type of overlap, and number of overlaps. For example, the Turtle star above may be either all yellow or have some white regions.",
            "code": ">>> turtle.color(\"black\", \"red\")\n>>> turtle.begin_fill()\n>>> turtle.circle(80)\n>>> turtle.end_fill()\n"
        },
        "parametres": [
            "\tFill the shape drawn after the last call to begin_fill().Whether or not overlap regions for self-intersecting polygons or multiple shapes are filled depends on the operating system graphics, type of overlap, and number of overlaps. For example, the Turtle star above may be either all yellow or have some white regions."
        ],
        "exemple": ">>> turtle.color(\"black\", \"red\")\n>>> turtle.begin_fill()\n>>> turtle.circle(80)\n>>> turtle.end_fill()\n"
    },
    "turtle.shapetransform": {
        "description": {
            "texte": "Set or return the current transformation matrix of the turtle shape.If none of the matrix elements are given, return the transformation matrix as a tuple of 4 elements. Otherwise set the given elements and transform the turtleshape according to the matrix consisting of first row t11, t12 and second row t21, 22. The determinant t11 * t22 - t12 * t21 must not be zero, otherwise an error is raised. Modify stretchfactor, shearfactor and tiltangle according to the given matrix.",
            "code": ">>> turtle = Turtle()\n>>> turtle.shape(\"square\")\n>>> turtle.shapesize(4,2)\n>>> turtle.shearfactor(-0.5)\n>>> turtle.shapetransform()\n(4.0, -1.0, -0.0, 2.0)\n"
        },
        "parametres": [
            "t11=None\t",
            " t12=None\t",
            " t21=None\t",
            " t22=None\t"
        ],
        "exemple": ">>> turtle = Turtle()\n>>> turtle.shape(\"square\")\n>>> turtle.shapesize(4,2)\n>>> turtle.shearfactor(-0.5)\n>>> turtle.shapetransform()\n(4.0, -1.0, -0.0, 2.0)\n"
    },
    "turtle.ondrag": {
        "description": {
            "texte": "Bind fun to mouse-move events on this turtle. If fun is None, existing bindings are removed.Remark: Every sequence of mouse-move-events on a turtle is preceded by a mouse-click event on that turtle.",
            "code": ">>> turtle.ondrag(turtle.goto)\n"
        },
        "parametres": [
            "fun\tBind fun to mouse-move events on this turtle. If fun is None, existing bindings are removed",
            " btn=1\t",
            " add=None\t"
        ],
        "exemple": ">>> turtle.ondrag(turtle.goto)\n"
    },
    "turtle.setworldcoordinates": {
        "description": {
            "texte": "Set up user-defined coordinate system and switch to mode \u201cworld\u201d if necessary. This performs a screen.reset(). If mode \u201cworld\u201d is already active, all drawings are redrawn according to the new coordinates.ATTENTION: in user-defined coordinate systems angles may appear distorted.",
            "code": ">>> screen.reset()\n>>> screen.setworldcoordinates(-50,-7.5,50,7.5)\n>>> for _ in range(72):\n...     left(10)\n...\n>>> for _ in range(8):\n...     left(45); fd(2)   # a regular octagon\n"
        },
        "parametres": [
            "llx\t",
            " lly\t",
            " urx\t",
            " ury\t"
        ],
        "exemple": ">>> screen.reset()\n>>> screen.setworldcoordinates(-50,-7.5,50,7.5)\n>>> for _ in range(72):\n...     left(10)\n...\n>>> for _ in range(8):\n...     left(45); fd(2)   # a regular octagon\n"
    },
    "turtle.delay": {
        "description": {
            "texte": "Set or return the drawing delay in milliseconds. (This is approximately the time interval between two consecutive canvas updates.) The longer the drawing delay, the slower the animation.Optional argument:",
            "code": ">>> screen.delay()\n10\n>>> screen.delay(5)\n>>> screen.delay()\n5\n"
        },
        "parametres": [
            "delay=None\t"
        ],
        "exemple": ">>> screen.delay()\n10\n>>> screen.delay(5)\n>>> screen.delay()\n5\n"
    },
    "turtle.onclick": {
        "description": {
            "texte": "Bind fun to mouse-click events on this screen. If fun is None, existing bindings are removed.Example for a TurtleScreen instance named screen and a Turtle instance named turtle:",
            "code": ">>> screen.onclick(turtle.goto) # Subsequently clicking into the TurtleScreen will\n>>>                             # make the turtle move to the clicked point.\n>>> screen.onclick(None)        # remove event binding again\n"
        },
        "parametres": [
            "fun\tBind fun to mouse-click events on this screen. If fun is None, existing bindings are removed",
            " btn=1\t",
            " add=None\t"
        ],
        "exemple": ">>> screen.onclick(turtle.goto) # Subsequently clicking into the TurtleScreen will\n>>>                             # make the turtle move to the clicked point.\n>>> screen.onclick(None)        # remove event binding again\n"
    },
    "turtle.onscreenclick": {
        "description": {
            "texte": "Bind fun to mouse-click events on this screen. If fun is None, existing bindings are removed.Example for a TurtleScreen instance named screen and a Turtle instance named turtle:",
            "code": ">>> screen.onclick(turtle.goto) # Subsequently clicking into the TurtleScreen will\n>>>                             # make the turtle move to the clicked point.\n>>> screen.onclick(None)        # remove event binding again\n"
        },
        "parametres": [
            "fun\tBind fun to mouse-click events on this screen. If fun is None, existing bindings are removed",
            " btn=1\t",
            " add=None\t"
        ],
        "exemple": ">>> screen.onclick(turtle.goto) # Subsequently clicking into the TurtleScreen will\n>>>                             # make the turtle move to the clicked point.\n>>> screen.onclick(None)        # remove event binding again\n"
    },
    "turtle.setup": {
        "description": {
            "texte": "Set the size and position of the main window. Default values of arguments are stored in the configuration dictionary and can be changed via a turtle.cfg file.",
            "code": ">>> screen.setup (width=200, height=200, startx=0, starty=0)\n>>>              # sets window to 200x200 pixels, in upper left of screen\n>>> screen.setup(width=.75, height=0.5, startx=None, starty=None)\n>>>              # sets window to 75% of screen by 50% of screen and centers\n"
        },
        "parametres": [
            "width=_CFG[\"width\"]\t",
            " height=_CFG[\"height\"]\t",
            " startx=_CFG[\"leftright\"]\t",
            " starty=_CFG[\"topbottom\"]\t"
        ],
        "exemple": ">>> screen.setup (width=200, height=200, startx=0, starty=0)\n>>>              # sets window to 200x200 pixels, in upper left of screen\n>>> screen.setup(width=.75, height=0.5, startx=None, starty=None)\n>>>              # sets window to 75% of screen by 50% of screen and centers\n"
    },
    "shlex.quote": {
        "description": {
            "texte": "Return a shell-escaped version of the string s. The returned value is a string that can safely be used as one token in a shell command line, for cases where you cannot use a list.This idiom would be unsafe:",
            "code": ">>> filename = 'somefile; rm -rf ~'\n>>> command = 'ls -l {}'.format(filename)\n>>> print(command)  # executed by a shell: boom!\nls -l somefile; rm -rf ~\n"
        },
        "parametres": [
            "s\tReturn a shell-escaped version of the string s. The returned value is a string that can safely be used as one token in a shell command line, for cases where you cannot use a list.This idiom would be unsafe:"
        ],
        "exemple": ">>> filename = 'somefile; rm -rf ~'\n>>> command = 'ls -l {}'.format(filename)\n>>> print(command)  # executed by a shell: boom!\nls -l somefile; rm -rf ~\n"
    },
    "tkinter.tix.tk": {
        "description": {
            "texte": "Toplevel widget of Tix which represents mostly the main window of an application. It has an associated Tcl interpreter.Classes in the tkinter.tix module subclasses the classes in the tkinter. The former imports the latter, so to use tkinter.tix with Tkinter, all you need to do is to import one module. In general, you can just import tkinter.tix, and replace the toplevel call to tkinter.Tk with tix.Tk:",
            "code": "from tkinter import tix\nfrom tkinter.constants import *\nroot = tix.Tk()\n"
        },
        "parametres": [
            "screenName=None\t",
            " baseName=None\t",
            " className='Tix'\t"
        ],
        "exemple": "from tkinter import tix\nfrom tkinter.constants import *\nroot = tix.Tk()\n"
    },
    "typing.type": {
        "description": {
            "texte": "A variable annotated with C may accept a value of type C. In contrast, a variable annotated with Type[C] may accept values that are classes themselves \u2013 specifically, it will accept the class object of C. For example:The only legal parameters for Type are classes, Any, type variables, and unions of any of these types. For example:",
            "code": "def new_non_team_user(user_class: Type[Union[BaseUser, ProUser]]): ...\n"
        },
        "parametres": [
            "Generic[CT_co]\t"
        ],
        "exemple": "a = 3         # Has type 'int'\nb = int       # Has type 'Type[int]'\nc = type(a)   # Also has type 'Type[int]'\n"
    },
    "typing.protocol": {
        "description": {
            "texte": "Base class for protocol classes. Protocol classes are defined like this:Protocol classes can be generic, for example:",
            "code": "class GenProto(Protocol[T]):\n    def meth(self) -> T:\n        ...\n"
        },
        "parametres": [
            "Generic\t"
        ],
        "exemple": "class Proto(Protocol):\n    def meth(self) -> int:\n        ...\n"
    },
    "typing.typeddict": {
        "description": {
            "texte": "Special construct to add type hints to a dictionary. At runtime it is a plain dict.TypedDict declares a dictionary type that expects all of its instances to have a certain set of keys, where each key is associated with a value of a consistent type. This expectation is not checked at runtime but is only enforced by type checkers. Usage:",
            "code": "class Point2D(TypedDict):\n    x: int\n    y: int\n    label: str\n\na: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK\nb: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check\n\nassert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first')\n"
        },
        "parametres": [
            "dict\tSpecial construct to add type hints to a dictionary. At runtime it is a plain dict.TypedDict declares a dictionary type that expects all of its instances to have a certain set of keys, where each key is associated with a value of a consistent type"
        ],
        "exemple": "class Point2D(TypedDict):\n    x: int\n    y: int\n    label: str\n\na: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK\nb: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check\n\nassert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first')\n"
    },
    "typing.dict": {
        "description": {
            "texte": "A generic version of dict. Useful for annotating return types. To annotate arguments it is preferred to use an abstract collection type such as Mapping.This type can be used as follows:",
            "code": "def count_words(text: str) -> Dict[str, int]:\n    ...\n"
        },
        "parametres": [
            "dict\tA generic version of dict",
            " MutableMapping[KT\t",
            " VT]\t"
        ],
        "exemple": "def count_words(text: str) -> Dict[str, int]:\n    ...\n"
    },
    "typing.list": {
        "description": {
            "texte": "Generic version of list. Useful for annotating return types. To annotate arguments it is preferred to use an abstract collection type such as Sequence or Iterable.This type may be used as follows:",
            "code": "T = TypeVar('T', int, float)\n\ndef vec2(x: T, y: T) -> List[T]:\n    return [x, y]\n\ndef keep_positives(vector: Sequence[T]) -> List[T]:\n    return [item for item in vector if item > 0]\n"
        },
        "parametres": [
            "list\tGeneric version of list",
            " MutableSequence[T]\t"
        ],
        "exemple": "T = TypeVar('T', int, float)\n\ndef vec2(x: T, y: T) -> List[T]:\n    return [x, y]\n\ndef keep_positives(vector: Sequence[T]) -> List[T]:\n    return [item for item in vector if item > 0]\n"
    },
    "typing.generator": {
        "description": {
            "texte": "A generator can be annotated by the generic type Generator[YieldType, SendType, ReturnType]. For example:If your generator will only yield values, set the SendType and ReturnType to None:",
            "code": "def infinite_stream(start: int) -> Generator[int, None, None]:\n    while True:\n        yield start\n        start += 1\n"
        },
        "parametres": [
            "Iterator[T_co]\t",
            " Generic[T_co\t",
            " T_contra\t",
            " V_co]\t"
        ],
        "exemple": "def echo_round() -> Generator[int, float, str]:\n    sent = yield 0\n    while sent >= 0:\n        sent = yield round(sent)\n    return 'Done'\n"
    },
    "typing.asyncgenerator": {
        "description": {
            "texte": "An async generator can be annotated by the generic type AsyncGenerator[YieldType, SendType]. For example:If your generator will only yield values, set the SendType to None:",
            "code": "async def infinite_stream(start: int) -> AsyncGenerator[int, None]:\n    while True:\n        yield start\n        start = await increment(start)\n"
        },
        "parametres": [
            "AsyncIterator[T_co]\t",
            " Generic[T_co\t",
            " T_contra]\t"
        ],
        "exemple": "async def echo_round() -> AsyncGenerator[int, float]:\n    sent = yield 0\n    while sent >= 0.0:\n        rounded = await round(sent)\n        sent = yield rounded\n"
    },
    "typing.get_origin": {
        "description": {
            "texte": "Provide basic introspection for generic types and special typing forms.For a typing object of the form X[Y, Z, ...] these functions return X and (Y, Z, ...). If X is a generic alias for a builtin or collections class, it gets normalized to the original class. For unsupported objects return None and () correspondingly. Examples:",
            "code": "assert get_origin(Dict[str, int]) is dict\nassert get_args(Dict[int, str]) == (int, str)\n\nassert get_origin(Union[int, str]) is Union\nassert get_args(Union[int, str]) == (int, str)\n"
        },
        "parametres": [
            "tp\t"
        ],
        "exemple": "assert get_origin(Dict[str, int]) is dict\nassert get_args(Dict[int, str]) == (int, str)\n\nassert get_origin(Union[int, str]) is Union\nassert get_args(Union[int, str]) == (int, str)\n"
    },
    "doctest.script_from_examples": {
        "description": {
            "texte": "Convert text with examples to a script.Argument s is a string containing doctest examples. The string is converted to a Python script, where doctest examples in s are converted to regular code, and everything else is converted to Python comments. The generated script is returned as a string. For example,",
            "code": "import doctest\nprint(doctest.script_from_examples(r\"\"\"\n    Set x and y to 1 and 2.\n    >>> x, y = 1, 2\n\n    Print their sum:\n    >>> print(x+y)\n    3\n\"\"\"))\n"
        },
        "parametres": [
            "s\tConvert text with examples to a script.Argument s is a string containing doctest examples. The string is converted to a Python script, where doctest examples in s are converted to regular code, and everything else is converted to Python comments. The generated script is returned as a string"
        ],
        "exemple": "import doctest\nprint(doctest.script_from_examples(r\"\"\"\n    Set x and y to 1 and 2.\n    >>> x, y = 1, 2\n\n    Print their sum:\n    >>> print(x+y)\n    3\n\"\"\"))\n"
    },
    "doctest.testsource": {
        "description": {
            "texte": "Convert the doctest for an object to a script.Argument module is a module object, or dotted name of a module, containing the object whose doctests are of interest. Argument name is the name (within the module) of the object with the doctests of interest. The result is a string, containing the object\u2019s docstring converted to a Python script, as described for script_from_examples() above. For example, if module a.py contains a top-level function f(), then",
            "code": "import a, doctest\nprint(doctest.testsource(a, \"a.f\"))\n"
        },
        "parametres": [
            "module\tArgument module is a module object, or dotted name of a module, containing the object whose doctests are of interest. Argument name is the name (within the module) of the object with the doctests of interest. For example, if module a",
            " name\tArgument module is a module object, or dotted name of a module, containing the object whose doctests are of interest. Argument name is the name (within the module) of the object with the doctests of interest"
        ],
        "exemple": "import a, doctest\nprint(doctest.testsource(a, \"a.f\"))\n"
    },
    "unittest.testcase.assertraises": {
        "description": {
            "texte": "Test that an exception is raised when callable is called with any positional or keyword arguments that are also passed to assertRaises(). The test passes if exception is raised, is an error if another exception is raised, or fails if no exception is raised. To catch any of a group of exceptions, a tuple containing the exception classes may be passed as exception.If only the exception and possibly the msg arguments are given, return a context manager so that the code under test can be written inline rather than as a function:",
            "code": "with self.assertRaises(SomeException):\n    do_something()\n"
        },
        "parametres": [
            "exception\tTest that an exception is raised when callable is called with any positional or keyword arguments that are also passed to assertRaises(). The test passes if exception is raised, is an error if another exception is raised, or fails if no exception is raised. To catch any of a group of exceptions, a tuple containing the exception classes may be passed as exception.If only the exception and possibly the msg arguments are given, return a context manager so that the code under test can be written inline rather than as a function:",
            " callable\tTest that an exception is raised when callable is called with any positional or keyword arguments that are also passed to assertRaises()",
            " *args\t",
            " **kwds\t"
        ],
        "exemple": "with self.assertRaises(SomeException):\n    do_something()\n"
    },
    "unittest.testcase.assertwarns": {
        "description": {
            "texte": "Test that a warning is triggered when callable is called with any positional or keyword arguments that are also passed to assertWarns(). The test passes if warning is triggered and fails if it isn\u2019t. Any exception is an error. To catch any of a group of warnings, a tuple containing the warning classes may be passed as warnings.If only the warning and possibly the msg arguments are given, return a context manager so that the code under test can be written inline rather than as a function:",
            "code": "with self.assertWarns(SomeWarning):\n    do_something()\n"
        },
        "parametres": [
            "warning\tTest that a warning is triggered when callable is called with any positional or keyword arguments that are also passed to assertWarns(). The test passes if warning is triggered and fails if it isn\u2019t. To catch any of a group of warnings, a tuple containing the warning classes may be passed as warnings.If only the warning and possibly the msg arguments are given, return a context manager so that the code under test can be written inline rather than as a function:",
            " callable\tTest that a warning is triggered when callable is called with any positional or keyword arguments that are also passed to assertWarns()",
            " *args\t",
            " **kwds\t"
        ],
        "exemple": "with self.assertWarns(SomeWarning):\n    do_something()\n"
    },
    "unittest.testcase.assertlogs": {
        "description": {
            "texte": "A context manager to test that at least one message is logged on the logger or one of its children, with at least the given level.If given, logger should be a logging.Logger object or a str giving the name of a logger. The default is the root logger, which will catch all messages that were not blocked by a non-propagating descendent logger.The test passes if at least one message emitted inside the with block matches the logger and level conditions, otherwise it fails.Example:",
            "code": "with self.assertLogs('foo', level='INFO') as cm:\n   logging.getLogger('foo').info('first message')\n   logging.getLogger('foo.bar').error('second message')\nself.assertEqual(cm.output, ['INFO:foo:first message',\n                             'ERROR:foo.bar:second message'])\n"
        },
        "parametres": [
            "logger=None\t",
            " level=None\t"
        ],
        "exemple": "with self.assertLogs('foo', level='INFO') as cm:\n   logging.getLogger('foo').info('first message')\n   logging.getLogger('foo.bar').error('second message')\nself.assertEqual(cm.output, ['INFO:foo:first message',\n                             'ERROR:foo.bar:second message'])\n"
    },
    "unittest.texttestrunner._makeresult": {
        "description": {
            "texte": "This method returns the instance of TestResult used by run(). It is not intended to be called directly, but can be overridden in subclasses to provide a custom TestResult._makeResult() instantiates the class or callable passed in the TextTestRunner constructor as the resultclass argument. It defaults to TextTestResult if no resultclass is provided. The result class is instantiated with the following arguments:",
            "code": "stream, descriptions, verbosity\n"
        },
        "parametres": [
            "\tThis method returns the instance of TestResult used by run(). It is not intended to be called directly, but can be overridden in subclasses to provide a custom TestResult._makeResult() instantiates the class or callable passed in the TextTestRunner constructor as the resultclass argument. It defaults to TextTestResult if no resultclass is provided. The result class is instantiated with the following arguments:"
        ],
        "exemple": "stream, descriptions, verbosity\n"
    },
    "unittest.mock.mock.assert_any_call": {
        "description": {
            "texte": "assert the mock has been called with the specified arguments.The assert passes if the mock has ever been called, unlike assert_called_with() and assert_called_once_with() that only pass if the call is the most recent one, and in the case of assert_called_once_with() it must also be the only call.",
            "code": ">>> mock = Mock(return_value=None)\n>>> mock(1, 2, arg='thing')\n>>> mock('some', 'thing', 'else')\n>>> mock.assert_any_call(1, 2, arg='thing')\n"
        },
        "parametres": [
            "*args\t",
            " **kwargs\t"
        ],
        "exemple": ">>> mock = Mock(return_value=None)\n>>> mock(1, 2, arg='thing')\n>>> mock('some', 'thing', 'else')\n>>> mock.assert_any_call(1, 2, arg='thing')\n"
    },
    "unittest.mock.mock.configure_mock": {
        "description": {
            "texte": "Set attributes on the mock through keyword arguments.Attributes plus return values and side effects can be set on child mocks using standard dot notation and unpacking a dictionary in the method call:",
            "code": ">>> mock = Mock()\n>>> attrs = {'method.return_value': 3, 'other.side_effect': KeyError}\n>>> mock.configure_mock(**attrs)\n>>> mock.method()\n3\n>>> mock.other()\nTraceback (most recent call last):\n  ...\nKeyError\n"
        },
        "parametres": [
            "**kwargs\t"
        ],
        "exemple": ">>> mock = Mock()\n>>> attrs = {'method.return_value': 3, 'other.side_effect': KeyError}\n>>> mock.configure_mock(**attrs)\n>>> mock.method()\n3\n>>> mock.other()\nTraceback (most recent call last):\n  ...\nKeyError\n"
    },
    "unittest.mock.propertymock": {
        "description": {
            "texte": "A mock intended to be used as a property, or other descriptor, on a class. PropertyMock provides __get__() and __set__() methods so you can specify a return value when it is fetched.Fetching a PropertyMock instance from an object calls the mock, with no args. Setting it calls the mock with the value being set.",
            "code": ">>> class Foo:\n...     @property\n...     def foo(self):\n...         return 'something'\n...     @foo.setter\n...     def foo(self, value):\n...         pass\n...\n>>> with patch('__main__.Foo.foo', new_callable=PropertyMock) as mock_foo:\n...     mock_foo.return_value = 'mockity-mock'\n...     this_foo = Foo()\n...     print(this_foo.foo)\n...     this_foo.foo = 6\n...\nmockity-mock\n>>> mock_foo.mock_calls\n[call(), call(6)]\n"
        },
        "parametres": [
            "*args\t",
            " **kwargs\t"
        ],
        "exemple": ">>> class Foo:\n...     @property\n...     def foo(self):\n...         return 'something'\n...     @foo.setter\n...     def foo(self, value):\n...         pass\n...\n>>> with patch('__main__.Foo.foo', new_callable=PropertyMock) as mock_foo:\n...     mock_foo.return_value = 'mockity-mock'\n...     this_foo = Foo()\n...     print(this_foo.foo)\n...     this_foo.foo = 6\n...\nmockity-mock\n>>> mock_foo.mock_calls\n[call(), call(6)]\n"
    },
    "unittest.mock.seal": {
        "description": {
            "texte": "Seal will disable the automatic creation of mocks when accessing an attribute of the mock being sealed or any of its attributes that are already mocks recursively.If a mock instance with a name or a spec is assigned to an attribute it won\u2019t be considered in the sealing chain. This allows one to prevent seal from fixing part of the mock object.",
            "code": ">>> mock = Mock()\n>>> mock.submock.attribute1 = 2\n>>> mock.not_submock = mock.Mock(name=\"sample_name\")\n>>> seal(mock)\n>>> mock.new_attribute  # This will raise AttributeError.\n>>> mock.submock.attribute2  # This will raise AttributeError.\n>>> mock.not_submock.attribute2  # This won't raise.\n"
        },
        "parametres": [
            "mock\tSeal will disable the automatic creation of mocks when accessing an attribute of the mock being sealed or any of its attributes that are already mocks recursively.If a mock instance with a name or a spec is assigned to an attribute it won\u2019t be considered in the sealing chain. This allows one to prevent seal from fixing part of the mock object"
        ],
        "exemple": ">>> mock = Mock()\n>>> mock.submock.attribute1 = 2\n>>> mock.not_submock = mock.Mock(name=\"sample_name\")\n>>> seal(mock)\n>>> mock.new_attribute  # This will raise AttributeError.\n>>> mock.submock.attribute2  # This will raise AttributeError.\n>>> mock.not_submock.attribute2  # This won't raise.\n"
    },
    "test.support.run_unittest": {
        "description": {
            "texte": "Execute unittest.TestCase subclasses passed to the function. The function scans the classes for methods starting with the prefix test_ and executes the tests individually.It is also legal to pass strings as parameters; these should be keys in sys.modules. Each associated module will be scanned by unittest.TestLoader.loadTestsFromModule(). This is usually seen in the following test_main() function:",
            "code": "def test_main():\n    support.run_unittest(__name__)\n"
        },
        "parametres": [
            "*classes\t"
        ],
        "exemple": "def test_main():\n    support.run_unittest(__name__)\n"
    },
    "test.support.check_warnings": {
        "description": {
            "texte": "A convenience wrapper for warnings.catch_warnings() that makes it easier to test that a warning was correctly raised. It is approximately equivalent to calling warnings.catch_warnings(record=True) with warnings.simplefilter() set to always and with the option to automatically validate the results that are recorded.check_warnings accepts 2-tuples of the form (\"message regexp\",\nWarningCategory) as positional arguments. If one or more filters are provided, or if the optional keyword argument quiet is False, it checks to make sure the warnings are as expected: each specified filter must match at least one of the warnings raised by the enclosed code or the test fails, and if any warnings are raised that do not match any of the specified filters the test fails. To disable the first of these checks, set quiet to True.On entry to the context manager, a WarningRecorder instance is returned. The underlying warnings list from catch_warnings() is available via the recorder object\u2019s warnings attribute. As a convenience, the attributes of the object representing the most recent warning can also be accessed directly through the recorder object (see example below). If no warning has been raised, then any of the attributes that would otherwise be expected on an object representing a warning will return None.The context manager is designed to be used like this:",
            "code": "with check_warnings((\"assertion is always true\", SyntaxWarning),\n                    (\"\", UserWarning)):\n    exec('assert(False, \"Hey!\")')\n    warnings.warn(UserWarning(\"Hide me!\"))\n"
        },
        "parametres": [
            "*filters\t",
            " quiet=True\t"
        ],
        "exemple": "check_warnings((\"\", Warning), quiet=True)\n"
    },
    "test.support.captured_stdin": {
        "description": {
            "texte": "A context managers that temporarily replaces the named stream with io.StringIO object.Example use with output streams:",
            "code": "with captured_stdout() as stdout, captured_stderr() as stderr:\n    print(\"hello\")\n    print(\"error\", file=sys.stderr)\nassert stdout.getvalue() == \"hello\\n\"\nassert stderr.getvalue() == \"error\\n\"\n"
        },
        "parametres": [
            "\tA context managers that temporarily replaces the named stream with io.StringIO object.Example use with output streams:"
        ],
        "exemple": "with captured_stdout() as stdout, captured_stderr() as stderr:\n    print(\"hello\")\n    print(\"error\", file=sys.stderr)\nassert stdout.getvalue() == \"hello\\n\"\nassert stderr.getvalue() == \"error\\n\"\n"
    },
    "test.support.captured_stdout": {
        "description": {
            "texte": "A context managers that temporarily replaces the named stream with io.StringIO object.Example use with output streams:",
            "code": "with captured_stdout() as stdout, captured_stderr() as stderr:\n    print(\"hello\")\n    print(\"error\", file=sys.stderr)\nassert stdout.getvalue() == \"hello\\n\"\nassert stderr.getvalue() == \"error\\n\"\n"
        },
        "parametres": [
            "\tA context managers that temporarily replaces the named stream with io.StringIO object.Example use with output streams:"
        ],
        "exemple": "with captured_stdout() as stdout, captured_stderr() as stderr:\n    print(\"hello\")\n    print(\"error\", file=sys.stderr)\nassert stdout.getvalue() == \"hello\\n\"\nassert stderr.getvalue() == \"error\\n\"\n"
    },
    "test.support.captured_stderr": {
        "description": {
            "texte": "A context managers that temporarily replaces the named stream with io.StringIO object.Example use with output streams:",
            "code": "with captured_stdout() as stdout, captured_stderr() as stderr:\n    print(\"hello\")\n    print(\"error\", file=sys.stderr)\nassert stdout.getvalue() == \"hello\\n\"\nassert stderr.getvalue() == \"error\\n\"\n"
        },
        "parametres": [
            "\tA context managers that temporarily replaces the named stream with io.StringIO object.Example use with output streams:"
        ],
        "exemple": "with captured_stdout() as stdout, captured_stderr() as stderr:\n    print(\"hello\")\n    print(\"error\", file=sys.stderr)\nassert stdout.getvalue() == \"hello\\n\"\nassert stderr.getvalue() == \"error\\n\"\n"
    },
    "test.support.swap_attr": {
        "description": {
            "texte": "Context manager to swap out an attribute with a new object.Usage:",
            "code": "with swap_attr(obj, \"attr\", 5):\n    ...\n"
        },
        "parametres": [
            "obj\tContext manager to swap out an attribute with a new object",
            " attr\tContext manager to swap out an attribute with a new object",
            " new_val\t"
        ],
        "exemple": "with swap_attr(obj, \"attr\", 5):\n    ...\n"
    },
    "test.support.swap_item": {
        "description": {
            "texte": "Context manager to swap out an item with a new object.Usage:",
            "code": "with swap_item(obj, \"item\", 5):\n    ...\n"
        },
        "parametres": [
            "obj\tContext manager to swap out an item with a new object",
            " attr\t",
            " new_val\t"
        ],
        "exemple": "with swap_item(obj, \"item\", 5):\n    ...\n"
    },
    "test.support.catch_threading_exception": {
        "description": {
            "texte": "Context manager catching threading.Thread exception using threading.excepthook().Attributes set when an exception is catched:See threading.excepthook() documentation.Usage:",
            "code": "with support.catch_threading_exception() as cm:\n    # code spawning a thread which raises an exception\n    ...\n\n    # check the thread exception, use cm attributes:\n    # exc_type, exc_value, exc_traceback, thread\n    ...\n\n# exc_type, exc_value, exc_traceback, thread attributes of cm no longer\n# exists at this point\n# (to avoid reference cycles)\n"
        },
        "parametres": [
            "\tContext manager catching threading.Thread exception using threading.excepthook().Attributes set when an exception is catched:See threading.excepthook() documentation.Usage:"
        ],
        "exemple": "with support.catch_threading_exception() as cm:\n    # code spawning a thread which raises an exception\n    ...\n\n    # check the thread exception, use cm attributes:\n    # exc_type, exc_value, exc_traceback, thread\n    ...\n\n# exc_type, exc_value, exc_traceback, thread attributes of cm no longer\n# exists at this point\n# (to avoid reference cycles)\n"
    },
    "test.support.catch_unraisable_exception": {
        "description": {
            "texte": "Context manager catching unraisable exception using sys.unraisablehook().Storing the exception value (cm.unraisable.exc_value) creates a reference cycle. The reference cycle is broken explicitly when the context manager exits.Usage:",
            "code": "with support.catch_unraisable_exception() as cm:\n    # code creating an \"unraisable exception\"\n    ...\n\n    # check the unraisable exception: use cm.unraisable\n    ...\n\n# cm.unraisable attribute no longer exists at this point\n# (to break a reference cycle)\n"
        },
        "parametres": [
            "\tContext manager catching unraisable exception using sys.unraisablehook().Storing the exception value (cm.unraisable.exc_value) creates a reference cycle. The reference cycle is broken explicitly when the context manager exits.Usage:"
        ],
        "exemple": "with support.catch_unraisable_exception() as cm:\n    # code creating an \"unraisable exception\"\n    ...\n\n    # check the unraisable exception: use cm.unraisable\n    ...\n\n# cm.unraisable attribute no longer exists at this point\n# (to break a reference cycle)\n"
    },
    "test.support.check__all__": {
        "description": {
            "texte": "Assert that the __all__ variable of module contains all public names.The module\u2019s public names (its API) are detected automatically based on whether they match the public name convention and were defined in module.The extra argument can be a set of names that wouldn\u2019t otherwise be automatically detected as \u201cpublic\u201d, like objects without a proper __module__ attribute. If provided, it will be added to the automatically detected ones.Example use:",
            "code": "import bar\nimport foo\nimport unittest\nfrom test import support\n\nclass MiscTestCase(unittest.TestCase):\n    def test__all__(self):\n        support.check__all__(self, foo)\n\nclass OtherTestCase(unittest.TestCase):\n    def test__all__(self):\n        extra = {'BAR_CONST', 'FOO_CONST'}\n        blacklist = {'baz'}  # Undocumented name.\n        # bar imports part of its API from _bar.\n        support.check__all__(self, bar, ('bar', '_bar'),\n                             extra=extra, blacklist=blacklist)\n"
        },
        "parametres": [
            "test_case\t",
            " module\tAssert that the __all__ variable of module contains all public names.The module\u2019s public names (its API) are detected automatically based on whether they match the public name convention and were defined in module",
            " name_of_module=None\t",
            " extra=(\t"
        ],
        "exemple": "import bar\nimport foo\nimport unittest\nfrom test import support\n\nclass MiscTestCase(unittest.TestCase):\n    def test__all__(self):\n        support.check__all__(self, foo)\n\nclass OtherTestCase(unittest.TestCase):\n    def test__all__(self):\n        extra = {'BAR_CONST', 'FOO_CONST'}\n        blacklist = {'baz'}  # Undocumented name.\n        # bar imports part of its API from _bar.\n        support.check__all__(self, bar, ('bar', '_bar'),\n                             extra=extra, blacklist=blacklist)\n"
    },
    "pdb.pdb": {
        "description": {
            "texte": "Pdb is the debugger class.The completekey, stdin and stdout arguments are passed to the underlying cmd.Cmd class; see the description there.By default, Pdb sets a handler for the SIGINT signal (which is sent when the user presses Ctrl-C on the console) when you give a continue command. This allows you to break into the debugger again by pressing Ctrl-C. If you want Pdb not to touch the SIGINT handler, set nosigint to true.Example call to enable tracing with skip:",
            "code": "import pdb; pdb.Pdb(skip=['django.*']).set_trace()\n"
        },
        "parametres": [
            "completekey='tab'\t",
            " stdin=None\t",
            " stdout=None\t",
            " skip=None\t",
            " nosigint=False\t",
            " readrc=True\t"
        ],
        "exemple": "import pdb; pdb.Pdb(skip=['django.*']).set_trace()\n"
    },
    "timeit.timer.print_exc": {
        "description": {
            "texte": "Helper to print a traceback from the timed code.Typical use:",
            "code": "t = Timer(...)       # outside the try/except\ntry:\n    t.timeit(...)    # or t.repeat(...)\nexcept Exception:\n    t.print_exc()\n"
        },
        "parametres": [
            "file=None\t"
        ],
        "exemple": "t = Timer(...)       # outside the try/except\ntry:\n    t.timeit(...)    # or t.repeat(...)\nexcept Exception:\n    t.print_exc()\n"
    },
    "venv.envbuilder.create": {
        "description": {
            "texte": "Create a virtual environment by specifying the target directory (absolute or relative to the current directory) which is to contain the virtual environment. The create method will either create the environment in the specified directory, or raise an appropriate exception.The create method of the EnvBuilder class illustrates the hooks available for subclass customization:",
            "code": "def create(self, env_dir):\n    \"\"\"\n    Create a virtualized Python environment in a directory.\n    env_dir is the target directory to create an environment in.\n    \"\"\"\n    env_dir = os.path.abspath(env_dir)\n    context = self.ensure_directories(env_dir)\n    self.create_configuration(context)\n    self.setup_python(context)\n    self.setup_scripts(context)\n    self.post_setup(context)\n"
        },
        "parametres": [
            "env_dir\t"
        ],
        "exemple": "def create(self, env_dir):\n    \"\"\"\n    Create a virtualized Python environment in a directory.\n    env_dir is the target directory to create an environment in.\n    \"\"\"\n    env_dir = os.path.abspath(env_dir)\n    context = self.ensure_directories(env_dir)\n    self.create_configuration(context)\n    self.setup_python(context)\n    self.setup_scripts(context)\n    self.post_setup(context)\n"
    },
    "dataclasses.field": {
        "description": {
            "texte": "For common and simple use cases, no other functionality is required. There are, however, some dataclass features that require additional per-field information. To satisfy this need for additional information, you can replace the default field value with a call to the provided field() function. For example:The parameters to field() are:If the default value of a field is specified by a call to field(), then the class attribute for this field will be replaced by the specified default value. If no default is provided, then the class attribute will be deleted. The intent is that after the dataclass() decorator runs, the class attributes will all contain the default values for the fields, just as if the default value itself were specified. For example, after:",
            "code": "@dataclass\nclass C:\n    x: int\n    y: int = field(repr=False)\n    z: int = field(repr=False, default=10)\n    t: int = 20\n"
        },
        "parametres": [
            "*\t",
            " default=MISSING\t",
            " default_factory=MISSING\t",
            " repr=True\t",
            " hash=None\t",
            " init=True\t",
            " compare=True\t",
            " metadata=None\t"
        ],
        "exemple": "@dataclass\nclass C:\n    mylist: list[int] = field(default_factory=list)\n\nc = C()\nc.mylist += [1, 2, 3]\n"
    },
    "dataclasses.astuple": {
        "description": {
            "texte": "Converts the dataclass instance to a tuple (by using the factory function tuple_factory). Each dataclass is converted to a tuple of its field values. dataclasses, dicts, lists, and tuples are recursed into.Continuing from the previous example:",
            "code": "assert astuple(p) == (10, 20)\nassert astuple(c) == ([(0, 0), (10, 4)],)\n"
        },
        "parametres": [
            "instance\tConverts the dataclass instance to a tuple (by using the factory function tuple_factory)",
            " *\t",
            " tuple_factory=tuple\t"
        ],
        "exemple": "assert astuple(p) == (10, 20)\nassert astuple(c) == ([(0, 0), (10, 4)],)\n"
    },
    "dataclasses.make_dataclass": {
        "description": {
            "texte": "Creates a new dataclass with name cls_name, fields as defined in fields, base classes as given in bases, and initialized with a namespace as given in namespace. fields is an iterable whose elements are each either name, (name, type), or (name, type, Field). If just name is supplied, typing.Any is used for type. The values of init, repr, eq, order, unsafe_hash, and frozen have the same meaning as they do in dataclass().This function is not strictly required, because any Python mechanism for creating a new class with __annotations__ can then apply the dataclass() function to convert that class to a dataclass. This function is provided as a convenience. For example:",
            "code": "C = make_dataclass('C',\n                   [('x', int),\n                     'y',\n                    ('z', int, field(default=5))],\n                   namespace={'add_one': lambda self: self.x + 1})\n"
        },
        "parametres": [
            "cls_name\tCreates a new dataclass with name cls_name, fields as defined in fields, base classes as given in bases, and initialized with a namespace as given in namespace",
            " fields\tCreates a new dataclass with name cls_name, fields as defined in fields, base classes as given in bases, and initialized with a namespace as given in namespace. fields is an iterable whose elements are each either name, (name, type), or (name, type, Field)",
            " *\t",
            " bases=(\t"
        ],
        "exemple": "C = make_dataclass('C',\n                   [('x', int),\n                     'y',\n                    ('z', int, field(default=5))],\n                   namespace={'add_one': lambda self: self.x + 1})\n"
    },
    "dataclasses.is_dataclass": {
        "description": {
            "texte": "Return True if its parameter is a dataclass or an instance of one, otherwise return False.If you need to know if a class is an instance of a dataclass (and not a dataclass itself), then add a further check for not\nisinstance(obj, type):",
            "code": "def is_dataclass_instance(obj):\n    return is_dataclass(obj) and not isinstance(obj, type)\n"
        },
        "parametres": [
            "class_or_instance\t"
        ],
        "exemple": "def is_dataclass_instance(obj):\n    return is_dataclass(obj) and not isinstance(obj, type)\n"
    },
    "contextlib.exitstack.pop_all": {
        "description": {
            "texte": "Transfers the callback stack to a fresh ExitStack instance and returns it. No callbacks are invoked by this operation - instead, they will now be invoked when the new stack is closed (either explicitly or implicitly at the end of a with statement).For example, a group of files can be opened as an \u201call or nothing\u201d operation as follows:",
            "code": "with ExitStack() as stack:\n    files = [stack.enter_context(open(fname)) for fname in filenames]\n    # Hold onto the close method, but don't call it yet.\n    close_files = stack.pop_all().close\n    # If opening any file fails, all previously opened files will be\n    # closed automatically. If all files are opened successfully,\n    # they will remain open even after the with statement ends.\n    # close_files() can then be invoked explicitly to close them all.\n"
        },
        "parametres": [
            "\tTransfers the callback stack to a fresh ExitStack instance and returns it. No callbacks are invoked by this operation - instead, they will now be invoked when the new stack is closed (either explicitly or implicitly at the end of a with statement).For example, a group of files can be opened as an \u201call or nothing\u201d operation as follows:"
        ],
        "exemple": "with ExitStack() as stack:\n    files = [stack.enter_context(open(fname)) for fname in filenames]\n    # Hold onto the close method, but don't call it yet.\n    close_files = stack.pop_all().close\n    # If opening any file fails, all previously opened files will be\n    # closed automatically. If all files are opened successfully,\n    # they will remain open even after the with statement ends.\n    # close_files() can then be invoked explicitly to close them all.\n"
    },
    "inspect.isawaitable": {
        "description": {
            "texte": "Return True if the object can be used in await expression.Can also be used to distinguish generator-based coroutines from regular generators:",
            "code": "def gen():\n    yield\n@types.coroutine\ndef gen_coro():\n    yield\n\nassert not isawaitable(gen())\nassert isawaitable(gen_coro())\n"
        },
        "parametres": [
            "object\tReturn True if the object can be used in await expression"
        ],
        "exemple": "def gen():\n    yield\n@types.coroutine\ndef gen_coro():\n    yield\n\nassert not isawaitable(gen())\nassert isawaitable(gen_coro())\n"
    },
    "inspect.signature.from_callable": {
        "description": {
            "texte": "Return a Signature (or its subclass) object for a given callable obj. Pass follow_wrapped=False to get a signature of obj without unwrapping its __wrapped__ chain.This method simplifies subclassing of Signature:",
            "code": "class MySignature(Signature):\n    pass\nsig = MySignature.from_callable(min)\nassert isinstance(sig, MySignature)\n"
        },
        "parametres": [
            "obj\tReturn a Signature (or its subclass) object for a given callable obj. Pass follow_wrapped=False to get a signature of obj without unwrapping its __wrapped__ chain",
            " *\t",
            " follow_wrapped=True\t"
        ],
        "exemple": "class MySignature(Signature):\n    pass\nsig = MySignature.from_callable(min)\nassert isinstance(sig, MySignature)\n"
    },
    "inspect.formatargspec": {
        "description": {
            "texte": "Format a pretty argument spec from the values returned by getfullargspec().The first seven arguments are (args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations).For example:",
            "code": ">>> from inspect import formatargspec, getfullargspec\n>>> def f(a: int, b: float):\n...     pass\n...\n>>> formatargspec(*getfullargspec(f))\n'(a: int, b: float)'\n"
        },
        "parametres": [
            "args[\t",
            " varargs\tThe first seven arguments are (args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations)",
            " varkw\tThe first seven arguments are (args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations)",
            " defaults\tThe first seven arguments are (args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations)",
            " kwonlyargs\tThe first seven arguments are (args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations)",
            " kwonlydefaults\tThe first seven arguments are (args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations)",
            " annotations[\t",
            " formatarg\t",
            " formatvarargs\t",
            " formatvarkw\t",
            " formatvalue\t",
            " formatreturns\t",
            " formatannotations]]\t"
        ],
        "exemple": ">>> from inspect import formatargspec, getfullargspec\n>>> def f(a: int, b: float):\n...     pass\n...\n>>> formatargspec(*getfullargspec(f))\n'(a: int, b: float)'\n"
    },
    "pkgutil.walk_packages": {
        "description": {
            "texte": "Yields ModuleInfo for all modules recursively on path, or, if path is None, all accessible modules.path should be either None or a list of paths to look for modules in.Note that this function must import all packages (not all modules!) on the given path, in order to access the __path__ attribute to find submodules.Examples:",
            "code": "# list all modules python can access\nwalk_packages()\n\n# list all submodules of ctypes\nwalk_packages(ctypes.__path__, ctypes.__name__ + '.')\n"
        },
        "parametres": [
            "path=None\t",
            " prefix=''\t",
            " onerror=None\t"
        ],
        "exemple": "# list all modules python can access\nwalk_packages()\n\n# list all submodules of ctypes\nwalk_packages(ctypes.__path__, ctypes.__name__ + '.')\n"
    },
    "pkgutil.get_data": {
        "description": {
            "texte": "Get a resource from a package.This is a wrapper for the loader get_data API. The package argument should be the name of a package, in standard module format (foo.bar). The resource argument should be in the form of a relative filename, using / as the path separator. The parent directory name .. is not allowed, and nor is a rooted name (starting with a /).For packages located in the filesystem, which have already been imported, this is the rough equivalent of:",
            "code": "d = os.path.dirname(sys.modules[package].__file__)\ndata = open(os.path.join(d, resource), 'rb').read()\n"
        },
        "parametres": [
            "package\tGet a resource from a package. The package argument should be the name of a package, in standard module format (foo.For packages located in the filesystem, which have already been imported, this is the rough equivalent of:",
            " resource\tGet a resource from a package. The resource argument should be in the form of a relative filename, using / as the path separator"
        ],
        "exemple": "d = os.path.dirname(sys.modules[package].__file__)\ndata = open(os.path.join(d, resource), 'rb').read()\n"
    },
    "ast.dict": {
        "description": {
            "texte": "A dictionary. keys and values hold lists of nodes representing the keys and the values respectively, in matching order (what would be returned when calling dictionary.keys() and dictionary.values()).When doing dictionary unpacking using dictionary literals the expression to be expanded goes in the values list, with a None at the corresponding position in keys.",
            "code": ">>> print(ast.dump(ast.parse('{\"a\":1, **d}', mode='eval'), indent=4))\nExpression(\n    body=Dict(\n        keys=[\n            Constant(value='a'),\n            None],\n        values=[\n            Constant(value=1),\n            Name(id='d', ctx=Load())]))\n"
        },
        "parametres": [
            "keys\t keys and values hold lists of nodes representing the keys and the values respectively, in matching order (what would be returned when calling dictionary.keys() and dictionary.When doing dictionary unpacking using dictionary literals the expression to be expanded goes in the values list, with a None at the corresponding position in keys",
            " values\t keys and values hold lists of nodes representing the keys and the values respectively, in matching order (what would be returned when calling dictionary.When doing dictionary unpacking using dictionary literals the expression to be expanded goes in the values list, with a None at the corresponding position in keys"
        ],
        "exemple": ">>> print(ast.dump(ast.parse('{\"a\":1, **d}', mode='eval'), indent=4))\nExpression(\n    body=Dict(\n        keys=[\n            Constant(value='a'),\n            None],\n        values=[\n            Constant(value=1),\n            Name(id='d', ctx=Load())]))\n"
    },
    "ast.boolop": {
        "description": {
            "texte": "A boolean operation, \u2018or\u2019 or \u2018and\u2019. op is Or or And. values are the values involved. Consecutive operations with the same operator, such as a or b or c, are collapsed into one node with several values.This doesn\u2019t include not, which is a UnaryOp.",
            "code": ">>> print(ast.dump(ast.parse('x or y', mode='eval'), indent=4))\nExpression(\n    body=BoolOp(\n        op=Or(),\n        values=[\n            Name(id='x', ctx=Load()),\n            Name(id='y', ctx=Load())]))\n"
        },
        "parametres": [
            "op\tA boolean operation, \u2018or\u2019 or \u2018and\u2019. op is Or or And. Consecutive operations with the same operator, such as a or b or c, are collapsed into one node with several values",
            " values\t values are the values involved. Consecutive operations with the same operator, such as a or b or c, are collapsed into one node with several values"
        ],
        "exemple": ">>> print(ast.dump(ast.parse('x or y', mode='eval'), indent=4))\nExpression(\n    body=BoolOp(\n        op=Or(),\n        values=[\n            Name(id='x', ctx=Load()),\n            Name(id='y', ctx=Load())]))\n"
    },
    "ast.listcomp": {
        "description": {
            "texte": "List and set comprehensions, generator expressions, and dictionary comprehensions. elt (or key and value) is a single node representing the part that will be evaluated for each item.generators is a list of comprehension nodes.",
            "code": ">>> print(ast.dump(ast.parse('[x for x in numbers]', mode='eval'), indent=4))\nExpression(\n    body=ListComp(\n        elt=Name(id='x', ctx=Load()),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n>>> print(ast.dump(ast.parse('{x: x**2 for x in numbers}', mode='eval'), indent=4))\nExpression(\n    body=DictComp(\n        key=Name(id='x', ctx=Load()),\n        value=BinOp(\n            left=Name(id='x', ctx=Load()),\n            op=Pow(),\n            right=Constant(value=2)),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n>>> print(ast.dump(ast.parse('{x for x in numbers}', mode='eval'), indent=4))\nExpression(\n    body=SetComp(\n        elt=Name(id='x', ctx=Load()),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n"
        },
        "parametres": [
            "elt\t elt (or key and value) is a single node representing the part that will be evaluated for each item",
            " generators\t"
        ],
        "exemple": ">>> print(ast.dump(ast.parse('[x for x in numbers]', mode='eval'), indent=4))\nExpression(\n    body=ListComp(\n        elt=Name(id='x', ctx=Load()),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n>>> print(ast.dump(ast.parse('{x: x**2 for x in numbers}', mode='eval'), indent=4))\nExpression(\n    body=DictComp(\n        key=Name(id='x', ctx=Load()),\n        value=BinOp(\n            left=Name(id='x', ctx=Load()),\n            op=Pow(),\n            right=Constant(value=2)),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n>>> print(ast.dump(ast.parse('{x for x in numbers}', mode='eval'), indent=4))\nExpression(\n    body=SetComp(\n        elt=Name(id='x', ctx=Load()),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n"
    },
    "ast.setcomp": {
        "description": {
            "texte": "List and set comprehensions, generator expressions, and dictionary comprehensions. elt (or key and value) is a single node representing the part that will be evaluated for each item.generators is a list of comprehension nodes.",
            "code": ">>> print(ast.dump(ast.parse('[x for x in numbers]', mode='eval'), indent=4))\nExpression(\n    body=ListComp(\n        elt=Name(id='x', ctx=Load()),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n>>> print(ast.dump(ast.parse('{x: x**2 for x in numbers}', mode='eval'), indent=4))\nExpression(\n    body=DictComp(\n        key=Name(id='x', ctx=Load()),\n        value=BinOp(\n            left=Name(id='x', ctx=Load()),\n            op=Pow(),\n            right=Constant(value=2)),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n>>> print(ast.dump(ast.parse('{x for x in numbers}', mode='eval'), indent=4))\nExpression(\n    body=SetComp(\n        elt=Name(id='x', ctx=Load()),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n"
        },
        "parametres": [
            "elt\t elt (or key and value) is a single node representing the part that will be evaluated for each item",
            " generators\t"
        ],
        "exemple": ">>> print(ast.dump(ast.parse('[x for x in numbers]', mode='eval'), indent=4))\nExpression(\n    body=ListComp(\n        elt=Name(id='x', ctx=Load()),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n>>> print(ast.dump(ast.parse('{x: x**2 for x in numbers}', mode='eval'), indent=4))\nExpression(\n    body=DictComp(\n        key=Name(id='x', ctx=Load()),\n        value=BinOp(\n            left=Name(id='x', ctx=Load()),\n            op=Pow(),\n            right=Constant(value=2)),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n>>> print(ast.dump(ast.parse('{x for x in numbers}', mode='eval'), indent=4))\nExpression(\n    body=SetComp(\n        elt=Name(id='x', ctx=Load()),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n"
    },
    "ast.generatorexp": {
        "description": {
            "texte": "List and set comprehensions, generator expressions, and dictionary comprehensions. elt (or key and value) is a single node representing the part that will be evaluated for each item.generators is a list of comprehension nodes.",
            "code": ">>> print(ast.dump(ast.parse('[x for x in numbers]', mode='eval'), indent=4))\nExpression(\n    body=ListComp(\n        elt=Name(id='x', ctx=Load()),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n>>> print(ast.dump(ast.parse('{x: x**2 for x in numbers}', mode='eval'), indent=4))\nExpression(\n    body=DictComp(\n        key=Name(id='x', ctx=Load()),\n        value=BinOp(\n            left=Name(id='x', ctx=Load()),\n            op=Pow(),\n            right=Constant(value=2)),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n>>> print(ast.dump(ast.parse('{x for x in numbers}', mode='eval'), indent=4))\nExpression(\n    body=SetComp(\n        elt=Name(id='x', ctx=Load()),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n"
        },
        "parametres": [
            "elt\t elt (or key and value) is a single node representing the part that will be evaluated for each item",
            " generators\t"
        ],
        "exemple": ">>> print(ast.dump(ast.parse('[x for x in numbers]', mode='eval'), indent=4))\nExpression(\n    body=ListComp(\n        elt=Name(id='x', ctx=Load()),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n>>> print(ast.dump(ast.parse('{x: x**2 for x in numbers}', mode='eval'), indent=4))\nExpression(\n    body=DictComp(\n        key=Name(id='x', ctx=Load()),\n        value=BinOp(\n            left=Name(id='x', ctx=Load()),\n            op=Pow(),\n            right=Constant(value=2)),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n>>> print(ast.dump(ast.parse('{x for x in numbers}', mode='eval'), indent=4))\nExpression(\n    body=SetComp(\n        elt=Name(id='x', ctx=Load()),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n"
    },
    "ast.dictcomp": {
        "description": {
            "texte": "List and set comprehensions, generator expressions, and dictionary comprehensions. elt (or key and value) is a single node representing the part that will be evaluated for each item.generators is a list of comprehension nodes.",
            "code": ">>> print(ast.dump(ast.parse('[x for x in numbers]', mode='eval'), indent=4))\nExpression(\n    body=ListComp(\n        elt=Name(id='x', ctx=Load()),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n>>> print(ast.dump(ast.parse('{x: x**2 for x in numbers}', mode='eval'), indent=4))\nExpression(\n    body=DictComp(\n        key=Name(id='x', ctx=Load()),\n        value=BinOp(\n            left=Name(id='x', ctx=Load()),\n            op=Pow(),\n            right=Constant(value=2)),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n>>> print(ast.dump(ast.parse('{x for x in numbers}', mode='eval'), indent=4))\nExpression(\n    body=SetComp(\n        elt=Name(id='x', ctx=Load()),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n"
        },
        "parametres": [
            "key\t elt (or key and value) is a single node representing the part that will be evaluated for each item",
            " value\t elt (or key and value) is a single node representing the part that will be evaluated for each item",
            " generators\t"
        ],
        "exemple": ">>> print(ast.dump(ast.parse('[x for x in numbers]', mode='eval'), indent=4))\nExpression(\n    body=ListComp(\n        elt=Name(id='x', ctx=Load()),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n>>> print(ast.dump(ast.parse('{x: x**2 for x in numbers}', mode='eval'), indent=4))\nExpression(\n    body=DictComp(\n        key=Name(id='x', ctx=Load()),\n        value=BinOp(\n            left=Name(id='x', ctx=Load()),\n            op=Pow(),\n            right=Constant(value=2)),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n>>> print(ast.dump(ast.parse('{x for x in numbers}', mode='eval'), indent=4))\nExpression(\n    body=SetComp(\n        elt=Name(id='x', ctx=Load()),\n        generators=[\n            comprehension(\n                target=Name(id='x', ctx=Store()),\n                iter=Name(id='numbers', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n"
    },
    "ast.comprehension": {
        "description": {
            "texte": "One for clause in a comprehension. target is the reference to use for each element - typically a Name or Tuple node. iter is the object to iterate over. ifs is a list of test expressions: each for clause can have multiple ifs.is_async indicates a comprehension is asynchronous (using an async for instead of for). The value is an integer (0 or 1).",
            "code": ">>> print(ast.dump(ast.parse('[ord(c) for line in file for c in line]', mode='eval'),\n...                indent=4)) # Multiple comprehensions in one.\nExpression(\n    body=ListComp(\n        elt=Call(\n            func=Name(id='ord', ctx=Load()),\n            args=[\n                Name(id='c', ctx=Load())],\n            keywords=[]),\n        generators=[\n            comprehension(\n                target=Name(id='line', ctx=Store()),\n                iter=Name(id='file', ctx=Load()),\n                ifs=[],\n                is_async=0),\n            comprehension(\n                target=Name(id='c', ctx=Store()),\n                iter=Name(id='line', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n\n>>> print(ast.dump(ast.parse('(n**2 for n in it if n>5 if n<10)', mode='eval'),\n...                indent=4)) # generator comprehension\nExpression(\n    body=GeneratorExp(\n        elt=BinOp(\n            left=Name(id='n', ctx=Load()),\n            op=Pow(),\n            right=Constant(value=2)),\n        generators=[\n            comprehension(\n                target=Name(id='n', ctx=Store()),\n                iter=Name(id='it', ctx=Load()),\n                ifs=[\n                    Compare(\n                        left=Name(id='n', ctx=Load()),\n                        ops=[\n                            Gt()],\n                        comparators=[\n                            Constant(value=5)]),\n                    Compare(\n                        left=Name(id='n', ctx=Load()),\n                        ops=[\n                            Lt()],\n                        comparators=[\n                            Constant(value=10)])],\n                is_async=0)]))\n\n>>> print(ast.dump(ast.parse('[i async for i in soc]', mode='eval'),\n...                indent=4)) # Async comprehension\nExpression(\n    body=ListComp(\n        elt=Name(id='i', ctx=Load()),\n        generators=[\n            comprehension(\n                target=Name(id='i', ctx=Store()),\n                iter=Name(id='soc', ctx=Load()),\n                ifs=[],\n                is_async=1)]))\n"
        },
        "parametres": [
            "target\t target is the reference to use for each element - typically a Name or Tuple node",
            " iter\t iter is the object to iterate over",
            " ifs\t ifs is a list of test expressions: each for clause can have multiple ifs",
            " is_async\t"
        ],
        "exemple": ">>> print(ast.dump(ast.parse('[ord(c) for line in file for c in line]', mode='eval'),\n...                indent=4)) # Multiple comprehensions in one.\nExpression(\n    body=ListComp(\n        elt=Call(\n            func=Name(id='ord', ctx=Load()),\n            args=[\n                Name(id='c', ctx=Load())],\n            keywords=[]),\n        generators=[\n            comprehension(\n                target=Name(id='line', ctx=Store()),\n                iter=Name(id='file', ctx=Load()),\n                ifs=[],\n                is_async=0),\n            comprehension(\n                target=Name(id='c', ctx=Store()),\n                iter=Name(id='line', ctx=Load()),\n                ifs=[],\n                is_async=0)]))\n\n>>> print(ast.dump(ast.parse('(n**2 for n in it if n>5 if n<10)', mode='eval'),\n...                indent=4)) # generator comprehension\nExpression(\n    body=GeneratorExp(\n        elt=BinOp(\n            left=Name(id='n', ctx=Load()),\n            op=Pow(),\n            right=Constant(value=2)),\n        generators=[\n            comprehension(\n                target=Name(id='n', ctx=Store()),\n                iter=Name(id='it', ctx=Load()),\n                ifs=[\n                    Compare(\n                        left=Name(id='n', ctx=Load()),\n                        ops=[\n                            Gt()],\n                        comparators=[\n                            Constant(value=5)]),\n                    Compare(\n                        left=Name(id='n', ctx=Load()),\n                        ops=[\n                            Lt()],\n                        comparators=[\n                            Constant(value=10)])],\n                is_async=0)]))\n\n>>> print(ast.dump(ast.parse('[i async for i in soc]', mode='eval'),\n...                indent=4)) # Async comprehension\nExpression(\n    body=ListComp(\n        elt=Name(id='i', ctx=Load()),\n        generators=[\n            comprehension(\n                target=Name(id='i', ctx=Store()),\n                iter=Name(id='soc', ctx=Load()),\n                ifs=[],\n                is_async=1)]))\n"
    },
    "ast.augassign": {
        "description": {
            "texte": "Augmented assignment, such as a += 1. In the following example, target is a Name node for x (with the Store context), op is Add, and value is a Constant with value for 1.The target attribute connot be of class Tuple or List, unlike the targets of Assign.",
            "code": ">>> print(ast.dump(ast.parse('x += 2'), indent=4))\nModule(\n    body=[\n        AugAssign(\n            target=Name(id='x', ctx=Store()),\n            op=Add(),\n            value=Constant(value=2))],\n    type_ignores=[])\n"
        },
        "parametres": [
            "target\t In the following example, target is a Name node for x (with the Store context), op is Add, and value is a Constant with value for 1.The target attribute connot be of class Tuple or List, unlike the targets of Assign",
            " op\t In the following example, target is a Name node for x (with the Store context), op is Add, and value is a Constant with value for 1",
            " value\t In the following example, target is a Name node for x (with the Store context), op is Add, and value is a Constant with value for 1"
        ],
        "exemple": ">>> print(ast.dump(ast.parse('x += 2'), indent=4))\nModule(\n    body=[\n        AugAssign(\n            target=Name(id='x', ctx=Store()),\n            op=Add(),\n            value=Constant(value=2))],\n    type_ignores=[])\n"
    },
    "ast.if": {
        "description": {
            "texte": "An if statement. test holds a single node, such as a Compare node. body and orelse each hold a list of nodes.elif clauses don\u2019t have a special representation in the AST, but rather appear as extra If nodes within the orelse section of the previous one.",
            "code": ">>> print(ast.dump(ast.parse(\"\"\"\n... if x:\n...    ...\n... elif y:\n...    ...\n... else:\n...    ...\n... \"\"\"), indent=4))\nModule(\n    body=[\n        If(\n            test=Name(id='x', ctx=Load()),\n            body=[\n                Expr(\n                    value=Constant(value=Ellipsis))],\n            orelse=[\n                If(\n                    test=Name(id='y', ctx=Load()),\n                    body=[\n                        Expr(\n                            value=Constant(value=Ellipsis))],\n                    orelse=[\n                        Expr(\n                            value=Constant(value=Ellipsis))])])],\n    type_ignores=[])\n"
        },
        "parametres": [
            "test\t test holds a single node, such as a Compare node",
            " body\t body and orelse each hold a list of nodes",
            " orelse\t body and orelse each hold a list of nodes.elif clauses don\u2019t have a special representation in the AST, but rather appear as extra If nodes within the orelse section of the previous one"
        ],
        "exemple": ">>> print(ast.dump(ast.parse(\"\"\"\n... if x:\n...    ...\n... elif y:\n...    ...\n... else:\n...    ...\n... \"\"\"), indent=4))\nModule(\n    body=[\n        If(\n            test=Name(id='x', ctx=Load()),\n            body=[\n                Expr(\n                    value=Constant(value=Ellipsis))],\n            orelse=[\n                If(\n                    test=Name(id='y', ctx=Load()),\n                    body=[\n                        Expr(\n                            value=Constant(value=Ellipsis))],\n                    orelse=[\n                        Expr(\n                            value=Constant(value=Ellipsis))])])],\n    type_ignores=[])\n"
    },
    "ast.for": {
        "description": {
            "texte": "A for loop. target holds the variable(s) the loop assigns to, as a single Name, Tuple or List node. iter holds the item to be looped over, again as a single node. body and orelse contain lists of nodes to execute. Those in orelse are executed if the loop finishes normally, rather than via a break statement.",
            "code": ">>> print(ast.dump(ast.parse(\"\"\"\n... for x in y:\n...     ...\n... else:\n...     ...\n... \"\"\"), indent=4))\nModule(\n    body=[\n        For(\n            target=Name(id='x', ctx=Store()),\n            iter=Name(id='y', ctx=Load()),\n            body=[\n                Expr(\n                    value=Constant(value=Ellipsis))],\n            orelse=[\n                Expr(\n                    value=Constant(value=Ellipsis))])],\n    type_ignores=[])\n"
        },
        "parametres": [
            "target\t target holds the variable(s) the loop assigns to, as a single Name, Tuple or List node",
            " iter\t iter holds the item to be looped over, again as a single node",
            " body\t body and orelse contain lists of nodes to execute",
            " orelse\t body and orelse contain lists of nodes to execute. Those in orelse are executed if the loop finishes normally, rather than via a break statement",
            " type_comment\t"
        ],
        "exemple": ">>> print(ast.dump(ast.parse(\"\"\"\n... for x in y:\n...     ...\n... else:\n...     ...\n... \"\"\"), indent=4))\nModule(\n    body=[\n        For(\n            target=Name(id='x', ctx=Store()),\n            iter=Name(id='y', ctx=Load()),\n            body=[\n                Expr(\n                    value=Constant(value=Ellipsis))],\n            orelse=[\n                Expr(\n                    value=Constant(value=Ellipsis))])],\n    type_ignores=[])\n"
    },
    "ast.arg": {
        "description": {
            "texte": "A single argument in a list. arg is a raw string of the argument name, annotation is its annotation, such as a Str or Name node.",
            "code": ">>> print(ast.dump(ast.parse(\"\"\"\\\n... @decorator1\n... @decorator2\n... def f(a: 'annotation', b=1, c=2, *d, e, f=3, **g) -> 'return annotation':\n...     pass\n... \"\"\"), indent=4))\nModule(\n    body=[\n        FunctionDef(\n            name='f',\n            args=arguments(\n                posonlyargs=[],\n                args=[\n                    arg(\n                        arg='a',\n                        annotation=Constant(value='annotation')),\n                    arg(arg='b'),\n                    arg(arg='c')],\n                vararg=arg(arg='d'),\n                kwonlyargs=[\n                    arg(arg='e'),\n                    arg(arg='f')],\n                kw_defaults=[\n                    None,\n                    Constant(value=3)],\n                kwarg=arg(arg='g'),\n                defaults=[\n                    Constant(value=1),\n                    Constant(value=2)]),\n            body=[\n                Pass()],\n            decorator_list=[\n                Name(id='decorator1', ctx=Load()),\n                Name(id='decorator2', ctx=Load())],\n            returns=Constant(value='return annotation'))],\n    type_ignores=[])\n"
        },
        "parametres": [
            "arg\tA single argument in a list. arg is a raw string of the argument name, annotation is its annotation, such as a Str or Name node",
            " annotation\t arg is a raw string of the argument name, annotation is its annotation, such as a Str or Name node",
            " type_comment\t"
        ],
        "exemple": ">>> print(ast.dump(ast.parse(\"\"\"\\\n... @decorator1\n... @decorator2\n... def f(a: 'annotation', b=1, c=2, *d, e, f=3, **g) -> 'return annotation':\n...     pass\n... \"\"\"), indent=4))\nModule(\n    body=[\n        FunctionDef(\n            name='f',\n            args=arguments(\n                posonlyargs=[],\n                args=[\n                    arg(\n                        arg='a',\n                        annotation=Constant(value='annotation')),\n                    arg(arg='b'),\n                    arg(arg='c')],\n                vararg=arg(arg='d'),\n                kwonlyargs=[\n                    arg(arg='e'),\n                    arg(arg='f')],\n                kw_defaults=[\n                    None,\n                    Constant(value=3)],\n                kwarg=arg(arg='g'),\n                defaults=[\n                    Constant(value=1),\n                    Constant(value=2)]),\n            body=[\n                Pass()],\n            decorator_list=[\n                Name(id='decorator1', ctx=Load()),\n                Name(id='decorator2', ctx=Load())],\n            returns=Constant(value='return annotation'))],\n    type_ignores=[])\n"
    },
    "ast.classdef": {
        "description": {
            "texte": "A class definition.",
            "code": ">>> print(ast.dump(ast.parse(\"\"\"\\\n... @decorator1\n... @decorator2\n... class Foo(base1, base2, metaclass=meta):\n...     pass\n... \"\"\"), indent=4))\nModule(\n    body=[\n        ClassDef(\n            name='Foo',\n            bases=[\n                Name(id='base1', ctx=Load()),\n                Name(id='base2', ctx=Load())],\n            keywords=[\n                keyword(\n                    arg='metaclass',\n                    value=Name(id='meta', ctx=Load()))],\n            body=[\n                Pass()],\n            decorator_list=[\n                Name(id='decorator1', ctx=Load()),\n                Name(id='decorator2', ctx=Load())])],\n    type_ignores=[])\n"
        },
        "parametres": [
            "name\t",
            " bases\t",
            " keywords\t",
            " starargs\t",
            " kwargs\t",
            " body\t",
            " decorator_list\t"
        ],
        "exemple": ">>> print(ast.dump(ast.parse(\"\"\"\\\n... @decorator1\n... @decorator2\n... class Foo(base1, base2, metaclass=meta):\n...     pass\n... \"\"\"), indent=4))\nModule(\n    body=[\n        ClassDef(\n            name='Foo',\n            bases=[\n                Name(id='base1', ctx=Load()),\n                Name(id='base2', ctx=Load())],\n            keywords=[\n                keyword(\n                    arg='metaclass',\n                    value=Name(id='meta', ctx=Load()))],\n            body=[\n                Pass()],\n            decorator_list=[\n                Name(id='decorator1', ctx=Load()),\n                Name(id='decorator2', ctx=Load())])],\n    type_ignores=[])\n"
    },
    "resource.getrusage": {
        "description": {
            "texte": "This function returns an object that describes the resources consumed by either the current process or its children, as specified by the who parameter. The who parameter should be specified using one of the RUSAGE_* constants described below.A simple example:",
            "code": "from resource import *\nimport time\n\n# a non CPU-bound task\ntime.sleep(3)\nprint(getrusage(RUSAGE_SELF))\n\n# a CPU-bound task\nfor i in range(10 ** 8):\n   _ = 1 + 1\nprint(getrusage(RUSAGE_SELF))\n"
        },
        "parametres": [
            "who\tThis function returns an object that describes the resources consumed by either the current process or its children, as specified by the who parameter. The who parameter should be specified using one of the RUSAGE_* constants described below"
        ],
        "exemple": "from resource import *\nimport time\n\n# a non CPU-bound task\ntime.sleep(3)\nprint(getrusage(RUSAGE_SELF))\n\n# a CPU-bound task\nfor i in range(10 ** 8):\n   _ = 1 + 1\nprint(getrusage(RUSAGE_SELF))\n"
    },
    "asyncio.run": {
        "description": {
            "texte": "Execute the coroutine coro and return the result.This function runs the passed coroutine, taking care of managing the asyncio event loop, finalizing asynchronous generators, and closing the threadpool.If debug is True, the event loop will be run in debug mode.Example:",
            "code": "async def main():\n    await asyncio.sleep(1)\n    print('hello')\n\nasyncio.run(main())\n"
        },
        "parametres": [
            "coro\tExecute the coroutine coro and return the result.This function runs the passed coroutine, taking care of managing the asyncio event loop, finalizing asynchronous generators, and closing the threadpool",
            " *\t",
            " debug=False\t"
        ],
        "exemple": "async def main():\n    await asyncio.sleep(1)\n    print('hello')\n\nasyncio.run(main())\n"
    },
    "asyncio.create_task": {
        "description": {
            "texte": "Wrap the coro coroutine into a Task and schedule its execution. Return the Task object.If name is not None, it is set as the name of the task using Task.set_name().This function has been added in Python 3.7. Prior to Python 3.7, the low-level asyncio.ensure_future() function can be used instead:",
            "code": "async def coro():\n    ...\n\n# In Python 3.7+\ntask = asyncio.create_task(coro())\n...\n\n# This works in all Python versions but is less readable\ntask = asyncio.ensure_future(coro())\n...\n"
        },
        "parametres": [
            "coro\tWrap the coro coroutine into a Task and schedule its execution",
            " *\t",
            " name=None\t"
        ],
        "exemple": "async def coro():\n    ...\n\n# In Python 3.7+\ntask = asyncio.create_task(coro())\n...\n\n# This works in all Python versions but is less readable\ntask = asyncio.ensure_future(coro())\n...\n"
    },
    "asyncio.wait": {
        "description": {
            "texte": "Run awaitable objects in the aws iterable concurrently and block until the condition specified by return_when.The aws iterable must not be empty.Usage:",
            "code": "done, pending = await asyncio.wait(aws)\n"
        },
        "parametres": [
            "aws\tRun awaitable objects in the aws iterable concurrently and block until the condition specified by return_when.The aws iterable must not be empty",
            " *\t",
            " loop=None\t",
            " timeout=None\t",
            " return_when=ALL_COMPLETED\t"
        ],
        "exemple": "done, pending = await asyncio.wait(aws)\n"
    },
    "asyncio.as_completed": {
        "description": {
            "texte": "Run awaitable objects in the aws iterable concurrently. Return an iterator of coroutines. Each coroutine returned can be awaited to get the earliest next result from the iterable of the remaining awaitables.Raises asyncio.TimeoutError if the timeout occurs before all Futures are done.Example:",
            "code": "for coro in as_completed(aws):\n    earliest_result = await coro\n    # ...\n"
        },
        "parametres": [
            "aws\tRun awaitable objects in the aws iterable concurrently",
            " *\t",
            " loop=None\t",
            " timeout=None\t"
        ],
        "exemple": "for coro in as_completed(aws):\n    earliest_result = await coro\n    # ...\n"
    },
    "asyncio.to_thread": {
        "description": {
            "texte": "Asynchronously run function func in a separate thread.Any *args and **kwargs supplied for this function are directly passed to func. Also, the current contextvars.Context is propogated, allowing context variables from the event loop thread to be accessed in the separate thread.This coroutine function is primarily intended to be used for executing IO-bound functions/methods that would otherwise block the event loop if they were ran in the main thread. For example:",
            "code": "def blocking_io():\n    print(f\"start blocking_io at {time.strftime('%X')}\")\n    # Note that time.sleep() can be replaced with any blocking\n    # IO-bound operation, such as file operations.\n    time.sleep(1)\n    print(f\"blocking_io complete at {time.strftime('%X')}\")\n\nasync def main():\n    print(f\"started main at {time.strftime('%X')}\")\n\n    await asyncio.gather(\n        asyncio.to_thread(blocking_io),\n        asyncio.sleep(1))\n\n    print(f\"finished main at {time.strftime('%X')}\")\n\n\nasyncio.run(main())\n\n# Expected output:\n#\n# started main at 19:50:53\n# start blocking_io at 19:50:53\n# blocking_io complete at 19:50:54\n# finished main at 19:50:54\n"
        },
        "parametres": [
            "func\tAsynchronously run function func in a separate thread.Any *args and **kwargs supplied for this function are directly passed to func.This coroutine function is primarily intended to be used for executing IO-bound functions/methods that would otherwise block the event loop if they were ran in the main thread",
            " /\t",
            " *args\tAny *args and **kwargs supplied for this function are directly passed to func",
            " **kwargs\tAny *args and **kwargs supplied for this function are directly passed to func"
        ],
        "exemple": "def blocking_io():\n    print(f\"start blocking_io at {time.strftime('%X')}\")\n    # Note that time.sleep() can be replaced with any blocking\n    # IO-bound operation, such as file operations.\n    time.sleep(1)\n    print(f\"blocking_io complete at {time.strftime('%X')}\")\n\nasync def main():\n    print(f\"started main at {time.strftime('%X')}\")\n\n    await asyncio.gather(\n        asyncio.to_thread(blocking_io),\n        asyncio.sleep(1))\n\n    print(f\"finished main at {time.strftime('%X')}\")\n\n\nasyncio.run(main())\n\n# Expected output:\n#\n# started main at 19:50:53\n# start blocking_io at 19:50:53\n# blocking_io complete at 19:50:54\n# finished main at 19:50:54\n"
    },
    "asyncio.streamwriter.write": {
        "description": {
            "texte": "The method attempts to write the data to the underlying socket immediately. If that fails, the data is queued in an internal write buffer until it can be sent.The method should be used along with the drain() method:",
            "code": "stream.write(data)\nawait stream.drain()\n"
        },
        "parametres": [
            "data\tThe method attempts to write the data to the underlying socket immediately. If that fails, the data is queued in an internal write buffer until it can be sent"
        ],
        "exemple": "stream.write(data)\nawait stream.drain()\n"
    },
    "asyncio.streamwriter.writelines": {
        "description": {
            "texte": "The method writes a list (or any iterable) of bytes to the underlying socket immediately. If that fails, the data is queued in an internal write buffer until it can be sent.The method should be used along with the drain() method:",
            "code": "stream.writelines(lines)\nawait stream.drain()\n"
        },
        "parametres": [
            "data\t If that fails, the data is queued in an internal write buffer until it can be sent"
        ],
        "exemple": "stream.writelines(lines)\nawait stream.drain()\n"
    },
    "asyncio.streamwriter.close": {
        "description": {
            "texte": "The method closes the stream and the underlying socket.The method should be used along with the wait_closed() method:",
            "code": "stream.close()\nawait stream.wait_closed()\n"
        },
        "parametres": [
            "\tThe method closes the stream and the underlying socket.The method should be used along with the wait_closed() method:"
        ],
        "exemple": "stream.close()\nawait stream.wait_closed()\n"
    },
    "asyncio.condition": {
        "description": {
            "texte": "A Condition object. Not thread-safe.An asyncio condition primitive can be used by a task to wait for some event to happen and then get exclusive access to a shared resource.The optional lock argument must be a Lock object or None. In the latter case a new Lock object is created automatically.The preferred way to use a Condition is an async with statement:",
            "code": "cond = asyncio.Condition()\n\n# ... later\nasync with cond:\n    await cond.wait()\n"
        },
        "parametres": [
            "lock=None\t",
            " *\t",
            " loop=None\t"
        ],
        "exemple": "cond = asyncio.Condition()\n\n# ... later\nasync with cond:\n    await cond.wait()\n"
    },
    "asyncio.basetransport.get_extra_info": {
        "description": {
            "texte": "Return information about the transport or underlying resources it uses.name is a string representing the piece of transport-specific information to get.For example, the following code attempts to get the underlying socket object of the transport:",
            "code": "sock = transport.get_extra_info('socket')\nif sock is not None:\n    print(sock.getsockopt(...))\n"
        },
        "parametres": [
            "name\tname is a string representing the piece of transport-specific information to get",
            " default=None\t"
        ],
        "exemple": "sock = transport.get_extra_info('socket')\nif sock is not None:\n    print(sock.getsockopt(...))\n"
    },
    "asyncio.future.cancelled": {
        "description": {
            "texte": "Return True if the Future was cancelled.The method is usually used to check if a Future is not cancelled before setting a result or an exception for it:",
            "code": "if not fut.cancelled():\n    fut.set_result(42)\n"
        },
        "parametres": [
            "\tReturn True if the Future was cancelled.The method is usually used to check if a Future is not cancelled before setting a result or an exception for it:"
        ],
        "exemple": "if not fut.cancelled():\n    fut.set_result(42)\n"
    },
    "email.message.emailmessage.__setitem__": {
        "description": {
            "texte": "Add a header to the message with field name name and value val. The field is appended to the end of the message\u2019s existing headers.Note that this does not overwrite or delete any existing header with the same name. If you want to ensure that the new header is the only one present in the message with field name name, delete the field first, e.g.:",
            "code": "del msg['subject']\nmsg['subject'] = 'Python roolz!'\n"
        },
        "parametres": [
            "name\tAdd a header to the message with field name name and value val.Note that this does not overwrite or delete any existing header with the same name. If you want to ensure that the new header is the only one present in the message with field name name, delete the field first, e",
            " val\tAdd a header to the message with field name name and value val"
        ],
        "exemple": "del msg['subject']\nmsg['subject'] = 'Python roolz!'\n"
    },
    "email.message.emailmessage.add_header": {
        "description": {
            "texte": "Extended header setting. This method is similar to __setitem__() except that additional header parameters can be provided as keyword arguments. _name is the header field to add and _value is the primary value for the header.For each item in the keyword argument dictionary _params, the key is taken as the parameter name, with underscores converted to dashes (since dashes are illegal in Python identifiers). Normally, the parameter will be added as key=\"value\" unless the value is None, in which case only the key will be added.Here is an example:",
            "code": "msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')\n"
        },
        "parametres": [
            "_name\t _name is the header field to add and _value is the primary value for the header",
            " _value\t _name is the header field to add and _value is the primary value for the header",
            " **_params\t"
        ],
        "exemple": "msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')\n"
    },
    "email.message.emailmessage.walk": {
        "description": {
            "texte": "The walk() method is an all-purpose generator which can be used to iterate over all the parts and subparts of a message object tree, in depth-first traversal order. You will typically use walk() as the iterator in a for loop; each iteration returns the next subpart.Here\u2019s an example that prints the MIME type of every part of a multipart message structure:",
            "code": ">>> for part in msg.walk():\n...     print(part.get_content_type())\nmultipart/report\ntext/plain\nmessage/delivery-status\ntext/plain\ntext/plain\nmessage/rfc822\ntext/plain\n"
        },
        "parametres": [
            "\tThe walk() method is an all-purpose generator which can be used to iterate over all the parts and subparts of a message object tree, in depth-first traversal order. You will typically use walk() as the iterator in a for loop; each iteration returns the next subpart.Here\u2019s an example that prints the MIME type of every part of a multipart message structure:"
        ],
        "exemple": ">>> for part in msg.walk():\n...     print(part.get_content_type())\nmultipart/report\ntext/plain\nmessage/delivery-status\ntext/plain\ntext/plain\nmessage/rfc822\ntext/plain\n"
    },
    "email.headerregistry.baseheader": {
        "description": {
            "texte": "name and value are passed to BaseHeader from the header_factory call. The string value of any header object is the value fully decoded to unicode.This base class defines the following read-only properties:BaseHeader also provides the following method, which is called by the email library code and should not in general be called by application programs:BaseHeader by itself cannot be used to create a header object. It defines a protocol that each specialized header cooperates with in order to produce the header object. Specifically, BaseHeader requires that the specialized class provide a classmethod() named parse. This method is called as follows:",
            "code": "parse(string, kwds)\n"
        },
        "parametres": [
            "name\tname and value are passed to BaseHeader from the header_factory call. Specifically, BaseHeader requires that the specialized class provide a classmethod() named parse",
            " value\tname and value are passed to BaseHeader from the header_factory call. The string value of any header object is the value fully decoded to unicode"
        ],
        "exemple": "parse(string, kwds)\n"
    },
    "email.message.message.__setitem__": {
        "description": {
            "texte": "Add a header to the message with field name name and value val. The field is appended to the end of the message\u2019s existing fields.Note that this does not overwrite or delete any existing header with the same name. If you want to ensure that the new header is the only one present in the message with field name name, delete the field first, e.g.:",
            "code": "del msg['subject']\nmsg['subject'] = 'Python roolz!'\n"
        },
        "parametres": [
            "name\tAdd a header to the message with field name name and value val.Note that this does not overwrite or delete any existing header with the same name. If you want to ensure that the new header is the only one present in the message with field name name, delete the field first, e",
            " val\tAdd a header to the message with field name name and value val"
        ],
        "exemple": "del msg['subject']\nmsg['subject'] = 'Python roolz!'\n"
    },
    "email.message.message.get_param": {
        "description": {
            "texte": "Return the value of the Content-Type header\u2019s parameter param as a string. If the message has no Content-Type header or if there is no such parameter, then failobj is returned (defaults to None).Optional header if given, specifies the message header to use instead of Content-Type.If your application doesn\u2019t care whether the parameter was encoded as in RFC 2231, you can collapse the parameter value by calling email.utils.collapse_rfc2231_value(), passing in the return value from get_param(). This will return a suitably decoded Unicode string when the value is a tuple, or the original string unquoted if it isn\u2019t. For example:",
            "code": "rawparam = msg.get_param('foo')\nparam = email.utils.collapse_rfc2231_value(rawparam)\n"
        },
        "parametres": [
            "param\tReturn the value of the Content-Type header\u2019s parameter param as a string. If the message has no Content-Type header or if there is no such parameter, then failobj is returned (defaults to None).If your application doesn\u2019t care whether the parameter was encoded as in RFC 2231, you can collapse the parameter value by calling email.collapse_rfc2231_value(), passing in the return value from get_param()",
            " failobj=None\t",
            " header='content-type'\t",
            " unquote=True\t"
        ],
        "exemple": "rawparam = msg.get_param('foo')\nparam = email.utils.collapse_rfc2231_value(rawparam)\n"
    },
    "email.message.message.walk": {
        "description": {
            "texte": "The walk() method is an all-purpose generator which can be used to iterate over all the parts and subparts of a message object tree, in depth-first traversal order. You will typically use walk() as the iterator in a for loop; each iteration returns the next subpart.Here\u2019s an example that prints the MIME type of every part of a multipart message structure:",
            "code": ">>> for part in msg.walk():\n...     print(part.get_content_type())\nmultipart/report\ntext/plain\nmessage/delivery-status\ntext/plain\ntext/plain\nmessage/rfc822\ntext/plain\n"
        },
        "parametres": [
            "\tThe walk() method is an all-purpose generator which can be used to iterate over all the parts and subparts of a message object tree, in depth-first traversal order. You will typically use walk() as the iterator in a for loop; each iteration returns the next subpart.Here\u2019s an example that prints the MIME type of every part of a multipart message structure:"
        ],
        "exemple": ">>> for part in msg.walk():\n...     print(part.get_content_type())\nmultipart/report\ntext/plain\nmessage/delivery-status\ntext/plain\ntext/plain\nmessage/rfc822\ntext/plain\n"
    }
}